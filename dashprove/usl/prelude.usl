// USL Standard Library: Prelude
// Basic types and commonly used properties
// Import: (conceptual - USL does not yet support imports, but these serve as templates)

// =============================================================================
// Basic Type Definitions
// =============================================================================

// Option type for nullable values
type Option = {
    has_value: Bool,
    value: Int
}

// Pair type for tuples
type Pair = {
    first: Int,
    second: Int
}

// =============================================================================
// Logical Equivalence Properties
// =============================================================================

// Law of excluded middle
theorem excluded_middle {
    forall p: Bool . p or not p
}

// Double negation elimination
theorem double_negation {
    forall p: Bool . not not p implies p
}

// Modus ponens as a theorem schema
theorem modus_ponens {
    forall p: Bool, q: Bool . (p and (p implies q)) implies q
}

// Contrapositive
theorem contrapositive {
    forall p: Bool, q: Bool . (p implies q) implies (not q implies not p)
}

// De Morgan's laws
theorem demorgan_and {
    forall p: Bool, q: Bool . not (p and q) implies (not p or not q)
}

theorem demorgan_or {
    forall p: Bool, q: Bool . not (p or q) implies (not p and not q)
}

// =============================================================================
// Arithmetic Properties
// =============================================================================

// Reflexivity of equality
theorem eq_reflexive {
    forall x: Int . x == x
}

// Symmetry of equality
theorem eq_symmetric {
    forall x: Int, y: Int . x == y implies y == x
}

// Transitivity of equality
theorem eq_transitive {
    forall x: Int, y: Int, z: Int . (x == y and y == z) implies x == z
}

// Addition is commutative
theorem add_commutative {
    forall x: Int, y: Int . x + y == y + x
}

// Addition is associative
theorem add_associative {
    forall x: Int, y: Int, z: Int . (x + y) + z == x + (y + z)
}

// Zero is additive identity
theorem add_identity {
    forall x: Int . x + 0 == x
}

// Multiplication is commutative
theorem mul_commutative {
    forall x: Int, y: Int . x * y == y * x
}

// Multiplication distributes over addition
theorem mul_distributive {
    forall x: Int, y: Int, z: Int . x * (y + z) == (x * y) + (x * z)
}

// =============================================================================
// Order Properties
// =============================================================================

// Reflexivity of <=
theorem leq_reflexive {
    forall x: Int . x <= x
}

// Antisymmetry of <=
theorem leq_antisymmetric {
    forall x: Int, y: Int . (x <= y and y <= x) implies x == y
}

// Transitivity of <=
theorem leq_transitive {
    forall x: Int, y: Int, z: Int . (x <= y and y <= z) implies x <= z
}

// Totality of <= (trichotomy)
theorem leq_total {
    forall x: Int, y: Int . x <= y or y <= x
}

// =============================================================================
// Natural Number Properties
// =============================================================================

// Non-negative integers are bounded below
theorem nat_bounded_below {
    forall n: Int . is_nat(n) implies n >= 0
}

// Successor is always greater
theorem succ_greater {
    forall n: Int . n + 1 > n
}

// Well-founded induction: if property holds for all smaller values, it holds
theorem induction_principle {
    forall n: Int, base: Bool, step: Bool .
        is_nat(n) implies (base and step) implies holds(n)
}
