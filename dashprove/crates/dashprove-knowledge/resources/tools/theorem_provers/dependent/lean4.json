{
  "id": "lean4",
  "name": "Lean 4",
  "category": "theorem_prover",
  "subcategory": "dependent_type",

  "description": "Dependently-typed theorem prover and programming language",
  "long_description": "Lean 4 is a theorem prover and programming language based on dependent type theory. It combines interactive theorem proving with practical programming, featuring a powerful tactic framework, metaprogramming capabilities, and excellent IDE support. Lean 4 is used for both mathematical proofs and verified software.",

  "capabilities": [
    "dependent_types",
    "interactive_proofs",
    "automation",
    "metaprogramming",
    "type_classes",
    "termination_checking",
    "code_extraction"
  ],
  "property_types": ["theorem", "lemma", "definition", "structure", "inductive"],
  "input_languages": ["lean"],
  "output_formats": ["proof", "executable"],

  "installation": {
    "methods": [
      {"type": "elan", "command": "curl https://raw.githubusercontent.com/leanprover/elan/master/elan-init.sh -sSf | sh"},
      {"type": "brew", "command": "brew install elan-init && elan default leanprover/lean4:stable"}
    ],
    "dependencies": [],
    "platforms": ["linux", "macos", "windows"]
  },

  "documentation": {
    "official": "https://lean-lang.org/",
    "tutorial": "https://lean-lang.org/theorem_proving_in_lean4/",
    "api_reference": "https://leanprover-community.github.io/mathlib4_docs/",
    "examples": "https://github.com/leanprover-community/mathlib4"
  },

  "tactics": [
    {
      "name": "intro",
      "description": "Introduce hypothesis into context",
      "syntax": "intro h",
      "when_to_use": "For implications and universal quantifiers",
      "examples": ["intro h", "intro x y", "intro ⟨a, b⟩"]
    },
    {
      "name": "apply",
      "description": "Apply a theorem or hypothesis",
      "syntax": "apply theorem_name",
      "when_to_use": "When goal matches theorem conclusion",
      "examples": ["apply Nat.add_comm", "apply h"]
    },
    {
      "name": "simp",
      "description": "Simplification using rewrite rules",
      "syntax": "simp [lemmas]",
      "when_to_use": "For simplifying expressions",
      "examples": ["simp", "simp [List.append_nil]", "simp only [h]"]
    },
    {
      "name": "rw",
      "description": "Rewrite using equality",
      "syntax": "rw [eq]",
      "when_to_use": "To replace equals with equals",
      "examples": ["rw [h]", "rw [← h]", "rw [a, b, c]"]
    },
    {
      "name": "induction",
      "description": "Proof by induction",
      "syntax": "induction n with | base => ... | ind ih => ...",
      "when_to_use": "For inductive types",
      "examples": ["induction n with | zero => ... | succ n ih => ..."]
    },
    {
      "name": "omega",
      "description": "Linear arithmetic solver",
      "syntax": "omega",
      "when_to_use": "For linear integer arithmetic",
      "examples": ["omega"]
    },
    {
      "name": "decide",
      "description": "Decidable proposition solver",
      "syntax": "decide",
      "when_to_use": "For decidable goals",
      "examples": ["decide"]
    },
    {
      "name": "aesop",
      "description": "Automated proof search",
      "syntax": "aesop",
      "when_to_use": "For routine goals",
      "examples": ["aesop"]
    }
  ],

  "error_patterns": [
    {
      "pattern": "type mismatch",
      "meaning": "Expected type doesn't match actual type",
      "common_causes": ["Wrong argument order", "Missing coercion", "Universe issue"],
      "fixes": ["Check types carefully", "Add explicit type annotations"]
    },
    {
      "pattern": "unknown identifier",
      "meaning": "Name not in scope",
      "common_causes": ["Missing import", "Typo", "Wrong namespace"],
      "fixes": ["Add import", "Check spelling", "Open namespace"]
    },
    {
      "pattern": "fail to prove termination",
      "meaning": "Termination checker failed",
      "common_causes": ["Non-structural recursion", "Missing termination proof"],
      "fixes": ["Add termination_by clause", "Use well-founded recursion"]
    },
    {
      "pattern": "tactic .* failed",
      "meaning": "Tactic could not solve goal",
      "common_causes": ["Goal shape wrong", "Missing hypothesis"],
      "fixes": ["Try different tactic", "Add intermediate steps"]
    }
  ],

  "integration": {
    "dashprove_backend": true,
    "usl_property_types": ["theorem", "lemma", "definition"],
    "cli_command": "dashprove verify --backend lean4"
  },

  "performance": {
    "typical_runtime": "milliseconds to hours",
    "scalability": "Handles large libraries (Mathlib)",
    "memory_usage": "2-16GB"
  },

  "comparisons": {
    "similar_tools": ["coq", "isabelle", "agda"],
    "advantages": [
      "Modern language design",
      "Fast compilation",
      "Excellent metaprogramming",
      "Good IDE support"
    ],
    "disadvantages": [
      "Smaller library than Coq/Isabelle",
      "Breaking changes from Lean 3",
      "Learning curve"
    ]
  },

  "metadata": {
    "version": "4.4.0",
    "last_updated": "2025-12-20",
    "maintainer": "Lean FRO",
    "license": "Apache-2.0"
  }
}
