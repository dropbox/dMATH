{
  "id": "coq",
  "name": "Coq",
  "category": "theorem_prover",
  "subcategory": "dependent_type",

  "description": "Interactive theorem prover based on Calculus of Inductive Constructions",
  "long_description": "Coq is a formal proof assistant based on the Calculus of Inductive Constructions. It allows development of mathematical proofs and certified programs. Coq has been used to verify major mathematical results (Four Color Theorem) and critical software (CompCert C compiler).",

  "capabilities": [
    "dependent_types",
    "interactive_proofs",
    "program_extraction",
    "inductive_types",
    "tactics",
    "type_classes",
    "modules"
  ],
  "property_types": ["theorem", "lemma", "definition", "inductive", "fixpoint"],
  "input_languages": ["gallina", "ltac", "ltac2"],
  "output_formats": ["proof", "ocaml", "haskell", "scheme"],

  "installation": {
    "methods": [
      {"type": "opam", "command": "opam install coq"},
      {"type": "brew", "command": "brew install coq"},
      {"type": "apt", "command": "apt install coq"}
    ],
    "dependencies": ["ocaml"],
    "platforms": ["linux", "macos", "windows"]
  },

  "documentation": {
    "official": "https://coq.inria.fr/",
    "tutorial": "https://softwarefoundations.cis.upenn.edu/",
    "api_reference": "https://coq.inria.fr/refman/",
    "examples": "https://github.com/coq-community"
  },

  "tactics": [
    {
      "name": "intro",
      "description": "Introduce variable or hypothesis",
      "syntax": "intro H",
      "when_to_use": "For forall and implications",
      "examples": ["intro x.", "intros H1 H2.", "intros."]
    },
    {
      "name": "apply",
      "description": "Apply theorem to goal",
      "syntax": "apply lemma",
      "when_to_use": "When goal matches lemma conclusion",
      "examples": ["apply plus_comm.", "apply H."]
    },
    {
      "name": "rewrite",
      "description": "Rewrite using equality",
      "syntax": "rewrite H",
      "when_to_use": "To substitute equals",
      "examples": ["rewrite H.", "rewrite <- H.", "rewrite H in H2."]
    },
    {
      "name": "induction",
      "description": "Proof by induction",
      "syntax": "induction n",
      "when_to_use": "For inductive types",
      "examples": ["induction n.", "induction l as [|x xs IH]."]
    },
    {
      "name": "destruct",
      "description": "Case analysis",
      "syntax": "destruct H",
      "when_to_use": "To split on cases",
      "examples": ["destruct n.", "destruct H as [H1 H2]."]
    },
    {
      "name": "simpl",
      "description": "Simplify expression",
      "syntax": "simpl",
      "when_to_use": "To compute definitions",
      "examples": ["simpl.", "simpl in H."]
    },
    {
      "name": "auto",
      "description": "Automatic proof search",
      "syntax": "auto",
      "when_to_use": "For simple goals",
      "examples": ["auto.", "auto with arith."]
    },
    {
      "name": "omega/lia",
      "description": "Linear arithmetic",
      "syntax": "lia",
      "when_to_use": "For integer inequalities",
      "examples": ["lia."]
    }
  ],

  "error_patterns": [
    {
      "pattern": "The term .* has type .* while it is expected to have type",
      "meaning": "Type mismatch",
      "common_causes": ["Wrong argument", "Missing conversion"],
      "fixes": ["Check types", "Add explicit type annotation"]
    },
    {
      "pattern": "Unable to unify",
      "meaning": "Unification failed",
      "common_causes": ["Types don't match", "Universe inconsistency"],
      "fixes": ["Check term construction", "Adjust universe levels"]
    },
    {
      "pattern": "Cannot guess decreasing argument",
      "meaning": "Termination checker failed",
      "common_causes": ["Non-structural recursion"],
      "fixes": ["Reorder arguments", "Use Program or well-founded recursion"]
    }
  ],

  "integration": {
    "dashprove_backend": true,
    "usl_property_types": ["theorem", "lemma", "definition"],
    "cli_command": "dashprove verify --backend coq"
  },

  "performance": {
    "typical_runtime": "milliseconds to hours",
    "scalability": "Handles very large developments",
    "memory_usage": "2-32GB"
  },

  "comparisons": {
    "similar_tools": ["lean4", "isabelle", "agda"],
    "advantages": [
      "Mature ecosystem",
      "Program extraction",
      "Strong tactic language",
      "Excellent documentation"
    ],
    "disadvantages": [
      "Verbose syntax",
      "Steep learning curve",
      "Slower than Lean 4"
    ]
  },

  "metadata": {
    "version": "8.18.0",
    "last_updated": "2025-12-20",
    "maintainer": "Inria",
    "license": "LGPL-2.1"
  }
}
