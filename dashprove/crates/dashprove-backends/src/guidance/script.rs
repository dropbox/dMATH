//! Guidance script generation and output parsing

use super::config::GuidanceConfig;
use crate::counterexample::StructuredCounterexample;
use crate::traits::{BackendError, VerificationStatus};
use dashprove_usl::typecheck::TypedSpec;
use serde_json::Value;

/// Generate Guidance verification script
pub fn generate_guidance_script(
    _spec: &TypedSpec,
    config: &GuidanceConfig,
) -> Result<String, BackendError> {
    let gen_mode = config.generation_mode.as_str();
    let val_mode = config.validation_mode.as_str();
    let allow_partial = if config.allow_partial {
        "True"
    } else {
        "False"
    };
    let max_tokens = config.max_tokens;
    let pass_threshold = config.pass_rate_threshold;

    Ok(format!(
        r#"#!/usr/bin/env python3
"""
Guidance structured generation verification script generated by DashProve
Tests constrained generation and output validation.
"""

import json
import sys
import time
import re

try:
    import guidance
except ImportError as e:
    print(f"GUIDANCE_ERROR: Missing dependencies: {{e}}")
    sys.exit(1)


def test_constrained_generation():
    """Test basic constrained generation."""
    test_cases = [
        # (pattern, valid_output, description)
        (r"^[A-Z][a-z]+$", "Hello", "capitalized word"),
        (r"^[A-Z][a-z]+$", "World", "another word"),
        (r"^\d{{4}}-\d{{2}}-\d{{2}}$", "2024-01-15", "date format"),
        (r"^\d{{4}}-\d{{2}}-\d{{2}}$", "invalid", "invalid date"),
        (r"^[a-z]+@[a-z]+\.[a-z]{{2,}}$", "user@example.com", "email"),
        (r"^[a-z]+@[a-z]+\.[a-z]{{2,}}$", "not-an-email", "invalid email"),
        (r"^\d+$", "12345", "numbers only"),
        (r"^(yes|no)$", "yes", "boolean choice"),
    ]

    passed = 0
    failed = 0
    errors = []

    for i, (pattern, output, desc) in enumerate(test_cases):
        try:
            if re.match(pattern, output):
                passed += 1
            else:
                failed += 1
                errors.append(f"Case {{i}} ({{desc}}): output doesn't match pattern")
        except Exception as e:
            failed += 1
            errors.append(f"Case {{i}}: {{str(e)[:50]}}")

    return passed, failed, errors, len(test_cases)


def test_grammar_generation():
    """Test grammar-based generation (simulated CFG)."""
    # Simple expression grammar test
    test_expressions = [
        ("1 + 2", True),
        ("(3 * 4)", True),
        ("5 - 3 + 2", True),
        ("not valid expression $$$", False),
        ("10 / 2", True),
        ("(1 + (2 * 3))", True),
        ("abc def", False),
        ("42", True),
    ]

    passed = 0
    failed = 0
    errors = []

    expr_pattern = r'^[\d\s\+\-\*\/\(\)]+$'

    for i, (expr, should_match) in enumerate(test_expressions):
        try:
            matches = bool(re.match(expr_pattern, expr))
            if matches == should_match:
                passed += 1
            else:
                failed += 1
                errors.append(f"Case {{i}}: expected {{should_match}}, got {{matches}}")
        except Exception as e:
            failed += 1
            errors.append(f"Case {{i}}: {{str(e)[:50]}}")

    return passed, failed, errors, len(test_expressions)


def test_json_schema_generation():
    """Test JSON schema validation."""
    schema = {{
        "type": "object",
        "properties": {{
            "name": {{"type": "string"}},
            "age": {{"type": "integer", "minimum": 0}},
            "email": {{"type": "string"}}
        }},
        "required": ["name", "age"]
    }}

    test_outputs = [
        {{"name": "Alice", "age": 30, "email": "alice@example.com"}},
        {{"name": "Bob", "age": 25}},
        {{"age": 40}},  # Missing required field
        {{"name": "Charlie", "age": -5}},  # Invalid age
        {{"name": "Diana", "age": 35, "extra": "field"}},
        {{"name": "", "age": 0}},  # Edge case
        {{"name": 123, "age": 30}},  # Wrong type
        {{"name": "Eve", "age": 28}},
    ]

    passed = 0
    failed = 0
    errors = []

    for i, obj in enumerate(test_outputs):
        try:
            is_valid = True
            # Check required fields
            if "name" not in obj or "age" not in obj:
                is_valid = False
            # Check types
            elif not isinstance(obj.get("name"), str):
                is_valid = False
            elif not isinstance(obj.get("age"), int):
                is_valid = False
            # Check constraints
            elif obj.get("age", 0) < 0:
                is_valid = False

            if is_valid:
                passed += 1
            else:
                failed += 1
                errors.append(f"Case {{i}}: JSON schema validation failed")
        except Exception as e:
            failed += 1
            errors.append(f"Case {{i}}: {{str(e)[:50]}}")

    return passed, failed, errors, len(test_outputs)


def test_regex_generation():
    """Test regex-based generation."""
    test_cases = [
        # (regex, input, should_match)
        (r"^\d{{3}}-\d{{4}}$", "123-4567", True),
        (r"^\d{{3}}-\d{{4}}$", "12-4567", False),
        (r"^[A-Z]{{2,3}}$", "AB", True),
        (r"^[A-Z]{{2,3}}$", "ABCD", False),
        (r"^\w+@\w+\.\w+$", "test@example.com", True),
        (r"^\w+@\w+\.\w+$", "invalid", False),
        (r"^(true|false)$", "true", True),
        (r"^(true|false)$", "maybe", False),
    ]

    passed = 0
    failed = 0
    errors = []

    for i, (pattern, text, should_match) in enumerate(test_cases):
        try:
            matches = bool(re.match(pattern, text))
            if matches == should_match:
                passed += 1
            else:
                failed += 1
                errors.append(f"Case {{i}}: expected {{should_match}}, got {{matches}}")
        except Exception as e:
            failed += 1
            errors.append(f"Case {{i}}: {{str(e)[:50]}}")

    return passed, failed, errors, len(test_cases)


def main():
    generation_mode = "{gen_mode}"
    validation_mode = "{val_mode}"
    allow_partial = {allow_partial}
    max_tokens = {max_tokens}
    pass_threshold = {pass_threshold}

    start_time = time.perf_counter()

    try:
        if generation_mode == "constrained":
            passed, failed, errors, total = test_constrained_generation()
        elif generation_mode == "grammar":
            passed, failed, errors, total = test_grammar_generation()
        elif generation_mode == "json_schema":
            passed, failed, errors, total = test_json_schema_generation()
        elif generation_mode == "regex":
            passed, failed, errors, total = test_regex_generation()
        else:
            passed, failed, errors, total = test_constrained_generation()

        pass_rate = passed / total if total > 0 else 0.0

        result = {{
            "status": "success",
            "generation_mode": generation_mode,
            "validation_mode": validation_mode,
            "allow_partial": allow_partial,
            "max_tokens": max_tokens,
            "passed": passed,
            "failed": failed,
            "total": total,
            "pass_rate": pass_rate,
            "pass_threshold": pass_threshold,
            "errors": errors[:5],
            "duration_s": time.perf_counter() - start_time,
        }}

        print("GUIDANCE_RESULT_START")
        print(json.dumps(result, indent=2, default=str))
        print("GUIDANCE_RESULT_END")

        if pass_rate >= pass_threshold:
            print("GUIDANCE_STATUS: VERIFIED")
        elif pass_rate >= pass_threshold * 0.7:
            print("GUIDANCE_STATUS: PARTIALLY_VERIFIED")
        else:
            print("GUIDANCE_STATUS: NOT_VERIFIED")
    except Exception as e:
        print(f"GUIDANCE_ERROR: {{e}}")


if __name__ == "__main__":
    main()
"#
    ))
}

/// Parse Guidance output into verification status
pub fn parse_guidance_output(
    stdout: &str,
    stderr: &str,
) -> (VerificationStatus, Option<StructuredCounterexample>) {
    if stdout.contains("GUIDANCE_ERROR:") || stderr.contains("GUIDANCE_ERROR:") {
        let reason = stdout
            .lines()
            .chain(stderr.lines())
            .find(|l| l.contains("GUIDANCE_ERROR:"))
            .map(|l| l.replace("GUIDANCE_ERROR:", "").trim().to_string())
            .unwrap_or_else(|| "Unknown Guidance error".to_string());
        return (VerificationStatus::Unknown { reason }, None);
    }

    if let Some(json_str) =
        extract_json_result(stdout, "GUIDANCE_RESULT_START", "GUIDANCE_RESULT_END")
    {
        if let Ok(val) = serde_json::from_str::<Value>(&json_str) {
            let status = val["status"].as_str().unwrap_or("error");
            let pass_rate = val["pass_rate"].as_f64().unwrap_or(0.0);
            let threshold = val["pass_threshold"].as_f64().unwrap_or(0.85);

            if status == "error" {
                let reason = val["error"]
                    .as_str()
                    .unwrap_or("Unknown Guidance failure")
                    .to_string();
                return (VerificationStatus::Unknown { reason }, None);
            }

            let counterexample = crate::counterexample::build_guidance_counterexample(&val);

            if pass_rate >= threshold {
                (VerificationStatus::Proven, counterexample)
            } else if pass_rate >= threshold * 0.7 {
                (
                    VerificationStatus::Partial {
                        verified_percentage: (pass_rate / threshold) * 100.0,
                    },
                    counterexample,
                )
            } else {
                (VerificationStatus::Disproven, counterexample)
            }
        } else {
            (
                VerificationStatus::Unknown {
                    reason: "Failed to parse Guidance output".to_string(),
                },
                None,
            )
        }
    } else if stdout.contains("GUIDANCE_STATUS: VERIFIED") {
        (VerificationStatus::Proven, None)
    } else if stdout.contains("GUIDANCE_STATUS: PARTIALLY_VERIFIED") {
        (
            VerificationStatus::Partial {
                verified_percentage: 80.0,
            },
            None,
        )
    } else if stdout.contains("GUIDANCE_STATUS: NOT_VERIFIED") {
        (VerificationStatus::Disproven, None)
    } else {
        (
            VerificationStatus::Unknown {
                reason: "Could not parse Guidance output".to_string(),
            },
            None,
        )
    }
}

fn extract_json_result(output: &str, start_marker: &str, end_marker: &str) -> Option<String> {
    if let Some(start) = output.find(start_marker) {
        let after = &output[start + start_marker.len()..];
        if let Some(end) = after.find(end_marker) {
            return Some(after[..end].trim().to_string());
        }
    }
    None
}
