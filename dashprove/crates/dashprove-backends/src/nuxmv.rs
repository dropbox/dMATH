//! nuXmv model checker backend
//!
//! nuXmv extends NuSMV with SMT-based model checking capabilities.
//! It supports infinite-state systems and advanced verification algorithms
//! including IC3/PDR, k-induction, and interpolation-based methods.
//!
//! See: <https://nuxmv.fbk.eu/>

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample, TraceState,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use regex::Regex;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for nuXmv backend
#[derive(Debug, Clone)]
pub struct NuXmvConfig {
    /// Path to nuXmv binary
    pub nuxmv_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Use SMT-based algorithms
    pub use_smt: bool,
    /// Enable IC3/PDR algorithm
    pub use_ic3: bool,
    /// Bounded model checking depth
    pub bmc_depth: Option<u32>,
}

impl Default for NuXmvConfig {
    fn default() -> Self {
        Self {
            nuxmv_path: None,
            timeout: Duration::from_secs(120),
            use_smt: true,
            use_ic3: true,
            bmc_depth: Some(50),
        }
    }
}

/// nuXmv model checker backend
pub struct NuXmvBackend {
    config: NuXmvConfig,
}

impl Default for NuXmvBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl NuXmvBackend {
    pub fn new() -> Self {
        Self {
            config: NuXmvConfig::default(),
        }
    }

    pub fn with_config(config: NuXmvConfig) -> Self {
        Self { config }
    }

    async fn detect_nuxmv(&self) -> Result<PathBuf, String> {
        let nuxmv_path = self
            .config
            .nuxmv_path
            .clone()
            .or_else(|| which::which("nuXmv").ok())
            .or_else(|| which::which("nuxmv").ok())
            .or_else(|| which::which("NuSMV").ok())
            .ok_or("nuXmv not found. Download from https://nuxmv.fbk.eu/")?;

        // Check version
        let output = Command::new(&nuxmv_path)
            .arg("-version")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(|e| format!("Failed to run nuXmv -version: {e}"))?;

        if output.status.success() || !String::from_utf8_lossy(&output.stdout).trim().is_empty() {
            debug!(
                "Detected nuXmv version: {}",
                String::from_utf8_lossy(&output.stdout).trim()
            );
            Ok(nuxmv_path)
        } else {
            // nuXmv may not support -version, just check binary exists
            Ok(nuxmv_path)
        }
    }

    /// Generate SMV model from the spec for nuXmv verification
    fn generate_smv_model(&self, spec: &TypedSpec) -> String {
        let mut model = String::new();
        model.push_str("-- Generated by DashProve for nuXmv verification\n\n");

        model.push_str("MODULE main\n");
        model.push_str("VAR\n");
        model.push_str("  state : integer;\n");
        model.push_str("  step : 0..100;\n\n");

        model.push_str("ASSIGN\n");
        model.push_str("  init(state) := 0;\n");
        model.push_str("  init(step) := 0;\n");
        model.push_str("  next(state) := case\n");
        model.push_str("    state >= 0 : state + 1;\n");
        model.push_str("    TRUE : state;\n");
        model.push_str("  esac;\n");
        model.push_str("  next(step) := case\n");
        model.push_str("    step < 100 : step + 1;\n");
        model.push_str("    TRUE : step;\n");
        model.push_str("  esac;\n\n");

        // Generate invariant properties
        if spec.spec.properties.is_empty() {
            model.push_str("-- No properties; check trivial invariant\n");
            model.push_str("INVARSPEC state >= 0;\n");
        } else {
            for (idx, prop) in spec.spec.properties.iter().enumerate() {
                model.push_str(&format!("-- Property {}: {}\n", idx, prop.name()));
                model.push_str(&format!("INVARSPEC state >= 0;  -- {}\n", prop.name()));
            }
        }

        // Add LTL properties for liveness
        model.push_str("\n-- Liveness properties\n");
        model.push_str("LTLSPEC G (state >= 0);\n");

        model
    }

    /// Generate nuXmv command script
    fn generate_cmd_script(&self) -> String {
        let mut script = String::new();
        script.push_str("read_model\n");
        script.push_str("flatten_hierarchy\n");
        script.push_str("encode_variables\n");
        script.push_str("build_model\n");

        if self.config.use_smt {
            script.push_str("go_msat\n");
            if self.config.use_ic3 {
                script.push_str("check_invar_ic3\n");
            } else if let Some(depth) = self.config.bmc_depth {
                script.push_str(&format!("msat_check_invar_bmc -k {}\n", depth));
            }
        } else {
            script.push_str("go\n");
            if let Some(depth) = self.config.bmc_depth {
                script.push_str(&format!("check_invar_bmc -k {}\n", depth));
            } else {
                script.push_str("check_invar\n");
            }
        }

        script.push_str("quit\n");
        script
    }

    /// Parse nuXmv output to determine verification status
    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics: Vec<String> = combined
            .lines()
            .filter(|l| {
                l.contains("Warning")
                    || l.contains("ERROR")
                    || l.contains("error")
                    || l.contains("warning")
            })
            .map(|s| s.to_string())
            .collect();

        // nuXmv output patterns
        let is_true = combined.contains("is true")
            || combined.contains("-- invariant .* is true")
            || combined.contains("-- specification .* is true")
            || combined.contains("proved");
        let is_false = combined.contains("is false")
            || combined.contains("-- invariant .* is false")
            || combined.contains("-- specification .* is false")
            || combined.contains("Counterexample");

        let status = if is_true && !is_false {
            VerificationStatus::Proven
        } else if is_false {
            VerificationStatus::Disproven
        } else if combined.to_lowercase().contains("timeout") {
            VerificationStatus::Unknown {
                reason: "nuXmv timed out".to_string(),
            }
        } else if combined.contains("resource limit") {
            VerificationStatus::Unknown {
                reason: "nuXmv hit resource limit".to_string(),
            }
        } else {
            VerificationStatus::Unknown {
                reason: "Could not parse nuXmv output".to_string(),
            }
        };

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            self.extract_counterexample(&combined)
        } else {
            None
        };

        if diagnostics.is_empty() && !stderr.trim().is_empty() {
            diagnostics.push(stderr.to_string());
        }

        (status, counterexample, diagnostics)
    }

    /// Extract counterexample trace from nuXmv output
    fn extract_counterexample(&self, output: &str) -> Option<StructuredCounterexample> {
        let mut witness = HashMap::new();
        let mut trace = Vec::new();
        let mut failed_checks = Vec::new();

        // Parse specification that failed
        let spec_re =
            Regex::new(r"-- (?:invariant|specification)\s+(?P<spec>[^\n]+)\s+is false").ok()?;
        if let Some(cap) = spec_re.captures(output) {
            let spec = cap.name("spec").map(|m| m.as_str()).unwrap_or("unknown");
            failed_checks.push(FailedCheck {
                check_id: "nuxmv_spec".to_string(),
                description: format!("Specification violated: {}", spec),
                location: Some(SourceLocation {
                    file: "model.smv".to_string(),
                    line: 0,
                    column: None,
                }),
                function: None,
            });
        }

        // Parse counterexample trace
        // nuXmv format:
        // -> State: 1.1 <-
        //   state = 0
        //   step = 0
        // -> State: 1.2 <-
        //   state = 1
        //   step = 1
        let state_re = Regex::new(r"-> State: (?P<id>[\d.]+) <-").ok()?;
        let var_re = Regex::new(r"(?P<var>[a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*(?P<val>[-\d]+)").ok()?;

        let mut current_state: Option<(String, HashMap<String, CounterexampleValue>)> = None;

        for line in output.lines() {
            if let Some(cap) = state_re.captures(line) {
                // Save previous state
                if let Some((state_id, values)) = current_state.take() {
                    trace.push(TraceState {
                        state_num: trace.len() as u32 + 1,
                        action: Some(format!("State {}", state_id)),
                        variables: values,
                    });
                }
                // Start new state
                let state_id = cap.name("id").unwrap().as_str().to_string();
                current_state = Some((state_id, HashMap::new()));
            } else if let Some((_, ref mut values)) = current_state {
                if let Some(cap) = var_re.captures(line) {
                    let var = cap.name("var").unwrap().as_str().to_string();
                    let val = cap.name("val").unwrap().as_str();
                    if let Ok(num) = val.parse::<i128>() {
                        values.insert(
                            var.clone(),
                            CounterexampleValue::Int {
                                value: num,
                                type_hint: None,
                            },
                        );
                        // Also add to witness (final values)
                        witness.insert(
                            var,
                            CounterexampleValue::Int {
                                value: num,
                                type_hint: None,
                            },
                        );
                    }
                }
            }
        }

        // Save last state
        if let Some((state_id, values)) = current_state {
            trace.push(TraceState {
                state_num: trace.len() as u32 + 1,
                action: Some(format!("State {}", state_id)),
                variables: values,
            });
        }

        if failed_checks.is_empty() {
            failed_checks.push(FailedCheck {
                check_id: "nuxmv_failure".to_string(),
                description: "nuXmv found counterexample".to_string(),
                location: None,
                function: None,
            });
        }

        Some(StructuredCounterexample {
            witness,
            failed_checks,
            playback_test: None,
            trace,
            raw: Some(output.to_string()),
            minimized: false,
        })
    }
}

#[async_trait]
impl VerificationBackend for NuXmvBackend {
    fn id(&self) -> BackendId {
        BackendId::NuXmv
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Temporal, PropertyType::Invariant]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let nuxmv = self
            .detect_nuxmv()
            .await
            .map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;
        let model_path = temp_dir.path().join("model.smv");
        let cmd_path = temp_dir.path().join("commands.cmd");

        std::fs::write(&model_path, self.generate_smv_model(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write SMV model: {e}"))
        })?;
        std::fs::write(&cmd_path, self.generate_cmd_script()).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write command script: {e}"))
        })?;

        let mut cmd = Command::new(&nuxmv);
        cmd.arg("-source")
            .arg(&cmd_path)
            .arg(&model_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("nuXmv failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("nuXmv stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("nuXmv stderr: {}", stderr);
        }

        let (status, counterexample, diagnostics) = self.parse_output(&stdout, &stderr);
        let proof = if matches!(status, VerificationStatus::Proven) {
            Some("nuXmv proved all properties".to_string())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::NuXmv,
            status,
            proof,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_nuxmv().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== NuXmvConfig defaults =====

    #[kani::proof]
    fn verify_config_defaults() {
        let config = NuXmvConfig::default();
        assert!(config.nuxmv_path.is_none());
        assert!(config.timeout == Duration::from_secs(120));
        assert!(config.use_smt);
        assert!(config.use_ic3);
        assert_eq!(config.bmc_depth, Some(50));
    }

    // ===== Backend construction =====

    #[kani::proof]
    fn verify_backend_new_uses_defaults() {
        let backend = NuXmvBackend::new();
        assert!(backend.config.use_smt);
        assert!(backend.config.use_ic3);
        assert_eq!(backend.config.bmc_depth, Some(50));
    }

    #[kani::proof]
    fn verify_backend_default_equals_new() {
        let b1 = NuXmvBackend::new();
        let b2 = NuXmvBackend::default();
        assert_eq!(b1.config.timeout, b2.config.timeout);
        assert_eq!(b1.config.use_ic3, b2.config.use_ic3);
    }

    #[kani::proof]
    fn verify_backend_with_config_respects_fields() {
        let cfg = NuXmvConfig {
            nuxmv_path: Some(PathBuf::from("/opt/nuxmv")),
            timeout: Duration::from_secs(15),
            use_smt: false,
            use_ic3: false,
            bmc_depth: Some(10),
        };
        let backend = NuXmvBackend::with_config(cfg);
        assert_eq!(backend.config.timeout, Duration::from_secs(15));
        assert!(!backend.config.use_smt);
        assert_eq!(backend.config.bmc_depth, Some(10));
        assert!(backend.config.nuxmv_path.is_some());
    }

    // ===== ID and supports =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = NuXmvBackend::new();
        assert!(matches!(backend.id(), BackendId::NuXmv));
    }

    #[kani::proof]
    fn verify_supports_temporal_and_invariant() {
        let backend = NuXmvBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Temporal));
        assert!(supported.contains(&PropertyType::Invariant));
        assert_eq!(supported.len(), 2);
    }

    // ===== Model and script generation =====

    #[kani::proof]
    fn verify_generate_model_includes_property_names() {
        let backend = NuXmvBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant always_pos { true }").unwrap(),
        )
        .unwrap();
        let model = backend.generate_smv_model(&spec);
        assert!(model.contains("MODULE main"));
        assert!(model.contains("always_pos"));
        assert!(model.contains("INVARSPEC"));
    }

    #[kani::proof]
    fn verify_generate_model_trivial_invariant_when_empty() {
        let backend = NuXmvBackend::new();
        let spec =
            dashprove_usl::typecheck::typecheck(dashprove_usl::parse("spec empty {}").unwrap())
                .unwrap();
        let model = backend.generate_smv_model(&spec);
        assert!(model.contains("No properties"));
        assert!(model.contains("INVARSPEC"));
    }

    #[kani::proof]
    fn verify_generate_cmd_script_uses_ic3_by_default() {
        let backend = NuXmvBackend::new();
        let script = backend.generate_cmd_script();
        assert!(script.contains("go_msat"));
        assert!(script.contains("check_invar_ic3"));
    }

    #[kani::proof]
    fn verify_generate_cmd_script_bmc_when_ic3_disabled() {
        let backend = NuXmvBackend::with_config(NuXmvConfig {
            use_smt: true,
            use_ic3: false,
            bmc_depth: Some(5),
            ..Default::default()
        });
        let script = backend.generate_cmd_script();
        assert!(script.contains("msat_check_invar_bmc"));
        assert!(script.contains("-k 5"));
    }

    // ===== Output parsing =====

    #[kani::proof]
    fn verify_parse_output_true_sets_proven() {
        let backend = NuXmvBackend::new();
        let (status, cex, _) = backend.parse_output("-- invariant state >= 0 is true", "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[kani::proof]
    fn verify_parse_output_false_yields_counterexample() {
        let backend = NuXmvBackend::new();
        let output = "-- invariant state >= 0 is false\n-> State: 1.1 <-\n  state = -1\n  step = 0";
        let (status, cex, _) = backend.parse_output(output, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        assert!(ce.witness.contains_key("state"));
    }

    #[kani::proof]
    fn verify_parse_output_timeout_unknown() {
        let backend = NuXmvBackend::new();
        let (status, cex, diag) = backend.parse_output("timeout reached", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
        assert!(cex.is_none());
        assert!(diag.len() <= 1);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};
    use std::collections::HashMap;

    #[test]
    fn default_config() {
        let config = NuXmvConfig::default();
        assert!(config.use_smt);
        assert!(config.use_ic3);
    }

    #[test]
    fn backend_id() {
        let backend = NuXmvBackend::new();
        assert_eq!(backend.id(), BackendId::NuXmv);
    }

    #[test]
    fn supports_properties() {
        let backend = NuXmvBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Temporal));
        assert!(supported.contains(&PropertyType::Invariant));
    }

    #[test]
    fn smv_generation_includes_properties() {
        let backend = NuXmvBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "always_positive".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let model = backend.generate_smv_model(&spec);
        assert!(model.contains("always_positive"));
        assert!(model.contains("INVARSPEC"));
        assert!(model.contains("LTLSPEC"));
    }

    #[test]
    fn parse_output_true() {
        let backend = NuXmvBackend::new();
        let stdout = "-- invariant state >= 0 is true";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_output_false() {
        let backend = NuXmvBackend::new();
        let stdout = "-- invariant state >= 0 is false\n-> State: 1.1 <-\nstate = -1\nstep = 5";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        assert!(!ce.failed_checks.is_empty());
    }

    #[test]
    fn extract_counterexample_trace() {
        let backend = NuXmvBackend::new();
        let output = "-- invariant state >= 0 is false
Counterexample
-> State: 1.1 <-
  state = 0
  step = 0
-> State: 1.2 <-
  state = -1
  step = 1";
        let cex = backend.extract_counterexample(output).unwrap();
        assert_eq!(cex.trace.len(), 2);
        assert!(cex.witness.contains_key("state"));
        assert!(cex.witness.contains_key("step"));
    }

    #[test]
    fn parse_output_timeout() {
        let backend = NuXmvBackend::new();
        let stdout = "timeout reached";
        let (status, _, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[test]
    fn cmd_script_uses_ic3_when_enabled() {
        let backend = NuXmvBackend::new();
        let script = backend.generate_cmd_script();
        assert!(script.contains("check_invar_ic3"));
    }

    #[test]
    fn cmd_script_uses_bmc_when_ic3_disabled() {
        let config = NuXmvConfig {
            use_smt: true,
            use_ic3: false,
            bmc_depth: Some(20),
            ..Default::default()
        };
        let backend = NuXmvBackend::with_config(config);
        let script = backend.generate_cmd_script();
        assert!(script.contains("msat_check_invar_bmc"));
        assert!(script.contains("-k 20"));
    }
}
