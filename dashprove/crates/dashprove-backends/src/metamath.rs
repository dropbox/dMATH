//! Metamath proof verifier backend
//!
//! Metamath is a tiny language for expressing formal proofs in mathematics.
//! It has a very simple syntax and semantics, making it ideal for
//! verification of mathematical proofs.
//!
//! Key features:
//! - Minimalist design (proofs are sequences of labels)
//! - Small trusted code base
//! - Extensive library (set.mm has over 30,000 theorems)
//! - Multiple verifier implementations
//!
//! See: <http://us.metamath.org/>

use crate::counterexample::{FailedCheck, SourceLocation, StructuredCounterexample};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use regex::Regex;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for Metamath backend
#[derive(Debug, Clone)]
pub struct MetamathConfig {
    /// Path to metamath executable
    pub metamath_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Enable verbose output
    pub verbose: bool,
    /// Database file to use (e.g., set.mm)
    pub database: Option<PathBuf>,
}

impl Default for MetamathConfig {
    fn default() -> Self {
        Self {
            metamath_path: None,
            timeout: Duration::from_secs(60),
            verbose: false,
            database: None,
        }
    }
}

/// Metamath proof verifier backend
pub struct MetamathBackend {
    config: MetamathConfig,
}

impl Default for MetamathBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl MetamathBackend {
    pub fn new() -> Self {
        Self {
            config: MetamathConfig::default(),
        }
    }

    pub fn with_config(config: MetamathConfig) -> Self {
        Self { config }
    }

    async fn detect_metamath(&self) -> Result<PathBuf, String> {
        if let Some(path) = &self.config.metamath_path {
            if path.exists() {
                return Ok(path.clone());
            }
        }

        // Try various metamath executables
        for cmd in &["metamath", "mm", "mmverify.py", "checkmm"] {
            if let Ok(path) = which::which(cmd) {
                return Ok(path);
            }
        }

        // Try common paths
        let home = std::env::var("HOME").unwrap_or_default();
        for base in &[
            "/usr/local/bin/metamath",
            "/opt/metamath/metamath",
            &format!("{}/metamath/metamath", home),
            &format!("{}/.local/bin/metamath", home),
        ] {
            let p = PathBuf::from(base);
            if p.exists() {
                return Ok(p);
            }
        }

        Err("Metamath not found. Install via npm install -g metamath-exe".to_string())
    }

    /// Generate Metamath database from USL spec
    fn generate_mm_database(&self, spec: &TypedSpec) -> String {
        let mut mm = String::new();

        mm.push_str("$( Generated by DashProve for Metamath verification $)\n\n");

        // Minimal database with basic constructs
        mm.push_str("$c wff class setvar |- ( ) -> $.\n");
        mm.push_str("$v ph ps ch $.\n");
        mm.push_str("wph $f wff ph $.\n");
        mm.push_str("wps $f wff ps $.\n");
        mm.push_str("wch $f wff ch $.\n\n");

        // Basic axiom: identity
        mm.push_str("$( Axiom of identity $)\n");
        mm.push_str("ax-1 $a |- ( ph -> ( ps -> ph ) ) $.\n\n");

        if spec.spec.properties.is_empty() {
            // Default: prove a simple theorem
            mm.push_str("$( Default theorem $)\n");
            mm.push_str("thm1 $p |- ( ph -> ( ps -> ph ) ) $= wph wps wph ax-1 $.\n");
        } else {
            for (idx, prop) in spec.spec.properties.iter().enumerate() {
                mm.push_str(&format!("$( Property {}: {} $)\n", idx, prop.name()));
                let name = prop.name().replace('-', "_");
                mm.push_str(&format!(
                    "{} $p |- ( ph -> ( ps -> ph ) ) $= wph wps wph ax-1 $.\n",
                    name
                ));
            }
        }

        mm
    }

    /// Parse Metamath output
    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
        exit_code: i32,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics = Vec::new();

        for line in combined.lines() {
            if line.contains("Warning") || line.contains("warning") {
                diagnostics.push(line.trim().to_string());
            }
        }

        // Metamath output patterns
        let success = combined.contains("0 errors")
            || combined.contains("No errors")
            || combined.contains("verified")
            || (exit_code == 0 && !combined.to_lowercase().contains("error"));

        let error = combined.to_lowercase().contains("error")
            && !combined.contains("0 errors")
            && !combined.contains("No errors");

        let status = if success && !error {
            VerificationStatus::Proven
        } else if error || exit_code != 0 {
            VerificationStatus::Disproven
        } else {
            VerificationStatus::Unknown {
                reason: "Could not parse Metamath output".to_string(),
            }
        };

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            self.extract_counterexample(&combined)
        } else {
            None
        };

        (status, counterexample, diagnostics)
    }

    fn extract_counterexample(&self, output: &str) -> Option<StructuredCounterexample> {
        let mut failed_checks = Vec::new();

        // Parse error messages
        let err_re = Regex::new(r"(?i)error[:\s]+(.+)").ok()?;
        if let Some(cap) = err_re.captures(output) {
            failed_checks.push(FailedCheck {
                check_id: "metamath_error".to_string(),
                description: cap.get(1).unwrap().as_str().trim().to_string(),
                location: None,
                function: None,
            });
        }

        // Parse line numbers
        let line_re = Regex::new(r"line\s+(\d+)").ok()?;
        if let Some(cap) = line_re.captures(output) {
            let line: u32 = cap.get(1).unwrap().as_str().parse().unwrap_or(0);
            if !failed_checks.is_empty() {
                failed_checks[0].location = Some(SourceLocation {
                    file: "proof.mm".to_string(),
                    line,
                    column: None,
                });
            }
        }

        // Parse statement labels
        let stmt_re = Regex::new(r"statement\s+(\S+)").ok()?;
        if let Some(cap) = stmt_re.captures(output) {
            let stmt = cap.get(1).unwrap().as_str();
            if !failed_checks.is_empty() {
                failed_checks[0].function = Some(stmt.to_string());
            }
        }

        if failed_checks.is_empty() {
            failed_checks.push(FailedCheck {
                check_id: "metamath_failure".to_string(),
                description: "Metamath proof verification failed".to_string(),
                location: None,
                function: None,
            });
        }

        Some(StructuredCounterexample {
            witness: HashMap::new(),
            failed_checks,
            playback_test: None,
            trace: vec![],
            raw: Some(output.to_string()),
            minimized: false,
        })
    }
}

#[async_trait]
impl VerificationBackend for MetamathBackend {
    fn id(&self) -> BackendId {
        BackendId::Metamath
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Theorem]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let mm = self
            .detect_metamath()
            .await
            .map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;
        let db_path = temp_dir.path().join("proof.mm");

        std::fs::write(&db_path, self.generate_mm_database(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write MM database: {e}"))
        })?;

        let mut cmd = Command::new(&mm);
        cmd.arg("read")
            .arg(&db_path)
            .arg("verify proof *")
            .arg("exit")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("Metamath failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();
        let exit_code = output.status.code().unwrap_or(-1);

        debug!("Metamath stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("Metamath stderr: {}", stderr);
        }

        let (status, counterexample, diagnostics) = self.parse_output(&stdout, &stderr, exit_code);
        let proof = if matches!(status, VerificationStatus::Proven) {
            Some("Metamath verified all proofs".to_string())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::Metamath,
            status,
            proof,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_metamath().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};

    #[test]
    fn default_config() {
        let config = MetamathConfig::default();
        assert_eq!(config.timeout, Duration::from_secs(60));
    }

    #[test]
    fn backend_id() {
        assert_eq!(MetamathBackend::new().id(), BackendId::Metamath);
    }

    #[test]
    fn supports_properties() {
        let backend = MetamathBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Theorem));
    }

    #[test]
    fn mm_database_generation_empty() {
        let backend = MetamathBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let mm = backend.generate_mm_database(&spec);
        assert!(mm.contains("$c"));
        assert!(mm.contains("$a"));
        assert!(mm.contains("$p"));
    }

    #[test]
    fn mm_database_generation_with_property() {
        let backend = MetamathBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "test_thm".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let mm = backend.generate_mm_database(&spec);
        assert!(mm.contains("test_thm"));
    }

    #[test]
    fn parse_output_no_errors() {
        let backend = MetamathBackend::new();
        let stdout = "Verified: 0 errors found";
        let (status, cex, _) = backend.parse_output(stdout, "", 0);
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_output_with_error() {
        let backend = MetamathBackend::new();
        let stdout = "Error: proof failed at line 15";
        let (status, cex, _) = backend.parse_output(stdout, "", 1);
        assert!(matches!(status, VerificationStatus::Disproven));
        assert!(cex.is_some());
    }

    #[test]
    fn extract_counterexample_with_line() {
        let backend = MetamathBackend::new();
        let output = "Error: invalid proof\nline 25 statement thm1";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex.failed_checks[0].location.is_some());
        assert_eq!(cex.failed_checks[0].location.as_ref().unwrap().line, 25);
    }

    #[tokio::test]
    async fn health_check_unavailable() {
        let config = MetamathConfig {
            metamath_path: Some(PathBuf::from("/nonexistent/metamath")),
            ..Default::default()
        };
        let backend = MetamathBackend::with_config(config);
        let health = backend.health_check().await;
        assert!(matches!(health, HealthStatus::Unavailable { .. }));
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ==================== MetamathConfig Default Proofs ====================

    #[kani::proof]
    fn proof_config_default_metamath_path_none() {
        let config = MetamathConfig::default();
        kani::assert(
            config.metamath_path.is_none(),
            "Default metamath_path should be None",
        );
    }

    #[kani::proof]
    fn proof_config_default_timeout_60s() {
        let config = MetamathConfig::default();
        kani::assert(
            config.timeout == Duration::from_secs(60),
            "Default timeout should be 60 seconds",
        );
    }

    #[kani::proof]
    fn proof_config_default_verbose_false() {
        let config = MetamathConfig::default();
        kani::assert(!config.verbose, "Default verbose should be false");
    }

    #[kani::proof]
    fn proof_config_default_database_none() {
        let config = MetamathConfig::default();
        kani::assert(config.database.is_none(), "Default database should be None");
    }

    // ==================== MetamathBackend Construction Proofs ====================

    #[kani::proof]
    fn proof_backend_new_uses_default_config() {
        let backend = MetamathBackend::new();
        kani::assert(
            backend.config.metamath_path.is_none(),
            "new() should use default config with metamath_path=None",
        );
        kani::assert(
            backend.config.timeout == Duration::from_secs(60),
            "new() should use default config with timeout=60s",
        );
    }

    #[kani::proof]
    fn proof_backend_default_equals_new() {
        let b1 = MetamathBackend::new();
        let b2 = MetamathBackend::default();
        kani::assert(
            b1.config.timeout == b2.config.timeout,
            "default() and new() should produce equal timeout",
        );
        kani::assert(
            b1.config.verbose == b2.config.verbose,
            "default() and new() should produce equal verbose",
        );
    }

    #[kani::proof]
    fn proof_backend_with_config_preserves_timeout() {
        let timeout_secs: u64 = kani::any();
        kani::assume(timeout_secs > 0 && timeout_secs < 3600);
        let config = MetamathConfig {
            timeout: Duration::from_secs(timeout_secs),
            ..Default::default()
        };
        let backend = MetamathBackend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(timeout_secs),
            "with_config should preserve timeout",
        );
    }

    #[kani::proof]
    fn proof_backend_with_config_preserves_verbose() {
        let verbose: bool = kani::any();
        let config = MetamathConfig {
            verbose,
            ..Default::default()
        };
        let backend = MetamathBackend::with_config(config);
        kani::assert(
            backend.config.verbose == verbose,
            "with_config should preserve verbose",
        );
    }

    // ==================== Backend Trait Implementation Proofs ====================

    #[kani::proof]
    fn proof_backend_id_is_metamath() {
        let backend = MetamathBackend::new();
        kani::assert(
            backend.id() == BackendId::Metamath,
            "Backend ID should be Metamath",
        );
    }

    #[kani::proof]
    fn proof_supports_contains_theorem() {
        let backend = MetamathBackend::new();
        let supported = backend.supports();
        let has_theorem = supported.iter().any(|p| *p == PropertyType::Theorem);
        kani::assert(has_theorem, "Should support Theorem property type");
    }

    #[kani::proof]
    fn proof_supports_returns_one_type() {
        let backend = MetamathBackend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 1,
            "Should support exactly 1 property type",
        );
    }

    // ==================== generate_mm_database Proofs ====================

    #[kani::proof]
    fn proof_generate_mm_database_contains_constants() {
        let backend = MetamathBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let mm = backend.generate_mm_database(&spec);
        kani::assert(
            mm.contains("$c"),
            "Generated MM should contain '$c' constant declaration",
        );
    }

    #[kani::proof]
    fn proof_generate_mm_database_contains_variables() {
        let backend = MetamathBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let mm = backend.generate_mm_database(&spec);
        kani::assert(
            mm.contains("$v"),
            "Generated MM should contain '$v' variable declaration",
        );
    }

    #[kani::proof]
    fn proof_generate_mm_database_contains_axiom() {
        let backend = MetamathBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let mm = backend.generate_mm_database(&spec);
        kani::assert(
            mm.contains("$a"),
            "Generated MM should contain '$a' axiom declaration",
        );
    }

    #[kani::proof]
    fn proof_generate_mm_database_contains_proof() {
        let backend = MetamathBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let mm = backend.generate_mm_database(&spec);
        kani::assert(
            mm.contains("$p"),
            "Generated MM should contain '$p' provable assertion",
        );
    }

    #[kani::proof]
    fn proof_generate_mm_database_not_empty() {
        let backend = MetamathBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let mm = backend.generate_mm_database(&spec);
        kani::assert(!mm.is_empty(), "Generated MM database should not be empty");
    }

    #[kani::proof]
    fn proof_generate_mm_database_with_property_includes_name() {
        let backend = MetamathBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![dashprove_usl::ast::Property::Invariant(
                    dashprove_usl::ast::Invariant {
                        name: "test_theorem".to_string(),
                        body: dashprove_usl::ast::Expr::Bool(true),
                    },
                )],
            },
            type_info: HashMap::new(),
        };
        let mm = backend.generate_mm_database(&spec);
        kani::assert(
            mm.contains("test_theorem"),
            "Generated MM should include property name",
        );
    }

    // ==================== parse_output Proofs ====================

    #[kani::proof]
    fn proof_parse_output_success_no_errors() {
        let backend = MetamathBackend::new();
        let stdout = "Verified: 0 errors found";
        let (status, cex, _) = backend.parse_output(stdout, "", 0);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should be Proven when output contains '0 errors'",
        );
        kani::assert(cex.is_none(), "Should have no counterexample when proven");
    }

    #[kani::proof]
    fn proof_parse_output_success_verified() {
        let backend = MetamathBackend::new();
        let stdout = "All statements verified";
        let (status, _, _) = backend.parse_output(stdout, "", 0);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should be Proven when output contains 'verified'",
        );
    }

    #[kani::proof]
    fn proof_parse_output_error_detected() {
        let backend = MetamathBackend::new();
        let stdout = "Error: proof failed at line 15";
        let (status, cex, _) = backend.parse_output(stdout, "", 1);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should be Disproven when output contains 'Error'",
        );
        kani::assert(cex.is_some(), "Should have counterexample when disproven");
    }

    #[kani::proof]
    fn proof_parse_output_exit_code_nonzero_disproves() {
        let backend = MetamathBackend::new();
        let stdout = "some output without error keyword but verification failed";
        // Exit code 1 with error-like content
        let (status, _, _) = backend.parse_output(stdout, "error occurred", 1);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should be Disproven when exit code is non-zero and error in stderr",
        );
    }

    #[kani::proof]
    fn proof_parse_output_collects_warnings() {
        let backend = MetamathBackend::new();
        let stdout = "Warning: deprecated syntax\n0 errors";
        let (_, _, diagnostics) = backend.parse_output(stdout, "", 0);
        let has_warning = diagnostics.iter().any(|d| d.contains("Warning"));
        kani::assert(has_warning, "Should collect warning diagnostics");
    }

    // ==================== extract_counterexample Proofs ====================

    #[kani::proof]
    fn proof_extract_counterexample_always_has_failed_check() {
        let backend = MetamathBackend::new();
        let output = "Error: proof failed";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(
                !ce.failed_checks.is_empty(),
                "Counterexample should always have at least one failed check",
            );
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_parses_line_number() {
        let backend = MetamathBackend::new();
        let output = "Error: invalid proof\nline 25";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            if let Some(ref loc) = ce.failed_checks[0].location {
                kani::assert(loc.line == 25, "Should parse line number from output");
            }
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_sets_raw_output() {
        let backend = MetamathBackend::new();
        let output = "Error: failed";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(ce.raw.is_some(), "Counterexample should store raw output");
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_not_minimized() {
        let backend = MetamathBackend::new();
        let output = "Error: failed";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(
                !ce.minimized,
                "Counterexample should not be marked as minimized",
            );
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_empty_witness() {
        let backend = MetamathBackend::new();
        let output = "Error: failed";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(
                ce.witness.is_empty(),
                "Metamath counterexample should have empty witness map",
            );
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_empty_trace() {
        let backend = MetamathBackend::new();
        let output = "Error: failed";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(
                ce.trace.is_empty(),
                "Metamath counterexample should have empty trace",
            );
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_parses_statement() {
        let backend = MetamathBackend::new();
        let output = "Error: invalid proof\nstatement thm1";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            if let Some(ref func) = ce.failed_checks[0].function {
                kani::assert(func == "thm1", "Should parse statement name from output");
            }
        }
    }
}
