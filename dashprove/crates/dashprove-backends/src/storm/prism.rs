//! PRISM model generation from USL specs

use super::config::StateVar;
use super::util::{extract_numeric_value, to_prism_ident};
use dashprove_usl::ast::{ComparisonOp, Expr, Property};
use dashprove_usl::typecheck::TypedSpec;
use std::collections::HashSet;

/// Generate PRISM model from USL spec
pub fn generate_prism(spec: &TypedSpec) -> String {
    let mut prism = String::new();
    prism.push_str("// Generated by DashProve\n");

    // Collect state variables, labels, and transitions from properties
    let mut state_vars: Vec<StateVar> = Vec::new();
    let mut labels: HashSet<String> = HashSet::new();
    let mut is_mdp = false;

    for property in &spec.spec.properties {
        if let Property::Probabilistic(prob) = property {
            extract_probabilistic_patterns(
                &prob.condition,
                &mut state_vars,
                &mut labels,
                &mut is_mdp,
            );
        }
    }

    // Also collect state variables from type definitions
    for typedef in &spec.spec.types {
        // Types with numeric-looking fields become state variables
        for field in &typedef.fields {
            if !state_vars.iter().any(|v| v.name == field.name) {
                state_vars.push(StateVar {
                    name: to_prism_ident(&field.name),
                    min: 0,
                    max: 10,
                    init: 0,
                });
            }
        }
    }

    // Determine model type based on analysis
    if is_mdp {
        prism.push_str("mdp\n\n");
    } else {
        prism.push_str("dtmc\n\n");
    }

    // Generate constants for bounds
    prism.push_str("// Constants\n");
    prism.push_str("const int MAX_STATE = 10;\n");
    prism.push_str("const double p_success = 0.9;\n");
    prism.push_str("const double p_fail = 0.1;\n\n");

    // Generate labels from extracted patterns
    if !labels.is_empty() {
        prism.push_str("// Labels for property checking\n");
        for label in &labels {
            let label_ident = to_prism_ident(label);
            // Generate appropriate label condition based on name
            if label.contains("goal") || label.contains("success") || label.contains("done") {
                prism.push_str(&format!("label \"{}\" = (state=MAX_STATE);\n", label_ident));
            } else if label.contains("fail") || label.contains("error") {
                prism.push_str(&format!("label \"{}\" = (state=-1);\n", label_ident));
            } else {
                prism.push_str(&format!("label \"{}\" = (state>0);\n", label_ident));
            }
        }
        prism.push('\n');
    }

    // Generate module with state variables
    prism.push_str("module main\n");

    if state_vars.is_empty() {
        // Default state variable if none extracted
        prism.push_str("  state : [0..MAX_STATE] init 0;\n");
    } else {
        for var in &state_vars {
            prism.push_str(&format!(
                "  {} : [{}..{}] init {};\n",
                var.name, var.min, var.max, var.init
            ));
        }
    }
    prism.push('\n');

    // Generate transitions based on extracted patterns
    prism.push_str("  // Transitions\n");
    if state_vars.is_empty() {
        // Default transitions
        prism.push_str(
            "  [] state<MAX_STATE -> p_success:(state'=state+1) + p_fail:(state'=state);\n",
        );
        prism.push_str("  [] state=MAX_STATE -> 1:(state'=MAX_STATE);\n");
    } else {
        // Generate transitions for each state variable
        for var in &state_vars {
            prism.push_str(&format!(
                "  [] {name}<{max} -> p_success:({name}'={name}+1) + p_fail:({name}'={name});\n",
                name = var.name,
                max = var.max
            ));
            prism.push_str(&format!(
                "  [] {name}={max} -> 1:({name}'={max});\n",
                name = var.name,
                max = var.max
            ));
        }
    }

    prism.push_str("endmodule\n\n");

    // Generate reward structure if time-related properties
    if labels
        .iter()
        .any(|l| l.contains("time") || l.contains("response"))
    {
        prism.push_str("// Reward structure for time-based properties\n");
        prism.push_str("rewards \"time\"\n");
        prism.push_str("  true : 1;\n");
        prism.push_str("endrewards\n");
    }

    prism
}

/// Extract patterns from probabilistic property conditions
fn extract_probabilistic_patterns(
    expr: &Expr,
    state_vars: &mut Vec<StateVar>,
    labels: &mut HashSet<String>,
    is_mdp: &mut bool,
) {
    match expr {
        // Function applications may indicate state predicates or labels
        Expr::App(name, args) => {
            // Common probabilistic model patterns
            let lower_name = name.to_lowercase();
            if lower_name.contains("goal")
                || lower_name.contains("done")
                || lower_name.contains("success")
                || lower_name.contains("fail")
                || lower_name.contains("error")
            {
                labels.insert(name.clone());
            }

            // Check for state variable references in arguments
            for arg in args {
                extract_probabilistic_patterns(arg, state_vars, labels, is_mdp);
            }
        }

        // Variable references may be state variables
        Expr::Var(name) => {
            let lower_name = name.to_lowercase();
            // Skip common keywords
            if !["true", "false", "self"].contains(&lower_name.as_str()) {
                // Add as potential state variable if not already present
                if !state_vars.iter().any(|v| v.name == *name) {
                    state_vars.push(StateVar {
                        name: to_prism_ident(name),
                        min: 0,
                        max: 10,
                        init: 0,
                    });
                }
            }
        }

        // Comparisons define ranges and goal states
        Expr::Compare(left, op, right) => {
            // Extract variable and bound from comparison
            if let Expr::Var(var_name) = left.as_ref() {
                if let Some(bound) = extract_numeric_value(right) {
                    let existing = state_vars.iter_mut().find(|v| v.name == *var_name);
                    if let Some(var) = existing {
                        // Update bounds based on comparison
                        match op {
                            ComparisonOp::Lt | ComparisonOp::Le => {
                                var.max = var.max.max(bound as i32);
                            }
                            ComparisonOp::Gt | ComparisonOp::Ge => {
                                var.min = var.min.min(bound as i32);
                            }
                            ComparisonOp::Eq => {
                                // Exact value - create label
                                labels.insert(format!("{}_{}", var_name, bound));
                            }
                            _ => {}
                        }
                    } else {
                        state_vars.push(StateVar {
                            name: to_prism_ident(var_name),
                            min: 0,
                            max: (bound as i32).max(10),
                            init: 0,
                        });
                    }
                }
            }
            extract_probabilistic_patterns(left, state_vars, labels, is_mdp);
            extract_probabilistic_patterns(right, state_vars, labels, is_mdp);
        }

        // Logical connectives - recurse
        Expr::And(left, right) | Expr::Or(left, right) | Expr::Implies(left, right) => {
            extract_probabilistic_patterns(left, state_vars, labels, is_mdp);
            extract_probabilistic_patterns(right, state_vars, labels, is_mdp);
        }

        Expr::Not(inner) => {
            extract_probabilistic_patterns(inner, state_vars, labels, is_mdp);
        }

        // ForAll in probabilistic context might indicate MDP (choices)
        Expr::ForAll { body, .. } | Expr::Exists { body, .. } => {
            // Existential quantifiers over actions â†’ MDP
            *is_mdp = true;
            extract_probabilistic_patterns(body, state_vars, labels, is_mdp);
        }

        Expr::ForAllIn {
            body, collection, ..
        }
        | Expr::ExistsIn {
            body, collection, ..
        } => {
            extract_probabilistic_patterns(collection, state_vars, labels, is_mdp);
            extract_probabilistic_patterns(body, state_vars, labels, is_mdp);
        }

        Expr::FieldAccess(object, field) => {
            // Field access may indicate state variable
            if !state_vars.iter().any(|v| v.name == *field) {
                state_vars.push(StateVar {
                    name: to_prism_ident(field),
                    min: 0,
                    max: 10,
                    init: 0,
                });
            }
            extract_probabilistic_patterns(object, state_vars, labels, is_mdp);
        }

        Expr::MethodCall { receiver, args, .. } => {
            extract_probabilistic_patterns(receiver, state_vars, labels, is_mdp);
            for arg in args {
                extract_probabilistic_patterns(arg, state_vars, labels, is_mdp);
            }
        }

        Expr::Binary(left, _, right) => {
            extract_probabilistic_patterns(left, state_vars, labels, is_mdp);
            extract_probabilistic_patterns(right, state_vars, labels, is_mdp);
        }

        Expr::Neg(inner) => {
            extract_probabilistic_patterns(inner, state_vars, labels, is_mdp);
        }

        // Literals don't contribute patterns
        Expr::Int(_) | Expr::Float(_) | Expr::String(_) | Expr::Bool(_) => {}
    }
}
