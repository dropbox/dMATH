//! Tests for PRISM backend

use super::*;
use crate::traits::{PropertyType, VerificationStatus};

#[test]
fn default_config() {
    let config = PrismConfig::default();
    assert!(matches!(config.engine, PrismEngine::Hybrid));
    assert_eq!(config.precision, 1e-6);
}

#[test]
fn parse_satisfied_result() {
    let status = parsing::parse_output("Property satisfied\n", "");
    assert!(matches!(status, VerificationStatus::Proven));
}

#[test]
fn parse_not_satisfied_result() {
    let status = parsing::parse_output("Property NOT satisfied\n", "");
    assert!(matches!(status, VerificationStatus::Disproven));
}

#[test]
fn parse_probability_result() {
    let status = parsing::parse_output("Result: 0.85\n", "");
    assert!(matches!(status, VerificationStatus::Partial { .. }));
}

#[test]
fn parse_true_result() {
    let status = parsing::parse_output("Result: true\n", "");
    assert!(matches!(status, VerificationStatus::Proven));
}

// ========== USL to PRISM Compilation Tests ==========

#[test]
fn test_to_prism_ident() {
    assert_eq!(util::to_prism_ident("state"), "state");
    assert_eq!(util::to_prism_ident("myVar"), "myVar");
    assert_eq!(util::to_prism_ident("123var"), "_123var");
    assert_eq!(util::to_prism_ident("var-name"), "var_name");
    assert_eq!(util::to_prism_ident("module"), "module_var");
    assert_eq!(util::to_prism_ident("true"), "true_var");
    assert_eq!(util::to_prism_ident("init"), "init_var");
}

#[test]
fn test_generate_prism_model_basic() {
    let spec = dashprove_usl::Spec {
        types: vec![],
        properties: vec![],
    };
    let typed_spec = dashprove_usl::typecheck(spec).unwrap();

    let prism_output = model::generate_prism_model(&typed_spec);

    assert!(
        prism_output.contains("dtmc"),
        "PRISM should specify model type"
    );
    assert!(
        prism_output.contains("module"),
        "PRISM should contain module"
    );
    assert!(
        prism_output.contains("endmodule"),
        "PRISM should close module"
    );
    assert!(
        prism_output.contains("Generated by DashProve"),
        "PRISM should have DashProve header"
    );
}

#[test]
fn test_generate_prism_model_has_transitions() {
    let spec = dashprove_usl::Spec {
        types: vec![],
        properties: vec![],
    };
    let typed_spec = dashprove_usl::typecheck(spec).unwrap();

    let prism_output = model::generate_prism_model(&typed_spec);

    assert!(
        prism_output.contains("->"),
        "PRISM should contain transition arrow"
    );
    assert!(
        prism_output.contains("[]"),
        "PRISM should contain guard brackets"
    );
}

#[test]
fn test_generate_prism_with_types() {
    use dashprove_usl::ast::{Field, Type, TypeDef};

    let spec = dashprove_usl::Spec {
        types: vec![TypeDef {
            name: "System".to_string(),
            fields: vec![
                Field {
                    name: "count".to_string(),
                    ty: Type::Named("Int".to_string()),
                },
                Field {
                    name: "active".to_string(),
                    ty: Type::Named("Bool".to_string()),
                },
            ],
        }],
        properties: vec![],
    };
    let typed_spec = dashprove_usl::typecheck(spec).unwrap();

    let prism_output = model::generate_prism_model(&typed_spec);

    // Should include state variables from type fields
    assert!(
        prism_output.contains("count") || prism_output.contains("active"),
        "PRISM should include state variables from types: {}",
        prism_output
    );
}

#[test]
fn test_generate_prism_reachability_property() {
    use dashprove_usl::ast::{ComparisonOp, Expr, Probabilistic, Property};

    let spec = dashprove_usl::Spec {
        types: vec![],
        properties: vec![Property::Probabilistic(Probabilistic {
            name: "reach_goal".to_string(),
            condition: Expr::App("goal".to_string(), vec![]),
            comparison: ComparisonOp::Ge,
            bound: 0.99,
        })],
    };
    let typed_spec = dashprove_usl::typecheck(spec).unwrap();

    let prism_output = model::generate_prism_model(&typed_spec);
    let pctl_output = pctl::generate_pctl_property(&typed_spec);

    // Should have label for goal
    assert!(
        prism_output.contains("label") && prism_output.contains("goal"),
        "PRISM should have goal label: {}",
        prism_output
    );

    // PCTL should reference the bound
    assert!(
        pctl_output.contains(">=0.99") || pctl_output.contains(">= 0.99"),
        "PCTL should have probability bound: {}",
        pctl_output
    );
}

#[test]
fn test_generate_prism_response_time() {
    use dashprove_usl::ast::{ComparisonOp, Expr, Probabilistic, Property};

    // probability(response_time < 100) >= 0.95
    let spec = dashprove_usl::Spec {
        types: vec![],
        properties: vec![Property::Probabilistic(Probabilistic {
            name: "response_bound".to_string(),
            condition: Expr::Compare(
                Box::new(Expr::Var("response_time".to_string())),
                ComparisonOp::Lt,
                Box::new(Expr::Int(100)),
            ),
            comparison: ComparisonOp::Ge,
            bound: 0.95,
        })],
    };
    let typed_spec = dashprove_usl::typecheck(spec).unwrap();

    let prism_output = model::generate_prism_model(&typed_spec);

    // Should have state variable for response_time
    assert!(
        prism_output.contains("response_time"),
        "PRISM should have response_time state variable: {}",
        prism_output
    );
}

#[test]
fn test_compile_pctl_eventually() {
    use dashprove_usl::ast::Expr;

    // eventually(done)
    let expr = Expr::App(
        "eventually".to_string(),
        vec![Expr::Var("done".to_string())],
    );

    let pctl_output = pctl::compile_pctl_condition(&expr);

    assert!(
        pctl_output.contains("F"),
        "Eventually should compile to F (finally): {}",
        pctl_output
    );
}

#[test]
fn test_compile_pctl_always() {
    use dashprove_usl::ast::Expr;

    // always(safe)
    let expr = Expr::App("always".to_string(), vec![Expr::Var("safe".to_string())]);

    let pctl_output = pctl::compile_pctl_condition(&expr);

    assert!(
        pctl_output.contains("G"),
        "Always should compile to G (globally): {}",
        pctl_output
    );
}

#[test]
fn test_compile_pctl_until() {
    use dashprove_usl::ast::Expr;

    // until(waiting, served)
    let expr = Expr::App(
        "until".to_string(),
        vec![
            Expr::Var("waiting".to_string()),
            Expr::Var("served".to_string()),
        ],
    );

    let pctl_output = pctl::compile_pctl_condition(&expr);

    assert!(
        pctl_output.contains("U"),
        "Until should compile to U: {}",
        pctl_output
    );
    assert!(
        pctl_output.contains("waiting"),
        "Until should include left operand: {}",
        pctl_output
    );
    assert!(
        pctl_output.contains("served"),
        "Until should include right operand: {}",
        pctl_output
    );
}

#[test]
fn test_compile_pctl_next() {
    use dashprove_usl::ast::Expr;

    // next(done)
    let expr = Expr::App("next".to_string(), vec![Expr::Var("done".to_string())]);

    let pctl_output = pctl::compile_pctl_condition(&expr);

    assert!(
        pctl_output.contains("X"),
        "Next should compile to X: {}",
        pctl_output
    );
}

#[test]
fn test_compile_pctl_comparison() {
    use dashprove_usl::ast::{ComparisonOp, Expr};

    // count >= 5
    let expr = Expr::Compare(
        Box::new(Expr::Var("count".to_string())),
        ComparisonOp::Ge,
        Box::new(Expr::Int(5)),
    );

    let pctl_output = pctl::compile_pctl_condition(&expr);

    assert!(
        pctl_output.contains("count"),
        "Comparison should include variable: {}",
        pctl_output
    );
    assert!(
        pctl_output.contains(">="),
        "Comparison should include operator: {}",
        pctl_output
    );
    assert!(
        pctl_output.contains("5"),
        "Comparison should include bound: {}",
        pctl_output
    );
}

#[test]
fn test_compile_pctl_and() {
    use dashprove_usl::ast::Expr;

    // a and b
    let expr = Expr::And(
        Box::new(Expr::Var("a".to_string())),
        Box::new(Expr::Var("b".to_string())),
    );

    let pctl_output = pctl::compile_pctl_condition(&expr);

    assert!(
        pctl_output.contains("&"),
        "And should compile to &: {}",
        pctl_output
    );
    assert!(
        pctl_output.contains("a"),
        "And should include left operand: {}",
        pctl_output
    );
    assert!(
        pctl_output.contains("b"),
        "And should include right operand: {}",
        pctl_output
    );
}

#[test]
fn test_compile_pctl_or() {
    use dashprove_usl::ast::Expr;

    // a or b
    let expr = Expr::Or(
        Box::new(Expr::Var("a".to_string())),
        Box::new(Expr::Var("b".to_string())),
    );

    let pctl_output = pctl::compile_pctl_condition(&expr);

    assert!(
        pctl_output.contains("|"),
        "Or should compile to |: {}",
        pctl_output
    );
}

#[test]
fn test_compile_pctl_not() {
    use dashprove_usl::ast::Expr;

    // not error
    let expr = Expr::Not(Box::new(Expr::Var("error".to_string())));

    let pctl_output = pctl::compile_pctl_condition(&expr);

    assert!(
        pctl_output.contains("!"),
        "Not should compile to !: {}",
        pctl_output
    );
    assert!(
        pctl_output.contains("error"),
        "Not should include operand: {}",
        pctl_output
    );
}

#[test]
fn test_compile_pctl_implies() {
    use dashprove_usl::ast::Expr;

    // request implies response
    let expr = Expr::Implies(
        Box::new(Expr::Var("request".to_string())),
        Box::new(Expr::Var("response".to_string())),
    );

    let pctl_output = pctl::compile_pctl_condition(&expr);

    // implies translates to !P | Q
    assert!(
        pctl_output.contains("!") && pctl_output.contains("|"),
        "Implies should compile to !P | Q: {}",
        pctl_output
    );
}

#[test]
fn test_generate_mdp_from_quantifiers() {
    use dashprove_usl::ast::{ComparisonOp, Expr, Probabilistic, Property};

    // Property with existential quantifier → MDP
    let spec = dashprove_usl::Spec {
        types: vec![],
        properties: vec![Property::Probabilistic(Probabilistic {
            name: "mdp_property".to_string(),
            condition: Expr::Exists {
                var: "action".to_string(),
                ty: None,
                body: Box::new(Expr::App("success".to_string(), vec![])),
            },
            comparison: ComparisonOp::Ge,
            bound: 0.9,
        })],
    };
    let typed_spec = dashprove_usl::typecheck(spec).unwrap();

    let prism_output = model::generate_prism_model(&typed_spec);

    assert!(
        prism_output.contains("mdp"),
        "Existential quantifier should trigger MDP model type: {}",
        prism_output
    );
}

#[test]
fn test_generate_dtmc_without_quantifiers() {
    use dashprove_usl::ast::{ComparisonOp, Expr, Probabilistic, Property};

    // Simple property without quantifiers → DTMC
    let spec = dashprove_usl::Spec {
        types: vec![],
        properties: vec![Property::Probabilistic(Probabilistic {
            name: "dtmc_property".to_string(),
            condition: Expr::App("done".to_string(), vec![]),
            comparison: ComparisonOp::Ge,
            bound: 0.99,
        })],
    };
    let typed_spec = dashprove_usl::typecheck(spec).unwrap();

    let prism_output = model::generate_prism_model(&typed_spec);

    assert!(
        prism_output.contains("dtmc"),
        "Simple property should generate DTMC model: {}",
        prism_output
    );
}

#[test]
fn test_model_without_probabilistic_properties() {
    let spec = dashprove_usl::Spec {
        types: vec![],
        properties: vec![],
    };
    let typed_spec = dashprove_usl::typecheck(spec).unwrap();

    let prism_output = model::generate_prism_model(&typed_spec);
    let pctl_output = pctl::generate_pctl_property(&typed_spec);

    // Should still generate valid PRISM model with defaults
    assert!(
        prism_output.contains("dtmc"),
        "Should default to DTMC: {}",
        prism_output
    );
    assert!(
        prism_output.contains("module main"),
        "Should have main module: {}",
        prism_output
    );
    assert!(
        prism_output.contains("state"),
        "Should have default state variable: {}",
        prism_output
    );

    // Should have default property
    assert!(
        pctl_output.contains("P=?") || pctl_output.contains("F"),
        "Should have default reachability property: {}",
        pctl_output
    );
}

#[test]
fn test_extract_state_bounds_from_comparison() {
    use dashprove_usl::ast::{ComparisonOp, Expr, Probabilistic, Property};

    // probability(count < 100) >= 0.8
    let spec = dashprove_usl::Spec {
        types: vec![],
        properties: vec![Property::Probabilistic(Probabilistic {
            name: "bounded_count".to_string(),
            condition: Expr::Compare(
                Box::new(Expr::Var("count".to_string())),
                ComparisonOp::Lt,
                Box::new(Expr::Int(100)),
            ),
            comparison: ComparisonOp::Ge,
            bound: 0.8,
        })],
    };
    let typed_spec = dashprove_usl::typecheck(spec).unwrap();

    let prism_output = model::generate_prism_model(&typed_spec);

    // Should extract bound from comparison and include in state variable range
    assert!(
        prism_output.contains("count"),
        "Should have count state variable: {}",
        prism_output
    );
}

#[test]
fn test_compile_pctl_field_access() {
    use dashprove_usl::ast::Expr;

    // system.counter
    let expr = Expr::FieldAccess(
        Box::new(Expr::Var("system".to_string())),
        "counter".to_string(),
    );

    let pctl_output = pctl::compile_pctl_condition(&expr);

    assert!(
        pctl_output.contains("counter"),
        "Field access should extract field name: {}",
        pctl_output
    );
}

#[test]
fn test_compile_pctl_arithmetic() {
    use dashprove_usl::ast::{BinaryOp, Expr};

    // x + y
    let expr = Expr::Binary(
        Box::new(Expr::Var("x".to_string())),
        BinaryOp::Add,
        Box::new(Expr::Var("y".to_string())),
    );

    let pctl_output = pctl::compile_pctl_condition(&expr);

    assert!(
        pctl_output.contains("+"),
        "Add should compile to +: {}",
        pctl_output
    );
    assert!(
        pctl_output.contains("x"),
        "Should include x: {}",
        pctl_output
    );
    assert!(
        pctl_output.contains("y"),
        "Should include y: {}",
        pctl_output
    );
}

#[test]
fn test_compile_pctl_literals() {
    use dashprove_usl::ast::Expr;

    assert_eq!(pctl::compile_pctl_condition(&Expr::Int(42)), "42");
    assert!(pctl::compile_pctl_condition(&Expr::Float(1.23)).contains("1.23"));
    assert_eq!(pctl::compile_pctl_condition(&Expr::Bool(true)), "true");
    assert_eq!(pctl::compile_pctl_condition(&Expr::Bool(false)), "false");
}

#[test]
fn test_multiple_probabilistic_properties() {
    use dashprove_usl::ast::{ComparisonOp, Expr, Probabilistic, Property};

    let spec = dashprove_usl::Spec {
        types: vec![],
        properties: vec![
            Property::Probabilistic(Probabilistic {
                name: "reach_goal".to_string(),
                condition: Expr::App("goal".to_string(), vec![]),
                comparison: ComparisonOp::Ge,
                bound: 0.99,
            }),
            Property::Probabilistic(Probabilistic {
                name: "avoid_fail".to_string(),
                condition: Expr::App("fail".to_string(), vec![]),
                comparison: ComparisonOp::Le,
                bound: 0.01,
            }),
        ],
    };
    let typed_spec = dashprove_usl::typecheck(spec).unwrap();

    let pctl_output = pctl::generate_pctl_property(&typed_spec);

    // Should combine multiple properties
    assert!(
        pctl_output.contains("&"),
        "Multiple properties should be combined with &: {}",
        pctl_output
    );
    assert!(
        pctl_output.contains(">=0.99"),
        "Should include first bound: {}",
        pctl_output
    );
    assert!(
        pctl_output.contains("<=0.01"),
        "Should include second bound: {}",
        pctl_output
    );
}

#[test]
fn test_backend_supports_probabilistic() {
    let backend = PrismBackend::new();
    let supported = backend.supports();
    assert!(
        supported.contains(&PropertyType::Probabilistic),
        "PRISM should support Probabilistic property type"
    );
}

#[test]
fn test_backend_id() {
    let backend = PrismBackend::new();
    assert!(matches!(backend.id(), BackendId::Prism));
}
