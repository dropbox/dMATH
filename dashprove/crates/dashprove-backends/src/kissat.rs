//! Kissat SAT solver backend
//!
//! Kissat is a high-performance SAT solver that won multiple SAT competitions.
//! It's known for its clean codebase and excellent performance.
//!
//! Input format: DIMACS CNF
//! Output format:
//! - s SATISFIABLE / s UNSATISFIABLE
//! - v 1 -2 3 0  (satisfying assignment, variables 1=true, 2=false, 3=true)
//!
//! See: <https://github.com/arminbiere/kissat>

use crate::counterexample::{CounterexampleValue, StructuredCounterexample};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for Kissat backend
#[derive(Debug, Clone)]
pub struct KissatConfig {
    /// Path to Kissat binary
    pub kissat_path: Option<PathBuf>,
    /// Timeout for solving
    pub timeout: Duration,
    /// Enable verbose output
    pub verbose: bool,
    /// Conflict limit (0 = no limit)
    pub conflicts: u64,
    /// Decision limit (0 = no limit)
    pub decisions: u64,
}

impl Default for KissatConfig {
    fn default() -> Self {
        Self {
            kissat_path: None,
            timeout: Duration::from_secs(60),
            verbose: false,
            conflicts: 0,
            decisions: 0,
        }
    }
}

/// DIMACS CNF representation
#[derive(Debug, Clone)]
pub struct DimacsCnf {
    /// Number of variables
    pub num_vars: u32,
    /// Number of clauses
    pub num_clauses: u32,
    /// Clauses: each clause is a list of literals (positive = true, negative = false)
    pub clauses: Vec<Vec<i32>>,
    /// Variable name mapping: variable number -> original name
    pub var_names: HashMap<u32, String>,
}

impl DimacsCnf {
    /// Create a new empty CNF formula
    pub fn new() -> Self {
        Self {
            num_vars: 0,
            num_clauses: 0,
            clauses: Vec::new(),
            var_names: HashMap::new(),
        }
    }

    /// Add a variable and return its number
    pub fn add_variable(&mut self, name: &str) -> u32 {
        self.num_vars += 1;
        self.var_names.insert(self.num_vars, name.to_string());
        self.num_vars
    }

    /// Add a clause
    pub fn add_clause(&mut self, literals: Vec<i32>) {
        if !literals.is_empty() {
            self.clauses.push(literals);
            self.num_clauses += 1;
        }
    }

    /// Generate DIMACS format string
    pub fn to_dimacs(&self) -> String {
        let mut output = String::new();

        // Comment with variable mapping
        output.push_str("c DIMACS CNF generated by DashProve\n");
        for (var_num, name) in &self.var_names {
            output.push_str(&format!("c var {} = {}\n", var_num, name));
        }

        // Problem line
        output.push_str(&format!("p cnf {} {}\n", self.num_vars, self.num_clauses));

        // Clauses
        for clause in &self.clauses {
            let clause_str: Vec<String> = clause.iter().map(|l| l.to_string()).collect();
            output.push_str(&clause_str.join(" "));
            output.push_str(" 0\n");
        }

        output
    }
}

impl Default for DimacsCnf {
    fn default() -> Self {
        Self::new()
    }
}

/// Kissat SAT solver backend
pub struct KissatBackend {
    config: KissatConfig,
}

impl Default for KissatBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl KissatBackend {
    pub fn new() -> Self {
        Self {
            config: KissatConfig::default(),
        }
    }

    pub fn with_config(config: KissatConfig) -> Self {
        Self { config }
    }

    async fn detect_kissat(&self) -> Result<PathBuf, String> {
        let kissat_path = self
            .config
            .kissat_path
            .clone()
            .or_else(|| which::which("kissat").ok())
            .ok_or("Kissat not found. Build from https://github.com/arminbiere/kissat")?;

        let output = Command::new(&kissat_path)
            .arg("--version")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(|e| format!("Failed to execute Kissat: {}", e))?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        if stdout.contains("kissat") || output.status.success() {
            debug!("Detected Kissat");
            Ok(kissat_path)
        } else {
            Err("Kissat detection failed".to_string())
        }
    }

    /// Parse Kissat output to extract verification result and model
    fn parse_output(&self, stdout: &str, _stderr: &str) -> (VerificationStatus, Option<Vec<i32>>) {
        // Check for UNSAT first (property holds - negation is unsatisfiable)
        if stdout.contains("s UNSATISFIABLE") {
            return (VerificationStatus::Proven, None);
        }

        // Check for SAT (counterexample exists)
        if stdout.contains("s SATISFIABLE") {
            // Extract model from lines starting with 'v'
            let mut model = Vec::new();
            for line in stdout.lines() {
                let trimmed = line.trim();
                if let Some(rest) = trimmed.strip_prefix('v') {
                    // Parse literals from the line
                    let parts: Vec<&str> = rest.split_whitespace().collect();
                    for part in parts {
                        if let Ok(lit) = part.parse::<i32>() {
                            if lit != 0 {
                                // 0 is the terminator
                                model.push(lit);
                            }
                        }
                    }
                }
            }
            return (VerificationStatus::Disproven, Some(model));
        }

        // Check for UNKNOWN (timeout or resource limit)
        if stdout.contains("s UNKNOWN") || stdout.contains("INDETERMINATE") {
            return (
                VerificationStatus::Unknown {
                    reason: "Kissat returned unknown (timeout or resource limit)".to_string(),
                },
                None,
            );
        }

        // Default: couldn't parse output
        (
            VerificationStatus::Unknown {
                reason: "Could not parse Kissat output".to_string(),
            },
            None,
        )
    }

    /// Parse model into structured counterexample
    fn parse_counterexample(
        &self,
        model: &[i32],
        var_names: &HashMap<u32, String>,
    ) -> StructuredCounterexample {
        let mut ce = StructuredCounterexample::new();

        // Build raw string
        let model_str: String = model.iter().map(|l| format!("{} ", l)).collect();
        ce.raw = Some(format!("SAT model: {}", model_str.trim()));

        // Convert model to named variables
        for &lit in model {
            let var_num = lit.unsigned_abs();
            let value = lit > 0;

            if let Some(name) = var_names.get(&var_num) {
                ce.witness
                    .insert(name.clone(), CounterexampleValue::Bool(value));
            } else {
                // Unnamed variable
                ce.witness
                    .insert(format!("x{}", var_num), CounterexampleValue::Bool(value));
            }
        }

        ce
    }

    /// Compile a USL spec to DIMACS CNF
    ///
    /// This is a simplified compiler that handles propositional formulas.
    /// For full SMT support, use Z3 or another SMT solver.
    fn compile_to_dimacs(&self, spec: &TypedSpec) -> Result<DimacsCnf, String> {
        use dashprove_usl::ast::Property;

        let mut cnf = DimacsCnf::new();

        // Check if spec has any properties
        if spec.spec.properties.is_empty() {
            return Err("No properties to verify".to_string());
        }

        // For demonstration, we encode simple propositional logic
        // Full implementation would traverse the AST and apply Tseitin transformation

        // Add variables for each property
        for (i, property) in spec.spec.properties.iter().enumerate() {
            let name = property.name();
            let kind = match property {
                Property::Theorem(_) => "thm",
                Property::Invariant(_) => "inv",
                Property::Contract(_) => "ctr",
                Property::Temporal(_) => "tmp",
                Property::Refinement(_) => "ref",
                Property::Probabilistic(_) => "prob",
                Property::Security(_) => "sec",
                Property::Semantic(_) => "sem",
                Property::PlatformApi(_) => "api",
                Property::Bisimulation(_) => "bisim",
                Property::Version(_) => "ver",
                Property::Capability(_) => "cap",
                Property::DistributedInvariant(_) => "dinv",
                Property::DistributedTemporal(_) => "dtemp",
                Property::Composed(_) => "comp",
                Property::ImprovementProposal(_) => "imp",
                Property::VerificationGate(_) => "gate",
                Property::Rollback(_) => "rollback",
            };

            let var = cnf.add_variable(&format!("{}_{}", kind, name));
            // The property should hold (single positive literal clause)
            cnf.add_clause(vec![var as i32]);

            // Add auxiliary variables for sub-expressions
            let aux = cnf.add_variable(&format!("aux_{}_{}", kind, i));
            // Link: property => aux (CNF: -property OR aux)
            cnf.add_clause(vec![-(var as i32), aux as i32]);
        }

        // If no clauses were generated, the formula is trivially true
        if cnf.clauses.is_empty() {
            // Add a tautology (x OR -x)
            let var = cnf.add_variable("trivial");
            cnf.add_clause(vec![var as i32]);
            cnf.add_clause(vec![-(var as i32)]);
        }

        Ok(cnf)
    }
}

#[async_trait]
impl VerificationBackend for KissatBackend {
    fn id(&self) -> BackendId {
        BackendId::Kissat
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Theorem, PropertyType::Invariant]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();

        let kissat_path = self
            .detect_kissat()
            .await
            .map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {}", e))
        })?;

        // Compile to DIMACS CNF
        let cnf = self.compile_to_dimacs(spec).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to compile to DIMACS: {}", e))
        })?;

        let cnf_path = temp_dir.path().join("spec.cnf");
        std::fs::write(&cnf_path, cnf.to_dimacs()).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write CNF file: {}", e))
        })?;

        // Build Kissat command
        let mut cmd = Command::new(&kissat_path);
        cmd.arg(&cnf_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        // Add optional arguments
        if self.config.conflicts > 0 {
            cmd.arg(format!("--conflicts={}", self.config.conflicts));
        }
        if self.config.decisions > 0 {
            cmd.arg(format!("--decisions={}", self.config.decisions));
        }
        if self.config.verbose {
            cmd.arg("--verbose");
        }

        // Execute with timeout
        let result =
            tokio::time::timeout(self.config.timeout + Duration::from_secs(5), cmd.output()).await;

        let duration = start.elapsed();

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout).to_string();
                let stderr = String::from_utf8_lossy(&output.stderr).to_string();

                debug!("Kissat stdout: {}", stdout);
                debug!("Kissat stderr: {}", stderr);

                let (status, model) = self.parse_output(&stdout, &stderr);

                let counterexample = model.map(|m| self.parse_counterexample(&m, &cnf.var_names));

                let diagnostics: Vec<String> = stderr
                    .lines()
                    .filter(|l| l.contains("warning") || l.contains("error"))
                    .map(String::from)
                    .collect();

                let proof = if matches!(status, VerificationStatus::Proven) {
                    Some("Verified by Kissat (UNSAT)".to_string())
                } else {
                    None
                };

                Ok(BackendResult {
                    backend: BackendId::Kissat,
                    status,
                    proof,
                    counterexample,
                    diagnostics,
                    time_taken: duration,
                })
            }
            Ok(Err(e)) => Err(BackendError::VerificationFailed(format!(
                "Failed to execute Kissat: {}",
                e
            ))),
            Err(_) => Err(BackendError::Timeout(self.config.timeout)),
        }
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_kissat().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    // =============================================
    // Configuration tests
    // =============================================

    #[test]
    fn default_config() {
        let config = KissatConfig::default();
        assert_eq!(config.timeout, Duration::from_secs(60));
        assert!(!config.verbose);
        assert_eq!(config.conflicts, 0);
        assert_eq!(config.decisions, 0);
    }

    #[test]
    fn custom_config() {
        let config = KissatConfig {
            kissat_path: Some(PathBuf::from("/usr/bin/kissat")),
            timeout: Duration::from_secs(120),
            verbose: true,
            conflicts: 10000,
            decisions: 50000,
        };
        assert_eq!(config.timeout, Duration::from_secs(120));
        assert!(config.verbose);
        assert_eq!(config.conflicts, 10000);
    }

    #[test]
    fn backend_id() {
        let backend = KissatBackend::new();
        assert_eq!(backend.id(), BackendId::Kissat);
    }

    #[test]
    fn backend_supports() {
        let backend = KissatBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Theorem));
        assert!(supported.contains(&PropertyType::Invariant));
    }

    // =============================================
    // Output parsing tests
    // =============================================

    #[test]
    fn parse_unsat() {
        let backend = KissatBackend::new();
        let (status, model) = backend.parse_output("s UNSATISFIABLE\n", "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(model.is_none());
    }

    #[test]
    fn parse_sat_simple() {
        let backend = KissatBackend::new();
        let output = "s SATISFIABLE\nv 1 -2 3 0\n";
        let (status, model) = backend.parse_output(output, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        assert!(model.is_some());
        let m = model.unwrap();
        assert_eq!(m, vec![1, -2, 3]);
    }

    #[test]
    fn parse_sat_multiline() {
        let backend = KissatBackend::new();
        let output = "s SATISFIABLE\nv 1 -2 3\nv 4 -5 0\n";
        let (status, model) = backend.parse_output(output, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let m = model.unwrap();
        assert_eq!(m, vec![1, -2, 3, 4, -5]);
    }

    #[test]
    fn parse_sat_with_header() {
        let backend = KissatBackend::new();
        let output = "c kissat SAT solver\nc version 3.0.0\ns SATISFIABLE\nv 1 2 -3 0\n";
        let (status, model) = backend.parse_output(output, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let m = model.unwrap();
        assert_eq!(m, vec![1, 2, -3]);
    }

    #[test]
    fn parse_unknown() {
        let backend = KissatBackend::new();
        let (status, model) = backend.parse_output("s UNKNOWN\n", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
        assert!(model.is_none());
    }

    #[test]
    fn parse_empty_output() {
        let backend = KissatBackend::new();
        let (status, model) = backend.parse_output("", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
        assert!(model.is_none());
    }

    #[test]
    fn parse_garbage_output() {
        let backend = KissatBackend::new();
        let (status, model) = backend.parse_output("random garbage\nno status line", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
        assert!(model.is_none());
    }

    // =============================================
    // DIMACS CNF generation tests
    // =============================================

    #[test]
    fn dimacs_cnf_new() {
        let cnf = DimacsCnf::new();
        assert_eq!(cnf.num_vars, 0);
        assert_eq!(cnf.num_clauses, 0);
        assert!(cnf.clauses.is_empty());
    }

    #[test]
    fn dimacs_cnf_add_variable() {
        let mut cnf = DimacsCnf::new();
        let v1 = cnf.add_variable("x");
        let v2 = cnf.add_variable("y");
        assert_eq!(v1, 1);
        assert_eq!(v2, 2);
        assert_eq!(cnf.num_vars, 2);
        assert_eq!(cnf.var_names.get(&1), Some(&"x".to_string()));
        assert_eq!(cnf.var_names.get(&2), Some(&"y".to_string()));
    }

    #[test]
    fn dimacs_cnf_add_clause() {
        let mut cnf = DimacsCnf::new();
        cnf.add_variable("x");
        cnf.add_variable("y");
        cnf.add_clause(vec![1, -2]);
        cnf.add_clause(vec![-1, 2]);
        assert_eq!(cnf.num_clauses, 2);
        assert_eq!(cnf.clauses[0], vec![1, -2]);
        assert_eq!(cnf.clauses[1], vec![-1, 2]);
    }

    #[test]
    fn dimacs_cnf_empty_clause_ignored() {
        let mut cnf = DimacsCnf::new();
        cnf.add_clause(vec![]);
        assert_eq!(cnf.num_clauses, 0);
    }

    #[test]
    fn dimacs_cnf_to_dimacs_format() {
        let mut cnf = DimacsCnf::new();
        cnf.add_variable("x");
        cnf.add_variable("y");
        cnf.add_clause(vec![1, -2]);
        cnf.add_clause(vec![-1, 2]);

        let output = cnf.to_dimacs();
        assert!(output.contains("p cnf 2 2"));
        assert!(output.contains("1 -2 0"));
        assert!(output.contains("-1 2 0"));
        assert!(output.contains("c var 1 = x"));
        assert!(output.contains("c var 2 = y"));
    }

    #[test]
    fn dimacs_cnf_complex_formula() {
        let mut cnf = DimacsCnf::new();
        let a = cnf.add_variable("a");
        let b = cnf.add_variable("b");
        let c = cnf.add_variable("c");

        // (a OR b) AND (NOT b OR c) AND (NOT a OR NOT c)
        cnf.add_clause(vec![a as i32, b as i32]);
        cnf.add_clause(vec![-(b as i32), c as i32]);
        cnf.add_clause(vec![-(a as i32), -(c as i32)]);

        assert_eq!(cnf.num_vars, 3);
        assert_eq!(cnf.num_clauses, 3);

        let output = cnf.to_dimacs();
        assert!(output.contains("p cnf 3 3"));
    }

    // =============================================
    // Counterexample parsing tests
    // =============================================

    #[test]
    fn parse_counterexample_simple() {
        let backend = KissatBackend::new();
        let model = vec![1, -2, 3];
        let mut var_names = HashMap::new();
        var_names.insert(1, "x".to_string());
        var_names.insert(2, "y".to_string());
        var_names.insert(3, "z".to_string());

        let ce = backend.parse_counterexample(&model, &var_names);

        assert!(ce.witness.contains_key("x"));
        assert!(ce.witness.contains_key("y"));
        assert!(ce.witness.contains_key("z"));

        assert_eq!(ce.witness["x"], CounterexampleValue::Bool(true));
        assert_eq!(ce.witness["y"], CounterexampleValue::Bool(false));
        assert_eq!(ce.witness["z"], CounterexampleValue::Bool(true));
    }

    #[test]
    fn parse_counterexample_unnamed_vars() {
        let backend = KissatBackend::new();
        let model = vec![1, -2];
        let var_names = HashMap::new(); // No names

        let ce = backend.parse_counterexample(&model, &var_names);

        assert!(ce.witness.contains_key("x1"));
        assert!(ce.witness.contains_key("x2"));
        assert_eq!(ce.witness["x1"], CounterexampleValue::Bool(true));
        assert_eq!(ce.witness["x2"], CounterexampleValue::Bool(false));
    }

    #[test]
    fn parse_counterexample_empty_model() {
        let backend = KissatBackend::new();
        let model: Vec<i32> = vec![];
        let var_names = HashMap::new();

        let ce = backend.parse_counterexample(&model, &var_names);

        assert!(ce.witness.is_empty());
        assert!(ce.raw.is_some());
    }

    #[test]
    fn parse_counterexample_has_raw() {
        let backend = KissatBackend::new();
        let model = vec![1, -2];
        let var_names = HashMap::new();

        let ce = backend.parse_counterexample(&model, &var_names);

        assert!(ce.raw.is_some());
        assert!(ce.raw.unwrap().contains("SAT model"));
    }

    #[test]
    fn parse_counterexample_summary() {
        let backend = KissatBackend::new();
        let model = vec![1, -2];
        let mut var_names = HashMap::new();
        var_names.insert(1, "p".to_string());
        var_names.insert(2, "q".to_string());

        let ce = backend.parse_counterexample(&model, &var_names);
        let summary = ce.summary();

        assert!(summary.contains("Witness:"));
    }

    // =============================================
    // Integration-style tests (parsing full output)
    // =============================================

    #[test]
    fn full_output_unsat_verification() {
        let backend = KissatBackend::new();

        // Typical Kissat UNSAT output
        let output = r#"c ---- [ banner ] ------------------------------------------------------------
c Kissat SAT Solver
c Copyright (c) 2019-2023 Armin Biere JKU Linz
c
c Version 3.0.0 c8d397ec36ff15cdf24a8c96c79acefda5d1b62e
c ---- [ solving ] -----------------------------------------------------------
c
c  seconds                                  MB
c   0.001    0 %  search 16 conflicts 5802 per second
c   0.003   50 %  propagate 1204 visits 21 per conflict
c
c ---- [ result ] ------------------------------------------------------------
c
s UNSATISFIABLE
c ---- [ statistics ] --------------------------------------------------------
c chronological:             0            0.00 %  of conflicts
c learned:                  16        100.00 %  per conflict
c
"#;

        let (status, _) = backend.parse_output(output, "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[test]
    fn full_output_sat_verification() {
        let backend = KissatBackend::new();

        // Typical Kissat SAT output
        let output = r#"c ---- [ banner ] ------------------------------------------------------------
c Kissat SAT Solver
c
s SATISFIABLE
v 1 -2 3 -4 5 0
c ---- [ statistics ] --------------------------------------------------------
"#;

        let (status, model) = backend.parse_output(output, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        assert!(model.is_some());
        assert_eq!(model.unwrap(), vec![1, -2, 3, -4, 5]);
    }

    #[test]
    fn full_output_sat_split_model() {
        let backend = KissatBackend::new();

        // Model split across multiple 'v' lines
        let output = r#"s SATISFIABLE
v 1 2 3 4 5 6 7 8 9 10
v 11 12 -13 14 -15 0
"#;

        let (status, model) = backend.parse_output(output, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let m = model.unwrap();
        assert_eq!(m.len(), 15);
        assert_eq!(m[12], -13); // Check negative literal
        assert_eq!(m[14], -15);
    }

    // =============================================
    // Edge cases
    // =============================================

    #[test]
    fn parse_output_indeterminate() {
        let backend = KissatBackend::new();
        let (status, _) = backend.parse_output("s INDETERMINATE\n", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[test]
    fn dimacs_single_unit_clause() {
        let mut cnf = DimacsCnf::new();
        let x = cnf.add_variable("x");
        cnf.add_clause(vec![x as i32]); // Unit clause: x must be true

        let output = cnf.to_dimacs();
        assert!(output.contains("p cnf 1 1"));
        assert!(output.contains("1 0"));
    }

    #[test]
    fn dimacs_contradiction() {
        let mut cnf = DimacsCnf::new();
        let x = cnf.add_variable("x");
        cnf.add_clause(vec![x as i32]); // x = true
        cnf.add_clause(vec![-(x as i32)]); // x = false (contradiction)

        assert_eq!(cnf.num_clauses, 2);
        let output = cnf.to_dimacs();
        assert!(output.contains("1 0"));
        assert!(output.contains("-1 0"));
    }

    #[test]
    fn parse_output_with_stderr_warnings() {
        let backend = KissatBackend::new();
        let (status, _) =
            backend.parse_output("s SATISFIABLE\nv 1 0\n", "warning: timeout approaching\n");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn backend_with_custom_config() {
        let config = KissatConfig {
            timeout: Duration::from_secs(300),
            verbose: true,
            conflicts: 100000,
            decisions: 500000,
            ..Default::default()
        };
        let backend = KissatBackend::with_config(config);
        assert_eq!(backend.config.timeout, Duration::from_secs(300));
        assert!(backend.config.verbose);
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // =============================================
    // KissatConfig default proofs
    // =============================================

    /// Verify KissatConfig::default kissat_path is None
    #[kani::proof]
    fn proof_kissat_config_default_path_none() {
        let config = KissatConfig::default();
        kani::assert(
            config.kissat_path.is_none(),
            "Default kissat_path should be None",
        );
    }

    /// Verify KissatConfig::default timeout is 60 seconds
    #[kani::proof]
    fn proof_kissat_config_default_timeout() {
        let config = KissatConfig::default();
        kani::assert(
            config.timeout == Duration::from_secs(60),
            "Default timeout should be 60 seconds",
        );
    }

    /// Verify KissatConfig::default verbose is false
    #[kani::proof]
    fn proof_kissat_config_default_verbose() {
        let config = KissatConfig::default();
        kani::assert(!config.verbose, "Default verbose should be false");
    }

    /// Verify KissatConfig::default conflicts is 0
    #[kani::proof]
    fn proof_kissat_config_default_conflicts() {
        let config = KissatConfig::default();
        kani::assert(config.conflicts == 0, "Default conflicts should be 0");
    }

    /// Verify KissatConfig::default decisions is 0
    #[kani::proof]
    fn proof_kissat_config_default_decisions() {
        let config = KissatConfig::default();
        kani::assert(config.decisions == 0, "Default decisions should be 0");
    }

    // =============================================
    // KissatBackend trait implementation proofs
    // =============================================

    /// Verify KissatBackend::id returns BackendId::Kissat
    #[kani::proof]
    fn proof_kissat_backend_id() {
        let backend = KissatBackend::new();
        kani::assert(
            backend.id() == BackendId::Kissat,
            "Backend ID should be Kissat",
        );
    }

    /// Verify KissatBackend::supports includes Theorem
    #[kani::proof]
    fn proof_kissat_backend_supports_theorem() {
        let backend = KissatBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::Theorem {
                found = true;
            }
        }
        kani::assert(found, "Should support Theorem");
    }

    /// Verify KissatBackend::supports includes Invariant
    #[kani::proof]
    fn proof_kissat_backend_supports_invariant() {
        let backend = KissatBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::Invariant {
                found = true;
            }
        }
        kani::assert(found, "Should support Invariant");
    }

    /// Verify KissatBackend::supports returns exactly 2 types
    #[kani::proof]
    fn proof_kissat_backend_supports_count() {
        let backend = KissatBackend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 2,
            "Should support exactly 2 property types",
        );
    }

    // =============================================
    // parse_output function proofs
    // =============================================

    /// Verify parse_output returns Proven for UNSATISFIABLE
    #[kani::proof]
    fn proof_parse_output_proven_unsatisfiable() {
        let backend = KissatBackend::new();
        let (status, _) = backend.parse_output("s UNSATISFIABLE\n", "");
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should return Proven for UNSATISFIABLE",
        );
    }

    /// Verify parse_output returns Disproven for SATISFIABLE
    #[kani::proof]
    fn proof_parse_output_disproven_satisfiable() {
        let backend = KissatBackend::new();
        let (status, _) = backend.parse_output("s SATISFIABLE\nv 1 0\n", "");
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should return Disproven for SATISFIABLE",
        );
    }

    /// Verify parse_output returns Unknown for UNKNOWN
    #[kani::proof]
    fn proof_parse_output_unknown_unknown() {
        let backend = KissatBackend::new();
        let (status, _) = backend.parse_output("s UNKNOWN\n", "");
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should return Unknown for s UNKNOWN",
        );
    }

    /// Verify parse_output returns Unknown for INDETERMINATE
    #[kani::proof]
    fn proof_parse_output_unknown_indeterminate() {
        let backend = KissatBackend::new();
        let (status, _) = backend.parse_output("s INDETERMINATE\n", "");
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should return Unknown for INDETERMINATE",
        );
    }

    /// Verify parse_output returns Unknown for empty output
    #[kani::proof]
    fn proof_parse_output_unknown_empty() {
        let backend = KissatBackend::new();
        let (status, _) = backend.parse_output("", "");
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should return Unknown for empty output",
        );
    }

    /// Verify parse_output parses model from SAT
    #[kani::proof]
    fn proof_parse_output_sat_has_model() {
        let backend = KissatBackend::new();
        let (_, model) = backend.parse_output("s SATISFIABLE\nv 1 -2 3 0\n", "");
        kani::assert(model.is_some(), "Should return model for SAT");
        let m = model.unwrap();
        kani::assert(m.len() == 3, "Model should have 3 literals");
    }

    // =============================================
    // DimacsCnf proofs
    // =============================================

    /// Verify DimacsCnf::new creates empty CNF
    #[kani::proof]
    fn proof_dimacs_cnf_new_empty() {
        let cnf = DimacsCnf::new();
        kani::assert(cnf.num_vars == 0, "New CNF should have 0 vars");
        kani::assert(cnf.num_clauses == 0, "New CNF should have 0 clauses");
        kani::assert(cnf.clauses.is_empty(), "New CNF should have empty clauses");
    }

    /// Verify DimacsCnf::default equals new
    #[kani::proof]
    fn proof_dimacs_cnf_default() {
        let cnf = DimacsCnf::default();
        kani::assert(cnf.num_vars == 0, "Default CNF should have 0 vars");
        kani::assert(cnf.num_clauses == 0, "Default CNF should have 0 clauses");
    }

    /// Verify add_variable increments num_vars
    #[kani::proof]
    fn proof_dimacs_cnf_add_variable() {
        let mut cnf = DimacsCnf::new();
        let v1 = cnf.add_variable("x");
        kani::assert(v1 == 1, "First variable should be 1");
        kani::assert(cnf.num_vars == 1, "num_vars should be 1");
    }

    /// Verify add_variable assigns sequential numbers
    #[kani::proof]
    fn proof_dimacs_cnf_add_variable_sequential() {
        let mut cnf = DimacsCnf::new();
        let v1 = cnf.add_variable("x");
        let v2 = cnf.add_variable("y");
        let v3 = cnf.add_variable("z");
        kani::assert(v1 == 1, "First variable should be 1");
        kani::assert(v2 == 2, "Second variable should be 2");
        kani::assert(v3 == 3, "Third variable should be 3");
    }

    /// Verify add_clause increments num_clauses
    #[kani::proof]
    fn proof_dimacs_cnf_add_clause() {
        let mut cnf = DimacsCnf::new();
        cnf.add_clause(vec![1, -2]);
        kani::assert(cnf.num_clauses == 1, "num_clauses should be 1");
        kani::assert(cnf.clauses.len() == 1, "clauses should have 1 element");
    }

    /// Verify add_clause ignores empty clauses
    #[kani::proof]
    fn proof_dimacs_cnf_add_empty_clause_ignored() {
        let mut cnf = DimacsCnf::new();
        cnf.add_clause(vec![]);
        kani::assert(cnf.num_clauses == 0, "Empty clause should be ignored");
        kani::assert(cnf.clauses.is_empty(), "clauses should be empty");
    }

    /// Verify to_dimacs produces valid format
    #[kani::proof]
    fn proof_dimacs_cnf_to_dimacs_format() {
        let mut cnf = DimacsCnf::new();
        cnf.add_variable("x");
        cnf.add_clause(vec![1]);
        let output = cnf.to_dimacs();
        kani::assert(
            output.contains("p cnf 1 1"),
            "DIMACS should have correct header",
        );
        kani::assert(output.contains("1 0"), "DIMACS should have clause");
    }

    /// Verify to_dimacs includes variable mapping
    #[kani::proof]
    fn proof_dimacs_cnf_to_dimacs_var_mapping() {
        let mut cnf = DimacsCnf::new();
        cnf.add_variable("test_var");
        let output = cnf.to_dimacs();
        kani::assert(
            output.contains("c var 1 = test_var"),
            "DIMACS should have var mapping comment",
        );
    }

    // =============================================
    // parse_counterexample function proofs
    // =============================================

    /// Verify parse_counterexample with named vars
    #[kani::proof]
    fn proof_parse_counterexample_named_vars() {
        let backend = KissatBackend::new();
        let model = vec![1, -2];
        let mut var_names = HashMap::new();
        var_names.insert(1, "x".to_string());
        var_names.insert(2, "y".to_string());
        let ce = backend.parse_counterexample(&model, &var_names);
        kani::assert(ce.witness.contains_key("x"), "Should have var x");
        kani::assert(ce.witness.contains_key("y"), "Should have var y");
    }

    /// Verify parse_counterexample with unnamed vars
    #[kani::proof]
    fn proof_parse_counterexample_unnamed_vars() {
        let backend = KissatBackend::new();
        let model = vec![1, -2];
        let var_names = HashMap::new();
        let ce = backend.parse_counterexample(&model, &var_names);
        kani::assert(ce.witness.contains_key("x1"), "Should have unnamed var x1");
        kani::assert(ce.witness.contains_key("x2"), "Should have unnamed var x2");
    }

    /// Verify parse_counterexample empty model
    #[kani::proof]
    fn proof_parse_counterexample_empty() {
        let backend = KissatBackend::new();
        let model: Vec<i32> = vec![];
        let var_names = HashMap::new();
        let ce = backend.parse_counterexample(&model, &var_names);
        kani::assert(
            ce.witness.is_empty(),
            "Empty model should have empty witness",
        );
    }

    /// Verify parse_counterexample sets raw field
    #[kani::proof]
    fn proof_parse_counterexample_has_raw() {
        let backend = KissatBackend::new();
        let model = vec![1];
        let var_names = HashMap::new();
        let ce = backend.parse_counterexample(&model, &var_names);
        kani::assert(ce.raw.is_some(), "Should have raw field set");
    }

    // =============================================
    // KissatBackend constructor proofs
    // =============================================

    /// Verify KissatBackend::new creates backend with default config
    #[kani::proof]
    fn proof_kissat_backend_new_default_config() {
        let backend = KissatBackend::new();
        kani::assert(
            backend.config.timeout == Duration::from_secs(60),
            "New backend should have default timeout",
        );
    }

    /// Verify KissatBackend::with_config preserves config
    #[kani::proof]
    fn proof_kissat_backend_with_config() {
        let config = KissatConfig {
            timeout: Duration::from_secs(120),
            ..Default::default()
        };
        let backend = KissatBackend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(120),
            "Custom config should be preserved",
        );
    }

    /// Verify KissatBackend implements Default
    #[kani::proof]
    fn proof_kissat_backend_default() {
        let backend = KissatBackend::default();
        kani::assert(
            backend.id() == BackendId::Kissat,
            "Default backend should have correct ID",
        );
    }

    /// Verify KissatBackend config verbose can be enabled
    #[kani::proof]
    fn proof_kissat_config_verbose() {
        let config = KissatConfig {
            verbose: true,
            ..Default::default()
        };
        let backend = KissatBackend::with_config(config);
        kani::assert(backend.config.verbose, "Verbose should be enabled");
    }

    /// Verify KissatBackend config conflicts can be set
    #[kani::proof]
    fn proof_kissat_config_conflicts() {
        let config = KissatConfig {
            conflicts: 10000,
            ..Default::default()
        };
        let backend = KissatBackend::with_config(config);
        kani::assert(
            backend.config.conflicts == 10000,
            "Conflicts should be preserved",
        );
    }

    /// Verify KissatBackend config decisions can be set
    #[kani::proof]
    fn proof_kissat_config_decisions() {
        let config = KissatConfig {
            decisions: 50000,
            ..Default::default()
        };
        let backend = KissatBackend::with_config(config);
        kani::assert(
            backend.config.decisions == 50000,
            "Decisions should be preserved",
        );
    }
}
