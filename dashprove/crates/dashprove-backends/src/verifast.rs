//! VeriFast separation logic verifier backend
//!
//! VeriFast verifies C and Java programs using separation logic annotations.
//! It can verify memory safety, data race freedom, and functional correctness.
//!
//! See: <https://github.com/verifast/verifast>

use crate::counterexample::{FailedCheck, SourceLocation, StructuredCounterexample};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for VeriFast backend
#[derive(Debug, Clone)]
pub struct VeriFastConfig {
    /// Path to verifast binary
    pub verifast_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Target language (c or java)
    pub language: VeriFastLanguage,
    /// Allow partial verification (ignore some annotations)
    pub allow_partial: bool,
    /// Additional VeriFast options
    pub extra_args: Vec<String>,
}

/// Target language for VeriFast verification
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum VeriFastLanguage {
    #[default]
    C,
    Java,
}

impl Default for VeriFastConfig {
    fn default() -> Self {
        Self {
            verifast_path: None,
            timeout: Duration::from_secs(120),
            language: VeriFastLanguage::C,
            allow_partial: false,
            extra_args: vec![],
        }
    }
}

/// VeriFast separation logic verifier backend
pub struct VeriFastBackend {
    config: VeriFastConfig,
}

impl Default for VeriFastBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl VeriFastBackend {
    /// Create a new VeriFast backend with default configuration
    pub fn new() -> Self {
        Self {
            config: VeriFastConfig::default(),
        }
    }

    /// Create with custom configuration
    pub fn with_config(config: VeriFastConfig) -> Self {
        Self { config }
    }

    async fn detect_verifast(&self) -> Result<PathBuf, String> {
        let verifast_path = self
            .config
            .verifast_path
            .clone()
            .or_else(|| which::which("verifast").ok())
            .or_else(|| which::which("vfide").ok()) // IDE version
            .ok_or(
                "VeriFast not found. Download from https://github.com/verifast/verifast/releases",
            )?;

        // Check if VeriFast works
        let output = Command::new(&verifast_path)
            .arg("-version")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(|e| format!("Failed to execute verifast: {}", e))?;

        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);

        // VeriFast might not have a -version flag, so also accept if it runs at all
        if output.status.success()
            || stdout.contains("VeriFast")
            || stderr.contains("VeriFast")
            || stdout.contains("verifast")
            || stderr.contains("verifast")
        {
            let version = if !stdout.trim().is_empty() {
                stdout.trim()
            } else if !stderr.trim().is_empty() {
                stderr.trim()
            } else {
                "unknown version"
            };
            debug!("Detected VeriFast: {}", version);
            Ok(verifast_path)
        } else {
            // VeriFast may not support -version, try without args
            let output2 = Command::new(&verifast_path)
                .stdout(Stdio::piped())
                .stderr(Stdio::piped())
                .output()
                .await
                .map_err(|e| format!("Failed to execute verifast: {}", e))?;

            // If it exits with usage info, consider it found
            let combined = format!(
                "{}{}",
                String::from_utf8_lossy(&output2.stdout),
                String::from_utf8_lossy(&output2.stderr)
            );
            if combined.contains("Usage") || combined.contains("verifast") {
                debug!("Detected VeriFast (no version info)");
                Ok(verifast_path)
            } else {
                Err("VeriFast version check failed".to_string())
            }
        }
    }

    /// Generate VeriFast-annotated C code from USL spec
    fn generate_verifast_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();
        code.push_str("// Generated by DashProve\n");
        code.push_str("// Verification with VeriFast separation logic\n\n");

        code.push_str("#include <stdlib.h>\n\n");

        // Generate type definitions as structs
        for type_def in &spec.spec.types {
            let safe_name = Self::sanitize_name(&type_def.name);
            code.push_str(&format!("// Type: {}\n", type_def.name));
            code.push_str(&format!("struct {} {{\n", safe_name));
            code.push_str("    int value;\n");
            code.push_str("};\n\n");
        }

        // Generate properties as verified functions
        for (i, prop) in spec.spec.properties.iter().enumerate() {
            let prop_name = prop.name();
            let safe_name = Self::sanitize_name(&prop_name);
            let fn_name = if safe_name.is_empty() {
                format!("verify_property_{}", i)
            } else {
                format!("verify_{}", safe_name)
            };

            code.push_str(&format!("// Property: {}\n", prop_name));
            code.push_str("/*@\nrequires true;\nensures true;\n@*/\n");
            code.push_str(&format!("void {}()\n", fn_name));
            code.push_str("{\n");
            code.push_str("    //@ assert true;\n");
            code.push_str("}\n\n");
        }

        // If no properties, add a trivial verification target
        if spec.spec.properties.is_empty() {
            code.push_str("/*@\nrequires true;\nensures true;\n@*/\n");
            code.push_str("void verify_trivial()\n");
            code.push_str("{\n");
            code.push_str("    //@ assert true;\n");
            code.push_str("}\n");
        }

        code
    }

    /// Sanitize a name for use in VeriFast/C
    fn sanitize_name(name: &str) -> String {
        let result: String = name
            .replace([' ', '-', ':', '/', '\\', '.', '(', ')', '[', ']'], "_")
            .chars()
            .filter(|c| c.is_alphanumeric() || *c == '_')
            .collect();

        // C identifiers cannot start with a digit
        if result.chars().next().is_some_and(|c| c.is_ascii_digit()) {
            format!("_{}", result)
        } else {
            result
        }
    }

    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
        success: bool,
    ) -> (VerificationStatus, Vec<String>) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics = Vec::new();

        // Count errors and successful verifications
        let mut errors_found = false;
        let mut verify_success = false;

        for line in combined.lines() {
            let trimmed = line.trim();

            // VeriFast success messages
            if trimmed.contains("0 errors found") || trimmed.contains("No errors found") {
                verify_success = true;
                diagnostics.push(format!("✓ {}", trimmed));
            }

            // VeriFast error patterns
            if (trimmed.contains("error:")
                || trimmed.contains("Error:")
                || trimmed.contains("errors found"))
                && !trimmed.contains("0 errors found")
            {
                errors_found = true;
                diagnostics.push(format!("✗ {}", trimmed));
            }

            // Assertion failures
            if trimmed.contains("Assertion might not hold")
                || trimmed.contains("assertion failure")
                || trimmed.contains("Precondition might not hold")
                || trimmed.contains("Postcondition might not hold")
            {
                errors_found = true;
                diagnostics.push(format!("✗ {}", trimmed));
            }

            // Separation logic failures
            if trimmed.contains("memory leak")
                || trimmed.contains("double free")
                || trimmed.contains("use after free")
                || trimmed.contains("heap violation")
            {
                errors_found = true;
                diagnostics.push(format!("✗ Memory safety: {}", trimmed));
            }

            // Track verification progress
            if trimmed.contains("verified") || trimmed.contains("Verified") {
                diagnostics.push(format!("✓ {}", trimmed));
            }
        }

        // Determine status
        if errors_found {
            return (VerificationStatus::Disproven, diagnostics);
        }

        if verify_success {
            return (VerificationStatus::Proven, diagnostics);
        }

        // Check exit status
        if success {
            // VeriFast succeeded with no explicit messages - consider proven
            return (VerificationStatus::Proven, diagnostics);
        }

        // Check for timeout
        if combined.contains("timeout") || combined.contains("Timeout") {
            return (
                VerificationStatus::Unknown {
                    reason: "Verification timed out".to_string(),
                },
                diagnostics,
            );
        }

        // Parse error count if present
        for line in combined.lines() {
            if line.contains("errors found") {
                let words: Vec<&str> = line.split_whitespace().collect();
                for (i, word) in words.iter().enumerate() {
                    if (*word == "errors" || *word == "error") && i > 0 {
                        if let Ok(n) = words[i - 1].parse::<usize>() {
                            if n > 0 {
                                return (VerificationStatus::Disproven, diagnostics);
                            } else {
                                return (VerificationStatus::Proven, diagnostics);
                            }
                        }
                    }
                }
            }
        }

        (
            VerificationStatus::Unknown {
                reason: "Could not parse VeriFast output".to_string(),
            },
            diagnostics,
        )
    }

    /// Parse counterexample from VeriFast output
    fn parse_counterexample(stdout: &str, stderr: &str) -> StructuredCounterexample {
        let mut ce = StructuredCounterexample::new();
        let combined = format!("{}\n{}", stdout, stderr);
        ce.raw = Some(combined.clone());

        // Extract failed checks
        ce.failed_checks = Self::extract_failed_checks(&combined);

        ce
    }

    /// Extract failed checks from VeriFast output
    fn extract_failed_checks(output: &str) -> Vec<FailedCheck> {
        let mut checks = Vec::new();

        for line in output.lines() {
            let trimmed = line.trim();

            // VeriFast error format: "file.c:line:col: error: message"
            if trimmed.contains("error:") || trimmed.contains("Error:") {
                let (location, description) = Self::parse_error_location(trimmed);

                let check_type =
                    if description.contains("assertion") || description.contains("Assertion") {
                        "verifast_assertion"
                    } else if description.contains("precondition")
                        || description.contains("Precondition")
                        || description.contains("requires")
                    {
                        "verifast_precondition"
                    } else if description.contains("postcondition")
                        || description.contains("Postcondition")
                        || description.contains("ensures")
                    {
                        "verifast_postcondition"
                    } else if description.contains("leak")
                        || description.contains("memory")
                        || description.contains("heap")
                    {
                        "verifast_memory"
                    } else if description.contains("data race") || description.contains("race") {
                        "verifast_race"
                    } else {
                        "verifast_error"
                    };

                checks.push(FailedCheck {
                    check_id: check_type.to_string(),
                    description,
                    location,
                    function: None,
                });
            }
        }

        checks
    }

    /// Parse error location from VeriFast error line
    fn parse_error_location(line: &str) -> (Option<SourceLocation>, String) {
        // Format: "file.c:line:col: error: message"
        // Or just: "error: message"
        let parts: Vec<&str> = line.splitn(2, "error:").collect();

        if parts.len() == 2 {
            let location_part = parts[0].trim().trim_end_matches(':');
            let message = parts[1].trim().to_string();

            // Try to parse location
            let loc_parts: Vec<&str> = location_part.split(':').collect();
            if loc_parts.len() >= 3 {
                let file = loc_parts[0].to_string();
                if let (Ok(line_num), Ok(col_num)) =
                    (loc_parts[1].parse::<u32>(), loc_parts[2].parse::<u32>())
                {
                    return (
                        Some(SourceLocation {
                            file,
                            line: line_num,
                            column: Some(col_num),
                        }),
                        message,
                    );
                }
            } else if loc_parts.len() == 2 {
                // Just file:line
                let file = loc_parts[0].to_string();
                if let Ok(line_num) = loc_parts[1].parse::<u32>() {
                    return (
                        Some(SourceLocation {
                            file,
                            line: line_num,
                            column: None,
                        }),
                        message,
                    );
                }
            }

            return (None, message);
        }

        // Fallback - try "Error:" pattern
        let parts: Vec<&str> = line.splitn(2, "Error:").collect();
        if parts.len() == 2 {
            return (None, parts[1].trim().to_string());
        }

        (None, line.to_string())
    }
}

#[async_trait]
impl VerificationBackend for VeriFastBackend {
    fn id(&self) -> BackendId {
        BackendId::VeriFast
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![
            PropertyType::Contract,
            PropertyType::MemorySafety,
            PropertyType::Invariant,
        ]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();

        let verifast_path = self
            .detect_verifast()
            .await
            .map_err(BackendError::Unavailable)?;

        // Create temp directory for VeriFast files
        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp directory: {}", e))
        })?;

        // Determine file extension based on language
        let extension = match self.config.language {
            VeriFastLanguage::C => "c",
            VeriFastLanguage::Java => "java",
        };

        let source_file = temp_dir.path().join(format!("spec.{}", extension));
        let verifast_code = self.generate_verifast_code(spec);

        debug!("Generated VeriFast code:\n{}", verifast_code);

        tokio::fs::write(&source_file, &verifast_code)
            .await
            .map_err(|e| {
                BackendError::VerificationFailed(format!("Failed to write VeriFast file: {}", e))
            })?;

        // Run VeriFast
        let mut cmd = Command::new(&verifast_path);
        cmd.arg(&source_file)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .current_dir(temp_dir.path());

        // Add options
        if self.config.allow_partial {
            cmd.arg("-allow_assume");
        }

        // Add extra args
        for arg in &self.config.extra_args {
            cmd.arg(arg);
        }

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| {
                BackendError::VerificationFailed(format!("Failed to run verifast: {}", e))
            })?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("VeriFast stdout: {}", stdout);
        debug!("VeriFast stderr: {}", stderr);

        let (status, diagnostics) = self.parse_output(&stdout, &stderr, output.status.success());

        // Generate counterexample for failures
        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            Some(Self::parse_counterexample(&stdout, &stderr))
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::VeriFast,
            status,
            proof: None,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_verifast().await {
            Ok(_) => HealthStatus::Healthy,
            Err(r) => HealthStatus::Unavailable { reason: r },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== VeriFastLanguage defaults =====

    #[kani::proof]
    fn verify_language_default_c() {
        let lang = VeriFastLanguage::default();
        assert!(matches!(lang, VeriFastLanguage::C));
    }

    // ===== VeriFastConfig defaults =====

    #[kani::proof]
    fn verify_config_defaults_timeout() {
        let config = VeriFastConfig::default();
        assert!(config.timeout == Duration::from_secs(120));
    }

    #[kani::proof]
    fn verify_config_defaults_options() {
        let config = VeriFastConfig::default();
        assert!(config.verifast_path.is_none());
        assert!(matches!(config.language, VeriFastLanguage::C));
        assert!(!config.allow_partial);
        assert!(config.extra_args.is_empty());
    }

    // ===== Backend construction =====

    #[kani::proof]
    fn verify_backend_new_uses_defaults() {
        let backend = VeriFastBackend::new();
        assert!(backend.config.timeout == Duration::from_secs(120));
        assert!(matches!(backend.config.language, VeriFastLanguage::C));
    }

    #[kani::proof]
    fn verify_backend_default_matches_new() {
        let b1 = VeriFastBackend::new();
        let b2 = VeriFastBackend::default();
        assert!(b1.config.timeout == b2.config.timeout);
        assert!(b1.config.allow_partial == b2.config.allow_partial);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_values() {
        let config = VeriFastConfig {
            verifast_path: Some(PathBuf::from("/usr/bin/verifast")),
            timeout: Duration::from_secs(60),
            language: VeriFastLanguage::Java,
            allow_partial: true,
            extra_args: vec!["--test".to_string()],
        };
        let backend = VeriFastBackend::with_config(config);
        assert!(backend.config.timeout == Duration::from_secs(60));
        assert!(matches!(backend.config.language, VeriFastLanguage::Java));
        assert!(backend.config.allow_partial);
    }

    // ===== ID and supports =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = VeriFastBackend::new();
        assert!(matches!(backend.id(), BackendId::VeriFast));
    }

    #[kani::proof]
    fn verify_supports_contract_memory_invariant() {
        let backend = VeriFastBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Contract));
        assert!(supported.contains(&PropertyType::MemorySafety));
        assert!(supported.contains(&PropertyType::Invariant));
        assert!(supported.len() == 3);
    }

    // ===== Name sanitization =====

    #[kani::proof]
    fn verify_sanitize_name_replaces_dash() {
        let result = VeriFastBackend::sanitize_name("hello-world");
        assert!(result == "hello_world");
    }

    #[kani::proof]
    fn verify_sanitize_name_digit_prefix() {
        let result = VeriFastBackend::sanitize_name("123abc");
        assert!(result == "_123abc");
    }

    // ===== Output parsing =====

    #[kani::proof]
    fn verify_parse_output_no_errors() {
        let backend = VeriFastBackend::new();
        let (status, _) = backend.parse_output("0 errors found", "", true);
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_errors() {
        let backend = VeriFastBackend::new();
        let (status, _) =
            backend.parse_output("", "error: Assertion might not hold\n2 errors found", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_timeout() {
        let backend = VeriFastBackend::new();
        let (status, _) = backend.parse_output("timeout", "", false);
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    // ===== Failed checks extraction =====

    #[kani::proof]
    fn verify_extract_failed_checks_assertion() {
        let output = "spec.c:10:5: error: assertion failed";
        let checks = VeriFastBackend::extract_failed_checks(output);
        assert!(checks.iter().any(|c| c.check_id == "verifast_assertion"));
    }

    #[kani::proof]
    fn verify_extract_failed_checks_memory() {
        let output = "spec.c:20:3: error: memory leak detected";
        let checks = VeriFastBackend::extract_failed_checks(output);
        assert!(checks.iter().any(|c| c.check_id == "verifast_memory"));
    }

    #[kani::proof]
    fn verify_extract_failed_checks_precondition() {
        let output = "spec.c:15:1: error: Precondition not satisfied";
        let checks = VeriFastBackend::extract_failed_checks(output);
        assert!(checks.iter().any(|c| c.check_id == "verifast_precondition"));
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn backend_id() {
        assert_eq!(VeriFastBackend::new().id(), BackendId::VeriFast);
    }

    #[test]
    fn default_config() {
        let config = VeriFastConfig::default();
        assert_eq!(config.language, VeriFastLanguage::C);
        assert_eq!(config.timeout, Duration::from_secs(120));
        assert!(!config.allow_partial);
    }

    #[test]
    fn supports_memory_safety() {
        let backend = VeriFastBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::MemorySafety));
        assert!(supported.contains(&PropertyType::Contract));
    }

    #[test]
    fn sanitize_name() {
        assert_eq!(VeriFastBackend::sanitize_name("hello-world"), "hello_world");
        assert_eq!(VeriFastBackend::sanitize_name("test:prop"), "test_prop");
        assert_eq!(VeriFastBackend::sanitize_name("123abc"), "_123abc");
    }

    #[test]
    fn parse_success_output() {
        let backend = VeriFastBackend::new();
        let stdout = "0 errors found";
        let (status, _diag) = backend.parse_output(stdout, "", true);
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[test]
    fn parse_error_output() {
        let backend = VeriFastBackend::new();
        let stderr = "spec.c:10:5: error: Assertion might not hold\n2 errors found";
        let (status, _diag) = backend.parse_output("", stderr, false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn parse_error_location_with_position() {
        let line = "spec.c:10:5: error: Assertion might not hold";
        let (loc, desc) = VeriFastBackend::parse_error_location(line);
        assert!(loc.is_some());
        let loc = loc.unwrap();
        assert_eq!(loc.file, "spec.c");
        assert_eq!(loc.line, 10);
        assert_eq!(loc.column, Some(5));
        assert!(desc.contains("Assertion might not hold"));
    }

    #[test]
    fn extract_failed_checks_by_type() {
        let output = "spec.c:10:5: error: Assertion might not hold\n\
                      spec.c:20:3: error: memory leak detected";
        let checks = VeriFastBackend::extract_failed_checks(output);
        assert_eq!(checks.len(), 2);
        assert_eq!(checks[0].check_id, "verifast_assertion");
        assert_eq!(checks[1].check_id, "verifast_memory");
    }

    #[test]
    fn generate_verifast_empty_spec() {
        use dashprove_usl::ast::Spec;
        use std::collections::HashMap;

        let backend = VeriFastBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_verifast_code(&spec);
        assert!(code.contains("// Generated by DashProve"));
        assert!(code.contains("verify_trivial"));
        assert!(code.contains("requires true"));
        assert!(code.contains("ensures true"));
    }
}
