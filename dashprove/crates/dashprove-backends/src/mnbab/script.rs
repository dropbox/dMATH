//! MNBaB script generation and output parsing

use super::config::MNBaBConfig;
use crate::counterexample::{build_nn_counterexample, StructuredCounterexample};
use crate::traits::{BackendError, VerificationStatus};
use dashprove_usl::ast::{ComparisonOp, Expr, Property};
use dashprove_usl::typecheck::TypedSpec;

/// Generate an MNBaB verification script from USL spec
pub fn generate_mnbab_script(
    spec: &TypedSpec,
    config: &MNBaBConfig,
) -> Result<String, BackendError> {
    let epsilon = extract_epsilon_from_spec(spec).unwrap_or(config.epsilon);
    let model_path = config
        .model_path
        .as_ref()
        .map(|p| p.display().to_string())
        .unwrap_or_else(|| "model.onnx".to_string());
    let branching = config.branching_strategy.as_str();
    let multi_neuron_count = config.multi_neuron_count;
    let max_branches = config.max_branches;
    let use_gpu = if config.use_gpu { "True" } else { "False" };

    Ok(format!(
        r#"#!/usr/bin/env python3
"""
MNBaB neural network verification script
Generated by DashProve

MNBaB uses multi-neuron relaxation and branch-and-bound for verification.
"""

import sys
import json
import numpy as np

try:
    import mnbab
    from mnbab import MNBaB
    from mnbab.config import Config
except ImportError as e:
    print(f"MNBAB_ERROR: Missing dependency: {{e}}")
    print("MNBAB_ERROR: Install from https://github.com/eth-sri/mn-bab")
    sys.exit(1)

def load_network(model_path: str):
    """Load network for MNBaB verification."""
    try:
        return mnbab.load_model(model_path)
    except Exception as e:
        print(f"MNBAB_ERROR: Failed to load network: {{e}}")
        return None

def create_test_network():
    """Create a simple test network."""
    import torch
    import torch.nn as nn

    model = nn.Sequential(
        nn.Linear(2, 4),
        nn.ReLU(),
        nn.Linear(4, 2)
    )
    model.eval()
    return model

def main():
    model_path = "{model_path}"
    epsilon = {epsilon}
    branching = "{branching}"
    multi_neuron_count = {multi_neuron_count}
    max_branches = {max_branches}
    use_gpu = {use_gpu}

    network = load_network(model_path)
    if network is None:
        print("MNBAB_INFO: Using synthetic test network")
        network = create_test_network()
        input_dim = 2
        output_dim = 2
    else:
        input_dim = network.input_shape[0] if hasattr(network, 'input_shape') else 2
        output_dim = network.output_shape[0] if hasattr(network, 'output_shape') else 2

    # Configure MNBaB
    config = Config()
    config.BRANCHING = branching
    config.MULTI_NEURON_COUNT = multi_neuron_count
    config.MAX_BRANCHES = max_branches
    config.USE_GPU = use_gpu

    np.random.seed(42)
    num_samples = 10
    test_inputs = np.random.rand(num_samples, input_dim).astype(np.float32)

    verified_count = 0
    total_count = num_samples
    counterexamples = []
    total_branches = 0

    for i, x in enumerate(test_inputs):
        try:
            import torch
            with torch.no_grad():
                if hasattr(network, 'forward'):
                    output = network(torch.tensor(x).unsqueeze(0))
                    true_label = output.argmax().item()
                else:
                    true_label = 0

            # Create input bounds
            input_lb = x - epsilon
            input_ub = x + epsilon

            # Run MN-BaB verification
            branches_used = 0
            try:
                verifier = MNBaB(network, config)
                result = verifier.verify(
                    input_lb.reshape(1, -1),
                    input_ub.reshape(1, -1),
                    true_label
                )
                is_verified = result.safe
                branches_used = result.branches if hasattr(result, 'branches') else 0
                counterexample_input = result.counterexample if hasattr(result, 'counterexample') else None
            except Exception as me:
                # Fall back to multi-neuron bounds check
                print(f"MNBAB_INFO: MN-BaB API unavailable, using bounds check: {{me}}")
                import torch
                with torch.no_grad():
                    output_orig = network(torch.tensor(x).unsqueeze(0).float())
                    # Check corners of epsilon ball for adversarial examples
                    corners = [input_lb, input_ub]
                    is_verified = True
                    counterexample_input = None
                    for corner in corners:
                        output_corner = network(torch.tensor(corner).unsqueeze(0).float())
                        if output_corner.argmax().item() != true_label:
                            is_verified = False
                            counterexample_input = corner
                            break

            total_branches += branches_used

            if is_verified:
                verified_count += 1
            else:
                counterexamples.append({{
                    "sample_index": i,
                    "original_input": x.tolist(),
                    "true_label": int(true_label),
                    "counterexample": counterexample_input.tolist() if counterexample_input is not None else input_ub.tolist(),
                    "branches_explored": branches_used
                }})
        except Exception as e:
            print(f"MNBAB_INFO: Sample {{i}} error: {{e}}")

    verification_rate = verified_count / total_count if total_count > 0 else 0.0

    print("MNBAB_RESULT_START")
    result = {{
        "verified_count": verified_count,
        "total_count": total_count,
        "verification_rate": float(verification_rate),
        "epsilon": float(epsilon),
        "branching_strategy": branching,
        "multi_neuron_count": multi_neuron_count,
        "max_branches": max_branches,
        "total_branches_explored": int(total_branches),
        "input_dim": int(input_dim),
        "output_dim": int(output_dim),
        "num_counterexamples": len(counterexamples)
    }}

    if counterexamples:
        result["counterexample"] = counterexamples[0]

    print(json.dumps(result, indent=2))
    print("MNBAB_RESULT_END")

    print(f"\\nMNBAB_SUMMARY: Verified {{verified_count}}/{{total_count}} ({{verification_rate:.2%}})")

    if verification_rate >= 0.99:
        print("MNBAB_STATUS: VERIFIED")
    elif verification_rate >= 0.90:
        print("MNBAB_STATUS: PARTIALLY_VERIFIED")
    else:
        print("MNBAB_STATUS: NOT_VERIFIED")

if __name__ == "__main__":
    main()
"#
    ))
}

fn extract_epsilon_from_spec(spec: &TypedSpec) -> Option<f64> {
    for prop in &spec.spec.properties {
        let expr = match prop {
            Property::Invariant(inv) => Some(&inv.body),
            Property::Theorem(thm) => Some(&thm.body),
            _ => None,
        };
        if let Some(e) = expr {
            if let Some(eps) = extract_epsilon(e) {
                return Some(eps);
            }
        }
    }
    None
}

fn extract_epsilon(expr: &Expr) -> Option<f64> {
    match expr {
        Expr::Compare(lhs, op, rhs) => {
            if let Expr::Var(name) = lhs.as_ref() {
                let lower = name.to_lowercase();
                if (lower.contains("epsilon") || lower == "eps")
                    && matches!(op, ComparisonOp::Le | ComparisonOp::Lt)
                {
                    return extract_numeric_value(rhs);
                }
            }
            extract_epsilon(lhs).or_else(|| extract_epsilon(rhs))
        }
        Expr::And(lhs, rhs) | Expr::Or(lhs, rhs) => {
            extract_epsilon(lhs).or_else(|| extract_epsilon(rhs))
        }
        _ => None,
    }
}

fn extract_numeric_value(expr: &Expr) -> Option<f64> {
    match expr {
        Expr::Float(f) => Some(*f),
        Expr::Int(i) => Some(*i as f64),
        _ => None,
    }
}

/// Parse MNBaB output
pub fn parse_mnbab_output(
    stdout: &str,
    stderr: &str,
) -> (VerificationStatus, Option<StructuredCounterexample>) {
    if stdout.contains("MNBAB_ERROR:") || stderr.contains("MNBAB_ERROR:") {
        let error_msg = stdout
            .lines()
            .chain(stderr.lines())
            .find(|l| l.contains("MNBAB_ERROR:"))
            .map(|l| l.replace("MNBAB_ERROR:", "").trim().to_string())
            .unwrap_or_else(|| "Unknown MNBaB error".to_string());
        return (VerificationStatus::Unknown { reason: error_msg }, None);
    }

    if let Some(json_str) = extract_json_result(stdout, "MNBAB_RESULT_START", "MNBAB_RESULT_END") {
        if let Ok(result) = serde_json::from_str::<serde_json::Value>(&json_str) {
            let verification_rate = result["verification_rate"].as_f64().unwrap_or(0.0);

            let counterexample = build_nn_counterexample("MNBaB", &result, verification_rate);

            if verification_rate >= 0.99 {
                return (VerificationStatus::Proven, None);
            } else if verification_rate >= 0.90 {
                return (
                    VerificationStatus::Partial {
                        verified_percentage: verification_rate * 100.0,
                    },
                    counterexample,
                );
            } else {
                return (VerificationStatus::Disproven, counterexample);
            }
        }
    }

    if stdout.contains("MNBAB_STATUS: VERIFIED") {
        (VerificationStatus::Proven, None)
    } else if stdout.contains("MNBAB_STATUS: PARTIALLY_VERIFIED") {
        (
            VerificationStatus::Partial {
                verified_percentage: 90.0,
            },
            None,
        )
    } else if stdout.contains("MNBAB_STATUS: NOT_VERIFIED") {
        (VerificationStatus::Disproven, None)
    } else {
        (
            VerificationStatus::Unknown {
                reason: "Could not parse MNBaB output".to_string(),
            },
            None,
        )
    }
}

fn extract_json_result(output: &str, start_marker: &str, end_marker: &str) -> Option<String> {
    if let Some(start) = output.find(start_marker) {
        let after_start = &output[start + start_marker.len()..];
        if let Some(end) = after_start.find(end_marker) {
            return Some(after_start[..end].trim().to_string());
        }
    }
    None
}
