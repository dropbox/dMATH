//! KeY Java verification system backend
//!
//! KeY verifies Java programs using symbolic execution and deductive verification.
//! It supports Java programs annotated with JML (Java Modeling Language) specifications.
//!
//! See: <https://www.key-project.org/>

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use regex::Regex;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

#[derive(Debug, Clone)]
pub struct KeyConfig {
    pub key_path: Option<PathBuf>,
    pub timeout: Duration,
    /// Auto-prove mode (tries automatic proof strategies)
    pub auto_mode: bool,
    /// Maximum rule applications for proof search
    pub max_rules: u32,
}

impl Default for KeyConfig {
    fn default() -> Self {
        Self {
            key_path: None,
            timeout: Duration::from_secs(120),
            auto_mode: true,
            max_rules: 10000,
        }
    }
}

pub struct KeyBackend {
    config: KeyConfig,
}

impl Default for KeyBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl KeyBackend {
    pub fn new() -> Self {
        Self {
            config: KeyConfig::default(),
        }
    }
    pub fn with_config(config: KeyConfig) -> Self {
        Self { config }
    }

    async fn detect(&self) -> Result<PathBuf, String> {
        let key = self
            .config
            .key_path
            .clone()
            .or_else(|| which::which("key").ok())
            .or_else(|| which::which("KeY").ok())
            .or_else(|| {
                // Check common installation locations
                let home = std::env::var("HOME").ok()?;
                let path = PathBuf::from(format!("{}/KeY/key.jar", home));
                if path.exists() {
                    Some(path)
                } else {
                    None
                }
            })
            .ok_or("KeY not found. Download from https://www.key-project.org/".to_string())?;

        // If it's a jar file, check if java is available
        if key.extension().map(|e| e == "jar").unwrap_or(false) {
            which::which("java")
                .map_err(|_| "Java required to run KeY but not found".to_string())?;
        }

        Ok(key)
    }

    /// Generate Java code with JML annotations from the spec for KeY verification
    fn generate_java_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();
        code.push_str("// Generated by DashProve for KeY verification\n\n");

        code.push_str("public class Verify {\n");
        code.push_str("    private /*@ spec_public @*/ int state;\n\n");

        // Generate class invariant
        if spec.spec.properties.is_empty() {
            code.push_str("    //@ public invariant state >= 0;\n\n");
        } else {
            for prop in &spec.spec.properties {
                code.push_str(&format!("    // Property: {}\n", prop.name()));
                code.push_str(&format!(
                    "    //@ public invariant state >= 0;  // {}\n",
                    prop.name()
                ));
            }
            code.push('\n');
        }

        // Generate constructor
        code.push_str("    /*@ public normal_behavior\n");
        code.push_str("      @   ensures state == 0;\n");
        code.push_str("      @*/\n");
        code.push_str("    public Verify() {\n");
        code.push_str("        state = 0;\n");
        code.push_str("    }\n\n");

        // Generate a method with contracts
        code.push_str("    /*@ public normal_behavior\n");
        code.push_str("      @   requires state >= 0;\n");
        code.push_str("      @   ensures state >= 0;\n");
        code.push_str("      @   ensures \\result >= 0;\n");
        code.push_str("      @*/\n");
        code.push_str("    public int getState() {\n");

        if !spec.spec.properties.is_empty() {
            for (idx, prop) in spec.spec.properties.iter().enumerate() {
                code.push_str(&format!(
                    "        //@ assert state >= 0;  // Check {}: {}\n",
                    idx,
                    prop.name()
                ));
            }
        }

        code.push_str("        return state;\n");
        code.push_str("    }\n");
        code.push_str("}\n");
        code
    }

    /// Parse KeY output to determine verification status
    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics: Vec<String> = combined
            .lines()
            .filter(|l| {
                l.contains("Error")
                    || l.contains("Warning")
                    || l.contains("error")
                    || l.contains("OPEN GOAL")
            })
            .map(|s| s.to_string())
            .collect();

        // KeY output patterns
        let proven = combined.contains("PROOF CLOSED")
            || combined.contains("Proof closed")
            || combined.contains("All goals closed")
            || combined.contains("proved");
        let failed = combined.contains("OPEN GOAL")
            || combined.contains("Could not close")
            || combined.contains("Proof not closed")
            || combined.contains("counterexample found");

        let status = if proven && !failed {
            VerificationStatus::Proven
        } else if failed {
            VerificationStatus::Disproven
        } else if combined.to_lowercase().contains("timeout") || combined.contains("MAX_RULE") {
            VerificationStatus::Unknown {
                reason: "KeY timed out or exceeded rule limit".to_string(),
            }
        } else {
            VerificationStatus::Unknown {
                reason: "Could not determine KeY result".to_string(),
            }
        };

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            self.extract_counterexample(&combined)
        } else {
            None
        };

        if diagnostics.is_empty() && !stderr.trim().is_empty() {
            diagnostics.push(stderr.to_string());
        }

        (status, counterexample, diagnostics)
    }

    /// Extract counterexample from KeY verification failure
    fn extract_counterexample(&self, output: &str) -> Option<StructuredCounterexample> {
        let mut witness = HashMap::new();
        let mut failed_checks = Vec::new();

        // Parse OPEN GOAL messages
        let goal_re = Regex::new(r"OPEN GOAL[:\s]+(?P<desc>[^\n]+)").ok()?;
        for cap in goal_re.captures_iter(output) {
            let description = cap
                .name("desc")
                .map(|m| m.as_str())
                .unwrap_or("Unproven goal");
            failed_checks.push(FailedCheck {
                check_id: format!("key_goal_{}", failed_checks.len()),
                description: description.to_string(),
                location: None,
                function: None,
            });
        }

        // Parse counterexample values if present
        // KeY format: variable = value or heap[obj.field] = value
        let value_re =
            Regex::new(r"(?P<var>[a-zA-Z_][a-zA-Z0-9_.]*)\s*=\s*(?P<val>[-\d]+)").ok()?;
        for cap in value_re.captures_iter(output) {
            let var = cap.name("var").unwrap().as_str().to_string();
            let val = cap.name("val").unwrap().as_str();
            if let Ok(num) = val.parse::<i128>() {
                witness.insert(
                    var,
                    CounterexampleValue::Int {
                        value: num,
                        type_hint: None,
                    },
                );
            }
        }

        // Try to find location info from stack traces or error messages
        let loc_re = Regex::new(r"(?P<file>[A-Za-z][A-Za-z0-9_]*\.java):(?P<line>\d+)").ok()?;
        if let Some(cap) = loc_re.captures(output) {
            let file = cap.name("file").unwrap().as_str().to_string();
            let line = cap
                .name("line")
                .and_then(|m| m.as_str().parse().ok())
                .unwrap_or(0);

            if failed_checks.is_empty() {
                failed_checks.push(FailedCheck {
                    check_id: "key_failure".to_string(),
                    description: "KeY verification failed".to_string(),
                    location: Some(SourceLocation {
                        file,
                        line,
                        column: None,
                    }),
                    function: None,
                });
            } else {
                // Add location to first failed check
                failed_checks[0].location = Some(SourceLocation {
                    file,
                    line,
                    column: None,
                });
            }
        }

        if failed_checks.is_empty() {
            failed_checks.push(FailedCheck {
                check_id: "key_failure".to_string(),
                description: "KeY verification failed".to_string(),
                location: None,
                function: None,
            });
        }

        Some(StructuredCounterexample {
            witness,
            failed_checks,
            playback_test: None,
            trace: Vec::new(),
            raw: Some(output.to_string()),
            minimized: false,
        })
    }
}

#[async_trait]
impl VerificationBackend for KeyBackend {
    fn id(&self) -> BackendId {
        BackendId::KeY
    }
    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Contract, PropertyType::Invariant]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let key_path = self.detect().await.map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;
        let source_path = temp_dir.path().join("Verify.java");

        std::fs::write(&source_path, self.generate_java_code(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write Java source: {e}"))
        })?;

        let mut cmd = if key_path.extension().map(|e| e == "jar").unwrap_or(false) {
            let mut c = Command::new("java");
            c.arg("-jar").arg(&key_path);
            c
        } else {
            Command::new(&key_path)
        };

        cmd.arg("--auto")
            .arg(&source_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        if self.config.auto_mode {
            cmd.arg("--auto-mode");
        }
        cmd.arg(format!("--max-rules={}", self.config.max_rules));

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("KeY failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("KeY stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("KeY stderr: {}", stderr);
        }

        let (status, counterexample, diagnostics) = self.parse_output(&stdout, &stderr);
        let proof = if matches!(status, VerificationStatus::Proven) {
            Some("KeY proved all JML specifications".to_string())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::KeY,
            status,
            proof,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect().await {
            Ok(_) => HealthStatus::Healthy,
            Err(r) => HealthStatus::Unavailable { reason: r },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};
    use std::collections::HashMap;

    #[test]
    fn backend_id() {
        assert_eq!(KeyBackend::new().id(), BackendId::KeY);
    }

    #[test]
    fn supports_contracts_and_invariants() {
        let backend = KeyBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Contract));
        assert!(supported.contains(&PropertyType::Invariant));
    }

    #[test]
    fn java_generation_includes_jml() {
        let backend = KeyBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "non_negative".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_java_code(&spec);
        assert!(code.contains("non_negative"));
        assert!(code.contains("//@ public invariant"));
        assert!(code.contains("requires"));
        assert!(code.contains("ensures"));
    }

    #[test]
    fn parse_output_proven() {
        let backend = KeyBackend::new();
        let stdout = "Starting KeY...\nPROOF CLOSED\nAll goals closed successfully";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_output_open_goal() {
        let backend = KeyBackend::new();
        let stdout = "OPEN GOAL: state >= 0\nProof not closed";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        assert!(!ce.failed_checks.is_empty());
        assert!(ce.failed_checks[0].description.contains("state >= 0"));
    }

    #[test]
    fn parse_output_timeout() {
        let backend = KeyBackend::new();
        let stdout = "MAX_RULE limit reached";
        let (status, _, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[test]
    fn extract_counterexample_with_values() {
        let backend = KeyBackend::new();
        let output = "OPEN GOAL: invariant\nstate = -1\ncount = 5";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex.witness.contains_key("state"));
        assert!(cex.witness.contains_key("count"));
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // =============================================
    // KeyConfig default proofs
    // =============================================

    /// Verify KeyConfig::default key_path is None
    #[kani::proof]
    fn proof_key_config_default_path_none() {
        let config = KeyConfig::default();
        kani::assert(config.key_path.is_none(), "Default key_path should be None");
    }

    /// Verify KeyConfig::default timeout is 120 seconds
    #[kani::proof]
    fn proof_key_config_default_timeout() {
        let config = KeyConfig::default();
        kani::assert(
            config.timeout == Duration::from_secs(120),
            "Default timeout should be 120 seconds",
        );
    }

    /// Verify KeyConfig::default auto_mode is true
    #[kani::proof]
    fn proof_key_config_default_auto_mode() {
        let config = KeyConfig::default();
        kani::assert(config.auto_mode, "Default auto_mode should be true");
    }

    /// Verify KeyConfig::default max_rules is 10000
    #[kani::proof]
    fn proof_key_config_default_max_rules() {
        let config = KeyConfig::default();
        kani::assert(
            config.max_rules == 10000,
            "Default max_rules should be 10000",
        );
    }

    // =============================================
    // KeyBackend trait implementation proofs
    // =============================================

    /// Verify KeyBackend::id returns BackendId::KeY
    #[kani::proof]
    fn proof_key_backend_id() {
        let backend = KeyBackend::new();
        kani::assert(backend.id() == BackendId::KeY, "Backend ID should be KeY");
    }

    /// Verify KeyBackend::supports includes Contract
    #[kani::proof]
    fn proof_key_backend_supports_contract() {
        let backend = KeyBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::Contract {
                found = true;
            }
        }
        kani::assert(found, "Should support Contract");
    }

    /// Verify KeyBackend::supports includes Invariant
    #[kani::proof]
    fn proof_key_backend_supports_invariant() {
        let backend = KeyBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::Invariant {
                found = true;
            }
        }
        kani::assert(found, "Should support Invariant");
    }

    /// Verify KeyBackend::supports returns exactly 2 types
    #[kani::proof]
    fn proof_key_backend_supports_count() {
        let backend = KeyBackend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 2,
            "Should support exactly 2 property types",
        );
    }

    // =============================================
    // parse_output function proofs
    // =============================================

    /// Verify parse_output returns Proven for PROOF CLOSED
    #[kani::proof]
    fn proof_parse_output_proven_proof_closed() {
        let backend = KeyBackend::new();
        let (status, _, _) = backend.parse_output("PROOF CLOSED", "");
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should return Proven for PROOF CLOSED",
        );
    }

    /// Verify parse_output returns Proven for Proof closed
    #[kani::proof]
    fn proof_parse_output_proven_proof_closed_lowercase() {
        let backend = KeyBackend::new();
        let (status, _, _) = backend.parse_output("Proof closed", "");
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should return Proven for Proof closed",
        );
    }

    /// Verify parse_output returns Proven for All goals closed
    #[kani::proof]
    fn proof_parse_output_proven_all_goals_closed() {
        let backend = KeyBackend::new();
        let (status, _, _) = backend.parse_output("All goals closed", "");
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should return Proven for All goals closed",
        );
    }

    /// Verify parse_output returns Disproven for OPEN GOAL
    #[kani::proof]
    fn proof_parse_output_disproven_open_goal() {
        let backend = KeyBackend::new();
        let (status, _, _) = backend.parse_output("OPEN GOAL: invariant", "");
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should return Disproven for OPEN GOAL",
        );
    }

    /// Verify parse_output returns Disproven for Could not close
    #[kani::proof]
    fn proof_parse_output_disproven_could_not_close() {
        let backend = KeyBackend::new();
        let (status, _, _) = backend.parse_output("Could not close proof", "");
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should return Disproven for Could not close",
        );
    }

    /// Verify parse_output returns Disproven for counterexample found
    #[kani::proof]
    fn proof_parse_output_disproven_counterexample() {
        let backend = KeyBackend::new();
        let (status, _, _) = backend.parse_output("counterexample found", "");
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should return Disproven for counterexample found",
        );
    }

    /// Verify parse_output returns Unknown for timeout
    #[kani::proof]
    fn proof_parse_output_unknown_timeout() {
        let backend = KeyBackend::new();
        let (status, _, _) = backend.parse_output("timeout reached", "");
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should return Unknown for timeout",
        );
    }

    /// Verify parse_output returns Unknown for MAX_RULE
    #[kani::proof]
    fn proof_parse_output_unknown_max_rule() {
        let backend = KeyBackend::new();
        let (status, _, _) = backend.parse_output("MAX_RULE limit reached", "");
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should return Unknown for MAX_RULE",
        );
    }

    // =============================================
    // KeyBackend constructor proofs
    // =============================================

    /// Verify KeyBackend::new creates backend with default config
    #[kani::proof]
    fn proof_key_backend_new_default_config() {
        let backend = KeyBackend::new();
        kani::assert(
            backend.config.timeout == Duration::from_secs(120),
            "New backend should have default timeout",
        );
    }

    /// Verify KeyBackend::with_config preserves config
    #[kani::proof]
    fn proof_key_backend_with_config() {
        let config = KeyConfig {
            timeout: Duration::from_secs(60),
            ..Default::default()
        };
        let backend = KeyBackend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(60),
            "Custom config should be preserved",
        );
    }

    /// Verify KeyBackend implements Default
    #[kani::proof]
    fn proof_key_backend_default() {
        let backend = KeyBackend::default();
        kani::assert(
            backend.id() == BackendId::KeY,
            "Default backend should have correct ID",
        );
    }

    /// Verify KeyBackend config auto_mode can be disabled
    #[kani::proof]
    fn proof_key_config_no_auto_mode() {
        let config = KeyConfig {
            auto_mode: false,
            ..Default::default()
        };
        let backend = KeyBackend::with_config(config);
        kani::assert(!backend.config.auto_mode, "Auto mode should be disabled");
    }

    /// Verify KeyBackend config max_rules can be set
    #[kani::proof]
    fn proof_key_config_with_max_rules() {
        let config = KeyConfig {
            max_rules: 50000,
            ..Default::default()
        };
        let backend = KeyBackend::with_config(config);
        kani::assert(
            backend.config.max_rules == 50000,
            "Max rules should be preserved",
        );
    }
}
