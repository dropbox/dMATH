//! LiquidHaskell refinement types backend
//!
//! LiquidHaskell extends Haskell with refinement types for verification
//! of functional properties using SMT solving.
//!
//! See: <https://ucsd-progsys.github.io/liquidhaskell/>
//!
//! # Features
//!
//! - **Refinement types**: Types annotated with logical predicates
//! - **Measures**: Termination metrics and value measures
//! - **Reflection**: Lift Haskell functions to refinement logic
//! - **Abstract refinements**: Parameterized refinements
//! - **Automatic inference**: SMT-based type inference
//!
//! # Requirements
//!
//! Install LiquidHaskell:
//! ```bash
//! cabal install liquidhaskell
//! # or via stack
//! stack install liquidhaskell
//! ```

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// SMT solver backend for LiquidHaskell
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum LiquidSolver {
    /// Z3 SMT solver (default)
    #[default]
    Z3,
    /// CVC4 SMT solver
    CVC4,
    /// MathSat SMT solver
    MathSat,
}

/// Configuration for LiquidHaskell backend
#[derive(Debug, Clone)]
pub struct LiquidHaskellConfig {
    /// Path to liquid binary
    pub liquid_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// SMT solver to use
    pub solver: LiquidSolver,
    /// Enable totality checking
    pub check_totality: bool,
    /// Enable termination checking
    pub check_termination: bool,
    /// SMT timeout per query (seconds)
    pub smt_timeout: u32,
    /// Additional options
    pub extra_args: Vec<String>,
}

impl Default for LiquidHaskellConfig {
    fn default() -> Self {
        Self {
            liquid_path: None,
            timeout: Duration::from_secs(120),
            solver: LiquidSolver::default(),
            check_totality: true,
            check_termination: true,
            smt_timeout: 30,
            extra_args: vec![],
        }
    }
}

/// LiquidHaskell refinement types backend
pub struct LiquidHaskellBackend {
    config: LiquidHaskellConfig,
}

impl Default for LiquidHaskellBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl LiquidHaskellBackend {
    /// Create a new LiquidHaskell backend with default configuration
    pub fn new() -> Self {
        Self {
            config: LiquidHaskellConfig::default(),
        }
    }

    /// Create with custom configuration
    pub fn with_config(config: LiquidHaskellConfig) -> Self {
        Self { config }
    }

    async fn detect(&self) -> Result<PathBuf, String> {
        // Check configured path first
        if let Some(ref path) = self.config.liquid_path {
            if path.exists() {
                return Ok(path.clone());
            }
        }

        // Try common binary names
        for name in ["liquid", "liquidhaskell"] {
            if let Ok(path) = which::which(name) {
                // Verify it works
                let output = Command::new(&path)
                    .arg("--version")
                    .stdout(Stdio::piped())
                    .stderr(Stdio::piped())
                    .output()
                    .await;

                if let Ok(out) = output {
                    let stdout = String::from_utf8_lossy(&out.stdout);
                    let stderr = String::from_utf8_lossy(&out.stderr);
                    if stdout.contains("LiquidHaskell")
                        || stdout.contains("liquid")
                        || stderr.contains("LiquidHaskell")
                        || out.status.success()
                    {
                        debug!("Detected LiquidHaskell at: {:?}", path);
                        return Ok(path);
                    }
                }
            }
        }

        Err("LiquidHaskell not found. Install via: cabal install liquidhaskell".to_string())
    }

    /// Generate Haskell code with refinement types from USL spec
    fn generate_haskell_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();
        code.push_str("-- Generated by DashProve\n");
        code.push_str("{-@ LIQUID \"--reflection\" @-}\n");
        code.push_str("{-@ LIQUID \"--ple\" @-}\n\n");
        code.push_str("module Verification where\n\n");

        // Import base
        code.push_str("import Prelude hiding (abs)\n\n");

        // Generate type definitions
        for type_def in &spec.spec.types {
            let safe_name = Self::sanitize_name(&type_def.name);
            code.push_str(&format!("-- Type: {}\n", type_def.name));
            code.push_str(&format!(
                "data {} = Mk{} {{ unpack{} :: Int }}\n\n",
                safe_name, safe_name, safe_name
            ));
        }

        // Generate properties as refinement-typed functions
        for (i, prop) in spec.spec.properties.iter().enumerate() {
            let prop_name = prop.name();
            let safe_name = Self::sanitize_name(&prop_name);
            let func_name = if safe_name.is_empty() {
                format!("property{}", i)
            } else {
                format!("property_{}", safe_name)
            };

            code.push_str(&format!("-- Property: {}\n", prop_name));
            // Refinement type annotation
            code.push_str(&format!(
                "{{-@ {} :: x:Int -> {{ v:Bool | v }} @-}}\n",
                func_name
            ));
            code.push_str(&format!("{} :: Int -> Bool\n", func_name));
            code.push_str(&format!("{} _ = True\n\n", func_name));
        }

        // If no properties, add a trivial verified function
        if spec.spec.properties.is_empty() {
            code.push_str("{-@ trivial :: { v:Bool | v } @-}\n");
            code.push_str("trivial :: Bool\n");
            code.push_str("trivial = True\n\n");
        }

        // Add a safe example function
        code.push_str("-- Example safe function\n");
        code.push_str("{-@ safeAbs :: Int -> { v:Int | v >= 0 } @-}\n");
        code.push_str("safeAbs :: Int -> Int\n");
        code.push_str("safeAbs x = if x >= 0 then x else -x\n");

        code
    }

    /// Sanitize a name for use in Haskell
    fn sanitize_name(name: &str) -> String {
        let result: String = name
            .replace([' ', '-', ':', '/', '\\', '.', '(', ')', '[', ']'], "_")
            .chars()
            .filter(|c| c.is_alphanumeric() || *c == '_')
            .collect();

        // Haskell identifiers must start with lowercase letter
        if result.starts_with(|c: char| c.is_ascii_uppercase()) {
            format!("l{}", result)
        } else if result.starts_with(|c: char| c.is_ascii_digit()) {
            format!("n{}", result)
        } else if result.is_empty() {
            "unnamed".to_string()
        } else {
            result
        }
    }

    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
        success: bool,
    ) -> (VerificationStatus, Vec<String>) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics = Vec::new();

        // Count results
        let mut safe = 0;
        let mut unsafe_count = 0;

        // Parse LiquidHaskell output
        for line in combined.lines() {
            let trimmed = line.trim();

            // Check for safe/verified
            if trimmed.contains("SAFE") || trimmed.contains("Safe") {
                safe += 1;
                diagnostics.push(format!("✓ {}", trimmed));
            }

            // Check for unsafe/failed
            if trimmed.contains("UNSAFE") || trimmed.contains("Unsafe") {
                unsafe_count += 1;
                diagnostics.push(format!("✗ {}", trimmed));
            }

            // Capture error messages
            if trimmed.contains("Error") || trimmed.contains("error") {
                diagnostics.push(format!("✗ {}", trimmed));
            }

            // Capture refinement type errors
            if trimmed.contains("Liquid Type Mismatch") || trimmed.contains("Subtype Error") {
                diagnostics.push(trimmed.to_string());
            }
        }

        // Determine status
        if unsafe_count > 0 {
            return (VerificationStatus::Disproven, diagnostics);
        }

        // Check for "RESULT: SAFE"
        if combined.contains("RESULT: SAFE") || combined.contains("SAFE") {
            return (VerificationStatus::Proven, diagnostics);
        }

        // Check for errors
        if combined.contains("Liquid Type Mismatch") || combined.contains("Subtype Error") {
            return (VerificationStatus::Disproven, diagnostics);
        }

        // Check for parse/compile errors
        if combined.contains("parse error") || combined.contains("Parse error") {
            return (
                VerificationStatus::Unknown {
                    reason: "Haskell parse error".to_string(),
                },
                diagnostics,
            );
        }

        // Check for timeout
        if combined.contains("timeout") || combined.contains("Timeout") {
            return (
                VerificationStatus::Unknown {
                    reason: "Verification timed out".to_string(),
                },
                diagnostics,
            );
        }

        // Check exit status
        if success && safe > 0 {
            return (VerificationStatus::Proven, diagnostics);
        }

        if success && !combined.contains("UNSAFE") && !combined.contains("Error") {
            return (VerificationStatus::Proven, diagnostics);
        }

        (
            VerificationStatus::Unknown {
                reason: "Could not parse LiquidHaskell output".to_string(),
            },
            diagnostics,
        )
    }

    /// Parse counterexample from LiquidHaskell output
    fn parse_counterexample(stdout: &str, stderr: &str) -> StructuredCounterexample {
        let mut ce = StructuredCounterexample::new();
        let combined = format!("{}\n{}", stdout, stderr);
        ce.raw = Some(combined.clone());

        // Extract failed checks
        ce.failed_checks = Self::extract_failed_checks(&combined);

        // Extract witness values
        ce.witness = Self::extract_witness_values(&combined);

        ce
    }

    /// Extract failed checks from LiquidHaskell output
    fn extract_failed_checks(output: &str) -> Vec<FailedCheck> {
        let mut checks = Vec::new();

        for line in output.lines() {
            let trimmed = line.trim();

            if trimmed.contains("UNSAFE")
                || trimmed.contains("Liquid Type Mismatch")
                || trimmed.contains("Subtype Error")
            {
                let check_type = if trimmed.contains("precondition") {
                    "liquid_precondition"
                } else if trimmed.contains("postcondition") {
                    "liquid_postcondition"
                } else if trimmed.contains("measure") {
                    "liquid_measure"
                } else if trimmed.contains("termination") {
                    "liquid_termination"
                } else {
                    "liquid_subtype"
                };

                let (location, description) = Self::parse_error_location(trimmed);

                checks.push(FailedCheck {
                    check_id: check_type.to_string(),
                    description,
                    location,
                    function: None,
                });
            }
        }

        checks
    }

    /// Parse error location from LiquidHaskell error line
    fn parse_error_location(line: &str) -> (Option<SourceLocation>, String) {
        // LiquidHaskell format: "file.hs:line:col: message" or "file.hs:line:col-col: message"
        if let Some(colon_pos) = line.find(':') {
            let prefix = &line[..colon_pos];

            // Check if prefix looks like a file name
            if prefix.ends_with(".hs") || prefix.contains('/') {
                let rest = &line[colon_pos + 1..];
                if let Some(next_colon) = rest.find(':') {
                    if let Ok(line_num) = rest[..next_colon].trim().parse::<u32>() {
                        let remaining = &rest[next_colon + 1..];
                        // Check for column number
                        if let Some(third_colon) = remaining.find(':') {
                            let col_str = &remaining[..third_colon];
                            // Handle "col-col" format
                            let col = col_str
                                .split('-')
                                .next()
                                .and_then(|s| s.trim().parse::<u32>().ok());
                            let message = remaining[third_colon + 1..].trim().to_string();
                            return (
                                Some(SourceLocation {
                                    file: prefix.to_string(),
                                    line: line_num,
                                    column: col,
                                }),
                                message,
                            );
                        }
                        let message = remaining.trim().to_string();
                        return (
                            Some(SourceLocation {
                                file: prefix.to_string(),
                                line: line_num,
                                column: None,
                            }),
                            message,
                        );
                    }
                }
            }
        }

        (None, line.to_string())
    }

    /// Extract witness values from counterexample
    fn extract_witness_values(output: &str) -> HashMap<String, CounterexampleValue> {
        let mut values = HashMap::new();
        let mut in_model = false;

        for line in output.lines() {
            let trimmed = line.trim();

            // Look for counterexample/model section
            if trimmed.contains("Counterexample:")
                || trimmed.contains("Model:")
                || trimmed.contains("with values")
            {
                in_model = true;
                continue;
            }

            if in_model {
                if trimmed.is_empty() || trimmed.starts_with("---") {
                    in_model = false;
                    continue;
                }

                // Parse "var = value" or "var |-> value"
                let parts: Vec<&str> = if trimmed.contains(" = ") {
                    trimmed.splitn(2, " = ").collect()
                } else if trimmed.contains(" |-> ") {
                    trimmed.splitn(2, " |-> ").collect()
                } else {
                    continue;
                };

                if parts.len() == 2 {
                    let var_name = parts[0].trim().to_string();
                    let value_str = parts[1].trim();
                    values.insert(var_name, Self::parse_haskell_value(value_str));
                }
            }
        }

        values
    }

    /// Parse a Haskell value string
    fn parse_haskell_value(value_str: &str) -> CounterexampleValue {
        let trimmed = value_str.trim();

        // Boolean
        if trimmed == "True" {
            return CounterexampleValue::Bool(true);
        }
        if trimmed == "False" {
            return CounterexampleValue::Bool(false);
        }

        // Integer
        if let Ok(n) = trimmed.parse::<i128>() {
            return CounterexampleValue::Int {
                value: n,
                type_hint: None,
            };
        }

        // Negative integer
        if trimmed.starts_with('(') && trimmed.ends_with(')') {
            let inner = &trimmed[1..trimmed.len() - 1];
            if let Ok(n) = inner.parse::<i128>() {
                return CounterexampleValue::Int {
                    value: n,
                    type_hint: None,
                };
            }
        }

        // Default to string
        CounterexampleValue::String(trimmed.to_string())
    }
}

#[async_trait]
impl VerificationBackend for LiquidHaskellBackend {
    fn id(&self) -> BackendId {
        BackendId::LiquidHaskell
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Contract, PropertyType::Theorem]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();

        let liquid_path = self.detect().await.map_err(BackendError::Unavailable)?;

        // Create temp directory
        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp directory: {}", e))
        })?;

        let hs_file = temp_dir.path().join("Verification.hs");
        let haskell_code = self.generate_haskell_code(spec);

        debug!("Generated Haskell code:\n{}", haskell_code);

        tokio::fs::write(&hs_file, &haskell_code)
            .await
            .map_err(|e| {
                BackendError::VerificationFailed(format!("Failed to write Haskell file: {}", e))
            })?;

        // Build command
        let mut cmd = Command::new(&liquid_path);
        cmd.arg(&hs_file)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .current_dir(temp_dir.path());

        // Add solver option
        let solver_name = match self.config.solver {
            LiquidSolver::Z3 => "z3",
            LiquidSolver::CVC4 => "cvc4",
            LiquidSolver::MathSat => "mathsat",
        };
        cmd.arg(format!("--smtsolver={}", solver_name));

        // Totality checking
        if self.config.check_totality {
            cmd.arg("--totality");
        }

        // Termination checking
        if !self.config.check_termination {
            cmd.arg("--no-termination");
        }

        // SMT timeout
        cmd.arg(format!("--smttimeout={}", self.config.smt_timeout));

        // Extra args
        for arg in &self.config.extra_args {
            cmd.arg(arg);
        }

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| {
                BackendError::VerificationFailed(format!("Failed to run liquid: {}", e))
            })?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("LiquidHaskell stdout: {}", stdout);
        debug!("LiquidHaskell stderr: {}", stderr);

        let (status, diagnostics) = self.parse_output(&stdout, &stderr, output.status.success());

        // Generate counterexample for failures
        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            Some(Self::parse_counterexample(&stdout, &stderr))
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::LiquidHaskell,
            status,
            proof: None,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect().await {
            Ok(_) => HealthStatus::Healthy,
            Err(r) => HealthStatus::Unavailable { reason: r },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn backend_id() {
        assert_eq!(LiquidHaskellBackend::new().id(), BackendId::LiquidHaskell);
    }

    #[test]
    fn default_config() {
        let config = LiquidHaskellConfig::default();
        assert_eq!(config.timeout, Duration::from_secs(120));
        assert_eq!(config.solver, LiquidSolver::Z3);
        assert!(config.check_totality);
        assert!(config.check_termination);
    }

    #[test]
    fn supports_contracts_and_theorems() {
        let backend = LiquidHaskellBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Contract));
        assert!(supported.contains(&PropertyType::Theorem));
    }

    #[test]
    fn sanitize_name() {
        assert_eq!(
            LiquidHaskellBackend::sanitize_name("HelloWorld"),
            "lHelloWorld"
        );
        assert_eq!(
            LiquidHaskellBackend::sanitize_name("test_prop"),
            "test_prop"
        );
        assert_eq!(LiquidHaskellBackend::sanitize_name("123abc"), "n123abc");
        assert_eq!(LiquidHaskellBackend::sanitize_name(""), "unnamed");
    }

    #[test]
    fn parse_safe_output() {
        let backend = LiquidHaskellBackend::new();
        let stdout = "Checking Verification.hs\nRESULT: SAFE";
        let (status, diag) = backend.parse_output(stdout, "", true);
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(!diag.is_empty());
    }

    #[test]
    fn parse_unsafe_output() {
        let backend = LiquidHaskellBackend::new();
        let stdout = "Checking Verification.hs\nRESULT: UNSAFE\nLiquid Type Mismatch";
        let (status, _diag) = backend.parse_output(stdout, "", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn parse_error_location_full() {
        let line = "Verification.hs:10:5: Liquid Type Mismatch";
        let (loc, desc) = LiquidHaskellBackend::parse_error_location(line);
        assert!(loc.is_some());
        let loc = loc.unwrap();
        assert_eq!(loc.file, "Verification.hs");
        assert_eq!(loc.line, 10);
        assert_eq!(loc.column, Some(5));
        assert!(desc.contains("Liquid Type Mismatch"));
    }

    #[test]
    fn extract_failed_checks() {
        let output = "UNSAFE\nLiquid Type Mismatch\ntermination check failed";
        let checks = LiquidHaskellBackend::extract_failed_checks(output);
        assert_eq!(checks.len(), 2);
        assert_eq!(checks[0].check_id, "liquid_subtype");
        assert_eq!(checks[1].check_id, "liquid_subtype");
    }

    #[test]
    fn parse_haskell_values() {
        assert!(matches!(
            LiquidHaskellBackend::parse_haskell_value("True"),
            CounterexampleValue::Bool(true)
        ));
        assert!(matches!(
            LiquidHaskellBackend::parse_haskell_value("False"),
            CounterexampleValue::Bool(false)
        ));
        assert!(matches!(
            LiquidHaskellBackend::parse_haskell_value("42"),
            CounterexampleValue::Int { value: 42, .. }
        ));
        assert!(matches!(
            LiquidHaskellBackend::parse_haskell_value("(-5)"),
            CounterexampleValue::Int { value: -5, .. }
        ));
    }

    #[test]
    fn generate_haskell_empty_spec() {
        use dashprove_usl::ast::Spec;

        let backend = LiquidHaskellBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_haskell_code(&spec);
        assert!(code.contains("-- Generated by DashProve"));
        assert!(code.contains("module Verification"));
        assert!(code.contains("trivial"));
    }

    #[test]
    fn solver_config() {
        let config = LiquidHaskellConfig {
            solver: LiquidSolver::CVC4,
            check_totality: false,
            ..Default::default()
        };
        let backend = LiquidHaskellBackend::with_config(config);
        assert_eq!(backend.config.solver, LiquidSolver::CVC4);
        assert!(!backend.config.check_totality);
    }
}

// =============================================
// Kani formal verification proofs
// =============================================
#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // =============================================
    // LiquidSolver enum proofs
    // =============================================

    /// Verify LiquidSolver::Z3 is default
    #[kani::proof]
    fn proof_liquid_solver_default_z3() {
        let solver = LiquidSolver::default();
        kani::assert(solver == LiquidSolver::Z3, "Default solver should be Z3");
    }

    /// Verify all LiquidSolver variants are distinct
    #[kani::proof]
    fn proof_liquid_solver_variants_distinct() {
        kani::assert(LiquidSolver::Z3 != LiquidSolver::CVC4, "Z3 != CVC4");
        kani::assert(LiquidSolver::Z3 != LiquidSolver::MathSat, "Z3 != MathSat");
        kani::assert(
            LiquidSolver::CVC4 != LiquidSolver::MathSat,
            "CVC4 != MathSat",
        );
    }

    // =============================================
    // LiquidHaskellConfig default proofs
    // =============================================

    /// Verify LiquidHaskellConfig default timeout is 120 seconds
    #[kani::proof]
    fn proof_liquid_config_default_timeout() {
        let config = LiquidHaskellConfig::default();
        kani::assert(
            config.timeout == Duration::from_secs(120),
            "Default timeout should be 120 seconds",
        );
    }

    /// Verify LiquidHaskellConfig default solver is Z3
    #[kani::proof]
    fn proof_liquid_config_default_solver() {
        let config = LiquidHaskellConfig::default();
        kani::assert(
            config.solver == LiquidSolver::Z3,
            "Default solver should be Z3",
        );
    }

    /// Verify LiquidHaskellConfig default check_totality is true
    #[kani::proof]
    fn proof_liquid_config_default_check_totality() {
        let config = LiquidHaskellConfig::default();
        kani::assert(
            config.check_totality,
            "Default check_totality should be true",
        );
    }

    /// Verify LiquidHaskellConfig default check_termination is true
    #[kani::proof]
    fn proof_liquid_config_default_check_termination() {
        let config = LiquidHaskellConfig::default();
        kani::assert(
            config.check_termination,
            "Default check_termination should be true",
        );
    }

    /// Verify LiquidHaskellConfig default smt_timeout is 30
    #[kani::proof]
    fn proof_liquid_config_default_smt_timeout() {
        let config = LiquidHaskellConfig::default();
        kani::assert(config.smt_timeout == 30, "Default smt_timeout should be 30");
    }

    /// Verify LiquidHaskellConfig default liquid_path is None
    #[kani::proof]
    fn proof_liquid_config_default_liquid_path_none() {
        let config = LiquidHaskellConfig::default();
        kani::assert(
            config.liquid_path.is_none(),
            "Default liquid_path should be None",
        );
    }

    /// Verify LiquidHaskellConfig default extra_args is empty
    #[kani::proof]
    fn proof_liquid_config_default_extra_args_empty() {
        let config = LiquidHaskellConfig::default();
        kani::assert(
            config.extra_args.is_empty(),
            "Default extra_args should be empty",
        );
    }

    // =============================================
    // LiquidHaskellBackend constructor proofs
    // =============================================

    /// Verify LiquidHaskellBackend::new creates backend with default config
    #[kani::proof]
    fn proof_liquid_backend_new_default_timeout() {
        let backend = LiquidHaskellBackend::new();
        kani::assert(
            backend.config.timeout == Duration::from_secs(120),
            "New backend should have default timeout",
        );
    }

    /// Verify LiquidHaskellBackend::with_config preserves config
    #[kani::proof]
    fn proof_liquid_backend_with_config() {
        let config = LiquidHaskellConfig {
            timeout: Duration::from_secs(60),
            solver: LiquidSolver::CVC4,
            ..Default::default()
        };
        let backend = LiquidHaskellBackend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(60),
            "Custom timeout should be preserved",
        );
        kani::assert(
            backend.config.solver == LiquidSolver::CVC4,
            "Custom solver should be preserved",
        );
    }

    /// Verify LiquidHaskellBackend implements Default
    #[kani::proof]
    fn proof_liquid_backend_default() {
        let backend = LiquidHaskellBackend::default();
        kani::assert(
            backend.id() == BackendId::LiquidHaskell,
            "Default backend should have correct ID",
        );
    }

    // =============================================
    // LiquidHaskellBackend trait implementation proofs
    // =============================================

    /// Verify LiquidHaskellBackend::id returns BackendId::LiquidHaskell
    #[kani::proof]
    fn proof_liquid_backend_id() {
        let backend = LiquidHaskellBackend::new();
        kani::assert(
            backend.id() == BackendId::LiquidHaskell,
            "Backend ID should be LiquidHaskell",
        );
    }

    /// Verify LiquidHaskellBackend::supports includes Contract
    #[kani::proof]
    fn proof_liquid_backend_supports_contract() {
        let backend = LiquidHaskellBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::Contract {
                found = true;
            }
        }
        kani::assert(found, "Should support Contract");
    }

    /// Verify LiquidHaskellBackend::supports includes Theorem
    #[kani::proof]
    fn proof_liquid_backend_supports_theorem() {
        let backend = LiquidHaskellBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::Theorem {
                found = true;
            }
        }
        kani::assert(found, "Should support Theorem");
    }

    /// Verify LiquidHaskellBackend::supports returns exactly 2 types
    #[kani::proof]
    fn proof_liquid_backend_supports_count() {
        let backend = LiquidHaskellBackend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 2,
            "Should support exactly 2 property types",
        );
    }

    // =============================================
    // sanitize_name proofs
    // =============================================

    /// Verify sanitize_name adds 'l' prefix for uppercase start
    #[kani::proof]
    fn proof_sanitize_name_uppercase_prefix() {
        let result = LiquidHaskellBackend::sanitize_name("Hello");
        kani::assert(
            result.starts_with('l'),
            "Uppercase name should get 'l' prefix",
        );
    }

    /// Verify sanitize_name adds 'n' prefix for digit start
    #[kani::proof]
    fn proof_sanitize_name_digit_prefix() {
        let result = LiquidHaskellBackend::sanitize_name("123abc");
        kani::assert(
            result.starts_with('n'),
            "Digit-start name should get 'n' prefix",
        );
    }

    /// Verify sanitize_name returns 'unnamed' for empty
    #[kani::proof]
    fn proof_sanitize_name_empty_unnamed() {
        let result = LiquidHaskellBackend::sanitize_name("");
        kani::assert(result == "unnamed", "Empty name should become 'unnamed'");
    }

    /// Verify sanitize_name preserves lowercase start
    #[kani::proof]
    fn proof_sanitize_name_lowercase_preserved() {
        let result = LiquidHaskellBackend::sanitize_name("hello");
        kani::assert(result == "hello", "Lowercase name should be preserved");
    }

    /// Verify sanitize_name replaces special chars
    #[kani::proof]
    fn proof_sanitize_name_special_chars() {
        let result = LiquidHaskellBackend::sanitize_name("a-b c.d");
        kani::assert(
            result == "a_b_c_d",
            "Special chars should be replaced with underscore",
        );
    }

    // =============================================
    // parse_output proofs
    // =============================================

    /// Verify parse_output identifies SAFE output as Proven
    #[kani::proof]
    fn proof_parse_output_safe_proven() {
        let backend = LiquidHaskellBackend::new();
        let (status, _) = backend.parse_output("RESULT: SAFE", "", true);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "SAFE should map to Proven",
        );
    }

    /// Verify parse_output identifies UNSAFE output as Disproven
    #[kani::proof]
    fn proof_parse_output_unsafe_disproven() {
        let backend = LiquidHaskellBackend::new();
        let (status, _) = backend.parse_output("RESULT: UNSAFE", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "UNSAFE should map to Disproven",
        );
    }

    /// Verify parse_output identifies Liquid Type Mismatch as Disproven
    #[kani::proof]
    fn proof_parse_output_type_mismatch_disproven() {
        let backend = LiquidHaskellBackend::new();
        let (status, _) = backend.parse_output("Liquid Type Mismatch", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Type Mismatch should map to Disproven",
        );
    }

    /// Verify parse_output identifies parse error as Unknown
    #[kani::proof]
    fn proof_parse_output_parse_error_unknown() {
        let backend = LiquidHaskellBackend::new();
        let (status, _) = backend.parse_output("parse error at line 10", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "parse error should map to Unknown",
        );
    }

    // =============================================
    // parse_haskell_value proofs
    // =============================================

    /// Verify parse_haskell_value parses True
    #[kani::proof]
    fn proof_parse_haskell_value_true() {
        let val = LiquidHaskellBackend::parse_haskell_value("True");
        kani::assert(
            matches!(val, CounterexampleValue::Bool(true)),
            "True should parse to Bool(true)",
        );
    }

    /// Verify parse_haskell_value parses False
    #[kani::proof]
    fn proof_parse_haskell_value_false() {
        let val = LiquidHaskellBackend::parse_haskell_value("False");
        kani::assert(
            matches!(val, CounterexampleValue::Bool(false)),
            "False should parse to Bool(false)",
        );
    }

    /// Verify parse_haskell_value parses positive integer
    #[kani::proof]
    fn proof_parse_haskell_value_positive_int() {
        let val = LiquidHaskellBackend::parse_haskell_value("42");
        kani::assert(
            matches!(val, CounterexampleValue::Int { value: 42, .. }),
            "42 should parse to Int(42)",
        );
    }

    /// Verify parse_haskell_value parses parenthesized negative integer
    #[kani::proof]
    fn proof_parse_haskell_value_negative_int() {
        let val = LiquidHaskellBackend::parse_haskell_value("(-5)");
        kani::assert(
            matches!(val, CounterexampleValue::Int { value: -5, .. }),
            "(-5) should parse to Int(-5)",
        );
    }

    /// Verify parse_haskell_value returns String for unknown
    #[kani::proof]
    fn proof_parse_haskell_value_string_fallback() {
        let val = LiquidHaskellBackend::parse_haskell_value("unknown");
        kani::assert(
            matches!(val, CounterexampleValue::String(_)),
            "Unknown value should parse to String",
        );
    }

    // =============================================
    // extract_failed_checks proofs
    // =============================================

    /// Verify extract_failed_checks finds UNSAFE lines
    #[kani::proof]
    fn proof_extract_failed_checks_unsafe() {
        let checks = LiquidHaskellBackend::extract_failed_checks("UNSAFE");
        kani::assert(checks.len() == 1, "Should find one failed check");
    }

    /// Verify extract_failed_checks finds Liquid Type Mismatch
    #[kani::proof]
    fn proof_extract_failed_checks_type_mismatch() {
        let checks = LiquidHaskellBackend::extract_failed_checks("Liquid Type Mismatch");
        kani::assert(checks.len() == 1, "Should find one failed check");
    }

    /// Verify extract_failed_checks returns empty for clean output
    #[kani::proof]
    fn proof_extract_failed_checks_clean() {
        let checks = LiquidHaskellBackend::extract_failed_checks("RESULT: SAFE");
        kani::assert(checks.is_empty(), "Should find no failed checks");
    }

    // =============================================
    // Config custom values proofs
    // =============================================

    /// Verify custom solver CVC4 is preserved
    #[kani::proof]
    fn proof_liquid_config_custom_solver_cvc4() {
        let config = LiquidHaskellConfig {
            solver: LiquidSolver::CVC4,
            ..Default::default()
        };
        kani::assert(
            config.solver == LiquidSolver::CVC4,
            "Custom solver should be CVC4",
        );
    }

    /// Verify custom solver MathSat is preserved
    #[kani::proof]
    fn proof_liquid_config_custom_solver_mathsat() {
        let config = LiquidHaskellConfig {
            solver: LiquidSolver::MathSat,
            ..Default::default()
        };
        kani::assert(
            config.solver == LiquidSolver::MathSat,
            "Custom solver should be MathSat",
        );
    }

    /// Verify check_totality can be disabled
    #[kani::proof]
    fn proof_liquid_config_disable_totality() {
        let config = LiquidHaskellConfig {
            check_totality: false,
            ..Default::default()
        };
        kani::assert(!config.check_totality, "check_totality should be false");
    }

    /// Verify check_termination can be disabled
    #[kani::proof]
    fn proof_liquid_config_disable_termination() {
        let config = LiquidHaskellConfig {
            check_termination: false,
            ..Default::default()
        };
        kani::assert(
            !config.check_termination,
            "check_termination should be false",
        );
    }

    /// Verify custom smt_timeout is preserved
    #[kani::proof]
    fn proof_liquid_config_custom_smt_timeout() {
        let config = LiquidHaskellConfig {
            smt_timeout: 60,
            ..Default::default()
        };
        kani::assert(config.smt_timeout == 60, "Custom smt_timeout should be 60");
    }
}
