//! Tamarin theory generation from USL specs

use dashprove_usl::ast::{ComparisonOp, Expr, Property, Type};
use dashprove_usl::typecheck::TypedSpec;
use std::collections::HashSet;

/// Generate Tamarin theory from USL spec
///
/// Compiles USL types, functions, and security properties to Tamarin syntax.
pub fn generate_theory(spec: &TypedSpec) -> String {
    let mut theory = String::new();
    theory.push_str("/*\n * Generated by DashProve\n */\n\n");
    theory.push_str("theory DashProve\nbegin\n\n");

    // Collect all referenced types and functions from properties
    let mut types_used: HashSet<String> = HashSet::new();
    let mut functions_used: HashSet<String> = HashSet::new();
    let mut secrets: HashSet<String> = HashSet::new();
    let mut integrity_predicates: Vec<(String, String)> = Vec::new();

    for property in &spec.spec.properties {
        if let Property::Security(sec) = property {
            collect_from_expr(&sec.body, &mut types_used, &mut functions_used);
            extract_security_patterns(&sec.body, &mut secrets, &mut integrity_predicates);
        }
    }

    // Determine required builtins based on functions used
    let mut builtins = Vec::new();
    if functions_used.iter().any(|f| f == "senc" || f == "sdec") {
        builtins.push("symmetric-encryption");
    }
    if functions_used
        .iter()
        .any(|f| f == "aenc" || f == "adec" || f == "pk")
    {
        builtins.push("asymmetric-encryption");
    }
    if functions_used.iter().any(|f| f == "sign" || f == "verify") {
        builtins.push("signing");
    }
    if functions_used.iter().any(|f| f == "hash") {
        builtins.push("hashing");
    }
    if builtins.is_empty() {
        // Default: symmetric encryption for basic secrecy
        builtins.push("symmetric-encryption");
    }
    theory.push_str(&format!("builtins: {}\n\n", builtins.join(", ")));

    // Compile types from spec as Tamarin sorts (message subtypes)
    if !spec.spec.types.is_empty() {
        theory.push_str("/* Sorts from USL types */\n");
        for typedef in &spec.spec.types {
            let sort_name = to_tamarin_ident(&typedef.name);
            // Tamarin uses subsort declarations
            theory.push_str(&format!(
                "// Type {}: fields used as message components\n",
                sort_name
            ));
        }
        theory.push('\n');
    }

    // Compile referenced functions as Tamarin function symbols
    let non_builtin_funcs: Vec<_> = functions_used
        .iter()
        .filter(|f| {
            ![
                "senc",
                "sdec",
                "aenc",
                "adec",
                "sign",
                "verify",
                "hash",
                "pk",
                "knows",
                "authorized",
                "authenticated",
                "modified",
                "performed",
                "can_observe",
                "actions",
            ]
            .contains(&f.as_str())
        })
        .collect();

    if !non_builtin_funcs.is_empty() {
        theory.push_str("/* Functions from USL spec */\n");
        theory.push_str("functions: ");
        let func_decls: Vec<String> = non_builtin_funcs
            .iter()
            .map(|f| format!("{}/1", to_tamarin_ident(f)))
            .collect();
        theory.push_str(&func_decls.join(", "));
        theory.push_str("\n\n");
    }

    // Generate rules for protocol behavior
    theory.push_str("/* Protocol rules */\n\n");

    // Key generation rule
    theory.push_str("rule Generate_Key:\n");
    theory.push_str("  [ Fr(~k) ]\n");
    theory.push_str("  --[ GeneratedKey(~k) ]-->\n");
    theory.push_str("  [ !Key(~k) ]\n\n");

    // Secret generation rule (for each secret identified)
    if !secrets.is_empty() {
        for secret in &secrets {
            let secret_name = to_tamarin_ident(secret);
            theory.push_str(&format!("rule Generate_Secret_{}:\n", secret_name));
            theory.push_str("  [ Fr(~s) ]\n");
            theory.push_str(&format!("  --[ Secret_{}(~s) ]-->\n", secret_name));
            theory.push_str(&format!("  [ !Secret_{}(~s) ]\n\n", secret_name));
        }
    } else {
        // Default secret rule
        theory.push_str("rule Generate_Secret:\n");
        theory.push_str("  [ Fr(~s) ]\n");
        theory.push_str("  --[ Secret(~s) ]-->\n");
        theory.push_str("  [ !Secret(~s) ]\n\n");
    }

    // Protocol send rule that protects secrets
    theory.push_str("rule Protocol_Send:\n");
    theory.push_str("  let m = senc(~s, ~k) in\n");
    theory.push_str("  [ !Key(~k), Fr(~s) ]\n");
    theory.push_str("  --[ Send($A, $B, m), Sent(~s) ]-->\n");
    theory.push_str("  [ Out(m) ]\n\n");

    // If integrity predicates exist, add authorization/modification rules
    if !integrity_predicates.is_empty() {
        theory.push_str("/* Integrity rules */\n\n");

        theory.push_str("rule Authorize:\n");
        theory.push_str("  [ Fr(~token) ]\n");
        theory.push_str("  --[ Authorized($A, $R) ]-->\n");
        theory.push_str("  [ AuthToken($A, $R, ~token) ]\n\n");

        theory.push_str("rule Modify:\n");
        theory.push_str("  [ AuthToken($A, $R, token) ]\n");
        theory.push_str("  --[ Modified($A, $R) ]-->\n");
        theory.push_str("  [ ]\n\n");
    }

    // Generate lemmas from security properties
    theory.push_str("/* Security lemmas from USL properties */\n\n");
    for property in &spec.spec.properties {
        if let Property::Security(sec) = property {
            let lemmas = compile_security_lemma(&sec.body, &sec.name);
            for lemma in lemmas {
                theory.push_str(&lemma);
                theory.push('\n');
            }
        }
    }

    // Default secrecy lemma if no specific lemmas generated
    let has_security = spec
        .spec
        .properties
        .iter()
        .any(|p| matches!(p, Property::Security(_)));
    if !has_security {
        theory.push_str("lemma secrecy:\n");
        theory.push_str("  \"All s #i. Secret(s) @ i ==> not (Ex #j. K(s) @ j)\"\n\n");
    }

    theory.push_str("end\n");
    theory
}

/// Convert USL identifier to valid Tamarin identifier
pub fn to_tamarin_ident(name: &str) -> String {
    // Tamarin identifiers: lowercase start for terms, uppercase for public constants
    let clean: String = name
        .chars()
        .filter(|c| c.is_alphanumeric() || *c == '_')
        .collect();
    if clean.is_empty() {
        "x".to_string()
    } else {
        clean
    }
}

/// Collect types and functions referenced in an expression
fn collect_from_expr(expr: &Expr, types: &mut HashSet<String>, functions: &mut HashSet<String>) {
    match expr {
        Expr::ForAll { ty, body, .. } | Expr::Exists { ty, body, .. } => {
            if let Some(t) = ty {
                collect_type(t, types);
            }
            collect_from_expr(body, types, functions);
        }
        Expr::ForAllIn {
            collection, body, ..
        }
        | Expr::ExistsIn {
            collection, body, ..
        } => {
            collect_from_expr(collection, types, functions);
            collect_from_expr(body, types, functions);
        }
        Expr::App(name, args) => {
            functions.insert(name.clone());
            for arg in args {
                collect_from_expr(arg, types, functions);
            }
        }
        Expr::MethodCall { receiver, args, .. } => {
            collect_from_expr(receiver, types, functions);
            for arg in args {
                collect_from_expr(arg, types, functions);
            }
        }
        Expr::Not(inner) | Expr::Neg(inner) => collect_from_expr(inner, types, functions),
        Expr::And(left, right)
        | Expr::Or(left, right)
        | Expr::Implies(left, right)
        | Expr::Compare(left, _, right)
        | Expr::Binary(left, _, right) => {
            collect_from_expr(left, types, functions);
            collect_from_expr(right, types, functions);
        }
        Expr::FieldAccess(object, _) => {
            collect_from_expr(object, types, functions);
        }
        _ => {}
    }
}

/// Collect type names from a type annotation
fn collect_type(ty: &Type, types: &mut HashSet<String>) {
    match ty {
        Type::Named(name) => {
            types.insert(name.clone());
        }
        Type::Set(inner) | Type::List(inner) | Type::Result(inner) => {
            collect_type(inner, types);
        }
        Type::Map(k, v) | Type::Relation(k, v) | Type::Function(k, v) => {
            collect_type(k, types);
            collect_type(v, types);
        }
        Type::Graph(n, e) => {
            collect_type(n, types);
            collect_type(e, types);
        }
        Type::Path(n) => {
            collect_type(n, types);
        }
        Type::Unit => {}
    }
}

/// Extract security-relevant patterns from expression
///
/// Identifies:
/// - Secrets that should not be leaked (from `not knows(_, x)` patterns)
/// - Integrity predicates (from `authorized implies modified` patterns)
pub fn extract_security_patterns(
    expr: &Expr,
    secrets: &mut HashSet<String>,
    integrity: &mut Vec<(String, String)>,
) {
    match expr {
        // `not knows(agent, secret)` → secret should be protected
        Expr::Not(inner) => {
            if let Expr::App(name, args) = inner.as_ref() {
                if name == "knows" && args.len() == 2 {
                    if let Expr::Var(secret_name) = &args[1] {
                        secrets.insert(secret_name.clone());
                    } else if let Expr::FieldAccess(_, field) = &args[1] {
                        secrets.insert(field.clone());
                    }
                }
            }
            extract_security_patterns(inner, secrets, integrity);
        }
        // `authorized(a, r) implies modified(a, r)` → integrity
        Expr::Implies(left, right) => {
            if let (Expr::App(left_name, left_args), Expr::App(right_name, _)) =
                (left.as_ref(), right.as_ref())
            {
                if (left_name == "authorized" || left_name == "authenticated")
                    && (right_name == "modified" || right_name == "performed")
                {
                    let subject = left_args.first().map(expr_to_string).unwrap_or_default();
                    let object = left_args.get(1).map(expr_to_string).unwrap_or_default();
                    integrity.push((subject, object));
                }
            }
            extract_security_patterns(left, secrets, integrity);
            extract_security_patterns(right, secrets, integrity);
        }
        Expr::ForAll { body, .. }
        | Expr::Exists { body, .. }
        | Expr::ForAllIn { body, .. }
        | Expr::ExistsIn { body, .. } => {
            extract_security_patterns(body, secrets, integrity);
        }
        Expr::And(left, right) | Expr::Or(left, right) => {
            extract_security_patterns(left, secrets, integrity);
            extract_security_patterns(right, secrets, integrity);
        }
        _ => {}
    }
}

/// Convert expression to simple string for variable naming
fn expr_to_string(expr: &Expr) -> String {
    match expr {
        Expr::Var(name) => name.clone(),
        Expr::FieldAccess(object, field) => {
            format!("{}_{}", expr_to_string(object), field)
        }
        _ => "x".to_string(),
    }
}

/// Compile a security property body to Tamarin lemmas
fn compile_security_lemma(expr: &Expr, prop_name: &str) -> Vec<String> {
    let mut lemmas = Vec::new();
    let clean_name = to_tamarin_ident(prop_name);

    match expr {
        // Universal quantifier → Tamarin's "All" in lemma
        Expr::ForAll { var, body, .. } => {
            let inner_lemmas = compile_security_lemma(body, prop_name);
            if inner_lemmas.is_empty() {
                // Generate a generic lemma for the forall
                lemmas.push(format!(
                    "lemma {} [reuse]:\n  all-traces\n  \"All {} #i. True ==> True\"\n",
                    clean_name, var
                ));
            } else {
                lemmas.extend(inner_lemmas);
            }
        }
        // `not knows(agent, secret)` → secrecy lemma
        Expr::Not(inner) => {
            if let Expr::App(name, args) = inner.as_ref() {
                if name == "knows" && args.len() == 2 {
                    let secret = compile_tamarin_term(&args[1]);
                    lemmas.push(format!(
                        "lemma {}:\n  \"All s #i. Secret_{}(s) @ i ==> not (Ex #j. K(s) @ j)\"\n",
                        clean_name, secret
                    ));
                } else if name == "can_observe" {
                    // Non-observation property
                    lemmas.push(format!(
                        "lemma {}:\n  /* {} - prevents observation */\n  \"All s #i. Sent(s) @ i ==> not (Ex #j. K(s) @ j)\"\n",
                        clean_name, prop_name
                    ));
                }
            } else {
                // Recurse into negated expression
                let inner_lemmas = compile_security_lemma(inner, prop_name);
                if !inner_lemmas.is_empty() {
                    lemmas.extend(inner_lemmas);
                }
            }
        }
        // Implication patterns for integrity/authentication
        Expr::Implies(left, right) => {
            // Check for `modified implies authorized` pattern (integrity)
            if let (Expr::App(left_name, left_args), Expr::App(right_name, _)) =
                (left.as_ref(), right.as_ref())
            {
                if (left_name == "modified" || left_name == "performed")
                    && (right_name == "authorized" || right_name == "authenticated")
                {
                    let subject_var = left_args
                        .first()
                        .map(compile_tamarin_term)
                        .unwrap_or_else(|| "A".to_string());
                    let object_var = left_args
                        .get(1)
                        .map(compile_tamarin_term)
                        .unwrap_or_else(|| "R".to_string());

                    lemmas.push(format!(
                        "lemma {}:\n  \"All {} {} #i. Modified({}, {}) @ i ==> Ex #j. Authorized({}, {}) @ j & j < i\"\n",
                        clean_name, subject_var, object_var, subject_var, object_var, subject_var, object_var
                    ));
                }
            }
            // Check for `authorized implies modified` pattern (permission grants action)
            if let (Expr::App(left_name, _), Expr::App(right_name, _)) =
                (left.as_ref(), right.as_ref())
            {
                if (left_name == "authorized" || left_name == "authenticated")
                    && (right_name == "modified" || right_name == "performed")
                {
                    lemmas.push(format!(
                        "lemma {}:\n  /* Authorization enables action */\n  \"All A R #i. Modified(A, R) @ i ==> Ex #j. Authorized(A, R) @ j & j < i\"\n",
                        clean_name
                    ));
                }
            }
        }
        // Equality for non-interference
        Expr::Compare(left, op, right) => {
            if matches!(op, ComparisonOp::Eq) {
                if let (Expr::App(l_name, _), Expr::App(r_name, _)) =
                    (left.as_ref(), right.as_ref())
                {
                    if l_name == "output" && r_name == "output" {
                        lemmas.push(format!(
                            "lemma {}:\n  /* Non-interference: outputs equivalent */\n  \"All s #i. Secret(s) @ i ==> not (Ex #j. K(s) @ j)\"\n",
                            clean_name
                        ));
                    }
                }
            }
        }
        Expr::And(left, right) => {
            lemmas.extend(compile_security_lemma(left, &format!("{}_left", prop_name)));
            lemmas.extend(compile_security_lemma(
                right,
                &format!("{}_right", prop_name),
            ));
        }
        _ => {
            // Default: generic secrecy lemma
            if lemmas.is_empty() {
                lemmas.push(format!(
                    "lemma {}:\n  \"All s #i. Secret(s) @ i ==> not (Ex #j. K(s) @ j)\"\n",
                    clean_name
                ));
            }
        }
    }

    lemmas
}

/// Compile an expression to a Tamarin term for use in lemmas
pub fn compile_tamarin_term(expr: &Expr) -> String {
    match expr {
        Expr::Var(name) => to_tamarin_ident(name),
        Expr::FieldAccess(object, field) => {
            format!("{}_{}", compile_tamarin_term(object), field)
        }
        Expr::App(name, args) => {
            if args.is_empty() {
                to_tamarin_ident(name)
            } else {
                let args_str: Vec<String> = args.iter().map(compile_tamarin_term).collect();
                format!("{}({})", to_tamarin_ident(name), args_str.join(", "))
            }
        }
        _ => "s".to_string(),
    }
}
