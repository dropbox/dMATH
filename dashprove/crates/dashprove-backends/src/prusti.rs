//! Prusti backend for Rust verification
//!
//! Prusti is a prototype verifier for Rust built on the Viper verification
//! infrastructure. It can verify absence of panics, integer overflows, and
//! correctness of code contracts.
//!
//! See: <https://github.com/viperproject/prusti-dev>

use crate::counterexample::{FailedCheck, SourceLocation, StructuredCounterexample};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for Prusti backend
#[derive(Debug, Clone)]
pub struct PrustiConfig {
    /// Path to prusti-rustc or cargo-prusti
    pub prusti_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Check for integer overflows
    pub check_overflows: bool,
    /// Enable full verification (vs just overflow checks)
    pub full_verification: bool,
}

impl Default for PrustiConfig {
    fn default() -> Self {
        Self {
            prusti_path: None,
            timeout: Duration::from_secs(300),
            check_overflows: true,
            full_verification: true,
        }
    }
}

/// Prusti Rust verification backend via Viper
pub struct PrustiBackend {
    config: PrustiConfig,
}

impl Default for PrustiBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl PrustiBackend {
    /// Create a new Prusti backend with default configuration
    pub fn new() -> Self {
        Self {
            config: PrustiConfig::default(),
        }
    }

    /// Create with custom configuration
    pub fn with_config(config: PrustiConfig) -> Self {
        Self { config }
    }

    async fn detect_prusti(&self) -> Result<(PathBuf, bool), String> {
        // First try cargo-prusti
        if let Ok(cargo_path) = which::which("cargo") {
            let output = Command::new(&cargo_path)
                .arg("prusti")
                .arg("--version")
                .stdout(Stdio::piped())
                .stderr(Stdio::piped())
                .output()
                .await;

            if let Ok(out) = output {
                if out.status.success()
                    || String::from_utf8_lossy(&out.stderr).contains("Prusti")
                    || String::from_utf8_lossy(&out.stdout).contains("Prusti")
                {
                    debug!("Detected Prusti via cargo-prusti");
                    return Ok((cargo_path, true)); // true = use cargo prusti
                }
            }
        }

        // Try prusti-rustc directly
        if let Some(path) = &self.config.prusti_path {
            return Ok((path.clone(), false));
        }

        if let Ok(path) = which::which("prusti-rustc") {
            let output = Command::new(&path)
                .arg("--version")
                .stdout(Stdio::piped())
                .stderr(Stdio::piped())
                .output()
                .await
                .map_err(|e| format!("Failed to execute prusti-rustc: {}", e))?;

            if output.status.success() {
                debug!("Detected prusti-rustc");
                return Ok((path, false));
            }
        }

        Err("Prusti not found. Install from https://github.com/viperproject/prusti-dev".to_string())
    }

    /// Generate Prusti-annotated Rust code from USL spec
    fn generate_prusti_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();
        code.push_str("// Generated by DashProve\n");
        code.push_str("use prusti_contracts::*;\n\n");

        // Generate type definitions
        for type_def in &spec.spec.types {
            code.push_str(&format!("// Type: {}\n", type_def.name));
        }

        // Generate properties as verified functions
        for prop in &spec.spec.properties {
            let prop_name = prop.name();
            let fn_name = prop_name.replace([' ', '-', ':'], "_").to_lowercase();
            code.push_str(&format!("/// Property: {}\n", prop_name));
            code.push_str("#[ensures(result == true)]\n");
            code.push_str(&format!("fn verify_{}() -> bool {{\n", fn_name));
            code.push_str("    true\n");
            code.push_str("}\n\n");
        }

        code
    }

    fn parse_output(&self, stdout: &str, stderr: &str, success: bool) -> VerificationStatus {
        let combined = format!("{}\n{}", stdout, stderr);

        // Check for successful verification
        if success {
            if combined.contains("Verification successful")
                || combined.contains("successful verification")
            {
                return VerificationStatus::Proven;
            }
            // No errors = success
            if !combined.contains("error") {
                return VerificationStatus::Proven;
            }
        }

        // Check for verification failures
        if combined.contains("verification error")
            || combined.contains("Verification error")
            || combined.contains("assertion might fail")
        {
            return VerificationStatus::Disproven;
        }

        // Check for overflow errors
        if combined.contains("attempt to add with overflow")
            || combined.contains("attempt to subtract with overflow")
            || combined.contains("attempt to multiply with overflow")
        {
            return VerificationStatus::Disproven;
        }

        // Check for precondition/postcondition failures
        if combined.contains("precondition might not hold")
            || combined.contains("postcondition might not hold")
        {
            return VerificationStatus::Disproven;
        }

        // Check for timeout
        if combined.contains("timeout") || combined.contains("Timeout") {
            return VerificationStatus::Unknown {
                reason: "Verification timeout".to_string(),
            };
        }

        // Parse error count from Prusti output
        if let Some(errors) = Self::extract_error_count(&combined) {
            if errors > 0 {
                return VerificationStatus::Disproven;
            }
        }

        // Other errors
        if combined.contains("error") || combined.contains("Error") {
            return VerificationStatus::Unknown {
                reason: "Verification error occurred".to_string(),
            };
        }

        VerificationStatus::Unknown {
            reason: "Could not parse Prusti output".to_string(),
        }
    }

    fn extract_error_count(output: &str) -> Option<usize> {
        // Look for patterns like "error: could not compile" or "error[E0...]"
        let error_count = output.lines().filter(|l| l.starts_with("error")).count();
        if error_count > 0 {
            return Some(error_count);
        }

        // Look for verification error summary
        for line in output.lines() {
            if line.contains("verification errors") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                for (i, part) in parts.iter().enumerate() {
                    if *part == "verification" && i > 0 {
                        if let Ok(count) = parts[i - 1].parse::<usize>() {
                            return Some(count);
                        }
                    }
                }
            }
        }

        None
    }

    /// Parse Prusti output into a structured counterexample with detailed failure info
    fn parse_structured_counterexample(stdout: &str, stderr: &str) -> StructuredCounterexample {
        let mut ce = StructuredCounterexample::new();
        let combined = format!("{}\n{}", stdout, stderr);
        ce.raw = Some(combined.clone());

        // Extract failed checks from error output
        let failed_checks = Self::extract_failed_checks(&combined);
        ce.failed_checks = failed_checks;

        ce
    }

    /// Extract failed checks from Prusti error output
    fn extract_failed_checks(output: &str) -> Vec<FailedCheck> {
        let mut checks = Vec::new();
        let lines: Vec<&str> = output.lines().collect();

        for i in 0..lines.len() {
            let line = lines[i];
            let trimmed = line.trim();

            // Prusti error patterns:
            // "error: verification error" or "error[...]: ..."
            // Uses Rust error format with "--> path:line:col"
            if trimmed.starts_with("error") {
                let description = if trimmed.contains("]:") {
                    // error[E0001]: message
                    trimmed.split("]:").nth(1).unwrap_or("").trim().to_string()
                } else if trimmed.contains(':') {
                    // error: message
                    trimmed
                        .split(':')
                        .skip(1)
                        .collect::<Vec<_>>()
                        .join(":")
                        .trim()
                        .to_string()
                } else {
                    trimmed.trim().to_string()
                };

                // Determine error type
                let check_id =
                    if description.contains("assertion") || description.contains("assert") {
                        "prusti_assertion".to_string()
                    } else if description.contains("precondition")
                        || description.contains("requires")
                        || description.contains("pre-condition")
                    {
                        "prusti_precondition".to_string()
                    } else if description.contains("postcondition")
                        || description.contains("ensures")
                        || description.contains("post-condition")
                    {
                        "prusti_postcondition".to_string()
                    } else if description.contains("invariant")
                        || description.contains("body invariant")
                    {
                        "prusti_invariant".to_string()
                    } else if description.contains("overflow")
                        || description.contains("add with overflow")
                        || description.contains("subtract with overflow")
                        || description.contains("multiply with overflow")
                    {
                        "prusti_overflow".to_string()
                    } else if description.contains("panic") || description.contains("unreachable") {
                        "prusti_panic".to_string()
                    } else if description.contains("fold") || description.contains("unfold") {
                        "prusti_fold".to_string()
                    } else if description.contains("loop") || description.contains("termination") {
                        "prusti_termination".to_string()
                    } else if description.contains("verification error") {
                        "prusti_verification".to_string()
                    } else {
                        "prusti_error".to_string()
                    };

                // Look for location in following lines (Rust error format)
                let location = Self::find_location_in_context(&lines, i);

                // Try to find function name from context
                let function = Self::extract_function_name(&lines, i);

                if !description.is_empty() {
                    checks.push(FailedCheck {
                        check_id,
                        description,
                        location,
                        function,
                    });
                }
            }
        }

        // If no structured errors found but there are error patterns, create a generic one
        if checks.is_empty() && (output.contains("error") || output.contains("Error")) {
            if let Some(first_error) = Self::extract_first_error(output) {
                checks.push(FailedCheck {
                    check_id: "prusti_error".to_string(),
                    description: first_error,
                    location: None,
                    function: None,
                });
            }
        }

        checks
    }

    /// Find location info in the context around an error line
    fn find_location_in_context(lines: &[&str], error_idx: usize) -> Option<SourceLocation> {
        // Look at lines following the error for location info
        // Rust format: "  --> src/file.rs:10:5"
        for line in lines
            .iter()
            .take(lines.len().min(error_idx + 5))
            .skip(error_idx)
        {
            let trimmed = line.trim();
            if trimmed.starts_with("-->") {
                return Self::parse_rust_location(trimmed);
            }
        }
        None
    }

    /// Parse Rust error location format: "--> path:line:column"
    fn parse_rust_location(line: &str) -> Option<SourceLocation> {
        let loc_str = line.strip_prefix("-->")?.trim();
        let parts: Vec<&str> = loc_str.split(':').collect();

        if parts.len() >= 2 {
            let file = parts[0].to_string();
            let line_num: u32 = parts[1].parse().ok()?;
            let column: Option<u32> = parts.get(2).and_then(|c| c.parse().ok());

            return Some(SourceLocation {
                file,
                line: line_num,
                column,
            });
        }

        None
    }

    /// Extract function name from context around the error
    fn extract_function_name(lines: &[&str], error_idx: usize) -> Option<String> {
        // Look for "fn name" pattern in surrounding lines
        let search_range = error_idx.saturating_sub(10)..lines.len().min(error_idx + 10);

        for idx in search_range {
            let line = lines[idx];

            // Match "fn name" or "pub fn name" patterns
            if line.contains("fn ") {
                if let Some(start) = line.find("fn ") {
                    let after_fn = &line[start + 3..];
                    let name: String = after_fn
                        .trim()
                        .chars()
                        .take_while(|c| c.is_alphanumeric() || *c == '_')
                        .collect();
                    if !name.is_empty() {
                        return Some(name);
                    }
                }
            }
        }
        None
    }

    /// Extract the first error message from output
    fn extract_first_error(output: &str) -> Option<String> {
        for line in output.lines() {
            let trimmed = line.trim();
            if trimmed.starts_with("error") {
                let msg = if trimmed.contains("]:") {
                    trimmed.split("]:").nth(1).unwrap_or("").trim().to_string()
                } else if trimmed.contains(':') {
                    trimmed
                        .split(':')
                        .skip(1)
                        .collect::<Vec<_>>()
                        .join(":")
                        .trim()
                        .to_string()
                } else {
                    trimmed.to_string()
                };
                if !msg.is_empty() {
                    return Some(msg);
                }
            }
        }
        None
    }
}

#[async_trait]
impl VerificationBackend for PrustiBackend {
    fn id(&self) -> BackendId {
        BackendId::Prusti
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Contract, PropertyType::Invariant]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();

        let (tool_path, use_cargo) = self
            .detect_prusti()
            .await
            .map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {}", e))
        })?;

        // Create a minimal Cargo project structure
        let project_dir = temp_dir.path().join("prusti_verify");
        std::fs::create_dir_all(project_dir.join("src")).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create project dir: {}", e))
        })?;

        // Write Cargo.toml
        let cargo_toml = r#"[package]
name = "prusti_verify"
version = "0.1.0"
edition = "2021"

[dependencies]
prusti-contracts = "*"
"#;
        std::fs::write(project_dir.join("Cargo.toml"), cargo_toml).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write Cargo.toml: {}", e))
        })?;

        // Write source file
        let prusti_code = self.generate_prusti_code(spec);
        std::fs::write(project_dir.join("src/lib.rs"), &prusti_code).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write source: {}", e))
        })?;

        // Run Prusti
        let mut cmd = if use_cargo {
            let mut c = Command::new(&tool_path);
            c.arg("prusti");
            c
        } else {
            Command::new(&tool_path)
        };

        cmd.current_dir(&project_dir)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        // Set Prusti configuration via environment
        if self.config.check_overflows {
            cmd.env("PRUSTI_CHECK_OVERFLOWS", "true");
        }
        if self.config.full_verification {
            cmd.env("PRUSTI_FULL_VERIFICATION", "true");
        }

        let result = tokio::time::timeout(self.config.timeout, cmd.output()).await;
        let duration = start.elapsed();

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout).to_string();
                let stderr = String::from_utf8_lossy(&output.stderr).to_string();

                debug!("Prusti stdout: {}", stdout);
                debug!("Prusti stderr: {}", stderr);

                let status = self.parse_output(&stdout, &stderr, output.status.success());

                let diagnostics: Vec<String> = stderr
                    .lines()
                    .filter(|l| {
                        l.contains("error") || l.contains("warning") || l.contains("verification")
                    })
                    .map(String::from)
                    .collect();

                // Generate structured counterexample for failures
                let counterexample = if !output.status.success() {
                    Some(Self::parse_structured_counterexample(&stdout, &stderr))
                } else {
                    None
                };

                Ok(BackendResult {
                    backend: BackendId::Prusti,
                    status,
                    proof: if output.status.success() {
                        Some("Verified by Prusti/Viper".to_string())
                    } else {
                        None
                    },
                    counterexample,
                    diagnostics,
                    time_taken: duration,
                })
            }
            Ok(Err(e)) => Err(BackendError::VerificationFailed(format!(
                "Failed to execute Prusti: {}",
                e
            ))),
            Err(_) => Err(BackendError::Timeout(self.config.timeout)),
        }
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_prusti().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== PrustiConfig defaults =====

    #[kani::proof]
    fn verify_config_defaults_timeout() {
        let config = PrustiConfig::default();
        assert!(config.timeout == Duration::from_secs(300));
    }

    #[kani::proof]
    fn verify_config_defaults_path() {
        let config = PrustiConfig::default();
        assert!(config.prusti_path.is_none());
    }

    #[kani::proof]
    fn verify_config_defaults_check_overflows() {
        let config = PrustiConfig::default();
        assert!(config.check_overflows);
    }

    #[kani::proof]
    fn verify_config_defaults_full_verification() {
        let config = PrustiConfig::default();
        assert!(config.full_verification);
    }

    // ===== Backend construction =====

    #[kani::proof]
    fn verify_backend_new_uses_defaults() {
        let backend = PrustiBackend::new();
        assert!(backend.config.timeout == Duration::from_secs(300));
        assert!(backend.config.check_overflows);
        assert!(backend.config.full_verification);
    }

    #[kani::proof]
    fn verify_backend_default_matches_new() {
        let b1 = PrustiBackend::new();
        let b2 = PrustiBackend::default();
        assert!(b1.config.timeout == b2.config.timeout);
        assert!(b1.config.check_overflows == b2.config.check_overflows);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_values() {
        let config = PrustiConfig {
            prusti_path: Some(PathBuf::from("/usr/bin/prusti")),
            timeout: Duration::from_secs(60),
            check_overflows: false,
            full_verification: false,
        };
        let backend = PrustiBackend::with_config(config);
        assert!(backend.config.timeout == Duration::from_secs(60));
        assert!(!backend.config.check_overflows);
        assert!(!backend.config.full_verification);
    }

    // ===== ID and supports =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = PrustiBackend::new();
        assert!(matches!(backend.id(), BackendId::Prusti));
    }

    #[kani::proof]
    fn verify_supports_contract_and_invariant() {
        let backend = PrustiBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Contract));
        assert!(supported.contains(&PropertyType::Invariant));
        assert!(supported.len() == 2);
    }

    // ===== Output parsing =====

    #[kani::proof]
    fn verify_parse_output_success() {
        let backend = PrustiBackend::new();
        let status = backend.parse_output("Verification successful", "", true);
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_verification_error() {
        let backend = PrustiBackend::new();
        let status = backend.parse_output("", "verification error: assertion might fail", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_overflow_add() {
        let backend = PrustiBackend::new();
        let status = backend.parse_output("", "attempt to add with overflow", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_overflow_subtract() {
        let backend = PrustiBackend::new();
        let status = backend.parse_output("", "attempt to subtract with overflow", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_overflow_multiply() {
        let backend = PrustiBackend::new();
        let status = backend.parse_output("", "attempt to multiply with overflow", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_precondition() {
        let backend = PrustiBackend::new();
        let status = backend.parse_output("", "precondition might not hold", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_postcondition() {
        let backend = PrustiBackend::new();
        let status = backend.parse_output("", "postcondition might not hold", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_timeout() {
        let backend = PrustiBackend::new();
        let status = backend.parse_output("timeout", "", false);
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[kani::proof]
    fn verify_parse_output_unknown() {
        let backend = PrustiBackend::new();
        let status = backend.parse_output("random output", "", false);
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    // ===== Error count extraction =====

    #[kani::proof]
    fn verify_extract_error_count_zero() {
        let result = PrustiBackend::extract_error_count("no errors here");
        assert!(result.is_none());
    }

    #[kani::proof]
    fn verify_extract_error_count_rust_format() {
        let result =
            PrustiBackend::extract_error_count("error[E0001]: something\nerror[E0002]: another");
        assert!(result == Some(2));
    }

    // ===== Location parsing =====

    #[kani::proof]
    fn verify_parse_rust_location_full() {
        let loc = PrustiBackend::parse_rust_location("--> src/lib.rs:42:15");
        assert!(loc.is_some());
        let loc = loc.unwrap();
        assert!(loc.file == "src/lib.rs");
        assert!(loc.line == 42);
        assert!(loc.column == Some(15));
    }

    #[kani::proof]
    fn verify_parse_rust_location_no_column() {
        let loc = PrustiBackend::parse_rust_location("--> src/main.rs:10");
        assert!(loc.is_some());
        let loc = loc.unwrap();
        assert!(loc.line == 10);
        assert!(loc.column.is_none());
    }

    #[kani::proof]
    fn verify_parse_rust_location_invalid() {
        let loc = PrustiBackend::parse_rust_location("not a location");
        assert!(loc.is_none());
    }

    // ===== Failed checks extraction =====

    #[kani::proof]
    fn verify_extract_failed_checks_assertion() {
        let output = "error: assertion might fail";
        let checks = PrustiBackend::extract_failed_checks(output);
        assert!(!checks.is_empty());
        assert!(checks[0].check_id == "prusti_assertion");
    }

    #[kani::proof]
    fn verify_extract_failed_checks_precondition() {
        let output = "error: precondition might not hold";
        let checks = PrustiBackend::extract_failed_checks(output);
        assert!(!checks.is_empty());
        assert!(checks[0].check_id == "prusti_precondition");
    }

    #[kani::proof]
    fn verify_extract_failed_checks_postcondition() {
        let output = "error: postcondition might not hold";
        let checks = PrustiBackend::extract_failed_checks(output);
        assert!(!checks.is_empty());
        assert!(checks[0].check_id == "prusti_postcondition");
    }

    #[kani::proof]
    fn verify_extract_failed_checks_empty() {
        let checks = PrustiBackend::extract_failed_checks("no errors");
        assert!(checks.is_empty());
    }

    // ===== Code generation =====

    #[kani::proof]
    fn verify_generate_prusti_code_header() {
        let backend = PrustiBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let code = backend.generate_prusti_code(&spec);
        assert!(code.contains("Generated by DashProve"));
        assert!(code.contains("use prusti_contracts::*"));
    }

    #[kani::proof]
    fn verify_generate_prusti_code_ensures() {
        let backend = PrustiBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let code = backend.generate_prusti_code(&spec);
        assert!(code.contains("#[ensures(result == true)]"));
    }

    #[kani::proof]
    fn verify_generate_prusti_code_function() {
        let backend = PrustiBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let code = backend.generate_prusti_code(&spec);
        assert!(code.contains("fn verify_demo()"));
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_success_output() {
        let backend = PrustiBackend::new();
        let status = backend.parse_output("Verification successful", "", true);
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[test]
    fn parse_assertion_failure() {
        let backend = PrustiBackend::new();
        let status =
            backend.parse_output("", "error: verification error: assertion might fail", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn parse_overflow_error() {
        let backend = PrustiBackend::new();
        let status = backend.parse_output(
            "",
            "error: verification error: attempt to add with overflow",
            false,
        );
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn parse_postcondition_failure() {
        let backend = PrustiBackend::new();
        let status =
            backend.parse_output("", "error: postcondition might not hold at line 10", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn extract_error_count_from_output() {
        let output = "error[E0001]: something\nerror[E0002]: another";
        assert_eq!(PrustiBackend::extract_error_count(output), Some(2));
    }

    #[test]
    fn default_config() {
        let config = PrustiConfig::default();
        assert_eq!(config.timeout, Duration::from_secs(300));
        assert!(config.check_overflows);
        assert!(config.full_verification);
    }

    // =============================================
    // Structured counterexample parsing tests
    // =============================================

    #[test]
    fn extract_failed_checks_assertion() {
        let output = "error: verification error: assertion might fail\n  --> src/lib.rs:10:5";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_assertion");
        assert!(checks[0].location.is_some());
        let loc = checks[0].location.as_ref().unwrap();
        assert_eq!(loc.file, "src/lib.rs");
        assert_eq!(loc.line, 10);
        assert_eq!(loc.column, Some(5));
    }

    #[test]
    fn extract_failed_checks_precondition() {
        let output = "error: precondition might not hold";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_precondition");
    }

    #[test]
    fn extract_failed_checks_requires() {
        let output = "error: requires clause might not hold";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_precondition");
    }

    #[test]
    fn extract_failed_checks_postcondition() {
        let output = "error: postcondition might not hold";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_postcondition");
    }

    #[test]
    fn extract_failed_checks_ensures() {
        let output = "error: ensures clause might not hold";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_postcondition");
    }

    #[test]
    fn extract_failed_checks_invariant() {
        let output = "error: body invariant might not hold";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_invariant");
    }

    #[test]
    fn extract_failed_checks_overflow_add() {
        let output = "error: verification error: attempt to add with overflow";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_overflow");
    }

    #[test]
    fn extract_failed_checks_overflow_subtract() {
        let output = "error: verification error: attempt to subtract with overflow";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_overflow");
    }

    #[test]
    fn extract_failed_checks_overflow_multiply() {
        let output = "error: verification error: attempt to multiply with overflow";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_overflow");
    }

    #[test]
    fn extract_failed_checks_panic() {
        let output = "error: possible panic detected";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_panic");
    }

    #[test]
    fn extract_failed_checks_unreachable() {
        let output = "error: unreachable code might be reached";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_panic");
    }

    #[test]
    fn extract_failed_checks_fold() {
        let output = "error: fold operation failed";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_fold");
    }

    #[test]
    fn extract_failed_checks_termination() {
        let output = "error: loop termination might not be guaranteed";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_termination");
    }

    #[test]
    fn extract_failed_checks_verification() {
        let output = "error: verification error detected";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_verification");
    }

    #[test]
    fn extract_failed_checks_generic() {
        let output = "error: some other error";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "prusti_error");
    }

    #[test]
    fn extract_failed_checks_rust_error_format() {
        let output = "error[E0123]: mismatched types\n  --> src/main.rs:5:10";
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert!(checks[0].description.contains("mismatched types"));
        assert!(checks[0].location.is_some());
        let loc = checks[0].location.as_ref().unwrap();
        assert_eq!(loc.file, "src/main.rs");
        assert_eq!(loc.line, 5);
        assert_eq!(loc.column, Some(10));
    }

    #[test]
    fn extract_failed_checks_multiple() {
        let output = r#"error: first error
  --> a.rs:1:1
error: second error
  --> b.rs:2:2"#;
        let checks = PrustiBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 2);
    }

    #[test]
    fn extract_failed_checks_empty() {
        let checks = PrustiBackend::extract_failed_checks("");
        assert!(checks.is_empty());
    }

    #[test]
    fn extract_failed_checks_success_output() {
        let output = "Verification successful";
        let checks = PrustiBackend::extract_failed_checks(output);
        assert!(checks.is_empty());
    }

    #[test]
    fn parse_rust_location_full() {
        let line = "--> src/lib.rs:42:15";
        let loc = PrustiBackend::parse_rust_location(line).expect("Should parse");

        assert_eq!(loc.file, "src/lib.rs");
        assert_eq!(loc.line, 42);
        assert_eq!(loc.column, Some(15));
    }

    #[test]
    fn parse_rust_location_no_column() {
        let line = "--> src/main.rs:10";
        let loc = PrustiBackend::parse_rust_location(line).expect("Should parse");

        assert_eq!(loc.file, "src/main.rs");
        assert_eq!(loc.line, 10);
        assert!(loc.column.is_none());
    }

    #[test]
    fn parse_rust_location_with_spaces() {
        let line = "  --> path/to/file.rs:5:3";
        // trim is applied in the actual usage
        let trimmed = line.trim();
        let loc = PrustiBackend::parse_rust_location(trimmed).expect("Should parse");

        assert_eq!(loc.file, "path/to/file.rs");
        assert_eq!(loc.line, 5);
    }

    #[test]
    fn parse_rust_location_invalid() {
        assert!(PrustiBackend::parse_rust_location("not a location").is_none());
        assert!(PrustiBackend::parse_rust_location("").is_none());
    }

    #[test]
    fn extract_function_name_fn_pattern() {
        let lines: Vec<&str> = vec!["error: test", "in fn my_function(x: i32)"];
        let func = PrustiBackend::extract_function_name(&lines, 0);

        assert_eq!(func, Some("my_function".to_string()));
    }

    #[test]
    fn extract_function_name_pub_fn() {
        let lines: Vec<&str> = vec!["error: test", "pub fn public_function()"];
        let func = PrustiBackend::extract_function_name(&lines, 0);

        assert_eq!(func, Some("public_function".to_string()));
    }

    #[test]
    fn extract_function_name_no_function() {
        let lines: Vec<&str> = vec!["error: test", "no function here"];
        let func = PrustiBackend::extract_function_name(&lines, 0);

        assert!(func.is_none());
    }

    #[test]
    fn structured_counterexample_has_raw() {
        let ce = PrustiBackend::parse_structured_counterexample("stdout", "stderr");
        assert!(ce.raw.is_some());
        assert!(ce.raw.as_ref().unwrap().contains("stdout"));
    }

    #[test]
    fn structured_counterexample_has_failed_checks() {
        let ce = PrustiBackend::parse_structured_counterexample(
            "",
            "error: assertion might fail\n  --> test.rs:1:1",
        );

        assert!(!ce.failed_checks.is_empty());
        assert_eq!(ce.failed_checks[0].check_id, "prusti_assertion");
    }

    #[test]
    fn extract_first_error_basic() {
        let output = "warning: unused\nerror: this is the error\nmore stuff";
        let err = PrustiBackend::extract_first_error(output);

        assert!(err.is_some());
        assert!(err.unwrap().contains("this is the error"));
    }

    #[test]
    fn extract_first_error_rust_format() {
        let output = "error[E0001]: specific error message";
        let err = PrustiBackend::extract_first_error(output);

        assert!(err.is_some());
        assert!(err.unwrap().contains("specific error message"));
    }

    #[test]
    fn extract_first_error_none() {
        let output = "no errors here";
        let err = PrustiBackend::extract_first_error(output);

        assert!(err.is_none());
    }
}
