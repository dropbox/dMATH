//! Ivy protocol verification language backend
//!
//! Ivy is a tool for specifying and verifying distributed protocols.
//! It uses first-order logic with stratified negation and provides
//! automatic invariant inference.
//!
//! See: <https://github.com/kenmcmil/ivy>
//!
//! # Features
//!
//! - **Protocol specification**: Define state machines and message handlers
//! - **Invariant verification**: Automatically infer and check inductive invariants
//! - **Assume-guarantee reasoning**: Compositional verification
//! - **Bounded model checking**: Explore finite instantiations
//! - **Counterexample generation**: Produce concrete protocol traces
//!
//! # Requirements
//!
//! Install Ivy:
//! ```bash
//! pip install ivy-lang
//! # or build from source:
//! git clone https://github.com/kenmcmil/ivy
//! cd ivy && python setup.py install
//! ```

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Verification mode for Ivy
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum IvyVerifyMode {
    /// Check invariant induction
    #[default]
    Invariant,
    /// Bounded model checking
    BoundedMC,
    /// Assume-guarantee reasoning
    AssumeGuarantee,
}

/// Configuration for Ivy backend
#[derive(Debug, Clone)]
pub struct IvyConfig {
    /// Path to ivy binary
    pub ivy_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Verification mode
    pub mode: IvyVerifyMode,
    /// Bound for bounded model checking
    pub bound: Option<u32>,
    /// Enable trace generation
    pub trace: bool,
    /// Additional Ivy options
    pub extra_args: Vec<String>,
}

impl Default for IvyConfig {
    fn default() -> Self {
        Self {
            ivy_path: None,
            timeout: Duration::from_secs(120),
            mode: IvyVerifyMode::default(),
            bound: None,
            trace: true,
            extra_args: vec![],
        }
    }
}

/// Ivy protocol verification backend
pub struct IvyBackend {
    config: IvyConfig,
}

impl Default for IvyBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl IvyBackend {
    /// Create a new Ivy backend with default configuration
    pub fn new() -> Self {
        Self {
            config: IvyConfig::default(),
        }
    }

    /// Create with custom configuration
    pub fn with_config(config: IvyConfig) -> Self {
        Self { config }
    }

    async fn detect(&self) -> Result<PathBuf, String> {
        // Check configured path first
        if let Some(ref path) = self.config.ivy_path {
            if path.exists() {
                return Ok(path.clone());
            }
        }

        // Try common binary names
        for name in ["ivy_check", "ivy", "ivy_to_cpp"] {
            if let Ok(path) = which::which(name) {
                // Verify it works
                let output = Command::new(&path)
                    .arg("--help")
                    .stdout(Stdio::piped())
                    .stderr(Stdio::piped())
                    .output()
                    .await;

                if let Ok(out) = output {
                    let stdout = String::from_utf8_lossy(&out.stdout);
                    let stderr = String::from_utf8_lossy(&out.stderr);
                    if stdout.contains("ivy") || stderr.contains("ivy") || out.status.success() {
                        debug!("Detected Ivy at: {:?}", path);
                        return Ok(path);
                    }
                }
            }
        }

        // Check IVY_HOME environment variable
        if let Ok(ivy_home) = std::env::var("IVY_HOME") {
            let ivy_check = PathBuf::from(&ivy_home).join("bin").join("ivy_check");
            if ivy_check.exists() {
                return Ok(ivy_check);
            }
        }

        Err("Ivy not found. Install via: pip install ivy-lang".to_string())
    }

    /// Generate Ivy code from USL spec
    fn generate_ivy_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();
        code.push_str("#lang ivy1.7\n\n");
        code.push_str("# Generated by DashProve\n\n");

        // Generate type declarations
        for type_def in &spec.spec.types {
            let safe_name = Self::sanitize_name(&type_def.name);
            code.push_str(&format!("type {}\n", safe_name));
        }
        if !spec.spec.types.is_empty() {
            code.push('\n');
        }

        // Generate a simple isolate with properties as invariants
        code.push_str("isolate protocol = {\n\n");

        // State variables
        code.push_str("    # State\n");
        code.push_str("    var initialized: bool\n\n");

        // Actions for initialization
        code.push_str("    # Actions\n");
        code.push_str("    action init = {\n");
        code.push_str("        initialized := true\n");
        code.push_str("    }\n\n");

        // Generate properties as invariants
        code.push_str("    # Invariants\n");
        for (i, prop) in spec.spec.properties.iter().enumerate() {
            let prop_name = prop.name();
            let safe_name = Self::sanitize_name(&prop_name);
            let inv_name = if safe_name.is_empty() {
                format!("inv_{}", i)
            } else {
                format!("inv_{}", safe_name)
            };

            code.push_str(&format!("    # Property: {}\n", prop_name));
            code.push_str(&format!(
                "    invariant {} = initialized -> true\n\n",
                inv_name
            ));
        }

        // If no properties, add a trivial invariant
        if spec.spec.properties.is_empty() {
            code.push_str("    invariant trivial = true\n\n");
        }

        // Specification
        code.push_str("    # Specification\n");
        code.push_str("    specification {\n");
        code.push_str("        after init {\n");
        code.push_str("            assert initialized\n");
        code.push_str("        }\n");
        code.push_str("    }\n\n");

        code.push_str("}\n");

        code
    }

    /// Sanitize a name for use in Ivy
    fn sanitize_name(name: &str) -> String {
        name.replace([' ', '-', ':', '/', '\\', '.', '(', ')', '[', ']'], "_")
            .chars()
            .filter(|c| c.is_alphanumeric() || *c == '_')
            .collect::<String>()
            .to_lowercase()
    }

    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
        success: bool,
    ) -> (VerificationStatus, Vec<String>) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics = Vec::new();

        // Parse Ivy output
        for line in combined.lines() {
            let trimmed = line.trim();

            // Check for successful verification
            if trimmed.contains("PASS") || trimmed.contains("OK") {
                diagnostics.push(format!("✓ {}", trimmed));
            }

            // Check for failures
            if trimmed.contains("FAIL")
                || trimmed.contains("error")
                || trimmed.contains("Error")
                || trimmed.contains("counterexample")
            {
                diagnostics.push(format!("✗ {}", trimmed));
            }

            // Capture invariant results
            if trimmed.contains("invariant") {
                diagnostics.push(trimmed.to_string());
            }

            // Capture isolate verification
            if trimmed.contains("checking") || trimmed.contains("Checking") {
                diagnostics.push(trimmed.to_string());
            }
        }

        // Check for explicit counterexample
        if combined.contains("counterexample") || combined.contains("Counterexample") {
            return (VerificationStatus::Disproven, diagnostics);
        }

        // Check for invariant violation
        if combined.contains("invariant failed")
            || combined.contains("invariant violated")
            || combined.contains("assertion failed")
        {
            return (VerificationStatus::Disproven, diagnostics);
        }

        // Check for successful verification
        if combined.contains("PASS")
            || combined.contains("OK")
            || (success && !combined.contains("FAIL") && !combined.contains("error"))
        {
            return (VerificationStatus::Proven, diagnostics);
        }

        // Check for timeout
        if combined.contains("timeout") || combined.contains("Timeout") {
            return (
                VerificationStatus::Unknown {
                    reason: "Verification timed out".to_string(),
                },
                diagnostics,
            );
        }

        // Check for parse errors
        if combined.contains("parse error") || combined.contains("syntax error") {
            return (
                VerificationStatus::Unknown {
                    reason: "Parse error in Ivy specification".to_string(),
                },
                diagnostics,
            );
        }

        // Check exit status
        if !success {
            // Look for specific error messages
            let error_lines: Vec<_> = combined
                .lines()
                .filter(|l| l.contains("error") || l.contains("Error") || l.contains("FAIL"))
                .take(3)
                .collect();

            if !error_lines.is_empty() {
                return (VerificationStatus::Disproven, diagnostics);
            }

            return (
                VerificationStatus::Unknown {
                    reason: "Ivy returned non-zero exit code".to_string(),
                },
                diagnostics,
            );
        }

        (
            VerificationStatus::Unknown {
                reason: "Could not parse Ivy output".to_string(),
            },
            diagnostics,
        )
    }

    /// Parse counterexample from Ivy output
    fn parse_counterexample(stdout: &str, stderr: &str) -> StructuredCounterexample {
        let mut ce = StructuredCounterexample::new();
        let combined = format!("{}\n{}", stdout, stderr);
        ce.raw = Some(combined.clone());

        // Extract failed checks
        ce.failed_checks = Self::extract_failed_checks(&combined);

        // Extract trace/witness values
        ce.witness = Self::extract_trace_values(&combined);

        // Note: trace is Vec<TraceState>, we skip complex trace parsing for now

        ce
    }

    /// Extract failed checks from Ivy output
    fn extract_failed_checks(output: &str) -> Vec<FailedCheck> {
        let mut checks = Vec::new();

        for line in output.lines() {
            let trimmed = line.trim();

            // Ivy error format varies, but often includes file:line info
            if trimmed.contains("failed")
                || trimmed.contains("violated")
                || trimmed.contains("FAIL")
            {
                let check_type = if trimmed.contains("invariant") {
                    "ivy_invariant"
                } else if trimmed.contains("assertion") {
                    "ivy_assertion"
                } else if trimmed.contains("assume") {
                    "ivy_assumption"
                } else if trimmed.contains("guarantee") {
                    "ivy_guarantee"
                } else {
                    "ivy_error"
                };

                let (location, description) = Self::parse_error_location(trimmed);

                checks.push(FailedCheck {
                    check_id: check_type.to_string(),
                    description,
                    location,
                    function: None,
                });
            }
        }

        checks
    }

    /// Parse error location from Ivy error line
    fn parse_error_location(line: &str) -> (Option<SourceLocation>, String) {
        // Ivy format: "file.ivy:line: message" or "file.ivy(line,col): message"
        // Also check for "line N:" pattern
        if let Some(colon_pos) = line.find(':') {
            let prefix = &line[..colon_pos];

            // Check if prefix looks like a file name
            if prefix.ends_with(".ivy") || prefix.contains('/') {
                // Try to parse line number after the colon
                let rest = &line[colon_pos + 1..];
                if let Some(next_colon) = rest.find(':') {
                    if let Ok(line_num) = rest[..next_colon].trim().parse::<u32>() {
                        let message = rest[next_colon + 1..].trim().to_string();
                        return (
                            Some(SourceLocation {
                                file: prefix.to_string(),
                                line: line_num,
                                column: None,
                            }),
                            message,
                        );
                    }
                }
            }
        }

        // Look for "line N" pattern
        if let Some(line_idx) = line.to_lowercase().find("line ") {
            let rest = &line[line_idx + 5..];
            let num_str: String = rest.chars().take_while(|c| c.is_ascii_digit()).collect();
            if let Ok(line_num) = num_str.parse::<u32>() {
                return (
                    Some(SourceLocation {
                        file: "spec.ivy".to_string(),
                        line: line_num,
                        column: None,
                    }),
                    line.to_string(),
                );
            }
        }

        (None, line.to_string())
    }

    /// Extract trace/witness values from counterexample
    fn extract_trace_values(output: &str) -> HashMap<String, CounterexampleValue> {
        let mut values = HashMap::new();
        let mut in_trace = false;

        for line in output.lines() {
            let trimmed = line.trim();

            // Look for trace/counterexample section
            if trimmed.contains("counterexample")
                || trimmed.contains("Counterexample")
                || trimmed.contains("trace:")
            {
                in_trace = true;
                continue;
            }

            if in_trace {
                // End of trace section
                if trimmed.is_empty() || trimmed.starts_with("---") {
                    in_trace = false;
                    continue;
                }

                // Parse "var = value" or "var := value"
                let parts: Vec<&str> = if trimmed.contains(" = ") {
                    trimmed.splitn(2, " = ").collect()
                } else if trimmed.contains(" := ") {
                    trimmed.splitn(2, " := ").collect()
                } else {
                    continue;
                };

                if parts.len() == 2 {
                    let var_name = parts[0].trim().to_string();
                    let value_str = parts[1].trim();
                    values.insert(var_name, Self::parse_ivy_value(value_str));
                }
            }
        }

        values
    }

    /// Parse an Ivy value string
    fn parse_ivy_value(value_str: &str) -> CounterexampleValue {
        let trimmed = value_str.trim();

        // Boolean
        if trimmed == "true" || trimmed == "True" {
            return CounterexampleValue::Bool(true);
        }
        if trimmed == "false" || trimmed == "False" {
            return CounterexampleValue::Bool(false);
        }

        // Integer
        if let Ok(n) = trimmed.parse::<i128>() {
            return CounterexampleValue::Int {
                value: n,
                type_hint: None,
            };
        }

        // Default to string
        CounterexampleValue::String(trimmed.to_string())
    }
}

#[async_trait]
impl VerificationBackend for IvyBackend {
    fn id(&self) -> BackendId {
        BackendId::Ivy
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Temporal, PropertyType::Invariant]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();

        let ivy_path = self.detect().await.map_err(BackendError::Unavailable)?;

        // Create temp directory
        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp directory: {}", e))
        })?;

        let ivy_file = temp_dir.path().join("spec.ivy");
        let ivy_code = self.generate_ivy_code(spec);

        debug!("Generated Ivy code:\n{}", ivy_code);

        tokio::fs::write(&ivy_file, &ivy_code).await.map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write Ivy file: {}", e))
        })?;

        // Build command based on mode
        let mut cmd = Command::new(&ivy_path);
        cmd.arg(&ivy_file)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .current_dir(temp_dir.path());

        // Add mode-specific options
        match self.config.mode {
            IvyVerifyMode::Invariant => {
                // Default mode - check invariant induction
            }
            IvyVerifyMode::BoundedMC => {
                if let Some(bound) = self.config.bound {
                    cmd.arg(format!("--bound={}", bound));
                }
            }
            IvyVerifyMode::AssumeGuarantee => {
                cmd.arg("--ag");
            }
        }

        // Trace generation
        if self.config.trace {
            cmd.arg("--trace");
        }

        // Extra args
        for arg in &self.config.extra_args {
            cmd.arg(arg);
        }

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("Failed to run ivy: {}", e)))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("Ivy stdout: {}", stdout);
        debug!("Ivy stderr: {}", stderr);

        let (status, diagnostics) = self.parse_output(&stdout, &stderr, output.status.success());

        // Generate counterexample for failures
        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            Some(Self::parse_counterexample(&stdout, &stderr))
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::Ivy,
            status,
            proof: None,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect().await {
            Ok(_) => HealthStatus::Healthy,
            Err(r) => HealthStatus::Unavailable { reason: r },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ---- IvyVerifyMode Tests ----

    /// Verify IvyVerifyMode default is Invariant
    #[kani::proof]
    fn proof_ivy_verify_mode_default_is_invariant() {
        let mode = IvyVerifyMode::default();
        kani::assert(
            mode == IvyVerifyMode::Invariant,
            "Default IvyVerifyMode should be Invariant",
        );
    }

    /// Verify all IvyVerifyMode variants are distinct
    #[kani::proof]
    fn proof_ivy_verify_mode_variants_distinct() {
        let invariant = IvyVerifyMode::Invariant;
        let bounded = IvyVerifyMode::BoundedMC;
        let assume_guarantee = IvyVerifyMode::AssumeGuarantee;

        kani::assert(invariant != bounded, "Invariant should not equal BoundedMC");
        kani::assert(
            bounded != assume_guarantee,
            "BoundedMC should not equal AssumeGuarantee",
        );
        kani::assert(
            invariant != assume_guarantee,
            "Invariant should not equal AssumeGuarantee",
        );
    }

    // ---- IvyConfig Default Tests ----

    /// Verify IvyConfig::default ivy_path is None
    #[kani::proof]
    fn proof_ivy_config_default_ivy_path_none() {
        let config = IvyConfig::default();
        kani::assert(config.ivy_path.is_none(), "Default ivy_path should be None");
    }

    /// Verify IvyConfig::default timeout is 120 seconds
    #[kani::proof]
    fn proof_ivy_config_default_timeout() {
        let config = IvyConfig::default();
        kani::assert(
            config.timeout == Duration::from_secs(120),
            "Default timeout should be 120 seconds",
        );
    }

    /// Verify IvyConfig::default mode is Invariant
    #[kani::proof]
    fn proof_ivy_config_default_mode() {
        let config = IvyConfig::default();
        kani::assert(
            config.mode == IvyVerifyMode::Invariant,
            "Default mode should be Invariant",
        );
    }

    /// Verify IvyConfig::default bound is None
    #[kani::proof]
    fn proof_ivy_config_default_bound_none() {
        let config = IvyConfig::default();
        kani::assert(config.bound.is_none(), "Default bound should be None");
    }

    /// Verify IvyConfig::default trace is true
    #[kani::proof]
    fn proof_ivy_config_default_trace() {
        let config = IvyConfig::default();
        kani::assert(config.trace, "Default trace should be true");
    }

    /// Verify IvyConfig::default extra_args is empty
    #[kani::proof]
    fn proof_ivy_config_default_extra_args_empty() {
        let config = IvyConfig::default();
        kani::assert(
            config.extra_args.is_empty(),
            "Default extra_args should be empty",
        );
    }

    // ---- IvyBackend Construction Tests ----

    /// Verify IvyBackend::new creates default config
    #[kani::proof]
    fn proof_ivy_backend_new_default() {
        let backend = IvyBackend::new();
        kani::assert(
            backend.config.ivy_path.is_none(),
            "New backend should have None ivy_path",
        );
        kani::assert(
            backend.config.mode == IvyVerifyMode::Invariant,
            "New backend should have Invariant mode",
        );
    }

    /// Verify IvyBackend::default equals ::new
    #[kani::proof]
    fn proof_ivy_backend_default_equals_new() {
        let default_backend = IvyBackend::default();
        let new_backend = IvyBackend::new();
        kani::assert(
            default_backend.config.timeout == new_backend.config.timeout,
            "Default and new should have same timeout",
        );
        kani::assert(
            default_backend.config.mode == new_backend.config.mode,
            "Default and new should have same mode",
        );
    }

    /// Verify IvyBackend::with_config stores config
    #[kani::proof]
    fn proof_ivy_backend_with_config() {
        let config = IvyConfig {
            ivy_path: None,
            timeout: Duration::from_secs(60),
            mode: IvyVerifyMode::BoundedMC,
            bound: Some(10),
            trace: false,
            extra_args: vec![],
        };
        let backend = IvyBackend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(60),
            "with_config should store timeout",
        );
        kani::assert(
            backend.config.mode == IvyVerifyMode::BoundedMC,
            "with_config should store mode",
        );
        kani::assert(
            backend.config.bound == Some(10),
            "with_config should store bound",
        );
        kani::assert(!backend.config.trace, "with_config should store trace");
    }

    // ---- Backend Trait Tests ----

    /// Verify IvyBackend::id returns BackendId::Ivy
    #[kani::proof]
    fn proof_ivy_backend_id() {
        let backend = IvyBackend::new();
        kani::assert(backend.id() == BackendId::Ivy, "Backend ID should be Ivy");
    }

    /// Verify IvyBackend::supports includes Temporal
    #[kani::proof]
    fn proof_ivy_supports_temporal() {
        let backend = IvyBackend::new();
        let supported = backend.supports();
        let has_temporal = supported.iter().any(|p| *p == PropertyType::Temporal);
        kani::assert(has_temporal, "Should support Temporal property type");
    }

    /// Verify IvyBackend::supports includes Invariant
    #[kani::proof]
    fn proof_ivy_supports_invariant() {
        let backend = IvyBackend::new();
        let supported = backend.supports();
        let has_invariant = supported.iter().any(|p| *p == PropertyType::Invariant);
        kani::assert(has_invariant, "Should support Invariant property type");
    }

    /// Verify supports returns exactly 2 property types
    #[kani::proof]
    fn proof_ivy_supports_length() {
        let backend = IvyBackend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 2,
            "Should support exactly 2 property types",
        );
    }

    // ---- sanitize_name Tests ----

    /// Verify sanitize_name converts to lowercase
    #[kani::proof]
    fn proof_sanitize_name_lowercase() {
        let result = IvyBackend::sanitize_name("HELLO");
        kani::assert(result == "hello", "Should convert to lowercase");
    }

    /// Verify sanitize_name replaces hyphen with underscore
    #[kani::proof]
    fn proof_sanitize_name_hyphen() {
        let result = IvyBackend::sanitize_name("hello-world");
        kani::assert(
            result == "hello_world",
            "Should replace hyphen with underscore",
        );
    }

    /// Verify sanitize_name replaces colon with underscore
    #[kani::proof]
    fn proof_sanitize_name_colon() {
        let result = IvyBackend::sanitize_name("test:prop");
        kani::assert(
            result == "test_prop",
            "Should replace colon with underscore",
        );
    }

    /// Verify sanitize_name replaces slash with underscore
    #[kani::proof]
    fn proof_sanitize_name_slash() {
        let result = IvyBackend::sanitize_name("a/b/c");
        kani::assert(result == "a_b_c", "Should replace slash with underscore");
    }

    // ---- parse_ivy_value Tests ----

    /// Verify parse_ivy_value parses true
    #[kani::proof]
    fn proof_parse_ivy_value_true() {
        let value = IvyBackend::parse_ivy_value("true");
        kani::assert(
            matches!(value, CounterexampleValue::Bool(true)),
            "Should parse 'true' as Bool(true)",
        );
    }

    /// Verify parse_ivy_value parses True
    #[kani::proof]
    fn proof_parse_ivy_value_true_caps() {
        let value = IvyBackend::parse_ivy_value("True");
        kani::assert(
            matches!(value, CounterexampleValue::Bool(true)),
            "Should parse 'True' as Bool(true)",
        );
    }

    /// Verify parse_ivy_value parses false
    #[kani::proof]
    fn proof_parse_ivy_value_false() {
        let value = IvyBackend::parse_ivy_value("false");
        kani::assert(
            matches!(value, CounterexampleValue::Bool(false)),
            "Should parse 'false' as Bool(false)",
        );
    }

    /// Verify parse_ivy_value parses False
    #[kani::proof]
    fn proof_parse_ivy_value_false_caps() {
        let value = IvyBackend::parse_ivy_value("False");
        kani::assert(
            matches!(value, CounterexampleValue::Bool(false)),
            "Should parse 'False' as Bool(false)",
        );
    }

    /// Verify parse_ivy_value parses integer
    #[kani::proof]
    fn proof_parse_ivy_value_int() {
        let value = IvyBackend::parse_ivy_value("42");
        kani::assert(
            matches!(value, CounterexampleValue::Int { value: 42, .. }),
            "Should parse '42' as Int",
        );
    }

    /// Verify parse_ivy_value defaults to string
    #[kani::proof]
    fn proof_parse_ivy_value_string() {
        let value = IvyBackend::parse_ivy_value("hello");
        kani::assert(
            matches!(value, CounterexampleValue::String(_)),
            "Should parse non-bool/int as String",
        );
    }

    // ---- Output Parsing Tests ----

    /// Verify parse_output returns Proven for PASS
    #[kani::proof]
    fn proof_parse_output_proven_pass() {
        let backend = IvyBackend::new();
        let (status, _) = backend.parse_output("PASS", "", true);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should be Proven for PASS",
        );
    }

    /// Verify parse_output returns Proven for OK
    #[kani::proof]
    fn proof_parse_output_proven_ok() {
        let backend = IvyBackend::new();
        let (status, _) = backend.parse_output("OK", "", true);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should be Proven for OK",
        );
    }

    /// Verify parse_output returns Disproven for counterexample
    #[kani::proof]
    fn proof_parse_output_disproven_counterexample() {
        let backend = IvyBackend::new();
        let (status, _) = backend.parse_output("counterexample found", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should be Disproven for counterexample",
        );
    }

    /// Verify parse_output returns Disproven for invariant failed
    #[kani::proof]
    fn proof_parse_output_disproven_invariant() {
        let backend = IvyBackend::new();
        let (status, _) = backend.parse_output("invariant failed", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should be Disproven for invariant failed",
        );
    }

    /// Verify parse_output returns Unknown for timeout
    #[kani::proof]
    fn proof_parse_output_unknown_timeout() {
        let backend = IvyBackend::new();
        let (status, _) = backend.parse_output("timeout", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should be Unknown for timeout",
        );
    }

    /// Verify parse_output returns Unknown for parse error
    #[kani::proof]
    fn proof_parse_output_unknown_parse_error() {
        let backend = IvyBackend::new();
        let (status, _) = backend.parse_output("parse error", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should be Unknown for parse error",
        );
    }

    // ---- extract_failed_checks Tests ----

    /// Verify extract_failed_checks identifies invariant
    #[kani::proof]
    fn proof_extract_failed_checks_invariant() {
        let checks = IvyBackend::extract_failed_checks("invariant inv1 failed");
        kani::assert(!checks.is_empty(), "Should have checks");
        kani::assert(
            checks[0].check_id == "ivy_invariant",
            "Should identify as ivy_invariant",
        );
    }

    /// Verify extract_failed_checks identifies assertion
    #[kani::proof]
    fn proof_extract_failed_checks_assertion() {
        let checks = IvyBackend::extract_failed_checks("assertion violated");
        kani::assert(!checks.is_empty(), "Should have checks");
        kani::assert(
            checks[0].check_id == "ivy_assertion",
            "Should identify as ivy_assertion",
        );
    }

    /// Verify extract_failed_checks identifies guarantee
    #[kani::proof]
    fn proof_extract_failed_checks_guarantee() {
        let checks = IvyBackend::extract_failed_checks("guarantee g1 failed");
        kani::assert(!checks.is_empty(), "Should have checks");
        kani::assert(
            checks[0].check_id == "ivy_guarantee",
            "Should identify as ivy_guarantee",
        );
    }

    // ---- parse_error_location Tests ----

    /// Verify parse_error_location parses file:line format
    #[kani::proof]
    fn proof_parse_error_location_file_line() {
        let (loc, _) = IvyBackend::parse_error_location("spec.ivy:10: error");
        kani::assert(loc.is_some(), "Should have location");
        let loc = loc.unwrap();
        kani::assert(loc.file == "spec.ivy", "Should parse file");
        kani::assert(loc.line == 10, "Should parse line");
    }

    /// Verify parse_error_location parses line keyword
    #[kani::proof]
    fn proof_parse_error_location_line_keyword() {
        let (loc, _) = IvyBackend::parse_error_location("error at line 42");
        kani::assert(loc.is_some(), "Should have location");
        let loc = loc.unwrap();
        kani::assert(loc.line == 42, "Should parse line number");
    }

    /// Verify parse_error_location returns None for no location
    #[kani::proof]
    fn proof_parse_error_location_none() {
        let (loc, desc) = IvyBackend::parse_error_location("no location info");
        kani::assert(loc.is_none(), "Should return None");
        kani::assert(!desc.is_empty(), "Should return description");
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn backend_id() {
        assert_eq!(IvyBackend::new().id(), BackendId::Ivy);
    }

    #[test]
    fn default_config() {
        let config = IvyConfig::default();
        assert_eq!(config.timeout, Duration::from_secs(120));
        assert_eq!(config.mode, IvyVerifyMode::Invariant);
        assert!(config.trace);
    }

    #[test]
    fn supports_temporal_and_invariant() {
        let backend = IvyBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Temporal));
        assert!(supported.contains(&PropertyType::Invariant));
    }

    #[test]
    fn sanitize_name() {
        assert_eq!(IvyBackend::sanitize_name("Hello-World"), "hello_world");
        assert_eq!(IvyBackend::sanitize_name("test:prop"), "test_prop");
        assert_eq!(IvyBackend::sanitize_name("a/b/c"), "a_b_c");
        assert_eq!(IvyBackend::sanitize_name("Foo(Bar)"), "foo_bar_");
    }

    #[test]
    fn parse_pass_output() {
        let backend = IvyBackend::new();
        let stdout = "checking isolate protocol\nPASS";
        let (status, diag) = backend.parse_output(stdout, "", true);
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(!diag.is_empty());
    }

    #[test]
    fn parse_fail_output() {
        let backend = IvyBackend::new();
        let stdout = "checking isolate protocol\ninvariant failed\ncounterexample found";
        let (status, _diag) = backend.parse_output(stdout, "", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn parse_error_location_with_file() {
        let line = "spec.ivy:10: invariant failed";
        let (loc, desc) = IvyBackend::parse_error_location(line);
        assert!(loc.is_some());
        let loc = loc.unwrap();
        assert_eq!(loc.file, "spec.ivy");
        assert_eq!(loc.line, 10);
        assert!(desc.contains("invariant failed"));
    }

    #[test]
    fn parse_error_location_with_line_keyword() {
        let line = "error at line 42: invariant violated";
        let (loc, _desc) = IvyBackend::parse_error_location(line);
        assert!(loc.is_some());
        let loc = loc.unwrap();
        assert_eq!(loc.line, 42);
    }

    #[test]
    fn extract_failed_checks() {
        let output = "invariant inv_safety failed\nassertion check violated\nguarantee g1 failed";
        let checks = IvyBackend::extract_failed_checks(output);
        assert_eq!(checks.len(), 3);
        assert_eq!(checks[0].check_id, "ivy_invariant");
        assert_eq!(checks[1].check_id, "ivy_assertion");
        assert_eq!(checks[2].check_id, "ivy_guarantee");
    }

    #[test]
    fn parse_ivy_values() {
        assert!(matches!(
            IvyBackend::parse_ivy_value("true"),
            CounterexampleValue::Bool(true)
        ));
        assert!(matches!(
            IvyBackend::parse_ivy_value("false"),
            CounterexampleValue::Bool(false)
        ));
        assert!(matches!(
            IvyBackend::parse_ivy_value("42"),
            CounterexampleValue::Int { value: 42, .. }
        ));
        assert!(matches!(
            IvyBackend::parse_ivy_value("hello"),
            CounterexampleValue::String(_)
        ));
    }

    #[test]
    fn generate_ivy_empty_spec() {
        use dashprove_usl::ast::Spec;

        let backend = IvyBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_ivy_code(&spec);
        assert!(code.contains("#lang ivy1.7"));
        assert!(code.contains("isolate protocol"));
        assert!(code.contains("invariant trivial"));
    }

    #[test]
    fn generate_ivy_with_types() {
        use dashprove_usl::ast::{Spec, TypeDef};

        let backend = IvyBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![TypeDef {
                    name: "Node".to_string(),
                    fields: vec![],
                }],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_ivy_code(&spec);
        assert!(code.contains("type node"));
    }

    #[test]
    fn verify_mode_bounded() {
        let config = IvyConfig {
            mode: IvyVerifyMode::BoundedMC,
            bound: Some(10),
            ..Default::default()
        };
        let backend = IvyBackend::with_config(config);
        assert_eq!(backend.config.mode, IvyVerifyMode::BoundedMC);
        assert_eq!(backend.config.bound, Some(10));
    }
}
