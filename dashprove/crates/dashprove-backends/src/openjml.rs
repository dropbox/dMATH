//! OpenJML Java verification backend
//!
//! OpenJML is a tool for Java Modeling Language (JML) specification checking.
//! It provides runtime assertion checking, extended static checking (ESC),
//! and full verification using SMT solvers.
//!
//! See: <https://www.openjml.org/>

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use regex::Regex;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// OpenJML verification mode
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OpenJmlMode {
    /// Runtime assertion checking (rac)
    Rac,
    /// Extended static checking (esc)
    #[default]
    Esc,
}

#[derive(Debug, Clone)]
pub struct OpenJmlConfig {
    pub openjml_path: Option<PathBuf>,
    pub timeout: Duration,
    /// Verification mode
    pub mode: OpenJmlMode,
    /// SMT solver to use (z3, cvc4, cvc5)
    pub solver: String,
    /// Timeout for SMT solver in seconds
    pub solver_timeout: u32,
}

impl Default for OpenJmlConfig {
    fn default() -> Self {
        Self {
            openjml_path: None,
            timeout: Duration::from_secs(120),
            mode: OpenJmlMode::Esc,
            solver: "z3".to_string(),
            solver_timeout: 60,
        }
    }
}

pub struct OpenJmlBackend {
    config: OpenJmlConfig,
}

impl Default for OpenJmlBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl OpenJmlBackend {
    pub fn new() -> Self {
        Self {
            config: OpenJmlConfig::default(),
        }
    }
    pub fn with_config(config: OpenJmlConfig) -> Self {
        Self { config }
    }

    async fn detect(&self) -> Result<PathBuf, String> {
        let openjml = self
            .config
            .openjml_path
            .clone()
            .or_else(|| which::which("openjml").ok())
            .or_else(|| which::which("openjml.jar").ok())
            .or_else(|| {
                // Check common installation locations
                let home = std::env::var("HOME").ok()?;
                let path = PathBuf::from(format!("{}/openjml/openjml.jar", home));
                if path.exists() {
                    Some(path)
                } else {
                    None
                }
            })
            .ok_or("OpenJML not found. Download from https://www.openjml.org/".to_string())?;

        // Check if java is available for jar files
        if openjml.extension().map(|e| e == "jar").unwrap_or(false) {
            which::which("java")
                .map_err(|_| "Java required to run OpenJML but not found".to_string())?;
        }

        Ok(openjml)
    }

    /// Generate Java code with JML annotations from the spec for OpenJML verification
    fn generate_java_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();
        code.push_str("// Generated by DashProve for OpenJML verification\n\n");

        code.push_str("public class Verify {\n");
        code.push_str("    private /*@ spec_public @*/ int state;\n\n");

        // Generate class invariant
        if spec.spec.properties.is_empty() {
            code.push_str("    //@ public invariant state >= 0;\n\n");
        } else {
            for prop in &spec.spec.properties {
                code.push_str(&format!("    // Property: {}\n", prop.name()));
                code.push_str(&format!(
                    "    //@ public invariant state >= 0;  // {}\n",
                    prop.name()
                ));
            }
            code.push('\n');
        }

        // Generate constructor with postcondition
        code.push_str("    //@ ensures state == 0;\n");
        code.push_str("    public Verify() {\n");
        code.push_str("        state = 0;\n");
        code.push_str("    }\n\n");

        // Generate a method with full contract
        code.push_str("    //@ requires state >= 0;\n");
        code.push_str("    //@ ensures state >= 0;\n");
        code.push_str("    //@ ensures \\result >= 0;\n");
        code.push_str("    //@ pure\n");
        code.push_str("    public int getState() {\n");

        if !spec.spec.properties.is_empty() {
            for (idx, prop) in spec.spec.properties.iter().enumerate() {
                code.push_str(&format!(
                    "        //@ assert state >= 0;  // Check {}: {}\n",
                    idx,
                    prop.name()
                ));
            }
        }

        code.push_str("        return state;\n");
        code.push_str("    }\n\n");

        // Generate a mutation method
        code.push_str("    //@ requires state >= 0;\n");
        code.push_str("    //@ requires delta >= -state;\n");
        code.push_str("    //@ ensures state == \\old(state) + delta;\n");
        code.push_str("    //@ assignable state;\n");
        code.push_str("    public void update(int delta) {\n");
        code.push_str("        state = state + delta;\n");
        code.push_str("    }\n");

        code.push_str("}\n");
        code
    }

    /// Parse OpenJML output to determine verification status
    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics: Vec<String> = combined
            .lines()
            .filter(|l| {
                l.contains("error")
                    || l.contains("warning")
                    || l.contains("Error")
                    || l.contains("Warning")
                    || l.contains("caution")
            })
            .map(|s| s.to_string())
            .collect();

        // OpenJML output patterns
        let verified = combined.contains("0 errors")
            || combined.contains("Verification succeeded")
            || combined.contains("valid");
        let failed = combined.contains("assertion is false")
            || combined.contains("precondition is false")
            || combined.contains("postcondition is false")
            || combined.contains("invariant is false")
            || combined.contains("assignable clause is false")
            || combined.contains("error:");

        let status = if verified && !failed {
            VerificationStatus::Proven
        } else if failed {
            VerificationStatus::Disproven
        } else if combined.to_lowercase().contains("timeout") {
            VerificationStatus::Unknown {
                reason: "OpenJML timed out".to_string(),
            }
        } else {
            VerificationStatus::Unknown {
                reason: "Could not determine OpenJML result".to_string(),
            }
        };

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            self.extract_counterexample(&combined)
        } else {
            None
        };

        if diagnostics.is_empty() && !stderr.trim().is_empty() {
            diagnostics.push(stderr.to_string());
        }

        (status, counterexample, diagnostics)
    }

    /// Extract counterexample from OpenJML verification failure
    fn extract_counterexample(&self, output: &str) -> Option<StructuredCounterexample> {
        let mut witness = HashMap::new();
        let mut failed_checks = Vec::new();

        // Parse OpenJML error messages like:
        // Verify.java:15: error: assertion is false
        // Verify.java:20: error: postcondition is false
        let error_re = Regex::new(
            r"(?P<file>[A-Za-z][A-Za-z0-9_]*\.java):(?P<line>\d+):\s*(?:error|warning):\s*(?P<desc>[^\n]+)"
        ).ok()?;

        for cap in error_re.captures_iter(output) {
            let file = cap
                .name("file")
                .map(|m| m.as_str().to_string())
                .unwrap_or_default();
            let line = cap
                .name("line")
                .and_then(|m| m.as_str().parse::<u32>().ok())
                .unwrap_or(0);
            let description = cap
                .name("desc")
                .map(|m| m.as_str())
                .unwrap_or("Verification failed");

            failed_checks.push(FailedCheck {
                check_id: format!("openjml_error_{}", failed_checks.len()),
                description: description.to_string(),
                location: Some(SourceLocation {
                    file,
                    line,
                    column: None,
                }),
                function: None,
            });
        }

        // Parse counterexample values from OpenJML trace
        // Format: variable = value
        let value_re =
            Regex::new(r"(?P<var>[a-zA-Z_][a-zA-Z0-9_.]*)\s*=\s*(?P<val>[-\d]+)").ok()?;
        for cap in value_re.captures_iter(output) {
            let var = cap.name("var").unwrap().as_str().to_string();
            let val = cap.name("val").unwrap().as_str();
            if let Ok(num) = val.parse::<i128>() {
                witness.insert(
                    var,
                    CounterexampleValue::Int {
                        value: num,
                        type_hint: None,
                    },
                );
            }
        }

        if failed_checks.is_empty() {
            failed_checks.push(FailedCheck {
                check_id: "openjml_error".to_string(),
                description: "OpenJML verification failed".to_string(),
                location: None,
                function: None,
            });
        }

        Some(StructuredCounterexample {
            witness,
            failed_checks,
            playback_test: None,
            trace: Vec::new(),
            raw: Some(output.to_string()),
            minimized: false,
        })
    }
}

#[async_trait]
impl VerificationBackend for OpenJmlBackend {
    fn id(&self) -> BackendId {
        BackendId::OpenJML
    }
    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Contract, PropertyType::Invariant]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let openjml_path = self.detect().await.map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;
        let source_path = temp_dir.path().join("Verify.java");

        std::fs::write(&source_path, self.generate_java_code(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write Java source: {e}"))
        })?;

        let mut cmd = if openjml_path
            .extension()
            .map(|e| e == "jar")
            .unwrap_or(false)
        {
            let mut c = Command::new("java");
            c.arg("-jar").arg(&openjml_path);
            c
        } else {
            Command::new(&openjml_path)
        };

        // Set verification mode
        match self.config.mode {
            OpenJmlMode::Esc => {
                cmd.arg("-esc");
            }
            OpenJmlMode::Rac => {
                cmd.arg("-rac");
            }
        }

        cmd.arg("-prover")
            .arg(&self.config.solver)
            .arg("-timeout")
            .arg(self.config.solver_timeout.to_string())
            .arg(&source_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("OpenJML failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("OpenJML stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("OpenJML stderr: {}", stderr);
        }

        let (status, counterexample, diagnostics) = self.parse_output(&stdout, &stderr);
        let proof = if matches!(status, VerificationStatus::Proven) {
            Some("OpenJML verified all JML specifications".to_string())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::OpenJML,
            status,
            proof,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect().await {
            Ok(_) => HealthStatus::Healthy,
            Err(r) => HealthStatus::Unavailable { reason: r },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== OpenJmlConfig defaults =====

    #[kani::proof]
    fn verify_config_defaults() {
        let config = OpenJmlConfig::default();
        assert!(config.openjml_path.is_none());
        assert_eq!(config.timeout, Duration::from_secs(120));
        assert!(matches!(config.mode, OpenJmlMode::Esc));
        assert_eq!(config.solver, "z3");
        assert_eq!(config.solver_timeout, 60);
    }

    // ===== Backend construction =====

    #[kani::proof]
    fn verify_backend_new_uses_defaults() {
        let backend = OpenJmlBackend::new();
        assert_eq!(backend.config.timeout, Duration::from_secs(120));
        assert!(matches!(backend.config.mode, OpenJmlMode::Esc));
    }

    #[kani::proof]
    fn verify_backend_default_equals_new() {
        let a = OpenJmlBackend::new();
        let b = OpenJmlBackend::default();
        assert_eq!(a.config.timeout, b.config.timeout);
        assert_eq!(a.config.solver, b.config.solver);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_solver() {
        let config = OpenJmlConfig {
            openjml_path: Some(PathBuf::from("/opt/openjml.jar")),
            timeout: Duration::from_secs(45),
            mode: OpenJmlMode::Rac,
            solver: "cvc5".to_string(),
            solver_timeout: 15,
        };
        let backend = OpenJmlBackend::with_config(config);
        assert_eq!(backend.config.timeout, Duration::from_secs(45));
        assert!(matches!(backend.config.mode, OpenJmlMode::Rac));
        assert_eq!(backend.config.solver, "cvc5");
        assert_eq!(backend.config.solver_timeout, 15);
        assert!(backend.config.openjml_path.is_some());
    }

    // ===== ID and supports =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = OpenJmlBackend::new();
        assert!(matches!(backend.id(), BackendId::OpenJML));
    }

    #[kani::proof]
    fn verify_supports_contract_and_invariant() {
        let backend = OpenJmlBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Contract));
        assert!(supported.contains(&PropertyType::Invariant));
        assert_eq!(supported.len(), 2);
    }

    // ===== Java generation =====

    #[kani::proof]
    fn verify_generate_java_code_includes_properties() {
        let backend = OpenJmlBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant safe_state { true }").unwrap(),
        )
        .unwrap();
        let code = backend.generate_java_code(&spec);
        assert!(code.contains("class Verify"));
        assert!(code.contains("Property: safe_state"));
        assert!(code.contains("requires state >= 0;"));
        assert!(code.contains("ensures state >= 0;"));
    }

    #[kani::proof]
    fn verify_generate_java_code_empty_spec_has_invariant() {
        let backend = OpenJmlBackend::new();
        let spec =
            dashprove_usl::typecheck::typecheck(dashprove_usl::parse("spec empty {}").unwrap())
                .unwrap();
        let code = backend.generate_java_code(&spec);
        assert!(code.contains("public invariant state >= 0"));
    }

    // ===== Output parsing =====

    #[kani::proof]
    fn verify_parse_output_verified_status() {
        let backend = OpenJmlBackend::new();
        let (status, cex, diag) = backend.parse_output("OpenJML verification\n0 errors", "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
        assert!(diag.iter().all(|d| !d.is_empty()));
    }

    #[kani::proof]
    fn verify_parse_output_failure_builds_counterexample() {
        let backend = OpenJmlBackend::new();
        let stdout = "Verify.java:15: error: assertion is false\nstate = -1\n1 error";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let counterexample = cex.expect("expected counterexample");
        assert!(!counterexample.failed_checks.is_empty());
        assert!(counterexample.witness.contains_key("state"));
    }

    #[kani::proof]
    fn verify_parse_output_unknown_on_timeout() {
        let backend = OpenJmlBackend::new();
        let (status, cex, _) = backend.parse_output("Solver timeout reached", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
        assert!(cex.is_none());
    }

    // ===== Counterexample extraction =====

    #[kani::proof]
    fn verify_extract_counterexample_records_locations() {
        let backend = OpenJmlBackend::new();
        let output = "Verify.java:20: error: postcondition is false\nresult = 5";
        let cex = backend
            .extract_counterexample(output)
            .expect("expected counterexample");
        assert!(!cex.failed_checks.is_empty());
        let loc = cex.failed_checks[0].location.as_ref().unwrap();
        assert_eq!(loc.file, "Verify.java");
        assert_eq!(loc.line, 20);
        assert!(cex.witness.contains_key("result"));
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};
    use std::collections::HashMap;

    #[test]
    fn backend_id() {
        assert_eq!(OpenJmlBackend::new().id(), BackendId::OpenJML);
    }

    #[test]
    fn supports_contracts_and_invariants() {
        let backend = OpenJmlBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Contract));
        assert!(supported.contains(&PropertyType::Invariant));
    }

    #[test]
    fn java_generation_includes_jml() {
        let backend = OpenJmlBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "bounds_check".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_java_code(&spec);
        assert!(code.contains("bounds_check"));
        assert!(code.contains("//@ public invariant"));
        assert!(code.contains("requires"));
        assert!(code.contains("ensures"));
        assert!(code.contains("assignable"));
    }

    #[test]
    fn parse_output_verified() {
        let backend = OpenJmlBackend::new();
        let stdout = "OpenJML verification\n0 errors";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_output_assertion_false() {
        let backend = OpenJmlBackend::new();
        let stdout = "Verify.java:15: error: assertion is false\n1 error";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        assert!(!ce.failed_checks.is_empty());
        assert!(ce.failed_checks[0]
            .description
            .contains("assertion is false"));
    }

    #[test]
    fn parse_output_postcondition_false() {
        let backend = OpenJmlBackend::new();
        let stdout = "Verify.java:20: error: postcondition is false\n1 error";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        let check = &ce.failed_checks[0];
        assert!(check.description.contains("postcondition"));
        let loc = check.location.as_ref().unwrap();
        assert_eq!(loc.file, "Verify.java");
        assert_eq!(loc.line, 20);
    }

    #[test]
    fn parse_output_timeout() {
        let backend = OpenJmlBackend::new();
        let stdout = "Solver timeout reached";
        let (status, _, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[test]
    fn openjml_mode_default() {
        let config = OpenJmlConfig::default();
        assert_eq!(config.mode, OpenJmlMode::Esc);
    }

    #[test]
    fn extract_counterexample_with_values() {
        let backend = OpenJmlBackend::new();
        let output = "Verify.java:15: error: assertion is false\nstate = -1\nresult = 42";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex.witness.contains_key("state"));
        assert!(cex.witness.contains_key("result"));
    }
}
