//! ProVerif backend for cryptographic protocol verification
//!
//! ProVerif is an automatic cryptographic protocol verifier using the
//! applied pi-calculus and Horn clause resolution.
//!
//! See: <https://bblanche.gitlabpages.inria.fr/proverif/>
//!
//! # USL to ProVerif Compilation
//!
//! This backend compiles USL security properties to ProVerif models:
//!
//! - `forall x: T . P(x)` → `query attacker(x)` for confidentiality
//! - `not knows(agent, secret)` → `query attacker(secret)`
//! - `authorized(a, r) implies modified(a, r)` → integrity events and queries
//! - Types are compiled to ProVerif type declarations
//! - Functions referenced in properties become ProVerif function symbols

use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::ast::{ComparisonOp, Expr, Property, Type};
use dashprove_usl::typecheck::TypedSpec;
use std::collections::HashSet;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for ProVerif backend
#[derive(Debug, Clone)]
pub struct ProverifConfig {
    /// Path to proverif binary
    pub proverif_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
}

impl Default for ProverifConfig {
    fn default() -> Self {
        Self {
            proverif_path: None,
            timeout: Duration::from_secs(300),
        }
    }
}

/// ProVerif cryptographic protocol verification backend
pub struct ProverifBackend {
    config: ProverifConfig,
}

impl Default for ProverifBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl ProverifBackend {
    pub fn new() -> Self {
        Self {
            config: ProverifConfig::default(),
        }
    }

    pub fn with_config(config: ProverifConfig) -> Self {
        Self { config }
    }

    async fn detect_proverif(&self) -> Result<PathBuf, String> {
        let proverif_path = self
            .config
            .proverif_path
            .clone()
            .or_else(|| which::which("proverif").ok())
            .ok_or(
                "ProVerif not found. Install from https://bblanche.gitlabpages.inria.fr/proverif/",
            )?;

        let output = Command::new(&proverif_path)
            .arg("-help")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(|e| format!("Failed to execute proverif: {}", e))?;

        // ProVerif outputs help to stderr
        if output.status.success() || !output.stderr.is_empty() {
            debug!("ProVerif is available");
            Ok(proverif_path)
        } else {
            Err("proverif -help failed".to_string())
        }
    }

    /// Generate ProVerif model from USL spec
    ///
    /// Compiles USL types, functions, and security properties to ProVerif syntax.
    fn generate_model(&self, spec: &TypedSpec) -> String {
        let mut model = String::new();
        model.push_str("(* Generated by DashProve *)\n\n");

        // Collect all referenced types and functions from properties
        let mut types_used: HashSet<String> = HashSet::new();
        let mut functions_used: HashSet<String> = HashSet::new();
        let mut secrets: HashSet<String> = HashSet::new();
        let mut integrity_predicates: Vec<(String, String)> = Vec::new(); // (subject, object)

        for property in &spec.spec.properties {
            if let Property::Security(sec) = property {
                self.collect_from_expr(&sec.body, &mut types_used, &mut functions_used);
                self.extract_security_patterns(&sec.body, &mut secrets, &mut integrity_predicates);
            }
        }

        // Compile types from spec
        model.push_str("(* Types *)\n");
        for typedef in &spec.spec.types {
            model.push_str(&format!(
                "type {}.\n",
                self.to_proverif_ident(&typedef.name)
            ));
        }

        // Add standard types used by security properties
        if types_used.contains("Agent") && !spec.spec.types.iter().any(|t| t.name == "Agent") {
            model.push_str("type agent.\n");
        }
        if types_used.contains("Secret") && !spec.spec.types.iter().any(|t| t.name == "Secret") {
            model.push_str("type secret.\n");
        }

        // Standard cryptographic types
        model.push_str("type key.\n");
        model.push_str("type nonce.\n");
        model.push_str("type bitstring.\n\n");

        // Standard cryptographic functions
        model.push_str("(* Cryptographic primitives *)\n");
        model.push_str("fun senc(bitstring, key): bitstring.\n");
        model.push_str("reduc forall m: bitstring, k: key; sdec(senc(m, k), k) = m.\n\n");
        model.push_str("fun aenc(bitstring, key): bitstring.\n");
        model.push_str("fun pk(key): key.\n");
        model.push_str("reduc forall m: bitstring, k: key; adec(aenc(m, pk(k)), k) = m.\n\n");
        model.push_str("fun sign(bitstring, key): bitstring.\n");
        model.push_str("reduc forall m: bitstring, k: key; verify(sign(m, k), pk(k)) = m.\n\n");
        model.push_str("fun hash(bitstring): bitstring.\n\n");

        // Compile referenced functions as constructors/predicates
        model.push_str("(* Functions from USL spec *)\n");
        for func in &functions_used {
            // Skip standard crypto functions
            if ![
                "senc", "sdec", "aenc", "adec", "sign", "verify", "hash", "pk",
            ]
            .contains(&func.as_str())
            {
                model.push_str(&format!(
                    "fun {}(bitstring): bitstring.\n",
                    self.to_proverif_ident(func)
                ));
            }
        }
        model.push('\n');

        // Channels and secrets
        model.push_str("(* Channels *)\n");
        model.push_str("free c: channel.\n\n");

        model.push_str("(* Secret values to protect *)\n");
        if secrets.is_empty() {
            // Default secret for generic security properties
            model.push_str("free secret_data: bitstring [private].\n");
        } else {
            for secret in &secrets {
                model.push_str(&format!(
                    "free {}: bitstring [private].\n",
                    self.to_proverif_ident(secret)
                ));
            }
        }
        model.push('\n');

        // Events for integrity properties
        if !integrity_predicates.is_empty() {
            model.push_str("(* Events for integrity verification *)\n");
            model.push_str("event authorized(bitstring, bitstring).\n");
            model.push_str("event modified(bitstring, bitstring).\n");
            model.push_str("event performed(bitstring, bitstring).\n");
            model.push_str("event authenticated(bitstring).\n\n");
        }

        // Generate queries from security properties
        model.push_str("(* Security queries from USL properties *)\n");
        for property in &spec.spec.properties {
            if let Property::Security(sec) = property {
                model.push_str(&format!("(* Property: {} *)\n", sec.name));
                let queries = self.compile_security_query(&sec.body, &sec.name);
                for query in queries {
                    model.push_str(&query);
                    model.push('\n');
                }
            }
        }
        model.push('\n');

        // Generate processes
        model.push_str("(* Protocol processes *)\n");
        let process = self.generate_process(spec, &secrets, &integrity_predicates);
        model.push_str(&process);

        model
    }

    /// Convert USL identifier to valid ProVerif identifier (lowercase)
    fn to_proverif_ident(&self, name: &str) -> String {
        name.chars()
            .enumerate()
            .map(|(i, c)| {
                if i == 0 {
                    c.to_lowercase().next().unwrap_or(c)
                } else {
                    c
                }
            })
            .collect()
    }

    /// Collect types and functions referenced in an expression
    fn collect_from_expr(
        &self,
        expr: &Expr,
        types: &mut HashSet<String>,
        functions: &mut HashSet<String>,
    ) {
        match expr {
            Expr::ForAll { ty, body, .. } | Expr::Exists { ty, body, .. } => {
                if let Some(t) = ty {
                    self.collect_type(t, types);
                }
                self.collect_from_expr(body, types, functions);
            }
            Expr::ForAllIn {
                collection, body, ..
            }
            | Expr::ExistsIn {
                collection, body, ..
            } => {
                self.collect_from_expr(collection, types, functions);
                self.collect_from_expr(body, types, functions);
            }
            Expr::App(name, args) => {
                functions.insert(name.clone());
                for arg in args {
                    self.collect_from_expr(arg, types, functions);
                }
            }
            Expr::MethodCall { receiver, args, .. } => {
                self.collect_from_expr(receiver, types, functions);
                for arg in args {
                    self.collect_from_expr(arg, types, functions);
                }
            }
            Expr::Not(inner) | Expr::Neg(inner) => self.collect_from_expr(inner, types, functions),
            Expr::And(left, right)
            | Expr::Or(left, right)
            | Expr::Implies(left, right)
            | Expr::Compare(left, _, right)
            | Expr::Binary(left, _, right) => {
                self.collect_from_expr(left, types, functions);
                self.collect_from_expr(right, types, functions);
            }
            Expr::FieldAccess(object, _) => {
                self.collect_from_expr(object, types, functions);
            }
            _ => {}
        }
    }

    /// Collect type names from a type annotation
    #[allow(clippy::only_used_in_recursion)]
    fn collect_type(&self, ty: &Type, types: &mut HashSet<String>) {
        match ty {
            Type::Named(name) => {
                types.insert(name.clone());
            }
            Type::Set(inner) | Type::List(inner) | Type::Result(inner) => {
                self.collect_type(inner, types);
            }
            Type::Map(k, v) | Type::Relation(k, v) | Type::Function(k, v) => {
                self.collect_type(k, types);
                self.collect_type(v, types);
            }
            Type::Graph(n, e) => {
                self.collect_type(n, types);
                self.collect_type(e, types);
            }
            Type::Path(n) => {
                self.collect_type(n, types);
            }
            Type::Unit => {}
        }
    }

    /// Extract security-relevant patterns from expression
    ///
    /// Identifies:
    /// - Secrets that should not be leaked (from `not knows(_, x)` patterns)
    /// - Integrity predicates (from `authorized implies modified` patterns)
    fn extract_security_patterns(
        &self,
        expr: &Expr,
        secrets: &mut HashSet<String>,
        integrity: &mut Vec<(String, String)>,
    ) {
        match expr {
            // `not knows(agent, secret)` → secret should be protected
            Expr::Not(inner) => {
                if let Expr::App(name, args) = inner.as_ref() {
                    if name == "knows" && args.len() == 2 {
                        if let Expr::Var(secret_name) = &args[1] {
                            secrets.insert(secret_name.clone());
                        } else if let Expr::FieldAccess(_, field) = &args[1] {
                            secrets.insert(field.clone());
                        }
                    }
                }
                self.extract_security_patterns(inner, secrets, integrity);
            }
            // `authorized(a, r) implies modified(a, r)` → integrity
            Expr::Implies(left, right) => {
                if let (Expr::App(left_name, left_args), Expr::App(right_name, _right_args)) =
                    (left.as_ref(), right.as_ref())
                {
                    if (left_name == "authorized" || left_name == "authenticated")
                        && (right_name == "modified" || right_name == "performed")
                    {
                        let subject = left_args
                            .first()
                            .map(|a| self.expr_to_string(a))
                            .unwrap_or_default();
                        let object = left_args
                            .get(1)
                            .map(|a| self.expr_to_string(a))
                            .unwrap_or_default();
                        integrity.push((subject, object));
                    }
                }
                self.extract_security_patterns(left, secrets, integrity);
                self.extract_security_patterns(right, secrets, integrity);
            }
            Expr::ForAll { body, .. }
            | Expr::Exists { body, .. }
            | Expr::ForAllIn { body, .. }
            | Expr::ExistsIn { body, .. } => {
                self.extract_security_patterns(body, secrets, integrity);
            }
            Expr::And(left, right) | Expr::Or(left, right) => {
                self.extract_security_patterns(left, secrets, integrity);
                self.extract_security_patterns(right, secrets, integrity);
            }
            _ => {}
        }
    }

    /// Convert expression to simple string for variable naming
    #[allow(clippy::only_used_in_recursion)]
    fn expr_to_string(&self, expr: &Expr) -> String {
        match expr {
            Expr::Var(name) => name.clone(),
            Expr::FieldAccess(object, field) => {
                format!("{}_{}", self.expr_to_string(object), field)
            }
            _ => "x".to_string(),
        }
    }

    /// Compile a security property body to ProVerif queries
    fn compile_security_query(&self, expr: &Expr, prop_name: &str) -> Vec<String> {
        let mut queries = Vec::new();

        match expr {
            // Universal quantifier → check attacker cannot learn secrets
            Expr::ForAll { body, .. } => {
                queries.extend(self.compile_security_query(body, prop_name));
            }
            // `not knows(agent, secret)` → query attacker(secret)
            Expr::Not(inner) => {
                if let Expr::App(name, args) = inner.as_ref() {
                    if name == "knows" && args.len() == 2 {
                        let secret = self.compile_query_term(&args[1]);
                        queries.push(format!("query attacker({}).", secret));
                    } else if name == "can_observe" {
                        // `not can_observe(t1, actions(t2))` → query for observation
                        queries.push(format!("(* {} prevents observation *)", prop_name));
                        queries.push("query attacker(secret_data).".to_string());
                    }
                } else {
                    queries.extend(self.compile_security_query(inner, prop_name));
                }
            }
            // Implication patterns for integrity/authentication
            Expr::Implies(left, right) => {
                // `modified(a, r) implies authorized(a, r)` → correspondence
                if let Expr::App(right_name, _right_args) = right.as_ref() {
                    if right_name == "authorized" || right_name == "authenticated" {
                        if let Expr::App(left_name, left_args) = left.as_ref() {
                            if left_name == "modified" || left_name == "performed" {
                                let subject = self.compile_query_term(
                                    left_args.first().unwrap_or(&Expr::Var("x".to_string())),
                                );
                                let object = if left_args.len() > 1 {
                                    self.compile_query_term(&left_args[1])
                                } else {
                                    "action".to_string()
                                };
                                queries.push(format!(
                                    "query x: bitstring, y: bitstring; event({}({}, {})) ==> event({}({}, {})).",
                                    left_name, subject, object, right_name, subject, object
                                ));
                            }
                        }
                    }
                }
                // Also check the reversed implication pattern
                if let Expr::App(left_name, _left_args) = left.as_ref() {
                    if left_name == "authorized" || left_name == "authenticated" {
                        if let Expr::App(right_name, _) = right.as_ref() {
                            if right_name == "modified" || right_name == "performed" {
                                // This is authorization implies can modify - check reverse
                                queries.push(format!(
                                    "query x: bitstring; event({}(x)) ==> event(authenticated(x)).",
                                    right_name
                                ));
                            }
                        }
                    }
                }
            }
            // Equality for non-interference
            Expr::Compare(left, op, right) => {
                if matches!(op, ComparisonOp::Eq) {
                    if let (Expr::App(l_name, _), Expr::App(r_name, _)) =
                        (left.as_ref(), right.as_ref())
                    {
                        if l_name == "output" && r_name == "output" {
                            queries.push(format!(
                                "(* {} - non-interference: outputs equivalent *)",
                                prop_name
                            ));
                            queries.push("query attacker(secret_data).".to_string());
                        }
                    }
                }
            }
            Expr::And(left, right) => {
                queries.extend(self.compile_security_query(left, prop_name));
                queries.extend(self.compile_security_query(right, prop_name));
            }
            _ => {
                // Default: generic secrecy query
                if queries.is_empty() {
                    queries.push("query attacker(secret_data).".to_string());
                }
            }
        }

        // Ensure at least one query
        if queries.is_empty() {
            queries.push("query attacker(secret_data).".to_string());
        }

        queries
    }

    /// Compile an expression to a ProVerif term for use in queries
    fn compile_query_term(&self, expr: &Expr) -> String {
        match expr {
            Expr::Var(name) => self.to_proverif_ident(name),
            Expr::FieldAccess(object, field) => {
                format!("{}_{}", self.compile_query_term(object), field)
            }
            Expr::App(name, args) => {
                if args.is_empty() {
                    self.to_proverif_ident(name)
                } else {
                    let args_str: Vec<String> =
                        args.iter().map(|a| self.compile_query_term(a)).collect();
                    format!("{}({})", self.to_proverif_ident(name), args_str.join(", "))
                }
            }
            _ => "secret_data".to_string(),
        }
    }

    /// Generate ProVerif processes based on the security properties
    fn generate_process(
        &self,
        spec: &TypedSpec,
        secrets: &HashSet<String>,
        _integrity: &[(String, String)],
    ) -> String {
        let mut proc = String::new();

        // Generate a process that models the protocol behavior
        // The process protects secrets and emits events for integrity

        proc.push_str("let Principal(sk: key) =\n");
        proc.push_str("  (* Generate fresh nonce for session *)\n");
        proc.push_str("  new n: nonce;\n");
        proc.push_str("  (* Authenticate and establish session *)\n");
        proc.push_str("  let msg = (n, pk(sk)) in\n");
        proc.push_str("  out(c, sign(msg, sk));\n");

        // If we have secrets, protect them
        if !secrets.is_empty() {
            proc.push_str("  (* Protect secret data *)\n");
            for secret in secrets {
                proc.push_str(&format!(
                    "  new session_key: key; out(c, senc({}, session_key));\n",
                    self.to_proverif_ident(secret)
                ));
            }
        } else {
            proc.push_str("  (* Protect generic secret *)\n");
            proc.push_str("  new session_key: key; out(c, senc(secret_data, session_key));\n");
        }

        // If we have integrity predicates, emit events
        if !_integrity.is_empty() {
            proc.push_str("  (* Integrity events *)\n");
            proc.push_str("  event authenticated(msg);\n");
        }

        proc.push_str("  0.\n\n");

        // Main process
        proc.push_str("process\n");
        proc.push_str("  (* Security verification process *)\n");
        proc.push_str("  new sk: key;  (* Long-term secret key *)\n");
        proc.push_str("  out(c, pk(sk));  (* Publish public key *)\n");

        // Run multiple instances for unbounded verification
        let num_properties = spec
            .spec
            .properties
            .iter()
            .filter(|p| matches!(p, Property::Security(_)))
            .count();

        if num_properties > 0 {
            proc.push_str(&format!(
                "  (!Principal(sk))  (* Unbounded principals for {} properties *)\n",
                num_properties
            ));
        } else {
            proc.push_str("  (!Principal(sk))\n");
        }

        proc
    }

    fn parse_output(&self, stdout: &str, stderr: &str) -> VerificationStatus {
        let combined = format!("{}\n{}", stdout, stderr);

        if combined.contains("RESULT not attacker") && combined.contains("true") {
            VerificationStatus::Proven
        } else if combined.contains("RESULT not attacker") && combined.contains("false") {
            VerificationStatus::Disproven
        } else if combined.contains("cannot be proved") {
            VerificationStatus::Unknown {
                reason: "ProVerif could not prove the property".to_string(),
            }
        } else if combined.contains("Error") || combined.contains("Syntax error") {
            VerificationStatus::Unknown {
                reason: "ProVerif encountered an error".to_string(),
            }
        } else {
            VerificationStatus::Unknown {
                reason: "Could not parse ProVerif output".to_string(),
            }
        }
    }
}

#[async_trait]
impl VerificationBackend for ProverifBackend {
    fn id(&self) -> BackendId {
        BackendId::ProVerif
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::SecurityProtocol]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();

        let proverif_path = self
            .detect_proverif()
            .await
            .map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {}", e))
        })?;

        let model = self.generate_model(spec);
        let model_path = temp_dir.path().join("model.pv");
        std::fs::write(&model_path, &model).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write model: {}", e))
        })?;

        let mut cmd = Command::new(&proverif_path);
        cmd.arg(&model_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        let result = tokio::time::timeout(self.config.timeout, cmd.output()).await;
        let duration = start.elapsed();

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout).to_string();
                let stderr = String::from_utf8_lossy(&output.stderr).to_string();

                debug!("ProVerif stdout: {}", stdout);
                let status = self.parse_output(&stdout, &stderr);

                Ok(BackendResult {
                    backend: BackendId::ProVerif,
                    status,
                    proof: None,
                    counterexample: None,
                    diagnostics: vec![],
                    time_taken: duration,
                })
            }
            Ok(Err(e)) => Err(BackendError::VerificationFailed(format!(
                "Failed to execute ProVerif: {}",
                e
            ))),
            Err(_) => Err(BackendError::Timeout(self.config.timeout)),
        }
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_proverif().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== ProverifConfig defaults =====

    #[kani::proof]
    fn verify_config_defaults_timeout() {
        let config = ProverifConfig::default();
        assert!(config.timeout == Duration::from_secs(300));
    }

    #[kani::proof]
    fn verify_config_defaults_path() {
        let config = ProverifConfig::default();
        assert!(config.proverif_path.is_none());
    }

    // ===== Backend construction =====

    #[kani::proof]
    fn verify_backend_new_uses_defaults() {
        let backend = ProverifBackend::new();
        assert!(backend.config.timeout == Duration::from_secs(300));
        assert!(backend.config.proverif_path.is_none());
    }

    #[kani::proof]
    fn verify_backend_default_matches_new() {
        let b1 = ProverifBackend::new();
        let b2 = ProverifBackend::default();
        assert!(b1.config.timeout == b2.config.timeout);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_values() {
        let config = ProverifConfig {
            proverif_path: Some(PathBuf::from("/usr/bin/proverif")),
            timeout: Duration::from_secs(60),
        };
        let backend = ProverifBackend::with_config(config);
        assert!(backend.config.timeout == Duration::from_secs(60));
        assert!(backend.config.proverif_path.is_some());
    }

    // ===== ID and supports =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = ProverifBackend::new();
        assert!(matches!(backend.id(), BackendId::ProVerif));
    }

    #[kani::proof]
    fn verify_supports_security_protocol() {
        let backend = ProverifBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::SecurityProtocol));
        assert!(supported.len() == 1);
    }

    // ===== Output parsing =====

    #[kani::proof]
    fn verify_parse_output_proven() {
        let backend = ProverifBackend::new();
        let status = backend.parse_output("RESULT not attacker(secret[]) is true.\n", "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_disproven() {
        let backend = ProverifBackend::new();
        let status = backend.parse_output("RESULT not attacker(secret[]) is false.\n", "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_cannot_prove() {
        let backend = ProverifBackend::new();
        let status = backend.parse_output("cannot be proved", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[kani::proof]
    fn verify_parse_output_error() {
        let backend = ProverifBackend::new();
        let status = backend.parse_output("", "Error in input file");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[kani::proof]
    fn verify_parse_output_syntax_error() {
        let backend = ProverifBackend::new();
        let status = backend.parse_output("Syntax error at line 1", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[kani::proof]
    fn verify_parse_output_unknown() {
        let backend = ProverifBackend::new();
        let status = backend.parse_output("random output", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    // ===== Identifier conversion =====

    #[kani::proof]
    fn verify_to_proverif_ident_lowercase_first() {
        let backend = ProverifBackend::new();
        let result = backend.to_proverif_ident("Agent");
        assert!(result.starts_with('a'));
    }

    #[kani::proof]
    fn verify_to_proverif_ident_preserves_rest() {
        let backend = ProverifBackend::new();
        let result = backend.to_proverif_ident("myVar");
        assert!(result == "myVar");
    }

    #[kani::proof]
    fn verify_to_proverif_ident_empty() {
        let backend = ProverifBackend::new();
        let result = backend.to_proverif_ident("");
        assert!(result.is_empty());
    }

    // ===== Query term compilation =====

    #[kani::proof]
    fn verify_compile_query_term_var() {
        let backend = ProverifBackend::new();
        let var = Expr::Var("secret".to_string());
        let result = backend.compile_query_term(&var);
        assert!(result == "secret");
    }

    #[kani::proof]
    fn verify_compile_query_term_field_access() {
        let backend = ProverifBackend::new();
        let field = Expr::FieldAccess(Box::new(Expr::Var("s".to_string())), "content".to_string());
        let result = backend.compile_query_term(&field);
        assert!(result.contains("s_content"));
    }

    #[kani::proof]
    fn verify_compile_query_term_app_no_args() {
        let backend = ProverifBackend::new();
        let func = Expr::App("hash".to_string(), vec![]);
        let result = backend.compile_query_term(&func);
        assert!(result == "hash");
    }

    #[kani::proof]
    fn verify_compile_query_term_app_with_args() {
        let backend = ProverifBackend::new();
        let func = Expr::App("hash".to_string(), vec![Expr::Var("msg".to_string())]);
        let result = backend.compile_query_term(&func);
        assert!(result.contains("hash(msg)"));
    }

    #[kani::proof]
    fn verify_compile_query_term_default() {
        let backend = ProverifBackend::new();
        // For unknown expressions, should return default
        let result = backend.compile_query_term(&Expr::Bool(true));
        assert!(result == "secret_data");
    }

    // ===== Model generation basics =====

    #[kani::proof]
    fn verify_generate_model_contains_header() {
        let backend = ProverifBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let model = backend.generate_model(&spec);
        assert!(model.contains("Generated by DashProve"));
    }

    #[kani::proof]
    fn verify_generate_model_contains_types() {
        let backend = ProverifBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let model = backend.generate_model(&spec);
        assert!(model.contains("type key."));
        assert!(model.contains("type nonce."));
        assert!(model.contains("type bitstring."));
    }

    #[kani::proof]
    fn verify_generate_model_contains_crypto() {
        let backend = ProverifBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let model = backend.generate_model(&spec);
        assert!(model.contains("fun senc(bitstring, key): bitstring."));
        assert!(model.contains("fun aenc(bitstring, key): bitstring."));
        assert!(model.contains("fun hash(bitstring): bitstring."));
    }

    #[kani::proof]
    fn verify_generate_model_contains_channel() {
        let backend = ProverifBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let model = backend.generate_model(&spec);
        assert!(model.contains("free c: channel."));
    }

    #[kani::proof]
    fn verify_generate_model_contains_process() {
        let backend = ProverifBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let model = backend.generate_model(&spec);
        assert!(model.contains("let Principal(sk: key)"));
        assert!(model.contains("process"));
    }

    // ===== Expression to string conversion =====

    #[kani::proof]
    fn verify_expr_to_string_var() {
        let backend = ProverifBackend::new();
        let result = backend.expr_to_string(&Expr::Var("test".to_string()));
        assert!(result == "test");
    }

    #[kani::proof]
    fn verify_expr_to_string_field() {
        let backend = ProverifBackend::new();
        let result = backend.expr_to_string(&Expr::FieldAccess(
            Box::new(Expr::Var("obj".to_string())),
            "field".to_string(),
        ));
        assert!(result.contains("obj_field"));
    }

    #[kani::proof]
    fn verify_expr_to_string_default() {
        let backend = ProverifBackend::new();
        let result = backend.expr_to_string(&Expr::Bool(true));
        assert!(result == "x");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::typecheck::typecheck;
    use dashprove_usl::{parse, Spec};

    fn create_typed_spec(input: &str) -> TypedSpec {
        let spec = parse(input).expect("should parse");
        typecheck(spec).expect("should typecheck")
    }

    #[test]
    fn parse_secure_output() {
        let backend = ProverifBackend::new();
        let status = backend.parse_output("RESULT not attacker(secret[]) is true.\n", "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[test]
    fn parse_attack_output() {
        let backend = ProverifBackend::new();
        let status = backend.parse_output("RESULT not attacker(secret[]) is false.\n", "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn test_generate_model_confidentiality() {
        let input = r#"
            security confidentiality {
                forall s: Secret, a: Agent .
                    not authorized(a, s) implies not knows(a, s.content)
            }
        "#;
        let typed_spec = create_typed_spec(input);
        let backend = ProverifBackend::new();
        let model = backend.generate_model(&typed_spec);

        // Check that model contains basic structure
        assert!(model.contains("(* Generated by DashProve *)"));
        assert!(model.contains("type key."));
        assert!(model.contains("type bitstring."));

        // Check for crypto primitives
        assert!(model.contains("fun senc(bitstring, key): bitstring."));
        assert!(model.contains("fun aenc(bitstring, key): bitstring."));

        // Check that security query is generated
        assert!(model.contains("(* Property: confidentiality *)"));
        assert!(model.contains("query attacker("));

        // Check for process definition
        assert!(model.contains("let Principal(sk: key)"));
        assert!(model.contains("process"));
    }

    #[test]
    fn test_generate_model_tenant_isolation() {
        let input = r#"
            type Tenant = { id: String }

            security tenant_isolation {
                forall t1: Tenant, t2: Tenant .
                    t1.id != t2.id implies not can_observe(t1, actions(t2))
            }
        "#;
        let typed_spec = create_typed_spec(input);
        let backend = ProverifBackend::new();
        let model = backend.generate_model(&typed_spec);

        // Check that type is declared
        assert!(model.contains("type tenant."));

        // Check for observation prevention query
        assert!(model.contains("(* Property: tenant_isolation *)"));
        // The `not can_observe` is nested in an implication, so we get a generic query
        assert!(model.contains("query attacker(secret_data)."));

        // Check for functions from USL
        assert!(model.contains("fun can_observe(bitstring): bitstring."));
        assert!(model.contains("fun actions(bitstring): bitstring."));
    }

    #[test]
    fn test_generate_model_integrity() {
        let input = r#"
            security data_integrity {
                forall r: Record, a: Agent .
                    modified(a, r) implies authorized(a, r)
            }
        "#;
        let typed_spec = create_typed_spec(input);
        let backend = ProverifBackend::new();
        let model = backend.generate_model(&typed_spec);

        // Check for integrity-related output
        assert!(model.contains("(* Property: data_integrity *)"));
        assert!(model.contains("query"));
    }

    #[test]
    fn test_generate_model_authentication() {
        let input = r#"
            security authentication_required {
                forall a: Action, u: User .
                    performed(u, a) implies authenticated(u)
            }
        "#;
        let typed_spec = create_typed_spec(input);
        let backend = ProverifBackend::new();
        let model = backend.generate_model(&typed_spec);

        // Check for authentication queries
        assert!(model.contains("(* Property: authentication_required *)"));
    }

    #[test]
    fn test_generate_model_noninterference() {
        let input = r#"
            security noninterference {
                forall h1: HighInput, h2: HighInput, l: LowInput .
                    output(h1, l) == output(h2, l)
            }
        "#;
        let typed_spec = create_typed_spec(input);
        let backend = ProverifBackend::new();
        let model = backend.generate_model(&typed_spec);

        // Check for non-interference handling
        assert!(model.contains("(* Property: noninterference *)"));
        assert!(model.contains("(* noninterference - non-interference: outputs equivalent *)"));
    }

    #[test]
    fn test_generate_model_multiple_properties() {
        let input = r#"
            security prop1 {
                forall x: Int . true
            }

            security prop2 {
                forall y: Bool . true
            }
        "#;
        let typed_spec = create_typed_spec(input);
        let backend = ProverifBackend::new();
        let model = backend.generate_model(&typed_spec);

        // Check both properties are included
        assert!(model.contains("(* Property: prop1 *)"));
        assert!(model.contains("(* Property: prop2 *)"));

        // Check unbounded principals comment mentions both
        assert!(model.contains("Unbounded principals for 2 properties"));
    }

    #[test]
    fn test_to_proverif_ident() {
        let backend = ProverifBackend::new();

        // Test lowercase conversion of first character
        assert_eq!(backend.to_proverif_ident("Agent"), "agent");
        assert_eq!(backend.to_proverif_ident("Secret"), "secret");
        assert_eq!(backend.to_proverif_ident("myVar"), "myVar");
        assert_eq!(backend.to_proverif_ident("ABC"), "aBC");
    }

    #[test]
    fn test_compile_query_term() {
        let backend = ProverifBackend::new();

        // Test variable
        let var = Expr::Var("secret".to_string());
        assert_eq!(backend.compile_query_term(&var), "secret");

        // Test field access
        let field = Expr::FieldAccess(Box::new(Expr::Var("s".to_string())), "content".to_string());
        assert_eq!(backend.compile_query_term(&field), "s_content");

        // Test function application
        let func = Expr::App("hash".to_string(), vec![Expr::Var("msg".to_string())]);
        assert_eq!(backend.compile_query_term(&func), "hash(msg)");
    }

    #[test]
    fn test_extract_secrets_from_knows_pattern() {
        let backend = ProverifBackend::new();
        let mut secrets = HashSet::new();
        let mut integrity = Vec::new();

        // `not knows(agent, secretVar)` should extract secretVar
        let expr = Expr::Not(Box::new(Expr::App(
            "knows".to_string(),
            vec![
                Expr::Var("agent".to_string()),
                Expr::Var("secretVar".to_string()),
            ],
        )));

        backend.extract_security_patterns(&expr, &mut secrets, &mut integrity);
        assert!(secrets.contains("secretVar"));
    }

    #[test]
    fn test_extract_secrets_from_field_access() {
        let backend = ProverifBackend::new();
        let mut secrets = HashSet::new();
        let mut integrity = Vec::new();

        // `not knows(a, s.content)` should extract "content"
        let expr = Expr::Not(Box::new(Expr::App(
            "knows".to_string(),
            vec![
                Expr::Var("a".to_string()),
                Expr::FieldAccess(Box::new(Expr::Var("s".to_string())), "content".to_string()),
            ],
        )));

        backend.extract_security_patterns(&expr, &mut secrets, &mut integrity);
        assert!(secrets.contains("content"));
    }

    #[test]
    fn test_model_without_security_properties() {
        // Test that an empty spec still generates a valid model
        let typed_spec = TypedSpec {
            spec: Spec::default(),
            type_info: Default::default(),
        };
        let backend = ProverifBackend::new();
        let model = backend.generate_model(&typed_spec);

        // Should still have basic structure
        assert!(model.contains("(* Generated by DashProve *)"));
        assert!(model.contains("type key."));
        assert!(model.contains("process"));
    }
}
