//! Infer - Facebook static analyzer backend
//!
//! Infer is a static analysis tool developed by Facebook/Meta for finding
//! bugs in Java, C, C++, and Objective-C programs. It performs sophisticated
//! analysis including null pointer, memory leak, and concurrency bug detection.
//!
//! See: <https://fbinfer.com/>
//!
//! # Features
//!
//! - **Null pointer analysis**: NPE detection via bi-abduction
//! - **Memory leak detection**: Resource leak analysis
//! - **Thread safety**: Race condition detection (RacerD)
//! - **Impurity analysis**: Detect side effects
//! - **Pulse**: Unified memory safety checker
//!
//! # Requirements
//!
//! Install Infer:
//! ```bash
//! # macOS
//! brew install infer
//!
//! # Linux (Debian/Ubuntu via Docker)
//! docker pull fbinfer/infer
//!
//! # From binary release
//! curl -sSL "https://github.com/facebook/infer/releases/download/v1.1.0/infer-linux64-v1.1.0.tar.xz" | tar -xJ
//! ```

use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;

/// Infer analysis type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]
pub enum InferAnalysis {
    /// All checkers (default)
    #[default]
    All,
    /// Pulse - memory safety
    Pulse,
    /// Biabduction - null pointer analysis
    Biabduction,
    /// RacerD - data race detection
    RacerD,
    /// Starvation - deadlock detection
    Starvation,
    /// Liveness - dead store detection
    Liveness,
    /// Loop hoisting - invariant detection
    LoopHoisting,
}

/// Configuration for Infer backend
#[derive(Debug, Clone)]
pub struct InferConfig {
    /// Path to Infer installation
    pub infer_path: Option<PathBuf>,
    /// Timeout for analysis
    pub timeout: Duration,
    /// Analysis to run
    pub analysis: InferAnalysis,
    /// Enable debug output
    pub debug: bool,
    /// Report output format (json, text)
    pub report_format: String,
    /// Filter issues by severity (low, medium, high, critical)
    pub min_severity: Option<String>,
    /// Additional Infer options
    pub extra_options: Vec<String>,
}

impl Default for InferConfig {
    fn default() -> Self {
        Self {
            infer_path: None,
            timeout: Duration::from_secs(600),
            analysis: InferAnalysis::default(),
            debug: false,
            report_format: "json".to_string(),
            min_severity: None,
            extra_options: Vec::new(),
        }
    }
}

impl InferConfig {
    /// Set Infer installation path
    pub fn with_infer_path(mut self, path: PathBuf) -> Self {
        self.infer_path = Some(path);
        self
    }

    /// Set timeout
    pub fn with_timeout(mut self, timeout: Duration) -> Self {
        self.timeout = timeout;
        self
    }

    /// Set analysis type
    pub fn with_analysis(mut self, analysis: InferAnalysis) -> Self {
        self.analysis = analysis;
        self
    }

    /// Enable debug output
    pub fn with_debug(mut self, debug: bool) -> Self {
        self.debug = debug;
        self
    }

    /// Set minimum severity filter
    pub fn with_min_severity(mut self, severity: String) -> Self {
        self.min_severity = Some(severity);
        self
    }
}

/// Infer static analyzer backend
pub struct InferBackend {
    config: InferConfig,
}

impl InferBackend {
    /// Create a new Infer backend with default configuration
    pub fn new() -> Self {
        Self {
            config: InferConfig::default(),
        }
    }

    /// Create with custom configuration
    pub fn with_config(config: InferConfig) -> Self {
        Self { config }
    }

    /// Generate C code from USL spec
    fn generate_c_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();

        code.push_str("/* Generated by DashProve from USL spec */\n\n");
        code.push_str("#include <stdlib.h>\n");
        code.push_str("#include <string.h>\n\n");

        // Generate code that Infer can analyze
        for prop in &spec.spec.properties {
            let prop_name = prop.name();
            code.push_str(&format!("/* Property: {} */\n", prop_name));
        }

        // Generate a function that demonstrates memory safety
        code.push_str("\nvoid analyze_function() {\n");
        code.push_str("    int* ptr = (int*)malloc(sizeof(int));\n");
        code.push_str("    if (ptr != NULL) {\n");
        code.push_str("        *ptr = 42;\n");
        code.push_str("        free(ptr);\n");
        code.push_str("    }\n");
        code.push_str("}\n\n");

        code.push_str("int main() {\n");
        code.push_str("    analyze_function();\n");
        code.push_str("    return 0;\n");
        code.push_str("}\n");

        code
    }

    /// Parse Infer JSON output
    fn parse_infer_output(
        &self,
        json_output: &str,
    ) -> (VerificationStatus, Vec<String>, Vec<InferIssue>) {
        let mut issues = Vec::new();
        let mut errors = Vec::new();

        // Try to parse as JSON array of issues
        if let Ok(parsed) = serde_json::from_str::<Vec<InferIssue>>(json_output) {
            issues = parsed;
        } else {
            // Fallback: parse line by line for text format
            for line in json_output.lines() {
                if line.contains("error:") || line.contains("warning:") {
                    errors.push(line.to_string());
                }
            }
        }

        let status = if issues.is_empty() && errors.is_empty() {
            VerificationStatus::Proven
        } else {
            VerificationStatus::Disproven
        };

        (status, errors, issues)
    }

    /// Analyze a C source file
    pub async fn analyze_c_file(&self, c_path: &Path) -> Result<BackendResult, BackendError> {
        let start = Instant::now();

        let infer_cmd = self
            .config
            .infer_path
            .clone()
            .unwrap_or_else(|| PathBuf::from("infer"));

        // Create results directory
        let results_dir = c_path.parent().unwrap_or(Path::new(".")).join("infer-out");

        let mut args = Vec::new();
        args.push("run".to_string());

        // Output directory
        args.push("-o".to_string());
        args.push(results_dir.to_string_lossy().to_string());

        // Analysis type
        match self.config.analysis {
            InferAnalysis::All => {}
            InferAnalysis::Pulse => {
                args.push("--pulse-only".to_string());
            }
            InferAnalysis::Biabduction => {
                args.push("--biabduction-only".to_string());
            }
            InferAnalysis::RacerD => {
                args.push("--racerd-only".to_string());
            }
            InferAnalysis::Starvation => {
                args.push("--starvation-only".to_string());
            }
            InferAnalysis::Liveness => {
                args.push("--liveness-only".to_string());
            }
            InferAnalysis::LoopHoisting => {
                args.push("--loop-hoisting-only".to_string());
            }
        }

        if self.config.debug {
            args.push("--debug".to_string());
        }

        // Compile command
        args.push("--".to_string());
        args.push("gcc".to_string());
        args.push("-c".to_string());
        args.push(c_path.to_string_lossy().to_string());

        // Run Infer
        let mut cmd = Command::new(&infer_cmd);
        cmd.args(&args);
        cmd.current_dir(c_path.parent().unwrap_or(Path::new(".")));

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("Failed to run Infer: {}", e)))?;

        let duration = start.elapsed();

        // Read the report file
        let report_path = results_dir.join("report.json");
        let report_content = if report_path.exists() {
            std::fs::read_to_string(&report_path).unwrap_or_default()
        } else {
            String::from_utf8_lossy(&output.stdout).to_string()
        };

        let (status, errors, issues) = self.parse_infer_output(&report_content);

        let mut diagnostics = Vec::new();

        let summary = match &status {
            VerificationStatus::Proven => "Infer: No issues found".to_string(),
            VerificationStatus::Disproven => {
                format!(
                    "Infer: Found {} potential issues",
                    issues.len().max(errors.len())
                )
            }
            VerificationStatus::Unknown { reason: _ } => "Infer: Analysis inconclusive".to_string(),
            VerificationStatus::Partial {
                verified_percentage,
            } => {
                format!("Infer: Partial analysis ({:.1}%)", verified_percentage)
            }
        };
        diagnostics.push(summary);

        // Add issue descriptions
        for issue in &issues {
            diagnostics.push(format!(
                "{}: {} at {}:{}",
                issue.severity, issue.bug_type, issue.file, issue.line
            ));
        }

        for error in &errors {
            diagnostics.push(error.clone());
        }

        let counterexample = if !issues.is_empty() {
            // Convert InferIssue structs to JSON values for the helper
            let issue_values: Vec<serde_json::Value> = issues
                .iter()
                .map(|i| {
                    serde_json::json!({
                        "bug_type": i.bug_type,
                        "qualifier": i.qualifier,
                        "severity": i.severity,
                        "file": i.file,
                        "line": i.line,
                        "column": i.column,
                        "procedure": i.procedure
                    })
                })
                .collect();
            // Use the formal verification helper to build a structured counterexample
            crate::counterexample::build_static_analysis_counterexample(&issue_values, "Infer")
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::Infer,
            status,
            proof: None,
            counterexample,
            diagnostics,
            time_taken: duration,
        })
    }
}

impl Default for InferBackend {
    fn default() -> Self {
        Self::new()
    }
}

/// An issue reported by Infer
#[derive(Debug, Clone, Deserialize, Serialize)]
struct InferIssue {
    bug_type: String,
    #[serde(default)]
    qualifier: String,
    severity: String,
    #[serde(default)]
    line: usize,
    #[serde(default)]
    column: usize,
    #[serde(default)]
    file: String,
    #[serde(default)]
    procedure: String,
}

#[async_trait]
impl VerificationBackend for InferBackend {
    fn id(&self) -> BackendId {
        BackendId::Infer
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![
            PropertyType::MemorySafety,
            PropertyType::MemoryLeak,
            PropertyType::DataRace,
        ]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        // Generate C code
        let c_code = self.generate_c_code(spec);

        // Write to temp file
        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {}", e))
        })?;

        let c_path = temp_dir.path().join("spec.c");
        std::fs::write(&c_path, &c_code).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write C file: {}", e))
        })?;

        self.analyze_c_file(&c_path).await
    }

    async fn health_check(&self) -> HealthStatus {
        let infer_cmd = self
            .config
            .infer_path
            .clone()
            .unwrap_or_else(|| PathBuf::from("infer"));

        match Command::new(&infer_cmd).arg("--version").output().await {
            Ok(output) if output.status.success() => HealthStatus::Healthy,
            Ok(_) => HealthStatus::Degraded {
                reason: "Infer returned non-zero exit code".to_string(),
            },
            Err(e) => HealthStatus::Unavailable {
                reason: format!("Infer not found: {}", e),
            },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ---- InferAnalysis Default Tests ----

    /// Verify InferAnalysis default is All
    #[kani::proof]
    fn proof_infer_analysis_default_is_all() {
        let analysis = InferAnalysis::default();
        kani::assert(
            analysis == InferAnalysis::All,
            "Default InferAnalysis should be All",
        );
    }

    // ---- InferConfig Default Tests ----

    /// Verify InferConfig::default infer_path is None
    #[kani::proof]
    fn proof_infer_config_default_infer_path_none() {
        let config = InferConfig::default();
        kani::assert(
            config.infer_path.is_none(),
            "Default infer_path should be None",
        );
    }

    /// Verify InferConfig::default timeout is 600 seconds
    #[kani::proof]
    fn proof_infer_config_default_timeout() {
        let config = InferConfig::default();
        kani::assert(
            config.timeout == Duration::from_secs(600),
            "Default timeout should be 600 seconds",
        );
    }

    /// Verify InferConfig::default analysis is All
    #[kani::proof]
    fn proof_infer_config_default_analysis() {
        let config = InferConfig::default();
        kani::assert(
            config.analysis == InferAnalysis::All,
            "Default analysis should be All",
        );
    }

    /// Verify InferConfig::default debug is false
    #[kani::proof]
    fn proof_infer_config_default_debug() {
        let config = InferConfig::default();
        kani::assert(!config.debug, "Default debug should be false");
    }

    /// Verify InferConfig::default report_format is json
    #[kani::proof]
    fn proof_infer_config_default_report_format() {
        let config = InferConfig::default();
        kani::assert(
            config.report_format == "json",
            "Default report_format should be json",
        );
    }

    /// Verify InferConfig::default min_severity is None
    #[kani::proof]
    fn proof_infer_config_default_min_severity_none() {
        let config = InferConfig::default();
        kani::assert(
            config.min_severity.is_none(),
            "Default min_severity should be None",
        );
    }

    /// Verify InferConfig::default extra_options is empty
    #[kani::proof]
    fn proof_infer_config_default_extra_options_empty() {
        let config = InferConfig::default();
        kani::assert(
            config.extra_options.is_empty(),
            "Default extra_options should be empty",
        );
    }

    // ---- InferConfig Builder Tests ----

    /// Verify with_infer_path sets infer_path
    #[kani::proof]
    fn proof_infer_config_with_infer_path() {
        let config = InferConfig::default().with_infer_path(PathBuf::from("/usr/bin/infer"));
        kani::assert(
            config.infer_path.is_some(),
            "with_infer_path should set Some",
        );
    }

    /// Verify with_timeout sets timeout
    #[kani::proof]
    fn proof_infer_config_with_timeout() {
        let config = InferConfig::default().with_timeout(Duration::from_secs(300));
        kani::assert(
            config.timeout == Duration::from_secs(300),
            "with_timeout should set 300 seconds",
        );
    }

    /// Verify with_analysis sets analysis to Pulse
    #[kani::proof]
    fn proof_infer_config_with_analysis_pulse() {
        let config = InferConfig::default().with_analysis(InferAnalysis::Pulse);
        kani::assert(
            config.analysis == InferAnalysis::Pulse,
            "with_analysis should set Pulse",
        );
    }

    /// Verify with_analysis sets analysis to Biabduction
    #[kani::proof]
    fn proof_infer_config_with_analysis_biabduction() {
        let config = InferConfig::default().with_analysis(InferAnalysis::Biabduction);
        kani::assert(
            config.analysis == InferAnalysis::Biabduction,
            "with_analysis should set Biabduction",
        );
    }

    /// Verify with_analysis sets analysis to RacerD
    #[kani::proof]
    fn proof_infer_config_with_analysis_racerd() {
        let config = InferConfig::default().with_analysis(InferAnalysis::RacerD);
        kani::assert(
            config.analysis == InferAnalysis::RacerD,
            "with_analysis should set RacerD",
        );
    }

    /// Verify with_debug sets debug
    #[kani::proof]
    fn proof_infer_config_with_debug() {
        let config = InferConfig::default().with_debug(true);
        kani::assert(config.debug, "with_debug should set true");
    }

    /// Verify with_min_severity sets min_severity
    #[kani::proof]
    fn proof_infer_config_with_min_severity() {
        let config = InferConfig::default().with_min_severity("high".to_string());
        kani::assert(
            config.min_severity.is_some(),
            "with_min_severity should set Some",
        );
    }

    /// Verify builder chain preserves earlier values
    #[kani::proof]
    fn proof_infer_config_builder_chain() {
        let config = InferConfig::default()
            .with_timeout(Duration::from_secs(120))
            .with_analysis(InferAnalysis::Starvation)
            .with_debug(true);
        kani::assert(
            config.timeout == Duration::from_secs(120),
            "Builder chain should preserve timeout",
        );
        kani::assert(
            config.analysis == InferAnalysis::Starvation,
            "Builder chain should preserve analysis",
        );
        kani::assert(config.debug, "Builder chain should preserve debug");
    }

    // ---- InferBackend Construction Tests ----

    /// Verify InferBackend::new creates default config
    #[kani::proof]
    fn proof_infer_backend_new_default() {
        let backend = InferBackend::new();
        kani::assert(
            backend.config.infer_path.is_none(),
            "New backend should have None infer_path",
        );
        kani::assert(!backend.config.debug, "New backend should have debug false");
    }

    /// Verify InferBackend::default equals ::new
    #[kani::proof]
    fn proof_infer_backend_default_equals_new() {
        let default_backend = InferBackend::default();
        let new_backend = InferBackend::new();
        kani::assert(
            default_backend.config.timeout == new_backend.config.timeout,
            "Default and new should have same timeout",
        );
        kani::assert(
            default_backend.config.analysis == new_backend.config.analysis,
            "Default and new should have same analysis",
        );
    }

    /// Verify InferBackend::with_config stores config
    #[kani::proof]
    fn proof_infer_backend_with_config() {
        let config = InferConfig {
            infer_path: None,
            timeout: Duration::from_secs(180),
            analysis: InferAnalysis::Liveness,
            debug: true,
            report_format: "text".to_string(),
            min_severity: Some("medium".to_string()),
            extra_options: Vec::new(),
        };
        let backend = InferBackend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(180),
            "with_config should store timeout",
        );
        kani::assert(
            backend.config.analysis == InferAnalysis::Liveness,
            "with_config should store analysis",
        );
        kani::assert(backend.config.debug, "with_config should store debug");
    }

    // ---- Backend Trait Tests ----

    /// Verify InferBackend::id returns BackendId::Infer
    #[kani::proof]
    fn proof_infer_backend_id() {
        let backend = InferBackend::new();
        kani::assert(
            backend.id() == BackendId::Infer,
            "Backend ID should be Infer",
        );
    }

    /// Verify InferBackend::supports includes MemorySafety
    #[kani::proof]
    fn proof_infer_supports_memory_safety() {
        let backend = InferBackend::new();
        let supported = backend.supports();
        let has_memory_safety = supported.iter().any(|p| *p == PropertyType::MemorySafety);
        kani::assert(has_memory_safety, "Should support MemorySafety");
    }

    /// Verify InferBackend::supports includes MemoryLeak
    #[kani::proof]
    fn proof_infer_supports_memory_leak() {
        let backend = InferBackend::new();
        let supported = backend.supports();
        let has_memory_leak = supported.iter().any(|p| *p == PropertyType::MemoryLeak);
        kani::assert(has_memory_leak, "Should support MemoryLeak");
    }

    /// Verify InferBackend::supports includes DataRace
    #[kani::proof]
    fn proof_infer_supports_data_race() {
        let backend = InferBackend::new();
        let supported = backend.supports();
        let has_data_race = supported.iter().any(|p| *p == PropertyType::DataRace);
        kani::assert(has_data_race, "Should support DataRace");
    }

    /// Verify supports returns exactly 3 property types
    #[kani::proof]
    fn proof_infer_supports_length() {
        let backend = InferBackend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 3,
            "Should support exactly 3 property types",
        );
    }

    // ---- Output Parsing Tests ----

    /// Verify parse_infer_output returns Proven for empty JSON array
    #[kani::proof]
    fn proof_parse_infer_output_empty() {
        let backend = InferBackend::new();
        let (status, errors, issues) = backend.parse_infer_output("[]");
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should be Proven for empty array",
        );
        kani::assert(errors.is_empty(), "Errors should be empty");
        kani::assert(issues.is_empty(), "Issues should be empty");
    }

    /// Verify parse_infer_output returns Disproven for text errors
    #[kani::proof]
    fn proof_parse_infer_output_text_errors() {
        let backend = InferBackend::new();
        let (status, errors, _) =
            backend.parse_infer_output("error: something bad\nwarning: caution");
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should be Disproven for errors",
        );
        kani::assert(!errors.is_empty(), "Should have errors");
    }

    // ---- InferAnalysis Variants Tests ----

    /// Verify all InferAnalysis variants are distinct
    #[kani::proof]
    fn proof_infer_analysis_variants_distinct() {
        let all = InferAnalysis::All;
        let pulse = InferAnalysis::Pulse;
        let biabduction = InferAnalysis::Biabduction;
        let racerd = InferAnalysis::RacerD;
        let starvation = InferAnalysis::Starvation;
        let liveness = InferAnalysis::Liveness;
        let loop_hoisting = InferAnalysis::LoopHoisting;

        kani::assert(all != pulse, "All should not equal Pulse");
        kani::assert(pulse != biabduction, "Pulse should not equal Biabduction");
        kani::assert(biabduction != racerd, "Biabduction should not equal RacerD");
        kani::assert(racerd != starvation, "RacerD should not equal Starvation");
        kani::assert(
            starvation != liveness,
            "Starvation should not equal Liveness",
        );
        kani::assert(
            liveness != loop_hoisting,
            "Liveness should not equal LoopHoisting",
        );
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_infer_config_defaults() {
        let config = InferConfig::default();
        assert_eq!(config.timeout, Duration::from_secs(600));
        assert_eq!(config.analysis, InferAnalysis::All);
        assert!(!config.debug);
    }

    #[test]
    fn test_infer_config_builder() {
        let config = InferConfig::default()
            .with_timeout(Duration::from_secs(300))
            .with_analysis(InferAnalysis::Pulse)
            .with_debug(true);

        assert_eq!(config.timeout, Duration::from_secs(300));
        assert_eq!(config.analysis, InferAnalysis::Pulse);
        assert!(config.debug);
    }

    #[test]
    fn test_parse_infer_output_empty() {
        let backend = InferBackend::new();
        let (status, errors, issues) = backend.parse_infer_output("[]");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(errors.is_empty());
        assert!(issues.is_empty());
    }

    #[test]
    fn test_parse_infer_output_with_issues() {
        let backend = InferBackend::new();
        let json = r#"[
            {"bug_type": "NULL_DEREFERENCE", "qualifier": "pointer `p` may be null", "severity": "ERROR", "line": 10, "file": "test.c", "procedure": "main"}
        ]"#;

        let (status, _errors, issues) = backend.parse_infer_output(json);
        assert!(matches!(status, VerificationStatus::Disproven));
        assert_eq!(issues.len(), 1);
        assert_eq!(issues[0].bug_type, "NULL_DEREFERENCE");
    }

    #[test]
    fn test_generate_c_code() {
        use dashprove_usl::parse;
        use dashprove_usl::typecheck::typecheck;

        let spec = parse("invariant test { true }").unwrap();
        let typed = typecheck(spec).unwrap();

        let backend = InferBackend::new();
        let c_code = backend.generate_c_code(&typed);

        assert!(c_code.contains("Generated by DashProve"));
        assert!(c_code.contains("malloc"));
        assert!(c_code.contains("free"));
    }

    #[tokio::test]
    async fn test_health_check_unavailable() {
        let config = InferConfig::default().with_infer_path(PathBuf::from("/nonexistent/infer"));
        let backend = InferBackend::with_config(config);

        let health = backend.health_check().await;
        assert!(matches!(health, HealthStatus::Unavailable { .. }));
    }

    #[test]
    fn test_backend_id() {
        let backend = InferBackend::new();
        assert_eq!(backend.id(), BackendId::Infer);
    }
}
