//! JasperGold formal verification backend
//!
//! JasperGold is a commercial formal verification tool from Cadence
//! for hardware verification. It supports assertion-based verification,
//! property checking, and sequential equivalence checking.
//!
//! See: <https://www.cadence.com/en_US/home/tools/system-design-and-verification/formal-and-static-verification.html>
//!
//! # Features
//!
//! - **Property checking**: Verify SystemVerilog Assertions (SVA)
//! - **Sequential equivalence**: Compare RTL against reference models
//! - **Bounded model checking**: Exhaustive state exploration
//! - **Counterexample generation**: Detailed waveform traces
//!
//! # Requirements
//!
//! Commercial license required from Cadence.

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Verification mode for JasperGold
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum JasperGoldMode {
    /// Property checking
    #[default]
    PropertyCheck,
    /// Sequential equivalence checking
    SecCheck,
    /// Formal verification
    FormalVerif,
    /// Bounded model checking
    BoundedMC,
}

/// Configuration for JasperGold backend
#[derive(Debug, Clone)]
pub struct JasperGoldConfig {
    /// Path to JasperGold binary
    pub jg_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Verification mode
    pub mode: JasperGoldMode,
    /// Bound for BMC
    pub bound: Option<u32>,
    /// Enable counterexample generation
    pub cex_enabled: bool,
    /// Additional JasperGold options
    pub extra_args: Vec<String>,
}

impl Default for JasperGoldConfig {
    fn default() -> Self {
        Self {
            jg_path: None,
            timeout: Duration::from_secs(600),
            mode: JasperGoldMode::default(),
            bound: None,
            cex_enabled: true,
            extra_args: vec![],
        }
    }
}

/// JasperGold formal verification backend
pub struct JasperGoldBackend {
    config: JasperGoldConfig,
}

impl Default for JasperGoldBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl JasperGoldBackend {
    /// Create a new JasperGold backend with default configuration
    pub fn new() -> Self {
        Self {
            config: JasperGoldConfig::default(),
        }
    }

    /// Create with custom configuration
    pub fn with_config(config: JasperGoldConfig) -> Self {
        Self { config }
    }

    async fn detect(&self) -> Result<PathBuf, String> {
        // Check configured path first
        if let Some(ref path) = self.config.jg_path {
            if path.exists() {
                return Ok(path.clone());
            }
        }

        // Try common binary names
        for name in ["jg", "jaspergold", "jasper"] {
            if let Ok(path) = which::which(name) {
                return Ok(path);
            }
        }

        // Check JASPER_HOME environment variable
        if let Ok(jasper_home) = std::env::var("JASPER_HOME") {
            let jg_bin = PathBuf::from(&jasper_home).join("bin").join("jg");
            if jg_bin.exists() {
                return Ok(jg_bin);
            }
        }

        // Check CDS_HOME for Cadence installation
        if let Ok(cds_home) = std::env::var("CDS_HOME") {
            let jg_bin = PathBuf::from(&cds_home)
                .join("tools")
                .join("jasper")
                .join("bin")
                .join("jg");
            if jg_bin.exists() {
                return Ok(jg_bin);
            }
        }

        Err("JasperGold not found (commercial license required)".to_string())
    }

    /// Generate JasperGold TCL script from USL spec
    fn generate_tcl_script(&self, spec: &TypedSpec) -> String {
        let mut tcl = String::new();
        tcl.push_str("# Generated by DashProve\n\n");

        // Clear any existing analysis
        tcl.push_str("clear -all\n\n");

        // Generate module declaration
        tcl.push_str("# Property module\n");
        tcl.push_str("analyze -sv {\n");
        tcl.push_str("  module verify_props;\n");
        tcl.push_str("    logic clk;\n");
        tcl.push_str("    logic rst;\n");
        tcl.push_str("    logic [31:0] state;\n\n");

        // Generate assertions for properties
        for (i, prop) in spec.spec.properties.iter().enumerate() {
            let prop_name = prop.name();
            let safe_name = Self::sanitize_name(&prop_name);
            let assert_name = if safe_name.is_empty() {
                format!("prop_{}", i)
            } else {
                format!("prop_{}", safe_name)
            };

            tcl.push_str(&format!("    // Property: {}\n", prop_name));
            tcl.push_str(&format!("    property {};\n", assert_name));
            tcl.push_str("      @(posedge clk) !rst |-> state >= 0;\n");
            tcl.push_str("    endproperty\n");
            tcl.push_str(&format!(
                "    assert_{}: assert property ({});\n\n",
                assert_name, assert_name
            ));
        }

        // If no properties, add a trivial assertion
        if spec.spec.properties.is_empty() {
            tcl.push_str("    property trivial;\n");
            tcl.push_str("      @(posedge clk) 1;\n");
            tcl.push_str("    endproperty\n");
            tcl.push_str("    assert_trivial: assert property (trivial);\n");
        }

        tcl.push_str("  endmodule\n");
        tcl.push_str("}\n\n");

        // Elaborate
        tcl.push_str("elaborate -top verify_props\n\n");

        // Configure based on mode
        match self.config.mode {
            JasperGoldMode::PropertyCheck => {
                tcl.push_str("# Property checking mode\n");
                if let Some(bound) = self.config.bound {
                    tcl.push_str(&format!("set_prove_opt -max_depth {}\n", bound));
                }
            }
            JasperGoldMode::BoundedMC => {
                tcl.push_str("# Bounded model checking\n");
                let bound = self.config.bound.unwrap_or(20);
                tcl.push_str(&format!("set_prove_opt -bmc_max_depth {}\n", bound));
            }
            JasperGoldMode::SecCheck => {
                tcl.push_str("# Sequential equivalence checking\n");
            }
            JasperGoldMode::FormalVerif => {
                tcl.push_str("# Full formal verification\n");
            }
        }

        // Run prove
        tcl.push_str("\n# Run verification\n");
        tcl.push_str("prove -all\n");

        // Report results
        tcl.push_str("\n# Report\n");
        tcl.push_str("report\n");

        tcl
    }

    /// Sanitize a name for use in JasperGold
    fn sanitize_name(name: &str) -> String {
        name.replace([' ', '-', ':', '/', '\\', '.', '(', ')', '[', ']'], "_")
            .chars()
            .filter(|c| c.is_alphanumeric() || *c == '_')
            .collect::<String>()
            .to_lowercase()
    }

    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
        success: bool,
    ) -> (VerificationStatus, Vec<String>) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics = Vec::new();

        // Parse JasperGold output
        for line in combined.lines() {
            let trimmed = line.trim();

            // Check for successful proofs
            if trimmed.contains("proven") || trimmed.contains("PROVEN") || trimmed.contains("PASS")
            {
                diagnostics.push(format!("✓ {}", trimmed));
            }

            // Check for failures
            if trimmed.contains("FAIL")
                || trimmed.contains("cex")
                || trimmed.contains("counterexample")
            {
                diagnostics.push(format!("✗ {}", trimmed));
            }

            // Capture proof status
            if trimmed.contains("assert") || trimmed.contains("cover") {
                diagnostics.push(trimmed.to_string());
            }
        }

        // Check for explicit success
        if combined.contains("All assertions proven")
            || combined.contains("100% proven")
            || (combined.contains("proven") && !combined.contains("FAIL"))
        {
            return (VerificationStatus::Proven, diagnostics);
        }

        // Check for counterexample
        if combined.contains("counterexample")
            || combined.contains("FAIL")
            || combined.contains("cex found")
        {
            return (VerificationStatus::Disproven, diagnostics);
        }

        // Check for inconclusive
        if combined.contains("inconclusive") || combined.contains("INCONCLUSIVE") {
            return (
                VerificationStatus::Unknown {
                    reason: "Verification inconclusive".to_string(),
                },
                diagnostics,
            );
        }

        // Check for successful run
        if success && !combined.contains("Error") && !combined.contains("error") {
            return (VerificationStatus::Proven, diagnostics);
        }

        // Check for timeout
        if combined.contains("timeout") || combined.contains("Timeout") {
            return (
                VerificationStatus::Unknown {
                    reason: "Verification timed out".to_string(),
                },
                diagnostics,
            );
        }

        // Check for errors
        if !success || combined.contains("Error") {
            let error_lines: Vec<_> = combined
                .lines()
                .filter(|l| l.contains("Error") || l.contains("error"))
                .take(3)
                .collect();

            if !error_lines.is_empty() {
                return (
                    VerificationStatus::Unknown {
                        reason: format!("JasperGold error: {}", error_lines.join("; ")),
                    },
                    diagnostics,
                );
            }
        }

        (
            VerificationStatus::Unknown {
                reason: "Could not parse JasperGold output".to_string(),
            },
            diagnostics,
        )
    }

    /// Parse counterexample from JasperGold output
    fn parse_counterexample(stdout: &str, stderr: &str) -> StructuredCounterexample {
        let mut ce = StructuredCounterexample::new();
        let combined = format!("{}\n{}", stdout, stderr);
        ce.raw = Some(combined.clone());

        // Extract failed assertions
        ce.failed_checks = Self::extract_failed_checks(&combined);

        // Extract witness values
        ce.witness = Self::extract_witness_values(&combined);

        ce
    }

    /// Extract failed checks from JasperGold output
    fn extract_failed_checks(output: &str) -> Vec<FailedCheck> {
        let mut checks = Vec::new();

        for line in output.lines() {
            let trimmed = line.trim();

            if trimmed.contains("FAIL") || trimmed.contains("counterexample") {
                let check_type = if trimmed.contains("assert") {
                    "jg_assertion"
                } else if trimmed.contains("cover") {
                    "jg_cover"
                } else if trimmed.contains("assume") {
                    "jg_assumption"
                } else {
                    "jg_property"
                };

                let (location, description) = Self::parse_error_location(trimmed);

                checks.push(FailedCheck {
                    check_id: check_type.to_string(),
                    description,
                    location,
                    function: None,
                });
            }
        }

        checks
    }

    /// Parse error location from JasperGold error line
    fn parse_error_location(line: &str) -> (Option<SourceLocation>, String) {
        // JasperGold format varies by context
        // Often: "assert_name FAIL at time X"
        if let Some(at_idx) = line.find(" at ") {
            let description = line[..at_idx].trim().to_string();
            let time_info = line[at_idx..].trim().to_string();
            return (None, format!("{} {}", description, time_info));
        }

        (None, line.to_string())
    }

    /// Extract witness values from JasperGold output
    fn extract_witness_values(output: &str) -> HashMap<String, CounterexampleValue> {
        let mut values = HashMap::new();
        let mut in_trace = false;

        for line in output.lines() {
            let trimmed = line.trim();

            // Look for trace section
            if trimmed.contains("Trace") || trimmed.contains("waveform") {
                in_trace = true;
                continue;
            }

            if in_trace {
                if trimmed.is_empty() || trimmed.starts_with("---") {
                    in_trace = false;
                    continue;
                }

                // Parse "signal = value" patterns
                if let Some(eq_pos) = trimmed.find('=') {
                    let var_name = trimmed[..eq_pos].trim().to_string();
                    let value_str = trimmed[eq_pos + 1..].trim();
                    values.insert(var_name, Self::parse_jg_value(value_str));
                }
            }
        }

        values
    }

    /// Parse a JasperGold value string
    fn parse_jg_value(value_str: &str) -> CounterexampleValue {
        let trimmed = value_str.trim();

        // Binary values (e.g., 4'b1010)
        if trimmed.contains("'b") {
            return CounterexampleValue::String(trimmed.to_string());
        }

        // Hex values (e.g., 8'hFF)
        if trimmed.contains("'h") {
            return CounterexampleValue::String(trimmed.to_string());
        }

        // Boolean-like
        if trimmed == "1" || trimmed == "1'b1" {
            return CounterexampleValue::Bool(true);
        }
        if trimmed == "0" || trimmed == "1'b0" {
            return CounterexampleValue::Bool(false);
        }

        // Integer
        if let Ok(n) = trimmed.parse::<i128>() {
            return CounterexampleValue::Int {
                value: n,
                type_hint: None,
            };
        }

        CounterexampleValue::String(trimmed.to_string())
    }
}

#[async_trait]
impl VerificationBackend for JasperGoldBackend {
    fn id(&self) -> BackendId {
        BackendId::JasperGold
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Invariant, PropertyType::Temporal]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();

        let jg_path = self.detect().await.map_err(BackendError::Unavailable)?;

        // Create temp directory
        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp directory: {}", e))
        })?;

        let tcl_file = temp_dir.path().join("verify.tcl");
        let tcl_script = self.generate_tcl_script(spec);

        debug!("Generated JasperGold TCL:\n{}", tcl_script);

        tokio::fs::write(&tcl_file, &tcl_script)
            .await
            .map_err(|e| {
                BackendError::VerificationFailed(format!("Failed to write TCL file: {}", e))
            })?;

        // Build command
        let mut cmd = Command::new(&jg_path);
        cmd.arg("-batch")
            .arg("-tcl")
            .arg(&tcl_file)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .current_dir(temp_dir.path());

        // Extra args
        for arg in &self.config.extra_args {
            cmd.arg(arg);
        }

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| {
                BackendError::VerificationFailed(format!("Failed to run JasperGold: {}", e))
            })?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("JasperGold stdout: {}", stdout);
        debug!("JasperGold stderr: {}", stderr);

        let (status, diagnostics) = self.parse_output(&stdout, &stderr, output.status.success());

        // Generate counterexample for failures
        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            Some(Self::parse_counterexample(&stdout, &stderr))
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::JasperGold,
            status,
            proof: None,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect().await {
            Ok(_) => HealthStatus::Healthy,
            Err(r) => HealthStatus::Unavailable { reason: r },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn backend_id() {
        assert_eq!(JasperGoldBackend::new().id(), BackendId::JasperGold);
    }

    #[test]
    fn default_config() {
        let config = JasperGoldConfig::default();
        assert_eq!(config.timeout, Duration::from_secs(600));
        assert_eq!(config.mode, JasperGoldMode::PropertyCheck);
        assert!(config.cex_enabled);
    }

    #[test]
    fn supports_invariant_and_temporal() {
        let backend = JasperGoldBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Invariant));
        assert!(supported.contains(&PropertyType::Temporal));
    }

    #[test]
    fn sanitize_name() {
        assert_eq!(JasperGoldBackend::sanitize_name("my-prop"), "my_prop");
        assert_eq!(JasperGoldBackend::sanitize_name("test:1"), "test_1");
    }

    #[test]
    fn parse_proven_output() {
        let backend = JasperGoldBackend::new();
        let stdout = "assert_foo: proven\nAll assertions proven";
        let (status, diag) = backend.parse_output(stdout, "", true);
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(!diag.is_empty());
    }

    #[test]
    fn parse_fail_output() {
        let backend = JasperGoldBackend::new();
        let stdout = "assert_foo: FAIL\ncounterexample found";
        let (status, _diag) = backend.parse_output(stdout, "", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn extract_failed_checks() {
        let output = "assert_foo FAIL at time 10\ncover_bar FAIL";
        let checks = JasperGoldBackend::extract_failed_checks(output);
        assert_eq!(checks.len(), 2);
        assert_eq!(checks[0].check_id, "jg_assertion");
        assert_eq!(checks[1].check_id, "jg_cover");
    }

    #[test]
    fn parse_jg_values() {
        assert!(matches!(
            JasperGoldBackend::parse_jg_value("1"),
            CounterexampleValue::Bool(true)
        ));
        assert!(matches!(
            JasperGoldBackend::parse_jg_value("0"),
            CounterexampleValue::Bool(false)
        ));
        assert!(matches!(
            JasperGoldBackend::parse_jg_value("4'b1010"),
            CounterexampleValue::String(_)
        ));
    }

    #[test]
    fn generate_tcl_empty_spec() {
        use dashprove_usl::ast::Spec;

        let backend = JasperGoldBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let tcl = backend.generate_tcl_script(&spec);
        assert!(tcl.contains("Generated by DashProve"));
        assert!(tcl.contains("prove -all"));
    }

    #[test]
    fn config_with_bmc_mode() {
        let config = JasperGoldConfig {
            mode: JasperGoldMode::BoundedMC,
            bound: Some(50),
            ..Default::default()
        };
        let backend = JasperGoldBackend::with_config(config);
        assert_eq!(backend.config.mode, JasperGoldMode::BoundedMC);
        assert_eq!(backend.config.bound, Some(50));
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // =============================================
    // JasperGoldMode enum proofs
    // =============================================

    /// Verify JasperGoldMode default is PropertyCheck
    #[kani::proof]
    fn proof_jaspergold_mode_default() {
        let mode = JasperGoldMode::default();
        kani::assert(
            mode == JasperGoldMode::PropertyCheck,
            "Default mode should be PropertyCheck",
        );
    }

    /// Verify all JasperGoldMode variants are distinct
    #[kani::proof]
    fn proof_jaspergold_mode_variants_distinct() {
        kani::assert(
            JasperGoldMode::PropertyCheck != JasperGoldMode::SecCheck,
            "PropertyCheck != SecCheck",
        );
        kani::assert(
            JasperGoldMode::PropertyCheck != JasperGoldMode::FormalVerif,
            "PropertyCheck != FormalVerif",
        );
        kani::assert(
            JasperGoldMode::PropertyCheck != JasperGoldMode::BoundedMC,
            "PropertyCheck != BoundedMC",
        );
        kani::assert(
            JasperGoldMode::SecCheck != JasperGoldMode::FormalVerif,
            "SecCheck != FormalVerif",
        );
        kani::assert(
            JasperGoldMode::SecCheck != JasperGoldMode::BoundedMC,
            "SecCheck != BoundedMC",
        );
        kani::assert(
            JasperGoldMode::FormalVerif != JasperGoldMode::BoundedMC,
            "FormalVerif != BoundedMC",
        );
    }

    // =============================================
    // JasperGoldConfig default proofs
    // =============================================

    /// Verify JasperGoldConfig::default jg_path is None
    #[kani::proof]
    fn proof_jaspergold_config_default_path_none() {
        let config = JasperGoldConfig::default();
        kani::assert(config.jg_path.is_none(), "Default jg_path should be None");
    }

    /// Verify JasperGoldConfig::default timeout is 600 seconds
    #[kani::proof]
    fn proof_jaspergold_config_default_timeout() {
        let config = JasperGoldConfig::default();
        kani::assert(
            config.timeout == Duration::from_secs(600),
            "Default timeout should be 600 seconds",
        );
    }

    /// Verify JasperGoldConfig::default mode is PropertyCheck
    #[kani::proof]
    fn proof_jaspergold_config_default_mode() {
        let config = JasperGoldConfig::default();
        kani::assert(
            config.mode == JasperGoldMode::PropertyCheck,
            "Default mode should be PropertyCheck",
        );
    }

    /// Verify JasperGoldConfig::default bound is None
    #[kani::proof]
    fn proof_jaspergold_config_default_bound_none() {
        let config = JasperGoldConfig::default();
        kani::assert(config.bound.is_none(), "Default bound should be None");
    }

    /// Verify JasperGoldConfig::default cex_enabled is true
    #[kani::proof]
    fn proof_jaspergold_config_default_cex_enabled() {
        let config = JasperGoldConfig::default();
        kani::assert(config.cex_enabled, "Default cex_enabled should be true");
    }

    /// Verify JasperGoldConfig::default extra_args is empty
    #[kani::proof]
    fn proof_jaspergold_config_default_extra_args_empty() {
        let config = JasperGoldConfig::default();
        kani::assert(
            config.extra_args.is_empty(),
            "Default extra_args should be empty",
        );
    }

    // =============================================
    // JasperGoldBackend trait implementation proofs
    // =============================================

    /// Verify JasperGoldBackend::id returns BackendId::JasperGold
    #[kani::proof]
    fn proof_jaspergold_backend_id() {
        let backend = JasperGoldBackend::new();
        kani::assert(
            backend.id() == BackendId::JasperGold,
            "Backend ID should be JasperGold",
        );
    }

    /// Verify JasperGoldBackend::supports includes Invariant
    #[kani::proof]
    fn proof_jaspergold_backend_supports_invariant() {
        let backend = JasperGoldBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::Invariant {
                found = true;
            }
        }
        kani::assert(found, "Should support Invariant");
    }

    /// Verify JasperGoldBackend::supports includes Temporal
    #[kani::proof]
    fn proof_jaspergold_backend_supports_temporal() {
        let backend = JasperGoldBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::Temporal {
                found = true;
            }
        }
        kani::assert(found, "Should support Temporal");
    }

    /// Verify JasperGoldBackend::supports returns exactly 2 types
    #[kani::proof]
    fn proof_jaspergold_backend_supports_count() {
        let backend = JasperGoldBackend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 2,
            "Should support exactly 2 property types",
        );
    }

    // =============================================
    // sanitize_name function proofs
    // =============================================

    /// Verify sanitize_name produces lowercase output
    #[kani::proof]
    fn proof_sanitize_name_produces_lowercase() {
        let result = JasperGoldBackend::sanitize_name("ABC");
        for c in result.chars() {
            kani::assert(
                !c.is_uppercase(),
                "Output should not contain uppercase characters",
            );
        }
    }

    /// Verify sanitize_name handles empty string
    #[kani::proof]
    fn proof_sanitize_name_empty_string() {
        let result = JasperGoldBackend::sanitize_name("");
        kani::assert(result.is_empty(), "Empty input should produce empty output");
    }

    /// Verify sanitize_name converts dash to underscore
    #[kani::proof]
    fn proof_sanitize_name_converts_dash() {
        let result = JasperGoldBackend::sanitize_name("a-b");
        kani::assert(
            result.contains('_'),
            "Dash should be converted to underscore",
        );
        kani::assert(!result.contains('-'), "Output should not contain dash");
    }

    // =============================================
    // parse_output function proofs
    // =============================================

    /// Verify parse_output returns Proven for all assertions proven
    #[kani::proof]
    fn proof_parse_output_proven_all_assertions() {
        let backend = JasperGoldBackend::new();
        let (status, _) = backend.parse_output("All assertions proven", "", true);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should return Proven for all assertions proven",
        );
    }

    /// Verify parse_output returns Proven for 100% proven
    #[kani::proof]
    fn proof_parse_output_proven_100_percent() {
        let backend = JasperGoldBackend::new();
        let (status, _) = backend.parse_output("100% proven", "", true);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should return Proven for 100% proven",
        );
    }

    /// Verify parse_output returns Disproven for counterexample
    #[kani::proof]
    fn proof_parse_output_disproven_counterexample() {
        let backend = JasperGoldBackend::new();
        let (status, _) = backend.parse_output("counterexample found", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should return Disproven for counterexample",
        );
    }

    /// Verify parse_output returns Disproven for FAIL
    #[kani::proof]
    fn proof_parse_output_disproven_fail() {
        let backend = JasperGoldBackend::new();
        let (status, _) = backend.parse_output("FAIL at cycle 10", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should return Disproven for FAIL",
        );
    }

    /// Verify parse_output returns Unknown for inconclusive
    #[kani::proof]
    fn proof_parse_output_unknown_inconclusive() {
        let backend = JasperGoldBackend::new();
        let (status, _) = backend.parse_output("INCONCLUSIVE", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should return Unknown for INCONCLUSIVE",
        );
    }

    /// Verify parse_output returns Unknown for timeout
    #[kani::proof]
    fn proof_parse_output_unknown_timeout() {
        let backend = JasperGoldBackend::new();
        let (status, _) = backend.parse_output("Timeout reached", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should return Unknown for timeout",
        );
    }

    // =============================================
    // parse_jg_value function proofs
    // =============================================

    /// Verify parse_jg_value returns Bool(true) for "1"
    #[kani::proof]
    fn proof_parse_jg_value_true_1() {
        let value = JasperGoldBackend::parse_jg_value("1");
        kani::assert(
            matches!(value, CounterexampleValue::Bool(true)),
            "Should return Bool(true) for '1'",
        );
    }

    /// Verify parse_jg_value returns Bool(false) for "0"
    #[kani::proof]
    fn proof_parse_jg_value_false_0() {
        let value = JasperGoldBackend::parse_jg_value("0");
        kani::assert(
            matches!(value, CounterexampleValue::Bool(false)),
            "Should return Bool(false) for '0'",
        );
    }

    /// Verify parse_jg_value returns String for binary literal
    #[kani::proof]
    fn proof_parse_jg_value_binary() {
        let value = JasperGoldBackend::parse_jg_value("4'b1010");
        kani::assert(
            matches!(value, CounterexampleValue::String(_)),
            "Should return String for binary literal",
        );
    }

    /// Verify parse_jg_value returns String for hex literal
    #[kani::proof]
    fn proof_parse_jg_value_hex() {
        let value = JasperGoldBackend::parse_jg_value("8'hFF");
        kani::assert(
            matches!(value, CounterexampleValue::String(_)),
            "Should return String for hex literal",
        );
    }

    /// Verify parse_jg_value parses integer
    #[kani::proof]
    fn proof_parse_jg_value_integer() {
        let value = JasperGoldBackend::parse_jg_value("42");
        kani::assert(
            matches!(value, CounterexampleValue::Int { value: 42, .. }),
            "Should parse integer 42",
        );
    }

    // =============================================
    // extract_failed_checks function proofs
    // =============================================

    /// Verify extract_failed_checks finds assertion failures
    #[kani::proof]
    fn proof_extract_failed_checks_assertion() {
        let checks = JasperGoldBackend::extract_failed_checks("assert_foo FAIL");
        kani::assert(!checks.is_empty(), "Should find assertion failure");
        kani::assert(
            checks[0].check_id == "jg_assertion",
            "Check ID should be jg_assertion",
        );
    }

    /// Verify extract_failed_checks finds cover failures
    #[kani::proof]
    fn proof_extract_failed_checks_cover() {
        let checks = JasperGoldBackend::extract_failed_checks("cover_bar FAIL");
        kani::assert(!checks.is_empty(), "Should find cover failure");
        kani::assert(
            checks[0].check_id == "jg_cover",
            "Check ID should be jg_cover",
        );
    }

    /// Verify extract_failed_checks returns empty for clean output
    #[kani::proof]
    fn proof_extract_failed_checks_empty() {
        let checks = JasperGoldBackend::extract_failed_checks("All proven");
        kani::assert(checks.is_empty(), "Should return empty for clean output");
    }

    // =============================================
    // parse_error_location function proofs
    // =============================================

    /// Verify parse_error_location parses " at " format
    #[kani::proof]
    fn proof_parse_error_location_at_format() {
        let (loc, desc) = JasperGoldBackend::parse_error_location("assert_foo FAIL at time 10");
        kani::assert(loc.is_none(), "Location should be None for this format");
        kani::assert(desc.contains("FAIL"), "Description should contain FAIL");
        kani::assert(
            desc.contains("time 10"),
            "Description should contain time info",
        );
    }

    /// Verify parse_error_location handles no location
    #[kani::proof]
    fn proof_parse_error_location_no_location() {
        let (loc, desc) = JasperGoldBackend::parse_error_location("just a message");
        kani::assert(loc.is_none(), "Should have no location");
        kani::assert(
            desc == "just a message",
            "Description should be the original line",
        );
    }

    // =============================================
    // JasperGoldBackend constructor proofs
    // =============================================

    /// Verify JasperGoldBackend::new creates backend with default config
    #[kani::proof]
    fn proof_jaspergold_backend_new_default_config() {
        let backend = JasperGoldBackend::new();
        kani::assert(
            backend.config.timeout == Duration::from_secs(600),
            "New backend should have default timeout",
        );
    }

    /// Verify JasperGoldBackend::with_config preserves config
    #[kani::proof]
    fn proof_jaspergold_backend_with_config() {
        let config = JasperGoldConfig {
            timeout: Duration::from_secs(300),
            ..Default::default()
        };
        let backend = JasperGoldBackend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(300),
            "Custom config should be preserved",
        );
    }

    /// Verify JasperGoldBackend implements Default
    #[kani::proof]
    fn proof_jaspergold_backend_default() {
        let backend = JasperGoldBackend::default();
        kani::assert(
            backend.id() == BackendId::JasperGold,
            "Default backend should have correct ID",
        );
    }

    /// Verify JasperGoldBackend config bound can be set
    #[kani::proof]
    fn proof_jaspergold_config_with_bound() {
        let config = JasperGoldConfig {
            bound: Some(50),
            ..Default::default()
        };
        let backend = JasperGoldBackend::with_config(config);
        kani::assert(
            backend.config.bound == Some(50),
            "Bound should be preserved",
        );
    }

    /// Verify JasperGoldBackend config mode can be set to BoundedMC
    #[kani::proof]
    fn proof_jaspergold_config_bmc_mode() {
        let config = JasperGoldConfig {
            mode: JasperGoldMode::BoundedMC,
            ..Default::default()
        };
        let backend = JasperGoldBackend::with_config(config);
        kani::assert(
            backend.config.mode == JasperGoldMode::BoundedMC,
            "Mode should be BoundedMC",
        );
    }
}
