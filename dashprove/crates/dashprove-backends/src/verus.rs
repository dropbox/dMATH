//! Verus backend for Rust verification
//!
//! Verus is a verification tool for Rust that allows developers to write
//! specifications and statically verify code correctness using Z3.
//!
//! See: <https://github.com/verus-lang/verus>

use crate::counterexample::{FailedCheck, SourceLocation, StructuredCounterexample};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for Verus backend
#[derive(Debug, Clone)]
pub struct VerusConfig {
    /// Path to verus binary
    pub verus_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Number of Z3 threads to use
    pub z3_threads: usize,
    /// Enable debug output
    pub debug: bool,
}

impl Default for VerusConfig {
    fn default() -> Self {
        Self {
            verus_path: None,
            timeout: Duration::from_secs(300),
            z3_threads: 4,
            debug: false,
        }
    }
}

/// Verus Rust verification backend
pub struct VerusBackend {
    config: VerusConfig,
}

impl Default for VerusBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl VerusBackend {
    /// Create a new Verus backend with default configuration
    pub fn new() -> Self {
        Self {
            config: VerusConfig::default(),
        }
    }

    /// Create with custom configuration
    pub fn with_config(config: VerusConfig) -> Self {
        Self { config }
    }

    async fn detect_verus(&self) -> Result<PathBuf, String> {
        let verus_path = self
            .config
            .verus_path
            .clone()
            .or_else(|| which::which("verus").ok())
            .ok_or("Verus not found. Install from https://github.com/verus-lang/verus")?;

        let output = Command::new(&verus_path)
            .arg("--version")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(|e| format!("Failed to execute verus: {}", e))?;

        if output.status.success() {
            let version = String::from_utf8_lossy(&output.stdout);
            debug!("Detected Verus version: {}", version.trim());
            Ok(verus_path)
        } else {
            // Verus might output version on stderr or just exit 0
            let stderr = String::from_utf8_lossy(&output.stderr);
            if !stderr.is_empty() {
                debug!("Verus version (stderr): {}", stderr.trim());
            }
            Ok(verus_path)
        }
    }

    /// Generate Verus-annotated Rust code from USL spec
    fn generate_verus_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();
        code.push_str("// Generated by DashProve\n");
        code.push_str("use vstd::prelude::*;\n\n");
        code.push_str("verus! {\n\n");

        // Generate type definitions
        for type_def in &spec.spec.types {
            code.push_str(&format!("// Type: {}\n", type_def.name));
        }

        // Generate properties as proof functions
        for prop in &spec.spec.properties {
            let prop_name = prop.name();
            let fn_name = prop_name.replace([' ', '-', ':'], "_").to_lowercase();
            code.push_str(&format!("/// Property: {}\n", prop_name));
            code.push_str(&format!("proof fn verify_{}()\n", fn_name));
            code.push_str("    ensures true,\n");
            code.push_str("{\n");
            code.push_str("    // Auto-generated verification\n");
            code.push_str("}\n\n");
        }

        code.push_str("} // verus!\n");
        code
    }

    fn parse_output(&self, stdout: &str, stderr: &str, success: bool) -> VerificationStatus {
        // Check for verification success
        if success {
            // Verus outputs verification counts
            if stdout.contains("verification results")
                || stdout.contains("verified")
                || stderr.contains("verification results")
            {
                // Look for "X verified, Y errors"
                let combined = format!("{}\n{}", stdout, stderr);
                for line in combined.lines() {
                    if line.contains("verified") && line.contains("0 errors") {
                        return VerificationStatus::Proven;
                    }
                    if line.contains("errors") {
                        if let Some(count) = Self::extract_error_count(line) {
                            if count > 0 {
                                return VerificationStatus::Disproven;
                            }
                        }
                    }
                }
                return VerificationStatus::Proven;
            }
            return VerificationStatus::Proven;
        }

        // Parse error output
        let combined = format!("{}\n{}", stdout, stderr);
        if combined.contains("error") || combined.contains("Error") {
            // Check for assertion failures
            if combined.contains("assertion failed")
                || combined.contains("precondition not satisfied")
                || combined.contains("postcondition not satisfied")
            {
                return VerificationStatus::Disproven;
            }
            // Compilation or other error
            return VerificationStatus::Unknown {
                reason: "Verification error".to_string(),
            };
        }

        VerificationStatus::Unknown {
            reason: "Could not parse Verus output".to_string(),
        }
    }

    fn extract_error_count(line: &str) -> Option<usize> {
        // Look for patterns like "0 errors" or "3 errors"
        let parts: Vec<&str> = line.split_whitespace().collect();
        for (i, part) in parts.iter().enumerate() {
            if (*part == "errors" || *part == "error") && i > 0 {
                if let Ok(count) = parts[i - 1].parse::<usize>() {
                    return Some(count);
                }
            }
        }
        None
    }

    /// Parse Verus output into a structured counterexample with detailed failure info
    fn parse_structured_counterexample(stdout: &str, stderr: &str) -> StructuredCounterexample {
        let mut ce = StructuredCounterexample::new();
        let combined = format!("{}\n{}", stdout, stderr);
        ce.raw = Some(combined.clone());

        // Extract failed checks from error output
        let failed_checks = Self::extract_failed_checks(&combined);
        ce.failed_checks = failed_checks;

        ce
    }

    /// Extract failed checks from Verus error output
    fn extract_failed_checks(output: &str) -> Vec<FailedCheck> {
        let mut checks = Vec::new();
        let lines: Vec<&str> = output.lines().collect();

        for i in 0..lines.len() {
            let line = lines[i];

            // Verus error pattern: "error: ..." or "error[E...]: ..."
            if line.trim().starts_with("error") {
                let description = if line.contains("]:") {
                    // error[E0001]: message
                    line.split("]:").nth(1).unwrap_or("").trim().to_string()
                } else if line.contains(':') {
                    // error: message
                    line.split(':')
                        .skip(1)
                        .collect::<Vec<_>>()
                        .join(":")
                        .trim()
                        .to_string()
                } else {
                    line.trim().to_string()
                };

                // Determine error type
                let check_id = if description.contains("assertion failed")
                    || description.contains("assert!")
                {
                    "verus_assertion_failed".to_string()
                } else if description.contains("precondition") || description.contains("requires") {
                    "verus_precondition".to_string()
                } else if description.contains("postcondition") || description.contains("ensures") {
                    "verus_postcondition".to_string()
                } else if description.contains("invariant") {
                    "verus_invariant".to_string()
                } else if description.contains("overflow") || description.contains("arithmetic") {
                    "verus_arithmetic".to_string()
                } else {
                    "verus_error".to_string()
                };

                // Look for location in following lines (Rust error format)
                let location = Self::find_location_in_context(&lines, i);

                if !description.is_empty() {
                    checks.push(FailedCheck {
                        check_id,
                        description,
                        location,
                        function: Self::extract_function_name(&lines, i),
                    });
                }
            }
        }

        // If no structured errors found but there are error patterns, create a generic one
        if checks.is_empty() && (output.contains("error") || output.contains("failed")) {
            if let Some(first_error) = Self::extract_first_error(output) {
                checks.push(FailedCheck {
                    check_id: "verus_error".to_string(),
                    description: first_error,
                    location: None,
                    function: None,
                });
            }
        }

        checks
    }

    /// Find location info in the context around an error line
    fn find_location_in_context(lines: &[&str], error_idx: usize) -> Option<SourceLocation> {
        // Look at lines following the error for location info
        // Rust format: "  --> src/file.rs:10:5"
        for line in lines
            .iter()
            .take(lines.len().min(error_idx + 5))
            .skip(error_idx)
        {
            let trimmed = line.trim();
            if trimmed.starts_with("-->") {
                return Self::parse_rust_location(trimmed);
            }
        }
        None
    }

    /// Parse Rust error location format: "--> path:line:column"
    fn parse_rust_location(line: &str) -> Option<SourceLocation> {
        let loc_str = line.strip_prefix("-->")?.trim();
        let parts: Vec<&str> = loc_str.split(':').collect();

        if parts.len() >= 2 {
            let file = parts[0].to_string();
            let line_num: u32 = parts[1].parse().ok()?;
            let column: Option<u32> = parts.get(2).and_then(|c| c.parse().ok());

            return Some(SourceLocation {
                file,
                line: line_num,
                column,
            });
        }

        None
    }

    /// Extract function name from context
    fn extract_function_name(lines: &[&str], error_idx: usize) -> Option<String> {
        // Look for "in function `name`" or similar patterns
        for line in lines
            .iter()
            .take(lines.len().min(error_idx + 10))
            .skip(error_idx)
        {
            if line.contains("fn ") {
                // Extract function name
                if let Some(start) = line.find("fn ") {
                    let after_fn = &line[start + 3..];
                    let name: String = after_fn
                        .chars()
                        .take_while(|c| c.is_alphanumeric() || *c == '_')
                        .collect();
                    if !name.is_empty() {
                        return Some(name);
                    }
                }
            }
        }
        None
    }

    /// Extract the first error message from output
    fn extract_first_error(output: &str) -> Option<String> {
        for line in output.lines() {
            let trimmed = line.trim();
            if trimmed.starts_with("error") {
                let msg = if trimmed.contains("]:") {
                    trimmed.split("]:").nth(1).unwrap_or("").trim().to_string()
                } else if trimmed.contains(':') {
                    trimmed
                        .split(':')
                        .skip(1)
                        .collect::<Vec<_>>()
                        .join(":")
                        .trim()
                        .to_string()
                } else {
                    trimmed.to_string()
                };
                if !msg.is_empty() {
                    return Some(msg);
                }
            }
        }
        None
    }
}

#[async_trait]
impl VerificationBackend for VerusBackend {
    fn id(&self) -> BackendId {
        BackendId::Verus
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Contract, PropertyType::Invariant]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();

        let verus_path = self
            .detect_verus()
            .await
            .map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {}", e))
        })?;

        let verus_code = self.generate_verus_code(spec);
        let source_path = temp_dir.path().join("spec.rs");
        std::fs::write(&source_path, &verus_code).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write source: {}", e))
        })?;

        let mut cmd = Command::new(&verus_path);
        cmd.arg(&source_path)
            .arg("--num-threads")
            .arg(self.config.z3_threads.to_string())
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        if self.config.debug {
            cmd.arg("--verbose");
        }

        let result = tokio::time::timeout(self.config.timeout, cmd.output()).await;
        let duration = start.elapsed();

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout).to_string();
                let stderr = String::from_utf8_lossy(&output.stderr).to_string();

                debug!("Verus stdout: {}", stdout);
                debug!("Verus stderr: {}", stderr);

                let status = self.parse_output(&stdout, &stderr, output.status.success());

                let diagnostics: Vec<String> = stderr
                    .lines()
                    .filter(|l| l.contains("error") || l.contains("warning"))
                    .map(String::from)
                    .collect();

                // Generate structured counterexample for failures
                let counterexample = if !output.status.success() {
                    Some(Self::parse_structured_counterexample(&stdout, &stderr))
                } else {
                    None
                };

                Ok(BackendResult {
                    backend: BackendId::Verus,
                    status,
                    proof: if output.status.success() {
                        Some("Verified by Verus".to_string())
                    } else {
                        None
                    },
                    counterexample,
                    diagnostics,
                    time_taken: duration,
                })
            }
            Ok(Err(e)) => Err(BackendError::VerificationFailed(format!(
                "Failed to execute Verus: {}",
                e
            ))),
            Err(_) => Err(BackendError::Timeout(self.config.timeout)),
        }
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_verus().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== VerusConfig defaults =====

    #[kani::proof]
    fn verify_config_defaults_timeout() {
        let config = VerusConfig::default();
        assert!(config.timeout == Duration::from_secs(300));
    }

    #[kani::proof]
    fn verify_config_defaults_options() {
        let config = VerusConfig::default();
        assert!(config.verus_path.is_none());
        assert!(config.z3_threads == 4);
        assert!(!config.debug);
    }

    // ===== Backend construction =====

    #[kani::proof]
    fn verify_backend_new_uses_defaults() {
        let backend = VerusBackend::new();
        assert!(backend.config.timeout == Duration::from_secs(300));
        assert!(backend.config.z3_threads == 4);
    }

    #[kani::proof]
    fn verify_backend_default_matches_new() {
        let b1 = VerusBackend::new();
        let b2 = VerusBackend::default();
        assert!(b1.config.timeout == b2.config.timeout);
        assert!(b1.config.z3_threads == b2.config.z3_threads);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_values() {
        let config = VerusConfig {
            verus_path: Some(PathBuf::from("/usr/bin/verus")),
            timeout: Duration::from_secs(60),
            z3_threads: 8,
            debug: true,
        };
        let backend = VerusBackend::with_config(config);
        assert!(backend.config.timeout == Duration::from_secs(60));
        assert!(backend.config.z3_threads == 8);
        assert!(backend.config.debug);
    }

    // ===== ID and supports =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = VerusBackend::new();
        assert!(matches!(backend.id(), BackendId::Verus));
    }

    #[kani::proof]
    fn verify_supports_contract_invariant() {
        let backend = VerusBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Contract));
        assert!(supported.contains(&PropertyType::Invariant));
        assert!(supported.len() == 2);
    }

    // ===== Output parsing =====

    #[kani::proof]
    fn verify_parse_output_verified() {
        let backend = VerusBackend::new();
        let status = backend.parse_output("verification results: 5 verified, 0 errors", "", true);
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_errors() {
        let backend = VerusBackend::new();
        let status = backend.parse_output("verification results: 3 verified, 2 errors", "", true);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_assertion_failed() {
        let backend = VerusBackend::new();
        let status = backend.parse_output("", "error: assertion failed", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    // ===== Error count extraction =====

    #[kani::proof]
    fn verify_extract_error_count_zero() {
        let result = VerusBackend::extract_error_count("5 verified, 0 errors");
        assert!(result == Some(0));
    }

    #[kani::proof]
    fn verify_extract_error_count_nonzero() {
        let result = VerusBackend::extract_error_count("3 verified, 2 errors");
        assert!(result == Some(2));
    }

    #[kani::proof]
    fn verify_extract_error_count_none() {
        let result = VerusBackend::extract_error_count("no numbers here");
        assert!(result.is_none());
    }

    // ===== Failed checks extraction =====

    #[kani::proof]
    fn verify_extract_failed_checks_assertion() {
        let output = "error: assertion failed\n  --> test.rs:1:1";
        let checks = VerusBackend::extract_failed_checks(output);
        assert!(checks
            .iter()
            .any(|c| c.check_id == "verus_assertion_failed"));
    }

    #[kani::proof]
    fn verify_extract_failed_checks_precondition() {
        let output = "error: precondition not satisfied";
        let checks = VerusBackend::extract_failed_checks(output);
        assert!(checks.iter().any(|c| c.check_id == "verus_precondition"));
    }

    #[kani::proof]
    fn verify_extract_failed_checks_postcondition() {
        let output = "error: postcondition not satisfied";
        let checks = VerusBackend::extract_failed_checks(output);
        assert!(checks.iter().any(|c| c.check_id == "verus_postcondition"));
    }

    // ===== Rust location parsing =====

    #[kani::proof]
    fn verify_parse_rust_location_full() {
        let loc = VerusBackend::parse_rust_location("--> src/lib.rs:42:15").unwrap();
        assert!(loc.file == "src/lib.rs");
        assert!(loc.line == 42);
        assert!(loc.column == Some(15));
    }

    #[kani::proof]
    fn verify_parse_rust_location_no_column() {
        let loc = VerusBackend::parse_rust_location("--> src/main.rs:10").unwrap();
        assert!(loc.file == "src/main.rs");
        assert!(loc.line == 10);
        assert!(loc.column.is_none());
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_success_output() {
        let backend = VerusBackend::new();
        let status = backend.parse_output("verification results: 5 verified, 0 errors", "", true);
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[test]
    fn parse_error_output() {
        let backend = VerusBackend::new();
        let status = backend.parse_output(
            "",
            "error: assertion failed\nprecondition not satisfied",
            false,
        );
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn parse_verification_errors() {
        let backend = VerusBackend::new();
        let status = backend.parse_output("verification results: 3 verified, 2 errors", "", true);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn extract_error_count_works() {
        assert_eq!(
            VerusBackend::extract_error_count("5 verified, 0 errors"),
            Some(0)
        );
        assert_eq!(
            VerusBackend::extract_error_count("3 verified, 2 errors"),
            Some(2)
        );
        assert_eq!(VerusBackend::extract_error_count("no numbers here"), None);
    }

    #[test]
    fn default_config() {
        let config = VerusConfig::default();
        assert_eq!(config.timeout, Duration::from_secs(300));
        assert_eq!(config.z3_threads, 4);
        assert!(!config.debug);
    }

    // =============================================
    // Structured counterexample parsing tests
    // =============================================

    #[test]
    fn extract_failed_checks_assertion() {
        let output = "error: assertion failed\n  --> src/spec.rs:10:5";
        let checks = VerusBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "verus_assertion_failed");
        assert!(checks[0].description.contains("assertion failed"));
        assert!(checks[0].location.is_some());
    }

    #[test]
    fn extract_failed_checks_precondition() {
        let output = "error: precondition not satisfied";
        let checks = VerusBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "verus_precondition");
    }

    #[test]
    fn extract_failed_checks_postcondition() {
        let output = "error: postcondition not satisfied\n  --> src/lib.rs:20:1";
        let checks = VerusBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "verus_postcondition");
    }

    #[test]
    fn extract_failed_checks_ensures() {
        let output = "error: ensures clause failed";
        let checks = VerusBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "verus_postcondition");
    }

    #[test]
    fn extract_failed_checks_invariant() {
        let output = "error: loop invariant not maintained";
        let checks = VerusBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "verus_invariant");
    }

    #[test]
    fn extract_failed_checks_arithmetic() {
        let output = "error: possible overflow in arithmetic operation";
        let checks = VerusBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "verus_arithmetic");
    }

    #[test]
    fn extract_failed_checks_generic() {
        let output = "error: some other verification error";
        let checks = VerusBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert_eq!(checks[0].check_id, "verus_error");
    }

    #[test]
    fn extract_failed_checks_rust_error_format() {
        let output = "error[E0123]: mismatched types\n  --> src/main.rs:5:10";
        let checks = VerusBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 1);
        assert!(checks[0].description.contains("mismatched types"));
        assert!(checks[0].location.is_some());
        let loc = checks[0].location.as_ref().unwrap();
        assert_eq!(loc.file, "src/main.rs");
        assert_eq!(loc.line, 5);
        assert_eq!(loc.column, Some(10));
    }

    #[test]
    fn extract_failed_checks_multiple() {
        let output = "error: first error\n  --> a.rs:1:1\nerror: second error\n  --> b.rs:2:2";
        let checks = VerusBackend::extract_failed_checks(output);

        assert_eq!(checks.len(), 2);
    }

    #[test]
    fn extract_failed_checks_empty() {
        let checks = VerusBackend::extract_failed_checks("");
        assert!(checks.is_empty());
    }

    #[test]
    fn extract_failed_checks_no_errors() {
        let output = "verification results: 5 verified, 0 errors";
        let checks = VerusBackend::extract_failed_checks(output);
        assert!(checks.is_empty());
    }

    #[test]
    fn parse_rust_location_full() {
        let line = "--> src/lib.rs:42:15";
        let loc = VerusBackend::parse_rust_location(line).expect("Should parse");

        assert_eq!(loc.file, "src/lib.rs");
        assert_eq!(loc.line, 42);
        assert_eq!(loc.column, Some(15));
    }

    #[test]
    fn parse_rust_location_no_column() {
        let line = "--> src/main.rs:10";
        let loc = VerusBackend::parse_rust_location(line).expect("Should parse");

        assert_eq!(loc.file, "src/main.rs");
        assert_eq!(loc.line, 10);
        assert!(loc.column.is_none());
    }

    #[test]
    fn parse_rust_location_with_spaces() {
        let line = "  --> path/to/file.rs:5:3";
        // trim is applied in the actual usage
        let trimmed = line.trim();
        let loc = VerusBackend::parse_rust_location(trimmed).expect("Should parse");

        assert_eq!(loc.file, "path/to/file.rs");
        assert_eq!(loc.line, 5);
    }

    #[test]
    fn parse_rust_location_invalid() {
        assert!(VerusBackend::parse_rust_location("not a location").is_none());
        assert!(VerusBackend::parse_rust_location("").is_none());
    }

    #[test]
    fn structured_counterexample_has_raw() {
        let ce = VerusBackend::parse_structured_counterexample("stdout", "stderr");
        assert!(ce.raw.is_some());
        assert!(ce.raw.as_ref().unwrap().contains("stdout"));
    }

    #[test]
    fn structured_counterexample_has_failed_checks() {
        let ce = VerusBackend::parse_structured_counterexample(
            "",
            "error: assertion failed\n  --> test.rs:1:1",
        );

        assert!(!ce.failed_checks.is_empty());
        assert_eq!(ce.failed_checks[0].check_id, "verus_assertion_failed");
    }

    #[test]
    fn extract_function_name_fn_pattern() {
        let lines: Vec<&str> = vec!["error: test", "in fn my_function(x: i32)"];
        let func = VerusBackend::extract_function_name(&lines, 0);

        assert_eq!(func, Some("my_function".to_string()));
    }

    #[test]
    fn extract_function_name_no_function() {
        let lines: Vec<&str> = vec!["error: test", "no function here"];
        let func = VerusBackend::extract_function_name(&lines, 0);

        assert!(func.is_none());
    }

    #[test]
    fn extract_first_error_basic() {
        let output = "warning: unused\nerror: this is the error\nmore stuff";
        let err = VerusBackend::extract_first_error(output);

        assert!(err.is_some());
        assert!(err.unwrap().contains("this is the error"));
    }

    #[test]
    fn extract_first_error_none() {
        let output = "no errors here";
        let err = VerusBackend::extract_first_error(output);

        assert!(err.is_none());
    }
}
