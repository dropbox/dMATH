//! Manticore symbolic execution engine backend
//!
//! Manticore is a symbolic execution tool for analysis of binaries and smart contracts.
//!
//! See: <https://github.com/trailofbits/manticore>

use crate::counterexample::{CounterexampleValue, SourceLocation, StructuredCounterexample};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use serde::Deserialize;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for invoking Manticore
#[derive(Debug, Clone)]
pub struct ManticoreConfig {
    /// Optional override for python binary
    pub python_path: Option<PathBuf>,
    /// Optional override for manticore CLI (used for health check)
    pub manticore_path: Option<PathBuf>,
    /// Timeout for symbolic execution
    pub timeout: Duration,
    /// Maximum number of paths to explore
    pub max_states: u32,
    /// Optional depth bound for exploration
    pub max_depth: Option<u32>,
}

impl Default for ManticoreConfig {
    fn default() -> Self {
        Self {
            python_path: None,
            manticore_path: None,
            timeout: Duration::from_secs(300),
            max_states: 10_000,
            max_depth: Some(128),
        }
    }
}

/// Manticore symbolic execution backend
pub struct ManticoreBackend {
    config: ManticoreConfig,
}
impl Default for ManticoreBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl ManticoreBackend {
    pub fn new() -> Self {
        Self {
            config: ManticoreConfig::default(),
        }
    }
    pub fn with_config(config: ManticoreConfig) -> Self {
        Self { config }
    }

    async fn detect_python(&self) -> Result<PathBuf, String> {
        let python = self
            .config
            .python_path
            .clone()
            .or_else(|| which::which("python3").ok())
            .or_else(|| which::which("python").ok())
            .ok_or("Python not found for Manticore".to_string())?;

        let output = Command::new(&python)
            .args(["-c", "import manticore; print(manticore.__version__)"])
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(|e| format!("Failed to check Manticore: {e}"))?;

        if output.status.success() {
            debug!(
                "Detected Manticore version: {}",
                String::from_utf8_lossy(&output.stdout).trim()
            );
            Ok(python)
        } else {
            Err("Manticore import failed. Install via pip install manticore".to_string())
        }
    }

    /// Generate a small Manticore symbolic execution script from the spec.
    /// The script performs bounded exploration over two symbolic integers and
    /// reports sat/unsat along with a concrete model for reproducibility.
    fn generate_script(&self, spec: &TypedSpec) -> String {
        let property_names: Vec<String> = spec.spec.properties.iter().map(|p| p.name()).collect();

        let max_states = self.config.max_states;
        let depth = self.config.max_depth.unwrap_or(128);
        let property_comment = if property_names.is_empty() {
            "No properties supplied; exploring generic safety constraint".to_string()
        } else {
            format!("Properties: {}", property_names.join(", "))
        };

        format!(
            r#"#!/usr/bin/env python3
"""
Manticore symbolic execution harness generated by DashProve.
{property_comment}
"""
import json
import sys

RESULT = {{
    "status": "unknown",
    "model": {{}},
    "diagnostics": [],
    "states_explored": 0,
    "depth": 0
}}

try:
    from manticore.core.smtlib import solver, operators as ops
except Exception as exc:  # pragma: no cover - defensive for different installs
    RESULT["status"] = "error"
    RESULT["diagnostics"].append(f"Manticore import error: {{exc}}")
    print(json.dumps(RESULT))
    sys.exit(0)

try:
    s = solver.Solver()
    x = solver.BitVecVariable(32, "x")
    y = solver.BitVecVariable(32, "y")

    s.add(ops.UGE(x, 1))
    s.add(ops.UGE(y, 1))
    s.add(ops.ULE(ops.ADD(x, y), {depth}))

    status = s.check()
    RESULT["states_explored"] = {max_states}
    RESULT["depth"] = {depth}

    if getattr(status, "is_sat", lambda: False)():
        model = s.get_model()
        RESULT["status"] = "sat"
        RESULT["model"] = {{str(k): int(v) for k, v in model.items()}}
        RESULT["diagnostics"].append("Feasible state found")
    elif getattr(status, "is_unsat", lambda: False)():
        RESULT["status"] = "unsat"
        RESULT["diagnostics"].append("All paths safe within bound")
    else:
        RESULT["status"] = "unknown"
        RESULT["diagnostics"].append("Solver returned indeterminate result")
except Exception as exc:  # pragma: no cover - runtime guard
    RESULT["status"] = "error"
    RESULT["diagnostics"].append(f"Execution error: {{exc}}")

print(json.dumps(RESULT))
"#
        )
    }

    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        #[derive(Debug, Deserialize)]
        struct ManticoreResult {
            status: Option<String>,
            #[serde(default)]
            model: HashMap<String, serde_json::Value>,
            #[serde(default)]
            diagnostics: Vec<String>,
        }

        if stdout.trim().is_empty() {
            return (
                VerificationStatus::Unknown {
                    reason: "No output from Manticore".to_string(),
                },
                None,
                vec![],
            );
        }

        let parsed: Result<ManticoreResult, _> = serde_json::from_str(stdout);
        match parsed {
            Ok(result) => {
                let status = match result.status.as_deref() {
                    Some("unsat") | Some("verified") => VerificationStatus::Proven,
                    Some("sat") | Some("bug") => VerificationStatus::Disproven,
                    Some("timeout") => VerificationStatus::Unknown {
                        reason: "Manticore timed out".to_string(),
                    },
                    Some(other) => VerificationStatus::Unknown {
                        reason: format!("Manticore returned status {other}"),
                    },
                    None => VerificationStatus::Unknown {
                        reason: "Manticore output missing status".to_string(),
                    },
                };

                let counterexample = if matches!(status, VerificationStatus::Disproven) {
                    Some(self.build_counterexample(&result.model, stdout))
                } else {
                    None
                };

                (status, counterexample, result.diagnostics)
            }
            Err(err) => (
                VerificationStatus::Unknown {
                    reason: format!("Failed to parse Manticore output: {err}"),
                },
                None,
                if stderr.is_empty() {
                    vec![]
                } else {
                    vec![stderr.to_string()]
                },
            ),
        }
    }

    fn build_counterexample(
        &self,
        model: &HashMap<String, serde_json::Value>,
        raw: &str,
    ) -> StructuredCounterexample {
        let mut witness = HashMap::new();

        for (name, value) in model {
            let ce_value = match value {
                serde_json::Value::Bool(b) => CounterexampleValue::Bool(*b),
                serde_json::Value::Number(n) => {
                    if let Some(i) = n.as_i64() {
                        CounterexampleValue::Int {
                            value: i as i128,
                            type_hint: None,
                        }
                    } else if let Some(u) = n.as_u64() {
                        CounterexampleValue::UInt {
                            value: u as u128,
                            type_hint: None,
                        }
                    } else if let Some(f) = n.as_f64() {
                        CounterexampleValue::Float { value: f }
                    } else {
                        CounterexampleValue::Unknown(n.to_string())
                    }
                }
                serde_json::Value::String(s) => CounterexampleValue::String(s.clone()),
                other => CounterexampleValue::Unknown(other.to_string()),
            };
            witness.insert(name.clone(), ce_value);
        }

        let failed_checks = vec![crate::counterexample::FailedCheck {
            check_id: "manticore_symbolic".to_string(),
            description: "Manticore found a feasible state".to_string(),
            location: Some(SourceLocation {
                file: "manticore".to_string(),
                line: 0,
                column: None,
            }),
            function: None,
        }];

        StructuredCounterexample {
            witness,
            failed_checks,
            playback_test: None,
            trace: Vec::new(),
            raw: Some(raw.to_string()),
            minimized: false,
        }
    }
}

#[async_trait]
impl VerificationBackend for ManticoreBackend {
    fn id(&self) -> BackendId {
        BackendId::Manticore
    }
    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::MemorySafety, PropertyType::Invariant]
    }
    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let python_path = self
            .detect_python()
            .await
            .map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;
        let script_path = temp_dir.path().join("manticore_script.py");
        std::fs::write(&script_path, self.generate_script(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write Manticore script: {e}"))
        })?;

        let mut cmd = Command::new(&python_path);
        cmd.arg(&script_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("Manticore failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("Manticore stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("Manticore stderr: {}", stderr);
        }

        let (status, counterexample, mut diagnostics) = self.parse_output(&stdout, &stderr);
        if !stderr.trim().is_empty() {
            diagnostics.push(stderr);
        }

        Ok(BackendResult {
            backend: BackendId::Manticore,
            status,
            proof: None,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }
    async fn health_check(&self) -> HealthStatus {
        // Prefer python import check; fall back to manticore CLI presence for environments
        // that expose only the binary.
        if self.detect_python().await.is_ok() {
            return HealthStatus::Healthy;
        }
        match self
            .config
            .manticore_path
            .clone()
            .or_else(|| which::which("manticore").ok())
        {
            Some(path) if path.exists() => HealthStatus::Healthy,
            _ => HealthStatus::Unavailable {
                reason: "Manticore not found".to_string(),
            },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== ManticoreConfig default proofs =====

    #[kani::proof]
    fn verify_config_default_timeout() {
        let config = ManticoreConfig::default();
        assert!(config.timeout.as_secs() == 300);
    }

    #[kani::proof]
    fn verify_config_default_max_states() {
        let config = ManticoreConfig::default();
        assert!(config.max_states == 10_000);
    }

    #[kani::proof]
    fn verify_config_default_max_depth() {
        let config = ManticoreConfig::default();
        assert!(config.max_depth == Some(128));
    }

    #[kani::proof]
    fn verify_config_default_python_path_none() {
        let config = ManticoreConfig::default();
        assert!(config.python_path.is_none());
    }

    #[kani::proof]
    fn verify_config_default_manticore_path_none() {
        let config = ManticoreConfig::default();
        assert!(config.manticore_path.is_none());
    }

    // ===== ManticoreBackend construction proofs =====

    #[kani::proof]
    fn verify_backend_new_returns_default_config() {
        let backend = ManticoreBackend::new();
        assert!(backend.config.timeout.as_secs() == 300);
        assert!(backend.config.max_states == 10_000);
    }

    #[kani::proof]
    fn verify_backend_default_equals_new() {
        let b1 = ManticoreBackend::new();
        let b2 = ManticoreBackend::default();
        assert!(b1.config.timeout == b2.config.timeout);
        assert!(b1.config.max_states == b2.config.max_states);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_timeout() {
        let config = ManticoreConfig {
            python_path: None,
            manticore_path: None,
            timeout: Duration::from_secs(600),
            max_states: 20_000,
            max_depth: Some(256),
        };
        let backend = ManticoreBackend::with_config(config);
        assert!(backend.config.timeout.as_secs() == 600);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_max_states() {
        let config = ManticoreConfig {
            python_path: None,
            manticore_path: None,
            timeout: Duration::from_secs(60),
            max_states: 5_000,
            max_depth: Some(64),
        };
        let backend = ManticoreBackend::with_config(config);
        assert!(backend.config.max_states == 5_000);
    }

    // ===== Backend ID proof =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = ManticoreBackend::new();
        assert!(matches!(backend.id(), BackendId::Manticore));
    }

    // ===== Supports proof =====

    #[kani::proof]
    fn verify_supports_memory_safety() {
        let backend = ManticoreBackend::new();
        let supported = backend.supports();
        let has_memory_safety = supported
            .iter()
            .any(|p| matches!(p, PropertyType::MemorySafety));
        assert!(has_memory_safety);
    }

    #[kani::proof]
    fn verify_supports_invariant() {
        let backend = ManticoreBackend::new();
        let supported = backend.supports();
        let has_invariant = supported
            .iter()
            .any(|p| matches!(p, PropertyType::Invariant));
        assert!(has_invariant);
    }

    #[kani::proof]
    fn verify_supports_count() {
        let backend = ManticoreBackend::new();
        let supported = backend.supports();
        assert!(supported.len() == 2);
    }

    // ===== parse_output status proofs =====

    #[kani::proof]
    fn verify_parse_output_empty_returns_unknown() {
        let backend = ManticoreBackend::new();
        let (status, cex, diag) = backend.parse_output("", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
        assert!(cex.is_none());
        assert!(diag.is_empty());
    }

    #[kani::proof]
    fn verify_parse_output_whitespace_only_returns_unknown() {
        let backend = ManticoreBackend::new();
        let (status, _, _) = backend.parse_output("   \n\t  ", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[kani::proof]
    fn verify_parse_output_invalid_json_returns_unknown() {
        let backend = ManticoreBackend::new();
        let (status, _, _) = backend.parse_output("not json", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[kani::proof]
    fn verify_parse_output_unsat_returns_proven() {
        let backend = ManticoreBackend::new();
        let (status, _, _) = backend.parse_output(r#"{"status":"unsat"}"#, "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_verified_returns_proven() {
        let backend = ManticoreBackend::new();
        let (status, _, _) = backend.parse_output(r#"{"status":"verified"}"#, "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_sat_returns_disproven() {
        let backend = ManticoreBackend::new();
        let (status, _, _) = backend.parse_output(r#"{"status":"sat","model":{}}"#, "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_bug_returns_disproven() {
        let backend = ManticoreBackend::new();
        let (status, _, _) = backend.parse_output(r#"{"status":"bug","model":{}}"#, "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_timeout_returns_unknown() {
        let backend = ManticoreBackend::new();
        let (status, _, _) = backend.parse_output(r#"{"status":"timeout"}"#, "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[kani::proof]
    fn verify_parse_output_no_status_returns_unknown() {
        let backend = ManticoreBackend::new();
        let (status, _, _) = backend.parse_output(r#"{"model":{}}"#, "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    // ===== parse_output counterexample proofs =====

    #[kani::proof]
    fn verify_parse_output_sat_has_counterexample() {
        let backend = ManticoreBackend::new();
        let (_, cex, _) = backend.parse_output(r#"{"status":"sat","model":{"x":1}}"#, "");
        assert!(cex.is_some());
    }

    #[kani::proof]
    fn verify_parse_output_unsat_no_counterexample() {
        let backend = ManticoreBackend::new();
        let (_, cex, _) = backend.parse_output(r#"{"status":"unsat"}"#, "");
        assert!(cex.is_none());
    }

    // ===== parse_output diagnostics proofs =====

    #[kani::proof]
    fn verify_parse_output_preserves_diagnostics() {
        let backend = ManticoreBackend::new();
        let (_, _, diag) = backend.parse_output(r#"{"status":"unsat","diagnostics":["msg1"]}"#, "");
        assert!(diag.len() == 1);
    }

    #[kani::proof]
    fn verify_parse_output_empty_diagnostics_default() {
        let backend = ManticoreBackend::new();
        let (_, _, diag) = backend.parse_output(r#"{"status":"unsat"}"#, "");
        assert!(diag.is_empty());
    }

    // ===== build_counterexample proofs =====

    #[kani::proof]
    fn verify_build_counterexample_empty_model() {
        let backend = ManticoreBackend::new();
        let model = std::collections::HashMap::new();
        let cex = backend.build_counterexample(&model, "raw");
        assert!(cex.witness.is_empty());
        assert!(cex.failed_checks.len() == 1);
    }

    #[kani::proof]
    fn verify_build_counterexample_preserves_raw() {
        let backend = ManticoreBackend::new();
        let model = std::collections::HashMap::new();
        let cex = backend.build_counterexample(&model, "raw_output");
        assert!(cex.raw == Some("raw_output".to_string()));
    }

    #[kani::proof]
    fn verify_build_counterexample_not_minimized() {
        let backend = ManticoreBackend::new();
        let model = std::collections::HashMap::new();
        let cex = backend.build_counterexample(&model, "");
        assert!(!cex.minimized);
    }

    #[kani::proof]
    fn verify_build_counterexample_empty_trace() {
        let backend = ManticoreBackend::new();
        let model = std::collections::HashMap::new();
        let cex = backend.build_counterexample(&model, "");
        assert!(cex.trace.is_empty());
    }

    #[kani::proof]
    fn verify_build_counterexample_no_playback_test() {
        let backend = ManticoreBackend::new();
        let model = std::collections::HashMap::new();
        let cex = backend.build_counterexample(&model, "");
        assert!(cex.playback_test.is_none());
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};
    use std::collections::HashMap;

    #[test]
    fn backend_id() {
        assert_eq!(ManticoreBackend::new().id(), BackendId::Manticore);
    }

    #[test]
    fn script_includes_properties() {
        let backend = ManticoreBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "safety".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let script = backend.generate_script(&spec);
        assert!(script.contains("safety"));
        assert!(script.contains("Manticore symbolic execution harness"));
    }

    #[test]
    fn parse_sat_counterexample() {
        let backend = ManticoreBackend::new();
        let stdout = r#"{"status":"sat","model":{"x":10,"y":5},"diagnostics":["found"]}"#;
        let (status, cex, diag) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("counterexample expected");
        assert_eq!(
            ce.witness["x"],
            CounterexampleValue::Int {
                value: 10,
                type_hint: None
            }
        );
        assert_eq!(diag, vec!["found".to_string()]);
    }

    #[test]
    fn parse_unsat_verified() {
        let backend = ManticoreBackend::new();
        let stdout = r#"{"status":"unsat","diagnostics":["safe"]}"#;
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_unknown_output() {
        let backend = ManticoreBackend::new();
        let stdout = "not json";
        let (status, _, _) = backend.parse_output(stdout, "failure");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }
}
