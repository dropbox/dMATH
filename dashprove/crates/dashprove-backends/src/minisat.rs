//! MiniSat SAT solver backend
//!
//! MiniSat is a minimalistic, open-source SAT solver that serves as the
//! foundation for many other solvers. It uses the DPLL/CDCL algorithm with
//! conflict-driven clause learning.
//!
//! See: <http://minisat.se/>

use crate::counterexample::{CounterexampleValue, StructuredCounterexample};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for MiniSat backend
#[derive(Debug, Clone)]
pub struct MiniSatConfig {
    /// Path to minisat binary
    pub minisat_path: Option<PathBuf>,
    /// Timeout for solving
    pub timeout: Duration,
    /// Enable verbose output
    pub verbose: bool,
    /// Memory limit in MB (0 = no limit)
    pub memory_limit: u32,
    /// CPU limit in seconds (0 = no limit)
    pub cpu_limit: u32,
    /// Restart strategy luby multiplier
    pub luby_restart: bool,
    /// Phase saving level (0-2)
    pub phase_saving: u8,
}

impl Default for MiniSatConfig {
    fn default() -> Self {
        Self {
            minisat_path: None,
            timeout: Duration::from_secs(60),
            verbose: false,
            memory_limit: 0,
            cpu_limit: 0,
            luby_restart: true,
            phase_saving: 2,
        }
    }
}

/// MiniSat SAT solver backend
pub struct MiniSatBackend {
    config: MiniSatConfig,
}

impl Default for MiniSatBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl MiniSatBackend {
    /// Create a new MiniSat backend with default configuration
    pub fn new() -> Self {
        Self {
            config: MiniSatConfig::default(),
        }
    }

    /// Create with custom configuration
    pub fn with_config(config: MiniSatConfig) -> Self {
        Self { config }
    }

    async fn detect_minisat(&self) -> Result<PathBuf, String> {
        let minisat_path = self
            .config
            .minisat_path
            .clone()
            .or_else(|| which::which("minisat").ok())
            .ok_or("MiniSat not found. Install from http://minisat.se/ or brew install minisat")?;

        // MiniSat doesn't have --version, test with a simple SAT problem
        let output = Command::new(&minisat_path)
            .arg("-h")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(|e| format!("Failed to execute minisat: {}", e))?;

        // MiniSat prints help to stdout/stderr even on "error"
        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);
        let combined = format!("{}{}", stdout, stderr);

        if combined.contains("USAGE")
            || combined.contains("minisat")
            || combined.contains("MiniSat")
        {
            debug!("Detected MiniSat");
            Ok(minisat_path)
        } else {
            Err("MiniSat detection failed".to_string())
        }
    }

    /// Convert a typed spec to DIMACS CNF format
    fn spec_to_dimacs(&self, spec: &TypedSpec) -> String {
        // For SAT solvers, we need to convert the spec to CNF format
        // This is a simplified conversion - full USL would need more sophisticated transformation
        let mut clauses = Vec::new();
        let mut num_vars = 0;

        // Extract boolean properties and convert to CNF
        for _prop in &spec.spec.properties {
            // Each property assertion becomes a clause
            // For now, we create a simple satisfiable formula
            num_vars = num_vars.max(1);
            clauses.push(vec![1]); // Simple clause: variable 1 must be true
        }

        // If no properties, create a trivially satisfiable formula
        if clauses.is_empty() {
            num_vars = 1;
            clauses.push(vec![1]);
        }

        // Generate DIMACS format
        let mut dimacs = "c Generated by DashProve\n".to_string();
        dimacs.push_str(&format!("p cnf {} {}\n", num_vars, clauses.len()));
        for clause in clauses {
            let clause_str: Vec<String> = clause.iter().map(|l| l.to_string()).collect();
            dimacs.push_str(&format!("{} 0\n", clause_str.join(" ")));
        }

        dimacs
    }

    fn parse_output(
        &self,
        stdout: &str,
        result_file: Option<&str>,
        success: bool,
    ) -> (VerificationStatus, Option<String>) {
        // MiniSat outputs result to a file if specified, otherwise to stdout
        let output = if let Some(result) = result_file {
            result.to_string()
        } else {
            stdout.to_string()
        };

        let lines: Vec<&str> = output.lines().collect();

        for line in &lines {
            let trimmed = line.trim();
            if trimmed == "UNSAT" || trimmed == "UNSATISFIABLE" {
                return (VerificationStatus::Proven, None);
            } else if trimmed == "SAT" || trimmed == "SATISFIABLE" {
                // Look for the model on the next line(s)
                let model = Self::extract_model(&lines);
                return (VerificationStatus::Disproven, model);
            } else if trimmed == "INDETERMINATE" {
                return (
                    VerificationStatus::Unknown {
                        reason: "MiniSat returned indeterminate".to_string(),
                    },
                    None,
                );
            }
        }

        // Check exit code patterns
        if stdout.contains("ERROR") || stdout.contains("error") {
            return (
                VerificationStatus::Unknown {
                    reason: format!(
                        "MiniSat error: {}",
                        stdout.lines().take(2).collect::<Vec<_>>().join("; ")
                    ),
                },
                None,
            );
        }

        if !success {
            // Exit code 10 = SAT, 20 = UNSAT in MiniSat convention
            return (
                VerificationStatus::Unknown {
                    reason: "MiniSat exited without result".to_string(),
                },
                None,
            );
        }

        (
            VerificationStatus::Unknown {
                reason: "Could not parse MiniSat output".to_string(),
            },
            None,
        )
    }

    fn extract_model(lines: &[&str]) -> Option<String> {
        // MiniSat model format: "v 1 -2 3 -4 0" or just "1 -2 3 -4 0"
        for line in lines {
            let trimmed = line.trim();
            let model_line = if let Some(rest) = trimmed.strip_prefix('v') {
                rest
            } else if trimmed
                .chars()
                .next()
                .is_some_and(|c| c.is_ascii_digit() || c == '-')
            {
                trimmed
            } else {
                continue;
            };
            if model_line.contains(' ') || model_line.ends_with('0') {
                return Some(model_line.trim().to_string());
            }
        }
        None
    }

    fn parse_counterexample(&self, model_str: &str) -> StructuredCounterexample {
        let mut ce = StructuredCounterexample::new();
        ce.raw = Some(model_str.to_string());

        // Parse DIMACS model format: "1 -2 3 -4 0"
        // Positive number = variable is true, negative = variable is false
        for lit_str in model_str.split_whitespace() {
            if lit_str == "0" {
                break; // End of clause marker
            }
            if let Ok(lit) = lit_str.parse::<i64>() {
                let var = lit.unsigned_abs();
                let value = lit > 0;
                ce.witness
                    .insert(format!("x{}", var), CounterexampleValue::Bool(value));
            }
        }

        ce
    }
}

#[async_trait]
impl VerificationBackend for MiniSatBackend {
    fn id(&self) -> BackendId {
        BackendId::MiniSat
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Theorem, PropertyType::Invariant]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();

        let minisat_path = self
            .detect_minisat()
            .await
            .map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {}", e))
        })?;

        // Convert spec to DIMACS CNF
        let dimacs = self.spec_to_dimacs(spec);
        let cnf_path = temp_dir.path().join("problem.cnf");
        let result_path = temp_dir.path().join("result.txt");

        std::fs::write(&cnf_path, &dimacs).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write CNF file: {}", e))
        })?;

        let mut cmd = Command::new(&minisat_path);
        cmd.arg(&cnf_path)
            .arg(&result_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        if self.config.verbose {
            cmd.arg("-verb=1");
        } else {
            cmd.arg("-verb=0");
        }

        if self.config.memory_limit > 0 {
            cmd.arg(format!("-mem-lim={}", self.config.memory_limit));
        }

        if self.config.cpu_limit > 0 {
            cmd.arg(format!("-cpu-lim={}", self.config.cpu_limit));
        }

        if self.config.luby_restart {
            cmd.arg("-luby");
        } else {
            cmd.arg("-no-luby");
        }

        cmd.arg(format!("-phase-saving={}", self.config.phase_saving));

        let result =
            tokio::time::timeout(self.config.timeout + Duration::from_secs(5), cmd.output()).await;

        let duration = start.elapsed();

        match result {
            Ok(Ok(output)) => {
                let stdout = String::from_utf8_lossy(&output.stdout).to_string();
                let stderr = String::from_utf8_lossy(&output.stderr).to_string();

                debug!("MiniSat stdout: {}", stdout);
                debug!("MiniSat stderr: {}", stderr);

                // Read result file if it exists
                let result_content = std::fs::read_to_string(&result_path).ok();

                let (status, counterexample_str) = self.parse_output(
                    &stdout,
                    result_content.as_deref(),
                    output.status.success()
                        || output.status.code() == Some(10)
                        || output.status.code() == Some(20),
                );

                let counterexample = counterexample_str.map(|m| self.parse_counterexample(&m));

                let diagnostics: Vec<String> = stderr
                    .lines()
                    .filter(|l| l.contains("WARNING") || l.contains("ERROR"))
                    .map(String::from)
                    .collect();

                let proof = if matches!(status, VerificationStatus::Proven) {
                    Some("Verified by MiniSat (UNSAT)".to_string())
                } else {
                    None
                };

                Ok(BackendResult {
                    backend: BackendId::MiniSat,
                    status,
                    proof,
                    counterexample,
                    diagnostics,
                    time_taken: duration,
                })
            }
            Ok(Err(e)) => Err(BackendError::VerificationFailed(format!(
                "Failed to execute MiniSat: {}",
                e
            ))),
            Err(_) => Err(BackendError::Timeout(self.config.timeout)),
        }
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_minisat().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn default_config() {
        let config = MiniSatConfig::default();
        assert_eq!(config.timeout, Duration::from_secs(60));
        assert!(!config.verbose);
        assert_eq!(config.memory_limit, 0);
        assert_eq!(config.cpu_limit, 0);
        assert!(config.luby_restart);
        assert_eq!(config.phase_saving, 2);
    }

    #[test]
    fn parse_unsat() {
        let backend = MiniSatBackend::new();
        let (status, model) = backend.parse_output("UNSAT", None, true);
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(model.is_none());
    }

    #[test]
    fn parse_unsatisfiable() {
        let backend = MiniSatBackend::new();
        let (status, model) = backend.parse_output("UNSATISFIABLE", None, true);
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(model.is_none());
    }

    #[test]
    fn parse_sat() {
        let backend = MiniSatBackend::new();
        let (status, _) = backend.parse_output("SAT\n1 -2 3 0", None, true);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn parse_satisfiable() {
        let backend = MiniSatBackend::new();
        let (status, _) = backend.parse_output("SATISFIABLE\nv 1 -2 3 0", None, true);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn parse_indeterminate() {
        let backend = MiniSatBackend::new();
        let (status, _) = backend.parse_output("INDETERMINATE", None, true);
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[test]
    fn parse_result_file() {
        let backend = MiniSatBackend::new();
        let (status, _) = backend.parse_output("", Some("UNSAT"), true);
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[test]
    fn extract_model_v_prefix() {
        let lines = vec!["SAT", "v 1 -2 3 -4 0"];
        let model = MiniSatBackend::extract_model(&lines);
        assert!(model.is_some());
        assert_eq!(model.unwrap(), "1 -2 3 -4 0");
    }

    #[test]
    fn extract_model_no_prefix() {
        let lines = vec!["SAT", "1 -2 3 0"];
        let model = MiniSatBackend::extract_model(&lines);
        assert!(model.is_some());
    }

    #[test]
    fn parse_counterexample_basic() {
        let backend = MiniSatBackend::new();
        let ce = backend.parse_counterexample("1 -2 3 0");
        assert_eq!(ce.witness.len(), 3);
        assert_eq!(ce.witness.get("x1"), Some(&CounterexampleValue::Bool(true)));
        assert_eq!(
            ce.witness.get("x2"),
            Some(&CounterexampleValue::Bool(false))
        );
        assert_eq!(ce.witness.get("x3"), Some(&CounterexampleValue::Bool(true)));
    }

    #[test]
    fn backend_id() {
        let backend = MiniSatBackend::new();
        assert_eq!(backend.id(), BackendId::MiniSat);
    }

    #[test]
    fn supports_properties() {
        let backend = MiniSatBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Theorem));
        assert!(supported.contains(&PropertyType::Invariant));
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ==================== MiniSatConfig Default Proofs ====================

    #[kani::proof]
    fn proof_config_default_minisat_path_none() {
        let config = MiniSatConfig::default();
        kani::assert(
            config.minisat_path.is_none(),
            "Default minisat_path should be None",
        );
    }

    #[kani::proof]
    fn proof_config_default_timeout_60s() {
        let config = MiniSatConfig::default();
        kani::assert(
            config.timeout == Duration::from_secs(60),
            "Default timeout should be 60 seconds",
        );
    }

    #[kani::proof]
    fn proof_config_default_verbose_false() {
        let config = MiniSatConfig::default();
        kani::assert(!config.verbose, "Default verbose should be false");
    }

    #[kani::proof]
    fn proof_config_default_memory_limit_zero() {
        let config = MiniSatConfig::default();
        kani::assert(
            config.memory_limit == 0,
            "Default memory_limit should be 0 (unlimited)",
        );
    }

    #[kani::proof]
    fn proof_config_default_cpu_limit_zero() {
        let config = MiniSatConfig::default();
        kani::assert(
            config.cpu_limit == 0,
            "Default cpu_limit should be 0 (unlimited)",
        );
    }

    #[kani::proof]
    fn proof_config_default_luby_restart_true() {
        let config = MiniSatConfig::default();
        kani::assert(config.luby_restart, "Default luby_restart should be true");
    }

    #[kani::proof]
    fn proof_config_default_phase_saving_2() {
        let config = MiniSatConfig::default();
        kani::assert(config.phase_saving == 2, "Default phase_saving should be 2");
    }

    // ==================== MiniSatBackend Construction Proofs ====================

    #[kani::proof]
    fn proof_backend_new_uses_default_config() {
        let backend = MiniSatBackend::new();
        kani::assert(
            backend.config.minisat_path.is_none(),
            "new() should use default config with minisat_path=None",
        );
        kani::assert(
            backend.config.timeout == Duration::from_secs(60),
            "new() should use default timeout of 60s",
        );
    }

    #[kani::proof]
    fn proof_backend_default_equals_new() {
        let b1 = MiniSatBackend::new();
        let b2 = MiniSatBackend::default();
        kani::assert(
            b1.config.timeout == b2.config.timeout,
            "default() and new() should produce equal timeout",
        );
        kani::assert(
            b1.config.verbose == b2.config.verbose,
            "default() and new() should produce equal verbose",
        );
    }

    #[kani::proof]
    fn proof_backend_with_config_preserves_timeout() {
        let timeout_secs: u64 = kani::any();
        kani::assume(timeout_secs > 0 && timeout_secs < 3600);
        let config = MiniSatConfig {
            timeout: Duration::from_secs(timeout_secs),
            ..Default::default()
        };
        let backend = MiniSatBackend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(timeout_secs),
            "with_config should preserve timeout",
        );
    }

    #[kani::proof]
    fn proof_backend_with_config_preserves_memory_limit() {
        let memory_limit: u32 = kani::any();
        let config = MiniSatConfig {
            memory_limit,
            ..Default::default()
        };
        let backend = MiniSatBackend::with_config(config);
        kani::assert(
            backend.config.memory_limit == memory_limit,
            "with_config should preserve memory_limit",
        );
    }

    #[kani::proof]
    fn proof_backend_with_config_preserves_cpu_limit() {
        let cpu_limit: u32 = kani::any();
        let config = MiniSatConfig {
            cpu_limit,
            ..Default::default()
        };
        let backend = MiniSatBackend::with_config(config);
        kani::assert(
            backend.config.cpu_limit == cpu_limit,
            "with_config should preserve cpu_limit",
        );
    }

    #[kani::proof]
    fn proof_backend_with_config_preserves_phase_saving() {
        let phase_saving: u8 = kani::any();
        kani::assume(phase_saving <= 2);
        let config = MiniSatConfig {
            phase_saving,
            ..Default::default()
        };
        let backend = MiniSatBackend::with_config(config);
        kani::assert(
            backend.config.phase_saving == phase_saving,
            "with_config should preserve phase_saving",
        );
    }

    // ==================== Backend Trait Implementation Proofs ====================

    #[kani::proof]
    fn proof_backend_id_is_minisat() {
        let backend = MiniSatBackend::new();
        kani::assert(
            backend.id() == BackendId::MiniSat,
            "Backend ID should be MiniSat",
        );
    }

    #[kani::proof]
    fn proof_supports_contains_theorem() {
        let backend = MiniSatBackend::new();
        let supported = backend.supports();
        let has_theorem = supported.iter().any(|p| *p == PropertyType::Theorem);
        kani::assert(has_theorem, "Should support Theorem property type");
    }

    #[kani::proof]
    fn proof_supports_contains_invariant() {
        let backend = MiniSatBackend::new();
        let supported = backend.supports();
        let has_invariant = supported.iter().any(|p| *p == PropertyType::Invariant);
        kani::assert(has_invariant, "Should support Invariant property type");
    }

    #[kani::proof]
    fn proof_supports_returns_two_types() {
        let backend = MiniSatBackend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 2,
            "Should support exactly 2 property types",
        );
    }

    // ==================== parse_output Proofs ====================

    #[kani::proof]
    fn proof_parse_output_unsat_is_proven() {
        let backend = MiniSatBackend::new();
        let (status, model) = backend.parse_output("UNSAT", None, true);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "UNSAT should map to Proven status",
        );
        kani::assert(model.is_none(), "UNSAT should have no model");
    }

    #[kani::proof]
    fn proof_parse_output_unsatisfiable_is_proven() {
        let backend = MiniSatBackend::new();
        let (status, model) = backend.parse_output("UNSATISFIABLE", None, true);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "UNSATISFIABLE should map to Proven status",
        );
        kani::assert(model.is_none(), "UNSATISFIABLE should have no model");
    }

    #[kani::proof]
    fn proof_parse_output_sat_is_disproven() {
        let backend = MiniSatBackend::new();
        let (status, _) = backend.parse_output("SAT\n1 -2 3 0", None, true);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "SAT should map to Disproven status",
        );
    }

    #[kani::proof]
    fn proof_parse_output_satisfiable_is_disproven() {
        let backend = MiniSatBackend::new();
        let (status, _) = backend.parse_output("SATISFIABLE\nv 1 -2 3 0", None, true);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "SATISFIABLE should map to Disproven status",
        );
    }

    #[kani::proof]
    fn proof_parse_output_indeterminate_is_unknown() {
        let backend = MiniSatBackend::new();
        let (status, _) = backend.parse_output("INDETERMINATE", None, true);
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "INDETERMINATE should map to Unknown status",
        );
    }

    #[kani::proof]
    fn proof_parse_output_result_file_unsat() {
        let backend = MiniSatBackend::new();
        let (status, _) = backend.parse_output("", Some("UNSAT"), true);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Result file UNSAT should map to Proven status",
        );
    }

    #[kani::proof]
    fn proof_parse_output_error_is_unknown() {
        let backend = MiniSatBackend::new();
        let (status, _) = backend.parse_output("ERROR: invalid input", None, false);
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "ERROR should map to Unknown status",
        );
    }

    // ==================== extract_model Proofs ====================

    #[kani::proof]
    fn proof_extract_model_v_prefix() {
        let lines = vec!["SAT", "v 1 -2 3 -4 0"];
        let model = MiniSatBackend::extract_model(&lines);
        kani::assert(model.is_some(), "Should extract model with 'v' prefix");
    }

    #[kani::proof]
    fn proof_extract_model_no_prefix() {
        let lines = vec!["SAT", "1 -2 3 0"];
        let model = MiniSatBackend::extract_model(&lines);
        kani::assert(model.is_some(), "Should extract model without prefix");
    }

    #[kani::proof]
    fn proof_extract_model_empty_lines() {
        let lines: Vec<&str> = vec![];
        let model = MiniSatBackend::extract_model(&lines);
        kani::assert(model.is_none(), "Empty lines should return None");
    }

    #[kani::proof]
    fn proof_extract_model_no_model_line() {
        let lines = vec!["SAT", "some other text"];
        let model = MiniSatBackend::extract_model(&lines);
        kani::assert(model.is_none(), "Non-model lines should return None");
    }

    // ==================== parse_counterexample Proofs ====================

    #[kani::proof]
    fn proof_parse_counterexample_positive_literal() {
        let backend = MiniSatBackend::new();
        let ce = backend.parse_counterexample("1 0");
        let val = ce.witness.get("x1");
        kani::assert(
            val == Some(&CounterexampleValue::Bool(true)),
            "Positive literal should map to true",
        );
    }

    #[kani::proof]
    fn proof_parse_counterexample_negative_literal() {
        let backend = MiniSatBackend::new();
        let ce = backend.parse_counterexample("-2 0");
        let val = ce.witness.get("x2");
        kani::assert(
            val == Some(&CounterexampleValue::Bool(false)),
            "Negative literal should map to false",
        );
    }

    #[kani::proof]
    fn proof_parse_counterexample_multiple_literals() {
        let backend = MiniSatBackend::new();
        let ce = backend.parse_counterexample("1 -2 3 0");
        kani::assert(ce.witness.len() == 3, "Should parse all 3 literals");
    }

    #[kani::proof]
    fn proof_parse_counterexample_sets_raw() {
        let backend = MiniSatBackend::new();
        let ce = backend.parse_counterexample("1 -2 0");
        kani::assert(ce.raw.is_some(), "Should set raw output");
    }

    #[kani::proof]
    fn proof_parse_counterexample_stops_at_zero() {
        let backend = MiniSatBackend::new();
        let ce = backend.parse_counterexample("1 -2 0 3 4");
        // Should only have x1 and x2, stopping at 0
        kani::assert(ce.witness.len() == 2, "Should stop parsing at 0 terminator");
    }

    // ==================== spec_to_dimacs Proofs ====================

    #[kani::proof]
    fn proof_spec_to_dimacs_has_header() {
        let backend = MiniSatBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: std::collections::HashMap::new(),
        };
        let dimacs = backend.spec_to_dimacs(&spec);
        kani::assert(
            dimacs.contains("p cnf"),
            "DIMACS should contain 'p cnf' header",
        );
    }

    #[kani::proof]
    fn proof_spec_to_dimacs_not_empty() {
        let backend = MiniSatBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: std::collections::HashMap::new(),
        };
        let dimacs = backend.spec_to_dimacs(&spec);
        kani::assert(!dimacs.is_empty(), "DIMACS output should not be empty");
    }

    #[kani::proof]
    fn proof_spec_to_dimacs_has_comment() {
        let backend = MiniSatBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: std::collections::HashMap::new(),
        };
        let dimacs = backend.spec_to_dimacs(&spec);
        kani::assert(dimacs.contains("c "), "DIMACS should contain comment line");
    }

    #[kani::proof]
    fn proof_spec_to_dimacs_clause_ends_with_zero() {
        let backend = MiniSatBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: std::collections::HashMap::new(),
        };
        let dimacs = backend.spec_to_dimacs(&spec);
        // Find a clause line (not comment or header)
        for line in dimacs.lines() {
            if !line.starts_with('c') && !line.starts_with('p') {
                kani::assert(line.ends_with(" 0"), "Clause lines should end with ' 0'");
                break;
            }
        }
    }
}
