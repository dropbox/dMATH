//! Project generation for Kani backend
//!
//! Functions for creating temporary Rust projects with Kani proof harnesses.

use crate::traits::BackendError;
use dashprove_usl::{compile_to_kani, typecheck::TypedSpec};
use std::fs;
use std::path::{Path, PathBuf};
use tempfile::TempDir;
use toml::Value;

/// Read the package name from Cargo.toml (workspace manifests are unsupported)
pub fn read_package_name(manifest_path: &Path) -> Result<String, BackendError> {
    let manifest_content = fs::read_to_string(manifest_path).map_err(|e| {
        BackendError::Unavailable(format!("Failed to read {}: {}", manifest_path.display(), e))
    })?;

    let parsed: Value = toml::from_str(&manifest_content).map_err(|e| {
        BackendError::Unavailable(format!(
            "Invalid Cargo.toml at {}: {}",
            manifest_path.display(),
            e
        ))
    })?;

    parsed
        .get("package")
        .and_then(|p| p.get("name"))
        .and_then(|n| n.as_str())
        .map(|s| s.to_string())
        .ok_or_else(|| {
            BackendError::Unavailable(
                "Cargo.toml missing package.name (workspace manifests are unsupported)".into(),
            )
        })
}

/// Inject an import for the target crate into generated harness code
pub fn inject_project_import(code: &str, crate_ident: &str) -> String {
    let use_stmt = format!("use {}::*;\n", crate_ident);
    if code.contains("#![allow(unused)]") {
        code.replacen(
            "#![allow(unused)]",
            &format!("#![allow(unused)]\n{}", use_stmt),
            1,
        )
    } else {
        format!("{}\n{}", use_stmt, code)
    }
}

/// Write a temporary harness crate that depends on the target project
pub async fn write_harness_project(
    spec: &TypedSpec,
    project_dir: &Path,
    package_name: &str,
    crate_ident: &str,
) -> Result<(TempDir, PathBuf), BackendError> {
    let compiled = compile_to_kani(spec);
    let harness_code = inject_project_import(&compiled.code, crate_ident);

    let temp_dir = TempDir::new().map_err(|e| {
        BackendError::CompilationFailed(format!("Failed to create temp dir: {}", e))
    })?;

    let manifest_path = temp_dir.path().join("Cargo.toml");
    let src_dir = temp_dir.path().join("src");
    tokio::fs::create_dir_all(&src_dir)
        .await
        .map_err(|e| BackendError::CompilationFailed(format!("Failed to create src dir: {}", e)))?;

    let manifest = format!(
        r#"[package]
name = "dashprove-kani-harness"
version = "0.1.0"
edition = "2021"

[dependencies]
{package} = {{ path = "{path}" }}
"#,
        package = package_name,
        path = project_dir.display(),
    );

    tokio::fs::write(&manifest_path, manifest)
        .await
        .map_err(|e| {
            BackendError::CompilationFailed(format!("Failed to write Cargo.toml: {}", e))
        })?;

    tokio::fs::write(src_dir.join("lib.rs"), harness_code)
        .await
        .map_err(|e| {
            BackendError::CompilationFailed(format!("Failed to write harness code: {}", e))
        })?;

    Ok((temp_dir, manifest_path))
}

/// Write a self-contained temporary crate with user code and generated harnesses
///
/// This is used by `verify_code` to verify inline Rust code against USL contracts
/// without requiring an external project directory.
pub async fn write_inline_project(
    code: &str,
    spec: &TypedSpec,
) -> Result<(TempDir, PathBuf), BackendError> {
    let compiled = compile_to_kani(spec);

    // Strip the header comments and #![allow(unused)] from harness code
    // since we'll be embedding it in the user's code
    let harness_code = compiled
        .code
        .lines()
        .filter(|line| !line.starts_with("//") && !line.starts_with("#![allow"))
        .collect::<Vec<_>>()
        .join("\n")
        .trim()
        .to_string();

    let temp_dir = TempDir::new().map_err(|e| {
        BackendError::CompilationFailed(format!("Failed to create temp dir: {}", e))
    })?;

    let manifest_path = temp_dir.path().join("Cargo.toml");
    let src_dir = temp_dir.path().join("src");
    tokio::fs::create_dir_all(&src_dir)
        .await
        .map_err(|e| BackendError::CompilationFailed(format!("Failed to create src dir: {}", e)))?;

    // Minimal Cargo.toml for standalone verification
    let manifest = r#"[package]
name = "dashprove-kani-verify"
version = "0.1.0"
edition = "2021"
"#;

    tokio::fs::write(&manifest_path, manifest)
        .await
        .map_err(|e| {
            BackendError::CompilationFailed(format!("Failed to write Cargo.toml: {}", e))
        })?;

    // Combine user code with generated harnesses
    let combined_code = format!(
        r#"// Generated by DashProve verify_code
#![allow(unused)]

// User code
{code}

// Generated Kani proof harnesses
{harness_code}
"#,
        code = code,
        harness_code = harness_code
    );

    tokio::fs::write(src_dir.join("lib.rs"), combined_code)
        .await
        .map_err(|e| {
            BackendError::CompilationFailed(format!("Failed to write combined code: {}", e))
        })?;

    Ok((temp_dir, manifest_path))
}
