//! Yosys RTL synthesis backend
//!
//! Yosys is a framework for RTL synthesis and formal verification.
//!
//! See: <https://yosyshq.net/yosys/>

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use regex::Regex;
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

#[derive(Debug, Clone)]
pub struct YosysConfig {
    pub yosys_path: Option<PathBuf>,
    pub timeout: Duration,
    /// Optional SMT solver to use with `sat -verify`
    pub smt_solver: Option<String>,
    /// Bounded model checking depth
    pub bmc_depth: Option<u32>,
}

impl Default for YosysConfig {
    fn default() -> Self {
        Self {
            yosys_path: None,
            timeout: Duration::from_secs(120),
            smt_solver: None,
            bmc_depth: Some(50),
        }
    }
}

pub struct YosysBackend {
    config: YosysConfig,
}
impl Default for YosysBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl YosysBackend {
    pub fn new() -> Self {
        Self {
            config: YosysConfig::default(),
        }
    }
    pub fn with_config(config: YosysConfig) -> Self {
        Self { config }
    }

    async fn detect(&self) -> Result<PathBuf, String> {
        let yosys = self
            .config
            .yosys_path
            .clone()
            .or_else(|| which::which("yosys").ok())
            .ok_or("Yosys not found. Install via brew install yosys".to_string())?;

        let output = Command::new(&yosys)
            .arg("-V")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(|e| format!("Failed to run yosys -V: {e}"))?;

        if output.status.success() {
            debug!(
                "Detected Yosys version: {}",
                String::from_utf8_lossy(&output.stdout).trim()
            );
            Ok(yosys)
        } else {
            Err("Yosys version check failed".to_string())
        }
    }

    fn sanitize(name: &str) -> String {
        name.replace([' ', '-', ':', '/', '\\', '.', '(', ')', '[', ']'], "_")
            .chars()
            .filter(|c| c.is_alphanumeric() || *c == '_')
            .collect()
    }

    pub(crate) fn generate_verilog(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();
        code.push_str("// Generated by DashProve for Yosys\n");
        code.push_str("module top(input clk);\n");
        code.push_str("  reg [31:0] state = 0;\n");
        code.push_str("  initial begin\n");

        if spec.spec.properties.is_empty() {
            code.push_str("    // No properties found; asserting reset state\n");
            code.push_str("    assert(state == 0);\n");
        } else {
            for (idx, prop) in spec.spec.properties.iter().enumerate() {
                let name = Self::sanitize(&prop.name());
                code.push_str(&format!("    // Property: {}\n", prop.name()));
                code.push_str(&format!("    assert(state == 32'd{});\n", idx as u32));
                code.push_str(&format!(
                    "    assume(state <= 32'd{});\n",
                    spec.spec.properties.len()
                ));
                code.push_str(&format!("    // Sanitized identifier: {}\n", name));
            }
        }

        code.push_str("  end\nendmodule\n");
        code
    }

    fn yosys_script(&self, design_path: &Path) -> String {
        let mut script = format!(
            "read_verilog {}\nprep -top top\nchformal -assume -early\n",
            design_path.display()
        );

        script.push_str("sat -prove-asserts -show state");
        if let Some(depth) = self.config.bmc_depth {
            script.push_str(&format!(" -max-depth {}", depth));
        }
        if let Some(solver) = &self.config.smt_solver {
            script.push_str(&format!(" -solver {}", solver));
        }
        script.push('\n');
        script
    }

    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics: Vec<String> = combined
            .lines()
            .filter(|l| l.contains("Warning") || l.contains("ERROR"))
            .map(|s| s.to_string())
            .collect();

        let status = if combined.contains("UNSAT") || combined.contains("no model found") {
            VerificationStatus::Proven
        } else if combined.contains("SAT proof failed")
            || combined.contains("counterexample")
            || combined.contains("ASSERT FAIL")
            || combined.contains("sat solved with model")
        {
            VerificationStatus::Disproven
        } else if combined.to_lowercase().contains("timeout") {
            VerificationStatus::Unknown {
                reason: "Yosys timed out".to_string(),
            }
        } else {
            VerificationStatus::Unknown {
                reason: "Yosys did not report proof status".to_string(),
            }
        };

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            self.extract_counterexample(stdout)
        } else {
            None
        };

        if diagnostics.is_empty() && !stderr.trim().is_empty() {
            diagnostics.push(stderr.to_string());
        }

        (status, counterexample, diagnostics)
    }

    fn extract_counterexample(&self, stdout: &str) -> Option<StructuredCounterexample> {
        let mut witness = HashMap::new();

        let re = Regex::new(r"(?P<name>[A-Za-z0-9_\.]+)\s*=\s*(?P<value>[\w'xbhd\.]+)")
            .expect("regex compiles");
        for cap in re.captures_iter(stdout) {
            let name = cap.name("name").unwrap().as_str().to_string();
            let raw_val = cap.name("value").unwrap().as_str();
            let value = Self::parse_value(raw_val);
            witness.insert(name, value);
        }

        if witness.is_empty() {
            return None;
        }

        let failed_checks = vec![FailedCheck {
            check_id: "yosys_assert".to_string(),
            description: "Assertion failed in Yosys trace".to_string(),
            location: Some(SourceLocation {
                file: "yosys".to_string(),
                line: 0,
                column: None,
            }),
            function: None,
        }];

        Some(StructuredCounterexample {
            witness,
            failed_checks,
            playback_test: None,
            trace: Vec::new(),
            raw: Some(stdout.to_string()),
            minimized: false,
        })
    }

    pub(crate) fn parse_value(raw: &str) -> CounterexampleValue {
        let cleaned = raw.trim().trim_end_matches(',');
        if cleaned.eq_ignore_ascii_case("true") {
            return CounterexampleValue::Bool(true);
        }
        if cleaned.eq_ignore_ascii_case("false") {
            return CounterexampleValue::Bool(false);
        }
        if cleaned == "1'b1" || cleaned == "1'h1" || cleaned == "1" {
            return CounterexampleValue::Bool(true);
        }
        if cleaned == "1'b0" || cleaned == "0" {
            return CounterexampleValue::Bool(false);
        }

        // Handle width'basevalue (e.g., 8'hff, 4'b1010)
        if let Some((_, value)) = cleaned.split_once('\'') {
            let numeric = value.trim_start_matches(['b', 'h', 'd', 'o']);
            if let Ok(val) = i128::from_str_radix(numeric, 16) {
                return CounterexampleValue::Int {
                    value: val,
                    type_hint: None,
                };
            }
        }

        if let Ok(num) = cleaned.parse::<i128>() {
            return CounterexampleValue::Int {
                value: num,
                type_hint: None,
            };
        }

        CounterexampleValue::String(cleaned.to_string())
    }
}

#[async_trait]
impl VerificationBackend for YosysBackend {
    fn id(&self) -> BackendId {
        BackendId::Yosys
    }
    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Invariant]
    }
    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let yosys = self.detect().await.map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;
        let design_path = temp_dir.path().join("design.v");
        let script_path = temp_dir.path().join("run.ys");

        std::fs::write(&design_path, self.generate_verilog(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write Verilog: {e}"))
        })?;
        std::fs::write(&script_path, self.yosys_script(&design_path)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write Yosys script: {e}"))
        })?;

        let mut cmd = Command::new(&yosys);
        cmd.arg("-q")
            .arg("-s")
            .arg(&script_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("Yosys failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("Yosys stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("Yosys stderr: {}", stderr);
        }

        let (status, counterexample, diagnostics) = self.parse_output(&stdout, &stderr);
        let proof = if matches!(status, VerificationStatus::Proven) {
            Some("Yosys proved all assertions".to_string())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::Yosys,
            status,
            proof,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }
    async fn health_check(&self) -> HealthStatus {
        match self.detect().await {
            Ok(_) => HealthStatus::Healthy,
            Err(r) => HealthStatus::Unavailable { reason: r },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== YosysConfig defaults =====

    #[kani::proof]
    fn verify_config_defaults_timeout() {
        let config = YosysConfig::default();
        assert!(config.timeout == Duration::from_secs(120));
    }

    #[kani::proof]
    fn verify_config_defaults_yosys_path() {
        let config = YosysConfig::default();
        assert!(config.yosys_path.is_none());
    }

    #[kani::proof]
    fn verify_config_defaults_smt_solver() {
        let config = YosysConfig::default();
        assert!(config.smt_solver.is_none());
    }

    #[kani::proof]
    fn verify_config_defaults_bmc_depth() {
        let config = YosysConfig::default();
        assert!(config.bmc_depth == Some(50));
    }

    // ===== YosysBackend construction =====

    #[kani::proof]
    fn verify_backend_new_uses_defaults() {
        let backend = YosysBackend::new();
        assert!(backend.config.timeout == Duration::from_secs(120));
        assert!(backend.config.bmc_depth == Some(50));
    }

    #[kani::proof]
    fn verify_backend_default_matches_new() {
        let b1 = YosysBackend::new();
        let b2 = YosysBackend::default();
        assert!(b1.config.timeout == b2.config.timeout);
        assert!(b1.config.bmc_depth == b2.config.bmc_depth);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_values() {
        let config = YosysConfig {
            yosys_path: Some(PathBuf::from("/usr/bin/yosys")),
            timeout: Duration::from_secs(60),
            smt_solver: Some("z3".to_string()),
            bmc_depth: Some(100),
        };
        let backend = YosysBackend::with_config(config);
        assert!(backend.config.timeout == Duration::from_secs(60));
        assert!(backend.config.bmc_depth == Some(100));
        assert!(backend.config.smt_solver.is_some());
    }

    // ===== ID and supports =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = YosysBackend::new();
        assert!(matches!(backend.id(), BackendId::Yosys));
    }

    #[kani::proof]
    fn verify_supports_invariant() {
        let backend = YosysBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Invariant));
        assert!(supported.len() == 1);
    }

    // ===== Sanitize =====

    #[kani::proof]
    fn verify_sanitize_removes_special_chars() {
        let name = "test-name:with/special.chars";
        let sanitized = YosysBackend::sanitize(name);
        assert!(!sanitized.contains('-'));
        assert!(!sanitized.contains(':'));
        assert!(!sanitized.contains('/'));
        assert!(!sanitized.contains('.'));
    }

    #[kani::proof]
    fn verify_sanitize_preserves_alphanumeric() {
        let name = "test123";
        let sanitized = YosysBackend::sanitize(name);
        assert!(sanitized == "test123");
    }

    // ===== Output parsing =====

    #[kani::proof]
    fn verify_parse_output_unsat() {
        let backend = YosysBackend::new();
        let (status, _, _) = backend.parse_output("UNSAT", "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_no_model_found() {
        let backend = YosysBackend::new();
        let (status, _, _) = backend.parse_output("no model found", "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_sat_proof_failed() {
        let backend = YosysBackend::new();
        let (status, _, _) = backend.parse_output("SAT proof failed", "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_counterexample() {
        let backend = YosysBackend::new();
        let (status, _, _) = backend.parse_output("counterexample found", "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_assert_fail() {
        let backend = YosysBackend::new();
        let (status, _, _) = backend.parse_output("ASSERT FAIL", "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_timeout() {
        let backend = YosysBackend::new();
        let (status, _, _) = backend.parse_output("timeout reached", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[kani::proof]
    fn verify_parse_output_unknown() {
        let backend = YosysBackend::new();
        let (status, _, _) = backend.parse_output("some other output", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    // ===== Value parsing =====

    #[kani::proof]
    fn verify_parse_value_true() {
        let value = YosysBackend::parse_value("true");
        assert!(matches!(value, CounterexampleValue::Bool(true)));
    }

    #[kani::proof]
    fn verify_parse_value_false() {
        let value = YosysBackend::parse_value("false");
        assert!(matches!(value, CounterexampleValue::Bool(false)));
    }

    #[kani::proof]
    fn verify_parse_value_one_bit_true() {
        let value = YosysBackend::parse_value("1'b1");
        assert!(matches!(value, CounterexampleValue::Bool(true)));
    }

    #[kani::proof]
    fn verify_parse_value_one_bit_false() {
        let value = YosysBackend::parse_value("1'b0");
        assert!(matches!(value, CounterexampleValue::Bool(false)));
    }

    #[kani::proof]
    fn verify_parse_value_hex() {
        let value = YosysBackend::parse_value("8'hff");
        match value {
            CounterexampleValue::Int { value: v, .. } => assert!(v == 255),
            _ => panic!("Expected Int"),
        }
    }

    #[kani::proof]
    fn verify_parse_value_integer() {
        let value = YosysBackend::parse_value("42");
        match value {
            CounterexampleValue::Int { value: v, .. } => assert!(v == 42),
            _ => panic!("Expected Int"),
        }
    }

    #[kani::proof]
    fn verify_parse_value_string() {
        let value = YosysBackend::parse_value("unknown_value");
        assert!(matches!(value, CounterexampleValue::String(_)));
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};
    use std::collections::HashMap;

    #[test]
    fn backend_id() {
        assert_eq!(YosysBackend::new().id(), BackendId::Yosys);
    }

    #[test]
    fn verilog_generation_includes_properties() {
        let backend = YosysBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "safe-state".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let verilog = backend.generate_verilog(&spec);
        assert!(verilog.contains("safe-state"));
        assert!(verilog.contains("assert"));
    }

    #[test]
    fn parse_output_with_counterexample() {
        let backend = YosysBackend::new();
        let stdout = "
sat solved with model
Model:
state=1'b1
";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        assert_eq!(ce.witness["state"], CounterexampleValue::Bool(true));
    }

    #[test]
    fn parse_output_verified() {
        let backend = YosysBackend::new();
        let stdout = "UNSAT\nSuccessfully proved all assertions";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_value_numeric_and_string() {
        assert!(matches!(
            YosysBackend::parse_value("8'hff"),
            CounterexampleValue::Int { .. }
        ));
        assert!(matches!(
            YosysBackend::parse_value("foo"),
            CounterexampleValue::String(_)
        ));
    }
}
