//! VCC (Verifier for Concurrent C) backend
//!
//! VCC is a mechanical verifier for concurrent C programs from Microsoft Research.
//! It verifies function contracts, invariants, and absence of data races using
//! the Boogie intermediate verification language and Z3 SMT solver.
//!
//! See: <https://github.com/microsoft/vcc>

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use regex::Regex;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for VCC backend
#[derive(Debug, Clone)]
pub struct VccConfig {
    pub vcc_path: Option<PathBuf>,
    pub timeout: Duration,
    /// Z3 timeout for individual queries
    pub z3_timeout: u32,
    /// Verify concurrent programs
    pub verify_concurrency: bool,
}

impl Default for VccConfig {
    fn default() -> Self {
        Self {
            vcc_path: None,
            timeout: Duration::from_secs(120),
            z3_timeout: 30,
            verify_concurrency: true,
        }
    }
}

/// VCC C verifier backend
pub struct VccBackend {
    config: VccConfig,
}

impl Default for VccBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl VccBackend {
    pub fn new() -> Self {
        Self {
            config: VccConfig::default(),
        }
    }
    pub fn with_config(config: VccConfig) -> Self {
        Self { config }
    }

    async fn detect_vcc(&self) -> Result<PathBuf, String> {
        let vcc = self
            .config
            .vcc_path
            .clone()
            .or_else(|| which::which("vcc").ok())
            .or_else(|| which::which("vcc.exe").ok())
            .ok_or("VCC not found. Download from https://github.com/microsoft/vcc".to_string())?;

        // Check version
        let output = Command::new(&vcc)
            .arg("/version")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(|e| format!("Failed to run vcc /version: {e}"))?;

        if output.status.success() {
            debug!(
                "Detected VCC version: {}",
                String::from_utf8_lossy(&output.stdout).trim()
            );
            Ok(vcc)
        } else {
            // VCC may not support /version, check if binary exists
            Ok(vcc)
        }
    }

    /// Generate annotated C code from the spec for VCC verification
    fn generate_vcc_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();
        code.push_str("// Generated by DashProve for VCC verification\n");
        code.push_str("#include <vcc.h>\n\n");

        // VCC uses requires/ensures/invariant annotations
        code.push_str("int state;\n\n");

        // Generate invariants
        if spec.spec.properties.is_empty() {
            code.push_str("_(invariant state >= 0)\n");
        } else {
            for prop in &spec.spec.properties {
                code.push_str(&format!("// Property: {}\n", prop.name()));
                code.push_str(&format!("_(invariant state >= 0)  // {}\n", prop.name()));
            }
        }

        // Generate a main function with contracts
        code.push_str("\nvoid main()\n");
        code.push_str("  _(requires state == 0)\n");
        code.push_str("  _(ensures state >= 0)\n");
        code.push_str("{\n");
        code.push_str("    state = 0;\n");

        if !spec.spec.properties.is_empty() {
            for (idx, prop) in spec.spec.properties.iter().enumerate() {
                code.push_str(&format!(
                    "    _(assert state >= 0)  // Check {}: {}\n",
                    idx,
                    prop.name()
                ));
            }
        }

        code.push_str("}\n");
        code
    }

    /// Parse VCC output to determine verification status
    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics: Vec<String> = combined
            .lines()
            .filter(|l| {
                l.contains("error")
                    || l.contains("warning")
                    || l.contains("Error")
                    || l.contains("Warning")
            })
            .map(|s| s.to_string())
            .collect();

        // VCC output patterns
        let verified = combined.contains("Verification succeeded")
            || combined.contains("verified")
            || combined.contains("0 errors");
        let failed = combined.contains("Verification failed")
            || combined.contains("assertion might not hold")
            || combined.contains("postcondition might not hold")
            || combined.contains("invariant might not hold")
            || combined.contains("could not verify");

        let status = if verified && !failed {
            VerificationStatus::Proven
        } else if failed {
            VerificationStatus::Disproven
        } else if combined.to_lowercase().contains("timeout") {
            VerificationStatus::Unknown {
                reason: "VCC timed out".to_string(),
            }
        } else {
            VerificationStatus::Unknown {
                reason: "Could not determine VCC result".to_string(),
            }
        };

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            self.extract_counterexample(&combined)
        } else {
            None
        };

        if diagnostics.is_empty() && !stderr.trim().is_empty() {
            diagnostics.push(stderr.to_string());
        }

        (status, counterexample, diagnostics)
    }

    /// Extract counterexample from VCC verification failure
    fn extract_counterexample(&self, output: &str) -> Option<StructuredCounterexample> {
        let mut witness = HashMap::new();
        let mut failed_checks = Vec::new();

        // Parse VCC failure messages like:
        // file.c(42,5): error VC9500: assertion might not hold
        // file.c(55,3): error VC9501: postcondition might not hold
        let error_re = Regex::new(
            r"(?P<file>[^(\s]+)\((?P<line>\d+),(?P<col>\d+)\):\s*error\s+(?P<code>VC\d+):\s*(?P<desc>[^\n]+)"
        ).ok()?;

        for cap in error_re.captures_iter(output) {
            let file = cap
                .name("file")
                .map(|m| m.as_str().to_string())
                .unwrap_or_default();
            let line = cap
                .name("line")
                .and_then(|m| m.as_str().parse::<u32>().ok())
                .unwrap_or(0);
            let col = cap.name("col").and_then(|m| m.as_str().parse::<u32>().ok());
            let code = cap.name("code").map(|m| m.as_str()).unwrap_or("VCC");
            let description = cap
                .name("desc")
                .map(|m| m.as_str())
                .unwrap_or("Verification failed");

            failed_checks.push(FailedCheck {
                check_id: code.to_string(),
                description: description.to_string(),
                location: Some(SourceLocation {
                    file,
                    line,
                    column: col,
                }),
                function: None,
            });
        }

        // Try to parse counterexample values from Z3 model
        let value_re =
            Regex::new(r"(?P<var>[a-zA-Z_][a-zA-Z0-9_]*)\s*->\s*(?P<val>[-\d]+)").ok()?;
        for cap in value_re.captures_iter(output) {
            let var = cap.name("var").unwrap().as_str().to_string();
            let val = cap.name("val").unwrap().as_str();
            if let Ok(num) = val.parse::<i128>() {
                witness.insert(
                    var,
                    CounterexampleValue::Int {
                        value: num,
                        type_hint: None,
                    },
                );
            }
        }

        if failed_checks.is_empty() {
            failed_checks.push(FailedCheck {
                check_id: "vcc_error".to_string(),
                description: "VCC verification failed".to_string(),
                location: None,
                function: None,
            });
        }

        Some(StructuredCounterexample {
            witness,
            failed_checks,
            playback_test: None,
            trace: Vec::new(),
            raw: Some(output.to_string()),
            minimized: false,
        })
    }
}

#[async_trait]
impl VerificationBackend for VccBackend {
    fn id(&self) -> BackendId {
        BackendId::VCC
    }
    fn supports(&self) -> Vec<PropertyType> {
        vec![
            PropertyType::Contract,
            PropertyType::DataRace,
            PropertyType::Invariant,
        ]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let vcc = self.detect_vcc().await.map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;
        let source_path = temp_dir.path().join("verify.c");

        std::fs::write(&source_path, self.generate_vcc_code(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write VCC source: {e}"))
        })?;

        let mut cmd = Command::new(&vcc);
        cmd.arg(&source_path)
            .arg(format!("/z3opt:/T:{}", self.config.z3_timeout))
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        if self.config.verify_concurrency {
            cmd.arg("/c");
        }

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("VCC failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("VCC stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("VCC stderr: {}", stderr);
        }

        let (status, counterexample, diagnostics) = self.parse_output(&stdout, &stderr);
        let proof = if matches!(status, VerificationStatus::Proven) {
            Some("VCC verified all contracts and invariants".to_string())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::VCC,
            status,
            proof,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_vcc().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== VccConfig defaults =====

    #[kani::proof]
    fn verify_config_defaults_timeout() {
        let config = VccConfig::default();
        assert!(config.timeout == Duration::from_secs(120));
    }

    #[kani::proof]
    fn verify_config_defaults_options() {
        let config = VccConfig::default();
        assert!(config.vcc_path.is_none());
        assert!(config.z3_timeout == 30);
        assert!(config.verify_concurrency);
    }

    // ===== Backend construction =====

    #[kani::proof]
    fn verify_backend_new_uses_defaults() {
        let backend = VccBackend::new();
        assert!(backend.config.timeout == Duration::from_secs(120));
        assert!(backend.config.verify_concurrency);
    }

    #[kani::proof]
    fn verify_backend_default_matches_new() {
        let b1 = VccBackend::new();
        let b2 = VccBackend::default();
        assert!(b1.config.timeout == b2.config.timeout);
        assert!(b1.config.z3_timeout == b2.config.z3_timeout);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_values() {
        let config = VccConfig {
            vcc_path: Some(PathBuf::from("/usr/bin/vcc")),
            timeout: Duration::from_secs(60),
            z3_timeout: 10,
            verify_concurrency: false,
        };
        let backend = VccBackend::with_config(config);
        assert!(backend.config.timeout == Duration::from_secs(60));
        assert!(backend.config.z3_timeout == 10);
        assert!(!backend.config.verify_concurrency);
    }

    // ===== ID and supports =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = VccBackend::new();
        assert!(matches!(backend.id(), BackendId::VCC));
    }

    #[kani::proof]
    fn verify_supports_contract_data_race_invariant() {
        let backend = VccBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Contract));
        assert!(supported.contains(&PropertyType::DataRace));
        assert!(supported.contains(&PropertyType::Invariant));
        assert!(supported.len() == 3);
    }

    // ===== Output parsing =====

    #[kani::proof]
    fn verify_parse_output_verified() {
        let backend = VccBackend::new();
        let (status, _, _) = backend.parse_output("Verification succeeded, 0 errors", "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_assertion_failed() {
        let backend = VccBackend::new();
        let (status, _, _) = backend.parse_output("assertion might not hold", "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_postcondition_failed() {
        let backend = VccBackend::new();
        let (status, _, _) = backend.parse_output("postcondition might not hold", "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_timeout() {
        let backend = VccBackend::new();
        let (status, _, _) = backend.parse_output("Z3 timeout reached", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    // ===== VCC code generation =====

    #[kani::proof]
    fn verify_generate_vcc_code_contains_header() {
        let backend = VccBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_vcc_code(&spec);
        assert!(code.contains("#include <vcc.h>"));
    }

    #[kani::proof]
    fn verify_generate_vcc_code_contains_invariant() {
        let backend = VccBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_vcc_code(&spec);
        assert!(code.contains("_(invariant"));
    }

    #[kani::proof]
    fn verify_generate_vcc_code_contains_requires_ensures() {
        let backend = VccBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_vcc_code(&spec);
        assert!(code.contains("_(requires"));
        assert!(code.contains("_(ensures"));
    }

    // ===== Counterexample extraction =====

    #[kani::proof]
    fn verify_extract_counterexample_with_location() {
        let backend = VccBackend::new();
        let output = "src/main.c(123,10): error VC9501: postcondition might not hold";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(!cex.failed_checks.is_empty());
        let check = &cex.failed_checks[0];
        assert!(check.check_id == "VC9501");
    }

    #[kani::proof]
    fn verify_extract_counterexample_fallback() {
        let backend = VccBackend::new();
        let output = "some generic error message";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex.failed_checks.iter().any(|c| c.check_id == "vcc_error"));
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};
    use std::collections::HashMap;

    #[test]
    fn backend_id() {
        assert_eq!(VccBackend::new().id(), BackendId::VCC);
    }

    #[test]
    fn supports_contracts_and_data_race() {
        let backend = VccBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Contract));
        assert!(supported.contains(&PropertyType::DataRace));
    }

    #[test]
    fn vcc_code_generation_includes_properties() {
        let backend = VccBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "no_overflow".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_vcc_code(&spec);
        assert!(code.contains("no_overflow"));
        assert!(code.contains("_(invariant"));
        assert!(code.contains("_(requires"));
        assert!(code.contains("_(ensures"));
    }

    #[test]
    fn parse_output_verified() {
        let backend = VccBackend::new();
        let stdout = "VCC verification\nVerification succeeded, 0 errors";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_output_failed() {
        let backend = VccBackend::new();
        let stdout = "test.c(42,5): error VC9500: assertion might not hold\nVerification failed";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        assert!(!ce.failed_checks.is_empty());
        assert_eq!(ce.failed_checks[0].check_id, "VC9500");
    }

    #[test]
    fn extract_counterexample_with_location() {
        let backend = VccBackend::new();
        let output = "src/main.c(123,10): error VC9501: postcondition might not hold";
        let cex = backend.extract_counterexample(output).unwrap();
        assert_eq!(cex.failed_checks.len(), 1);
        let check = &cex.failed_checks[0];
        assert!(check.description.contains("postcondition"));
        let loc = check.location.as_ref().unwrap();
        assert_eq!(loc.file, "src/main.c");
        assert_eq!(loc.line, 123);
        assert_eq!(loc.column, Some(10));
    }

    #[test]
    fn parse_output_timeout() {
        let backend = VccBackend::new();
        let stdout = "Z3 timeout reached";
        let (status, _, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }
}
