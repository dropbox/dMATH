//! mCRL2 process algebra toolset backend
//!
//! mCRL2 is a specification language and toolset for analyzing concurrent systems
//! using process algebra. It supports verification of modal mu-calculus properties
//! on labelled transition systems.
//!
//! Key features:
//! - Process algebra specification language (mCRL2)
//! - Modal mu-calculus property verification
//! - Equivalence checking (bisimulation, trace equivalence)
//! - Counterexample generation with trace replay
//! - State space visualization
//!
//! See: <https://www.mcrl2.org/>

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample, TraceState,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use regex::Regex;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for mCRL2 backend
#[derive(Debug, Clone)]
pub struct Mcrl2Config {
    /// Path to mCRL2 tools directory (contains mcrl22lps, lps2pbes, etc.)
    pub mcrl2_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Rewriter strategy (jitty, jittyc, jittyp)
    pub rewriter: String,
    /// Generate counterexample traces
    pub generate_trace: bool,
    /// Maximum number of states to explore (0 = unlimited)
    pub max_states: u64,
}

impl Default for Mcrl2Config {
    fn default() -> Self {
        Self {
            mcrl2_path: None,
            timeout: Duration::from_secs(120),
            rewriter: "jitty".to_string(),
            generate_trace: true,
            max_states: 0,
        }
    }
}

/// mCRL2 process algebra verification backend
pub struct Mcrl2Backend {
    config: Mcrl2Config,
}

impl Default for Mcrl2Backend {
    fn default() -> Self {
        Self::new()
    }
}

impl Mcrl2Backend {
    pub fn new() -> Self {
        Self {
            config: Mcrl2Config::default(),
        }
    }

    pub fn with_config(config: Mcrl2Config) -> Self {
        Self { config }
    }

    async fn detect(&self) -> Result<PathBuf, String> {
        // If explicit path is configured, verify it exists
        if let Some(ref path) = self.config.mcrl2_path {
            if path.exists() {
                return Ok(path.clone());
            } else {
                return Err(format!(
                    "mCRL2 not found at configured path: {}",
                    path.display()
                ));
            }
        }

        // Otherwise, try to find in PATH
        which::which("mcrl22lps")
            .map_err(|_| "mCRL2 not found. Install from https://www.mcrl2.org/".to_string())
    }

    /// Get the path to an mCRL2 tool
    fn tool_path(&self, tool: &str) -> PathBuf {
        if let Some(ref base) = self.config.mcrl2_path {
            // If base is a tool itself, get its directory
            if base.is_file() {
                base.parent().unwrap_or(base).join(tool)
            } else {
                base.join(tool)
            }
        } else {
            PathBuf::from(tool)
        }
    }

    /// Generate mCRL2 specification from the spec
    fn generate_mcrl2_spec(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();
        code.push_str("% Generated by DashProve for mCRL2 verification\n\n");

        // Data types
        code.push_str("sort State = struct idle | running | done;\n");
        code.push_str("sort Signal = struct tick | tock;\n\n");

        // Actions
        code.push_str("act\n");
        code.push_str("  start, stop, progress: State;\n");
        code.push_str("  signal: Signal;\n");
        code.push_str("  error;\n\n");

        // Process definition
        code.push_str("proc\n");
        code.push_str("  Process(s: State) =\n");
        code.push_str("    (s == idle) -> start(running) . Process(running)\n");
        code.push_str("  + (s == running) -> progress(running) . Process(running)\n");
        code.push_str("  + (s == running) -> stop(done) . Process(done)\n");
        code.push_str("  + (s == done) -> signal(tick) . Process(idle);\n\n");

        // Initial process
        code.push_str("init Process(idle);\n");

        // Add property names as comments
        for prop in &spec.spec.properties {
            code.push_str(&format!("% Property: {}\n", prop.name()));
        }

        code
    }

    /// Generate modal mu-calculus formula file
    fn generate_mcf_formula(&self, spec: &TypedSpec) -> String {
        let mut formula = String::new();
        formula.push_str("% Generated modal mu-calculus formula\n");

        if spec.spec.properties.is_empty() {
            // Default safety property: no error action is reachable
            formula.push_str("[true*]<true>true\n");
        } else {
            // Generate a simple safety formula
            // nu X. [true]X (no deadlock)
            formula.push_str("nu X. [true]X\n");
        }

        formula
    }

    /// Parse mCRL2 verification output
    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics: Vec<String> = combined
            .lines()
            .filter(|l| {
                l.contains("error:")
                    || l.contains("warning:")
                    || l.contains("Error:")
                    || l.contains("Warning:")
            })
            .map(|s| s.trim().to_string())
            .collect();

        // mCRL2 pbes2bool output patterns
        // "The solution for the initial variable is true" = proven
        // "The solution for the initial variable is false" = disproven
        let proven = combined.contains("solution for the initial variable is true")
            || combined.contains("Formula holds")
            || combined.contains("property holds")
            || combined.contains("true");

        let disproven = combined.contains("solution for the initial variable is false")
            || combined.contains("Formula does not hold")
            || combined.contains("property does not hold")
            || combined.contains("counterexample");

        let status = if proven && !disproven {
            VerificationStatus::Proven
        } else if disproven {
            VerificationStatus::Disproven
        } else if combined.contains("out of memory") || combined.contains("memory exhausted") {
            VerificationStatus::Unknown {
                reason: "mCRL2 ran out of memory".to_string(),
            }
        } else if combined.contains("state space too large") || combined.contains("too many states")
        {
            VerificationStatus::Unknown {
                reason: "State space too large".to_string(),
            }
        } else if combined.contains("parse error") || combined.contains("syntax error") {
            VerificationStatus::Unknown {
                reason: "Specification syntax error".to_string(),
            }
        } else {
            VerificationStatus::Unknown {
                reason: "Could not parse mCRL2 output".to_string(),
            }
        };

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            self.extract_counterexample(&combined)
        } else {
            None
        };

        if diagnostics.is_empty() && !stderr.trim().is_empty() {
            for line in stderr.lines().take(5) {
                if !line.trim().is_empty() {
                    diagnostics.push(line.trim().to_string());
                }
            }
        }

        (status, counterexample, diagnostics)
    }

    /// Extract counterexample trace from mCRL2 output
    fn extract_counterexample(&self, output: &str) -> Option<StructuredCounterexample> {
        let mut witness = HashMap::new();
        let mut trace = Vec::new();
        let mut failed_checks = Vec::new();

        // Parse the formula that failed
        let formula_re = Regex::new(r"Formula\s+(.+)\s+does not hold").ok()?;
        if let Some(cap) = formula_re.captures(output) {
            let formula = cap.get(1).map(|m| m.as_str()).unwrap_or("unknown");
            failed_checks.push(FailedCheck {
                check_id: "mcrl2_formula".to_string(),
                description: format!("Formula does not hold: {}", formula),
                location: Some(SourceLocation {
                    file: "spec.mcrl2".to_string(),
                    line: 0,
                    column: None,
                }),
                function: None,
            });
        }

        // Parse counterexample trace from lps2lts output
        // Format varies but typically includes action labels and state numbers
        // State N: action(params)
        let action_re = Regex::new(r"(?:State|step)\s*(\d+):\s*(\w+)(?:\(([^)]*)\))?").ok()?;
        let state_re = Regex::new(r"state\s+(\d+)").ok()?;

        let mut state_num = 0u32;
        let mut current_action: Option<String> = None;
        let mut current_vars: HashMap<String, CounterexampleValue> = HashMap::new();

        for line in output.lines() {
            // Check for state markers
            if let Some(cap) = state_re.captures(line) {
                // Save previous state if we have accumulated data
                if current_action.is_some() || !current_vars.is_empty() {
                    trace.push(TraceState {
                        state_num,
                        action: current_action.take(),
                        variables: current_vars.clone(),
                    });
                    current_vars.clear();
                }
                state_num = cap
                    .get(1)
                    .unwrap()
                    .as_str()
                    .parse()
                    .unwrap_or(state_num + 1);
            }

            // Check for actions
            if let Some(cap) = action_re.captures(line) {
                let action = cap.get(2).map(|m| m.as_str()).unwrap_or("tau");
                let params = cap.get(3).map(|m| m.as_str()).unwrap_or("");

                current_action = Some(format!("{}({})", action, params));

                // Try to extract parameter values
                if !params.is_empty() {
                    for (idx, param) in params.split(',').enumerate() {
                        let param = param.trim();
                        if let Ok(num) = param.parse::<i128>() {
                            let var = format!("param_{}", idx);
                            let value = CounterexampleValue::Int {
                                value: num,
                                type_hint: None,
                            };
                            current_vars.insert(var.clone(), value.clone());
                            witness.insert(var, value);
                        } else if param == "true" || param == "false" {
                            let var = format!("param_{}", idx);
                            let value = CounterexampleValue::Bool(param == "true");
                            current_vars.insert(var.clone(), value.clone());
                            witness.insert(var, value);
                        }
                    }
                }
            }
        }

        // Save final state
        if current_action.is_some() || !current_vars.is_empty() {
            trace.push(TraceState {
                state_num,
                action: current_action,
                variables: current_vars,
            });
        }

        // Ensure we have at least one failed check
        if failed_checks.is_empty() {
            failed_checks.push(FailedCheck {
                check_id: "mcrl2_property".to_string(),
                description: "mCRL2 property violation".to_string(),
                location: None,
                function: None,
            });
        }

        Some(StructuredCounterexample {
            witness,
            failed_checks,
            playback_test: None,
            trace,
            raw: Some(output.to_string()),
            minimized: false,
        })
    }
}

#[async_trait]
impl VerificationBackend for Mcrl2Backend {
    fn id(&self) -> BackendId {
        BackendId::MCRL2
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Temporal, PropertyType::Invariant]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let _base_path = self.detect().await.map_err(BackendError::Unavailable)?;

        // Create temp directory
        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;

        let spec_path = temp_dir.path().join("spec.mcrl2");
        let lps_path = temp_dir.path().join("spec.lps");
        let pbes_path = temp_dir.path().join("spec.pbes");
        let mcf_path = temp_dir.path().join("property.mcf");

        // Write specification files
        std::fs::write(&spec_path, self.generate_mcrl2_spec(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write mCRL2 spec: {e}"))
        })?;
        std::fs::write(&mcf_path, self.generate_mcf_formula(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write MCF formula: {e}"))
        })?;

        // Step 1: mcrl22lps - convert mCRL2 to LPS
        let mcrl22lps = self.tool_path("mcrl22lps");
        let output1 = tokio::time::timeout(
            self.config.timeout / 3,
            Command::new(&mcrl22lps)
                .arg(&spec_path)
                .arg(&lps_path)
                .arg("-r")
                .arg(&self.config.rewriter)
                .stdout(Stdio::piped())
                .stderr(Stdio::piped())
                .output(),
        )
        .await
        .map_err(|_| BackendError::Timeout(self.config.timeout))?
        .map_err(|e| BackendError::VerificationFailed(format!("mcrl22lps failed: {e}")))?;

        if !output1.status.success() {
            let stderr = String::from_utf8_lossy(&output1.stderr);
            return Ok(BackendResult {
                backend: BackendId::MCRL2,
                status: VerificationStatus::Unknown {
                    reason: format!("mcrl22lps failed: {}", stderr),
                },
                proof: None,
                counterexample: None,
                diagnostics: vec![stderr.to_string()],
                time_taken: start.elapsed(),
            });
        }

        // Step 2: lps2pbes - convert LPS + MCF to PBES
        let lps2pbes = self.tool_path("lps2pbes");
        let output2 = tokio::time::timeout(
            self.config.timeout / 3,
            Command::new(&lps2pbes)
                .arg(&lps_path)
                .arg("-f")
                .arg(&mcf_path)
                .arg(&pbes_path)
                .stdout(Stdio::piped())
                .stderr(Stdio::piped())
                .output(),
        )
        .await
        .map_err(|_| BackendError::Timeout(self.config.timeout))?
        .map_err(|e| BackendError::VerificationFailed(format!("lps2pbes failed: {e}")))?;

        if !output2.status.success() {
            let stderr = String::from_utf8_lossy(&output2.stderr);
            return Ok(BackendResult {
                backend: BackendId::MCRL2,
                status: VerificationStatus::Unknown {
                    reason: format!("lps2pbes failed: {}", stderr),
                },
                proof: None,
                counterexample: None,
                diagnostics: vec![stderr.to_string()],
                time_taken: start.elapsed(),
            });
        }

        // Step 3: pbes2bool - solve PBES
        let pbes2bool = self.tool_path("pbes2bool");
        let output3 = tokio::time::timeout(
            self.config.timeout / 3,
            Command::new(&pbes2bool)
                .arg(&pbes_path)
                .stdout(Stdio::piped())
                .stderr(Stdio::piped())
                .output(),
        )
        .await
        .map_err(|_| BackendError::Timeout(self.config.timeout))?
        .map_err(|e| BackendError::VerificationFailed(format!("pbes2bool failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output3.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output3.stderr).to_string();

        debug!("pbes2bool stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("pbes2bool stderr: {}", stderr);
        }

        let (status, counterexample, diagnostics) = self.parse_output(&stdout, &stderr);
        let proof = if matches!(status, VerificationStatus::Proven) {
            Some("mCRL2 verified property".to_string())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::MCRL2,
            status,
            proof,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect().await {
            Ok(_) => HealthStatus::Healthy,
            Err(r) => HealthStatus::Unavailable { reason: r },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};

    #[test]
    fn default_config() {
        let config = Mcrl2Config::default();
        assert_eq!(config.rewriter, "jitty");
        assert!(config.generate_trace);
        assert_eq!(config.max_states, 0);
    }

    #[test]
    fn backend_id() {
        assert_eq!(Mcrl2Backend::new().id(), BackendId::MCRL2);
    }

    #[test]
    fn supports_properties() {
        let backend = Mcrl2Backend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Temporal));
        assert!(supported.contains(&PropertyType::Invariant));
    }

    #[test]
    fn mcrl2_spec_generation() {
        let backend = Mcrl2Backend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "safety_prop".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_mcrl2_spec(&spec);
        assert!(code.contains("sort State"));
        assert!(code.contains("act"));
        assert!(code.contains("proc"));
        assert!(code.contains("init"));
        assert!(code.contains("safety_prop"));
    }

    #[test]
    fn mcf_formula_generation() {
        let backend = Mcrl2Backend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let formula = backend.generate_mcf_formula(&spec);
        assert!(formula.contains("true"));
    }

    #[test]
    fn parse_output_true() {
        let backend = Mcrl2Backend::new();
        let stdout = "The solution for the initial variable is true";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_output_false() {
        let backend = Mcrl2Backend::new();
        let stdout = "The solution for the initial variable is false\ncounterexample found";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        assert!(!ce.failed_checks.is_empty());
    }

    #[test]
    fn parse_output_memory_exhausted() {
        let backend = Mcrl2Backend::new();
        let stdout = "out of memory";
        let (status, _, _) = backend.parse_output(stdout, "");
        match status {
            VerificationStatus::Unknown { reason } => {
                assert!(reason.contains("memory"));
            }
            _ => panic!("Expected Unknown status"),
        }
    }

    #[test]
    fn extract_counterexample_with_actions() {
        let backend = Mcrl2Backend::new();
        let output = r#"Formula does not hold
counterexample found
state 0
State 0: start(running)
state 1
State 1: stop(done)"#;
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(!cex.trace.is_empty());
        assert!(!cex.failed_checks.is_empty());
    }

    #[test]
    fn tool_path_with_base() {
        let config = Mcrl2Config {
            mcrl2_path: Some(PathBuf::from("/opt/mcrl2/bin/mcrl22lps")),
            ..Default::default()
        };
        let backend = Mcrl2Backend::with_config(config);
        let path = backend.tool_path("pbes2bool");
        assert!(path.to_string_lossy().contains("pbes2bool"));
    }

    #[tokio::test]
    async fn health_check_unavailable_with_invalid_path() {
        let config = Mcrl2Config {
            mcrl2_path: Some(PathBuf::from("/nonexistent/path/mcrl22lps")),
            ..Default::default()
        };
        let backend = Mcrl2Backend::with_config(config);
        let health = backend.health_check().await;
        // With an invalid explicit path, should be unavailable
        assert!(matches!(health, HealthStatus::Unavailable { .. }));
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ==================== Mcrl2Config Default Proofs ====================

    #[kani::proof]
    fn proof_config_default_mcrl2_path_none() {
        let config = Mcrl2Config::default();
        kani::assert(
            config.mcrl2_path.is_none(),
            "Default mcrl2_path should be None",
        );
    }

    #[kani::proof]
    fn proof_config_default_timeout_120s() {
        let config = Mcrl2Config::default();
        kani::assert(
            config.timeout == Duration::from_secs(120),
            "Default timeout should be 120 seconds",
        );
    }

    #[kani::proof]
    fn proof_config_default_rewriter_jitty() {
        let config = Mcrl2Config::default();
        kani::assert(
            config.rewriter == "jitty",
            "Default rewriter should be 'jitty'",
        );
    }

    #[kani::proof]
    fn proof_config_default_generate_trace_true() {
        let config = Mcrl2Config::default();
        kani::assert(
            config.generate_trace,
            "Default generate_trace should be true",
        );
    }

    #[kani::proof]
    fn proof_config_default_max_states_zero() {
        let config = Mcrl2Config::default();
        kani::assert(
            config.max_states == 0,
            "Default max_states should be 0 (unlimited)",
        );
    }

    // ==================== Mcrl2Backend Construction Proofs ====================

    #[kani::proof]
    fn proof_backend_new_uses_default_config() {
        let backend = Mcrl2Backend::new();
        kani::assert(
            backend.config.mcrl2_path.is_none(),
            "new() should use default config with mcrl2_path=None",
        );
        kani::assert(
            backend.config.rewriter == "jitty",
            "new() should use default config with rewriter='jitty'",
        );
    }

    #[kani::proof]
    fn proof_backend_default_equals_new() {
        let b1 = Mcrl2Backend::new();
        let b2 = Mcrl2Backend::default();
        kani::assert(
            b1.config.timeout == b2.config.timeout,
            "default() and new() should produce equal timeout",
        );
        kani::assert(
            b1.config.generate_trace == b2.config.generate_trace,
            "default() and new() should produce equal generate_trace",
        );
    }

    #[kani::proof]
    fn proof_backend_with_config_preserves_timeout() {
        let timeout_secs: u64 = kani::any();
        kani::assume(timeout_secs > 0 && timeout_secs < 3600);
        let config = Mcrl2Config {
            timeout: Duration::from_secs(timeout_secs),
            ..Default::default()
        };
        let backend = Mcrl2Backend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(timeout_secs),
            "with_config should preserve timeout",
        );
    }

    #[kani::proof]
    fn proof_backend_with_config_preserves_max_states() {
        let max_states: u64 = kani::any();
        let config = Mcrl2Config {
            max_states,
            ..Default::default()
        };
        let backend = Mcrl2Backend::with_config(config);
        kani::assert(
            backend.config.max_states == max_states,
            "with_config should preserve max_states",
        );
    }

    #[kani::proof]
    fn proof_backend_with_config_preserves_generate_trace() {
        let generate_trace: bool = kani::any();
        let config = Mcrl2Config {
            generate_trace,
            ..Default::default()
        };
        let backend = Mcrl2Backend::with_config(config);
        kani::assert(
            backend.config.generate_trace == generate_trace,
            "with_config should preserve generate_trace",
        );
    }

    // ==================== Backend Trait Implementation Proofs ====================

    #[kani::proof]
    fn proof_backend_id_is_mcrl2() {
        let backend = Mcrl2Backend::new();
        kani::assert(
            backend.id() == BackendId::MCRL2,
            "Backend ID should be MCRL2",
        );
    }

    #[kani::proof]
    fn proof_supports_contains_temporal() {
        let backend = Mcrl2Backend::new();
        let supported = backend.supports();
        let has_temporal = supported.iter().any(|p| *p == PropertyType::Temporal);
        kani::assert(has_temporal, "Should support Temporal property type");
    }

    #[kani::proof]
    fn proof_supports_contains_invariant() {
        let backend = Mcrl2Backend::new();
        let supported = backend.supports();
        let has_invariant = supported.iter().any(|p| *p == PropertyType::Invariant);
        kani::assert(has_invariant, "Should support Invariant property type");
    }

    #[kani::proof]
    fn proof_supports_returns_two_types() {
        let backend = Mcrl2Backend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 2,
            "Should support exactly 2 property types",
        );
    }

    // ==================== tool_path Proofs ====================

    #[kani::proof]
    fn proof_tool_path_no_base_returns_tool_name() {
        let backend = Mcrl2Backend::new();
        let path = backend.tool_path("pbes2bool");
        kani::assert(
            path == PathBuf::from("pbes2bool"),
            "Without base path, should return tool name directly",
        );
    }

    #[kani::proof]
    fn proof_tool_path_with_directory_base() {
        let config = Mcrl2Config {
            mcrl2_path: Some(PathBuf::from("/opt/mcrl2/bin")),
            ..Default::default()
        };
        let backend = Mcrl2Backend::with_config(config);
        let path = backend.tool_path("pbes2bool");
        // Path should contain the tool name
        let path_str = path.to_string_lossy();
        kani::assert(
            path_str.contains("pbes2bool"),
            "Tool path should contain tool name",
        );
    }

    // ==================== parse_output Status Detection Proofs ====================

    #[kani::proof]
    fn proof_parse_output_proven_on_true() {
        let backend = Mcrl2Backend::new();
        let stdout = "The solution for the initial variable is true";
        let (status, _, _) = backend.parse_output(stdout, "");
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should be Proven when output contains 'solution...is true'",
        );
    }

    #[kani::proof]
    fn proof_parse_output_proven_on_formula_holds() {
        let backend = Mcrl2Backend::new();
        let stdout = "Formula holds for all states";
        let (status, _, _) = backend.parse_output(stdout, "");
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should be Proven when output contains 'Formula holds'",
        );
    }

    #[kani::proof]
    fn proof_parse_output_disproven_on_false() {
        let backend = Mcrl2Backend::new();
        let stdout = "The solution for the initial variable is false";
        let (status, _, _) = backend.parse_output(stdout, "");
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should be Disproven when output contains 'solution...is false'",
        );
    }

    #[kani::proof]
    fn proof_parse_output_disproven_on_counterexample() {
        let backend = Mcrl2Backend::new();
        let stdout = "counterexample found";
        let (status, _, _) = backend.parse_output(stdout, "");
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should be Disproven when output contains 'counterexample'",
        );
    }

    #[kani::proof]
    fn proof_parse_output_unknown_on_memory_exhausted() {
        let backend = Mcrl2Backend::new();
        let stdout = "out of memory";
        let (status, _, _) = backend.parse_output(stdout, "");
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should be Unknown when output contains 'out of memory'",
        );
    }

    #[kani::proof]
    fn proof_parse_output_unknown_on_state_space_too_large() {
        let backend = Mcrl2Backend::new();
        let stdout = "state space too large";
        let (status, _, _) = backend.parse_output(stdout, "");
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should be Unknown when state space too large",
        );
    }

    #[kani::proof]
    fn proof_parse_output_unknown_on_parse_error() {
        let backend = Mcrl2Backend::new();
        let stdout = "parse error in specification";
        let (status, _, _) = backend.parse_output(stdout, "");
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should be Unknown when output contains parse error",
        );
    }

    #[kani::proof]
    fn proof_parse_output_counterexample_only_when_disproven() {
        let backend = Mcrl2Backend::new();
        // Proven case
        let stdout_proven = "true";
        let (status1, cex1, _) = backend.parse_output(stdout_proven, "");
        // Disproven case
        let stdout_disproven = "counterexample found";
        let (status2, cex2, _) = backend.parse_output(stdout_disproven, "");

        // When proven, no counterexample
        if matches!(status1, VerificationStatus::Proven) {
            kani::assert(
                cex1.is_none(),
                "Proven status should have no counterexample",
            );
        }
        // When disproven, counterexample present
        if matches!(status2, VerificationStatus::Disproven) {
            kani::assert(
                cex2.is_some(),
                "Disproven status should have counterexample",
            );
        }
    }

    #[kani::proof]
    fn proof_parse_output_collects_error_diagnostics() {
        let backend = Mcrl2Backend::new();
        let stdout = "error: something went wrong";
        let (_, _, diagnostics) = backend.parse_output(stdout, "");
        let has_error = diagnostics.iter().any(|d| d.contains("error"));
        kani::assert(has_error, "Diagnostics should contain error messages");
    }

    #[kani::proof]
    fn proof_parse_output_collects_warning_diagnostics() {
        let backend = Mcrl2Backend::new();
        let stdout = "warning: potential issue";
        let (_, _, diagnostics) = backend.parse_output(stdout, "");
        let has_warning = diagnostics.iter().any(|d| d.contains("warning"));
        kani::assert(has_warning, "Diagnostics should contain warning messages");
    }

    // ==================== generate_mcrl2_spec Proofs ====================

    #[kani::proof]
    fn proof_generate_mcrl2_spec_contains_sort() {
        let backend = Mcrl2Backend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_mcrl2_spec(&spec);
        kani::assert(
            code.contains("sort"),
            "Generated spec should contain 'sort' declaration",
        );
    }

    #[kani::proof]
    fn proof_generate_mcrl2_spec_contains_act() {
        let backend = Mcrl2Backend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_mcrl2_spec(&spec);
        kani::assert(
            code.contains("act"),
            "Generated spec should contain 'act' declaration",
        );
    }

    #[kani::proof]
    fn proof_generate_mcrl2_spec_contains_proc() {
        let backend = Mcrl2Backend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_mcrl2_spec(&spec);
        kani::assert(
            code.contains("proc"),
            "Generated spec should contain 'proc' declaration",
        );
    }

    #[kani::proof]
    fn proof_generate_mcrl2_spec_contains_init() {
        let backend = Mcrl2Backend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_mcrl2_spec(&spec);
        kani::assert(
            code.contains("init"),
            "Generated spec should contain 'init' declaration",
        );
    }

    // ==================== generate_mcf_formula Proofs ====================

    #[kani::proof]
    fn proof_generate_mcf_formula_not_empty() {
        let backend = Mcrl2Backend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let formula = backend.generate_mcf_formula(&spec);
        kani::assert(!formula.is_empty(), "MCF formula should not be empty");
    }

    #[kani::proof]
    fn proof_generate_mcf_formula_empty_props_has_true() {
        let backend = Mcrl2Backend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let formula = backend.generate_mcf_formula(&spec);
        kani::assert(
            formula.contains("true"),
            "MCF formula for empty props should contain 'true'",
        );
    }

    #[kani::proof]
    fn proof_generate_mcf_formula_with_props_has_nu() {
        let backend = Mcrl2Backend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![dashprove_usl::ast::Property::Invariant(
                    dashprove_usl::ast::Invariant {
                        name: "test".to_string(),
                        body: dashprove_usl::ast::Expr::Bool(true),
                    },
                )],
            },
            type_info: HashMap::new(),
        };
        let formula = backend.generate_mcf_formula(&spec);
        kani::assert(
            formula.contains("nu"),
            "MCF formula with properties should contain 'nu' (greatest fixpoint)",
        );
    }

    // ==================== extract_counterexample Proofs ====================

    #[kani::proof]
    fn proof_extract_counterexample_always_has_failed_check() {
        let backend = Mcrl2Backend::new();
        let output = "counterexample found";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(
                !ce.failed_checks.is_empty(),
                "Counterexample should always have at least one failed check",
            );
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_sets_raw_output() {
        let backend = Mcrl2Backend::new();
        let output = "counterexample";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(ce.raw.is_some(), "Counterexample should store raw output");
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_not_minimized() {
        let backend = Mcrl2Backend::new();
        let output = "counterexample";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(
                !ce.minimized,
                "Counterexample should not be marked as minimized",
            );
        }
    }
}
