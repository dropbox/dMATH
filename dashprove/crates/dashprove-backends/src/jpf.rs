//! Java PathFinder (JPF) model checker backend
//!
//! JPF is an extensible software model checker for Java bytecode.
//! It systematically explores all execution paths, detecting:
//! - Deadlocks and race conditions
//! - Unhandled exceptions
//! - Assertion violations
//! - Custom property violations
//!
//! JPF works by running as a specialized JVM that can backtrack
//! and explore different thread interleavings.
//!
//! See: <https://github.com/javapathfinder/jpf-core>

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample, TraceState,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use regex::Regex;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for Java PathFinder backend
#[derive(Debug, Clone)]
pub struct JpfConfig {
    /// Path to JPF installation directory or jpf binary
    pub jpf_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Maximum search depth
    pub search_depth: u32,
    /// Search algorithm: DFS, BFS, or heuristic
    pub search_class: String,
    /// Enable data race detection
    pub detect_races: bool,
    /// Enable deadlock detection
    pub detect_deadlocks: bool,
    /// JVM heap size for JPF
    pub heap_size: String,
}

impl Default for JpfConfig {
    fn default() -> Self {
        Self {
            jpf_path: None,
            timeout: Duration::from_secs(120),
            search_depth: 100,
            search_class: "gov.nasa.jpf.search.DFSearch".to_string(),
            detect_races: true,
            detect_deadlocks: true,
            heap_size: "4g".to_string(),
        }
    }
}

/// Java PathFinder model checker backend
pub struct JpfBackend {
    config: JpfConfig,
}

impl Default for JpfBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl JpfBackend {
    pub fn new() -> Self {
        Self {
            config: JpfConfig::default(),
        }
    }

    pub fn with_config(config: JpfConfig) -> Self {
        Self { config }
    }

    async fn detect_jpf(&self) -> Result<PathBuf, String> {
        // Check configured path first
        if let Some(path) = &self.config.jpf_path {
            if path.exists() {
                return Ok(path.clone());
            }
        }

        // Check JPF_HOME environment variable
        if let Ok(jpf_home) = std::env::var("JPF_HOME") {
            let jpf_path = PathBuf::from(&jpf_home);
            if jpf_path.exists() {
                // Look for jpf script or jar
                let script = jpf_path.join("bin").join("jpf");
                if script.exists() {
                    return Ok(script);
                }
                let jar = jpf_path.join("build").join("jpf-core").join("jpf.jar");
                if jar.exists() {
                    return Ok(jar);
                }
                return Ok(jpf_path);
            }
        }

        // Try to find jpf in PATH
        if let Ok(path) = which::which("jpf") {
            return Ok(path);
        }

        // Try common installation paths
        let home = std::env::var("HOME").unwrap_or_default();
        for base in &[
            format!("{}/jpf", home),
            format!("{}/.jpf", home),
            format!("{}/java-pathfinder", home),
            "/opt/jpf".to_string(),
            "/usr/local/jpf".to_string(),
        ] {
            let p = PathBuf::from(base);
            if p.exists() {
                return Ok(p);
            }
        }

        Err(
            "Java PathFinder not found. Install from https://github.com/javapathfinder/jpf-core"
                .to_string(),
        )
    }

    /// Generate Java source code from USL spec for JPF verification
    fn generate_java_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();

        code.push_str("// Generated by DashProve for JPF verification\n");
        code.push_str("import gov.nasa.jpf.vm.Verify;\n");
        code.push('\n');
        code.push_str("public class DashProveTest {\n");
        code.push_str("    \n");

        // Generate properties as assertions
        if spec.spec.properties.is_empty() {
            // Default test: check for data races and deadlocks
            code.push_str("    static int sharedVar = 0;\n");
            code.push_str("    \n");
            code.push_str("    public static void main(String[] args) {\n");
            code.push_str("        Thread t1 = new Thread(() -> {\n");
            code.push_str("            sharedVar++;\n");
            code.push_str("        });\n");
            code.push_str("        Thread t2 = new Thread(() -> {\n");
            code.push_str("            sharedVar++;\n");
            code.push_str("        });\n");
            code.push_str("        t1.start();\n");
            code.push_str("        t2.start();\n");
            code.push_str("        try {\n");
            code.push_str("            t1.join();\n");
            code.push_str("            t2.join();\n");
            code.push_str("        } catch (InterruptedException e) {}\n");
            code.push_str("        assert sharedVar == 2 : \"Race condition detected\";\n");
            code.push_str("    }\n");
        } else {
            code.push_str("    public static void main(String[] args) {\n");
            for (idx, prop) in spec.spec.properties.iter().enumerate() {
                code.push_str(&format!("        // Property {}: {}\n", idx, prop.name()));
                code.push_str("        int x = Verify.getInt(0, 100);\n");
                code.push_str(&format!(
                    "        assert x >= 0 : \"Property {} violated\";\n",
                    prop.name()
                ));
            }
            code.push_str("    }\n");
        }

        code.push_str("}\n");
        code
    }

    /// Generate JPF configuration file (.jpf)
    fn generate_jpf_config(&self, class_path: &str) -> String {
        let mut config = String::new();

        config.push_str("# Generated by DashProve for JPF verification\n");
        config.push_str("target = DashProveTest\n");
        config.push_str(&format!("classpath = {}\n", class_path));
        config.push('\n');

        // Search configuration
        config.push_str(&format!("search.class = {}\n", self.config.search_class));
        config.push_str(&format!(
            "search.depth_limit = {}\n",
            self.config.search_depth
        ));

        // Listener configuration for detecting issues
        let mut listeners = Vec::new();
        if self.config.detect_races {
            listeners.push("gov.nasa.jpf.listener.PreciseRaceDetector");
        }
        if self.config.detect_deadlocks {
            listeners.push("gov.nasa.jpf.listener.DeadlockAnalyzer");
        }

        if !listeners.is_empty() {
            config.push_str(&format!("listener = {}\n", listeners.join(",")));
        }

        // Report configuration
        config.push_str("report.console.property_violation = error,trace\n");
        config.push_str("report.console.finished = result,statistics\n");

        config
    }

    /// Parse JPF output
    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics = Vec::new();

        // Collect warnings and errors
        for line in combined.lines() {
            if line.contains("WARNING") || line.contains("ERROR") || line.contains("[SEVERE]") {
                diagnostics.push(line.trim().to_string());
            }
        }

        // JPF output patterns:
        // "no errors detected" - verification passed
        // "error #N" or "====== error N" - property violation found
        // "OutOfMemoryError" - resource exhausted

        let no_error = combined.contains("no errors detected")
            || combined.contains("states: new=0")
                && !combined.contains("error")
                && !combined.contains("violation");

        let error_found = combined.contains("error #")
            || combined.contains("====== error")
            || combined.contains("AssertionError")
            || combined.contains("property violated")
            || combined.contains("race detected")
            || combined.contains("deadlock detected");

        let status = if no_error && !error_found {
            VerificationStatus::Proven
        } else if error_found {
            VerificationStatus::Disproven
        } else if combined.contains("OutOfMemoryError")
            || combined.contains("java.lang.OutOfMemoryError")
        {
            VerificationStatus::Unknown {
                reason: "JPF ran out of memory".to_string(),
            }
        } else if combined.contains("search constraint hit")
            || combined.contains("depth limit reached")
        {
            VerificationStatus::Unknown {
                reason: "JPF search constraint hit (depth/time limit)".to_string(),
            }
        } else if combined.contains("Exception") || combined.contains("error:") {
            VerificationStatus::Unknown {
                reason: "JPF encountered an error".to_string(),
            }
        } else {
            VerificationStatus::Unknown {
                reason: "Could not parse JPF output".to_string(),
            }
        };

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            self.extract_counterexample(&combined)
        } else {
            None
        };

        (status, counterexample, diagnostics)
    }

    /// Extract counterexample from JPF output
    fn extract_counterexample(&self, output: &str) -> Option<StructuredCounterexample> {
        let mut witness = HashMap::new();
        let mut trace = Vec::new();
        let mut failed_checks = Vec::new();

        // Parse error type and location
        // Pattern: "java.lang.AssertionError: message"
        let assert_re = Regex::new(r"java\.lang\.AssertionError:\s*(.+)").ok()?;
        if let Some(cap) = assert_re.captures(output) {
            let msg = cap.get(1).map(|m| m.as_str()).unwrap_or("assertion failed");
            failed_checks.push(FailedCheck {
                check_id: "jpf_assertion".to_string(),
                description: format!("Assertion failed: {}", msg),
                location: None,
                function: None,
            });
        }

        // Parse race condition
        if output.contains("race detected") || output.contains("PreciseRaceDetector") {
            // Pattern: "race for field X at Y"
            let race_re = Regex::new(r"race for field\s+(\S+)\s+at\s+(\S+)").ok()?;
            if let Some(cap) = race_re.captures(output) {
                let field = cap.get(1).map(|m| m.as_str()).unwrap_or("unknown");
                let location = cap.get(2).map(|m| m.as_str()).unwrap_or("unknown");
                failed_checks.push(FailedCheck {
                    check_id: "jpf_race".to_string(),
                    description: format!("Data race detected on field: {}", field),
                    location: Some(SourceLocation {
                        file: location.to_string(),
                        line: 0,
                        column: None,
                    }),
                    function: None,
                });
            } else {
                failed_checks.push(FailedCheck {
                    check_id: "jpf_race".to_string(),
                    description: "Data race detected".to_string(),
                    location: None,
                    function: None,
                });
            }
        }

        // Parse deadlock
        if output.contains("deadlock detected") || output.contains("DeadlockAnalyzer") {
            failed_checks.push(FailedCheck {
                check_id: "jpf_deadlock".to_string(),
                description: "Deadlock detected".to_string(),
                location: None,
                function: None,
            });
        }

        // Parse stack trace for location info
        // Pattern: "at ClassName.methodName(File.java:line)"
        let stack_re = Regex::new(r"at\s+(\S+)\.(\w+)\((\w+\.java):(\d+)\)").ok()?;
        let mut state_num = 0u32;

        for cap in stack_re.captures_iter(output) {
            let class = cap.get(1).unwrap().as_str();
            let method = cap.get(2).unwrap().as_str();
            let file = cap.get(3).unwrap().as_str();
            let line: u32 = cap.get(4).unwrap().as_str().parse().unwrap_or(0);

            // Update location for first failed check if not set
            if !failed_checks.is_empty() && failed_checks[0].location.is_none() {
                failed_checks[0].location = Some(SourceLocation {
                    file: file.to_string(),
                    line,
                    column: None,
                });
                failed_checks[0].function = Some(format!("{}.{}", class, method));
            }

            // Add to trace
            let mut vars = HashMap::new();
            vars.insert(
                "class".to_string(),
                CounterexampleValue::String(class.to_string()),
            );
            vars.insert(
                "method".to_string(),
                CounterexampleValue::String(method.to_string()),
            );
            vars.insert(
                "line".to_string(),
                CounterexampleValue::Int {
                    value: line as i128,
                    type_hint: None,
                },
            );

            trace.push(TraceState {
                state_num,
                action: Some(format!("{}.{}:{}", class, method, line)),
                variables: vars,
            });
            state_num += 1;
        }

        // Parse thread transition trace
        // Pattern: "Thread-N: ..."
        let thread_re = Regex::new(r"Thread-(\d+):\s*(.+)").ok()?;
        for cap in thread_re.captures_iter(output) {
            let thread_id = cap.get(1).unwrap().as_str();
            let action = cap.get(2).unwrap().as_str().trim();

            let mut vars = HashMap::new();
            vars.insert(
                "thread".to_string(),
                CounterexampleValue::Int {
                    value: thread_id.parse().unwrap_or(0),
                    type_hint: None,
                },
            );

            trace.push(TraceState {
                state_num,
                action: Some(format!("Thread-{}: {}", thread_id, action)),
                variables: vars,
            });
            state_num += 1;
        }

        // Parse choice generator values
        // Pattern: "choice: X"
        let choice_re = Regex::new(r"choice:\s*(\d+)").ok()?;
        for cap in choice_re.captures_iter(output) {
            let choice_val: i128 = cap.get(1).unwrap().as_str().parse().unwrap_or(0);
            witness.insert(
                format!("choice_{}", witness.len()),
                CounterexampleValue::Int {
                    value: choice_val,
                    type_hint: None,
                },
            );
        }

        // Ensure we have at least one failed check
        if failed_checks.is_empty() {
            failed_checks.push(FailedCheck {
                check_id: "jpf_error".to_string(),
                description: "JPF found an error".to_string(),
                location: None,
                function: None,
            });
        }

        Some(StructuredCounterexample {
            witness,
            failed_checks,
            playback_test: None,
            trace,
            raw: Some(output.to_string()),
            minimized: false,
        })
    }
}

#[async_trait]
impl VerificationBackend for JpfBackend {
    fn id(&self) -> BackendId {
        BackendId::JPF
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Invariant, PropertyType::DataRace]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let jpf_path = self.detect_jpf().await.map_err(BackendError::Unavailable)?;

        // Create temp directory for Java source and class files
        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;
        let java_path = temp_dir.path().join("DashProveTest.java");
        let jpf_config_path = temp_dir.path().join("test.jpf");

        // Write Java source
        std::fs::write(&java_path, self.generate_java_code(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write Java source: {e}"))
        })?;

        // Compile Java source
        let javac_output = Command::new("javac")
            .arg("-cp")
            .arg(jpf_path.to_string_lossy().to_string())
            .arg(&java_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(|e| BackendError::VerificationFailed(format!("Failed to run javac: {e}")))?;

        if !javac_output.status.success() {
            let stderr = String::from_utf8_lossy(&javac_output.stderr);
            return Err(BackendError::VerificationFailed(format!(
                "Java compilation failed: {}",
                stderr
            )));
        }

        // Write JPF config
        let class_path = temp_dir.path().to_string_lossy().to_string();
        std::fs::write(&jpf_config_path, self.generate_jpf_config(&class_path)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write JPF config: {e}"))
        })?;

        // Run JPF
        let mut cmd = if jpf_path.extension().is_some_and(|ext| ext == "jar") {
            let mut c = Command::new("java");
            c.arg(format!("-Xmx{}", self.config.heap_size))
                .arg("-jar")
                .arg(&jpf_path)
                .arg(&jpf_config_path);
            c
        } else {
            let mut c = Command::new(&jpf_path);
            c.arg(&jpf_config_path);
            c
        };

        cmd.stdout(Stdio::piped()).stderr(Stdio::piped());

        // Run verification with timeout
        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("JPF failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("JPF stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("JPF stderr: {}", stderr);
        }

        let (status, counterexample, diagnostics) = self.parse_output(&stdout, &stderr);
        let proof = if matches!(status, VerificationStatus::Proven) {
            Some("JPF verified no errors in explored state space".to_string())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::JPF,
            status,
            proof,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_jpf().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};

    #[test]
    fn default_config() {
        let config = JpfConfig::default();
        assert_eq!(config.search_depth, 100);
        assert!(config.detect_races);
        assert!(config.detect_deadlocks);
    }

    #[test]
    fn backend_id() {
        assert_eq!(JpfBackend::new().id(), BackendId::JPF);
    }

    #[test]
    fn supports_properties() {
        let backend = JpfBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Invariant));
        assert!(supported.contains(&PropertyType::DataRace));
    }

    #[test]
    fn java_code_generation_empty_spec() {
        let backend = JpfBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_java_code(&spec);
        assert!(code.contains("public class DashProveTest"));
        assert!(code.contains("Thread"));
        assert!(code.contains("sharedVar"));
    }

    #[test]
    fn java_code_generation_with_property() {
        let backend = JpfBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "test_inv".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_java_code(&spec);
        assert!(code.contains("test_inv"));
        assert!(code.contains("Verify.getInt"));
    }

    #[test]
    fn jpf_config_generation() {
        let backend = JpfBackend::new();
        let config = backend.generate_jpf_config("/tmp/classes");
        assert!(config.contains("target = DashProveTest"));
        assert!(config.contains("classpath = /tmp/classes"));
        assert!(config.contains("search.class"));
        assert!(config.contains("PreciseRaceDetector"));
    }

    #[test]
    fn jpf_config_no_race_detection() {
        let config = JpfConfig {
            detect_races: false,
            ..Default::default()
        };
        let backend = JpfBackend::with_config(config);
        let jpf_config = backend.generate_jpf_config("/tmp");
        assert!(!jpf_config.contains("PreciseRaceDetector"));
    }

    #[test]
    fn parse_output_no_errors() {
        let backend = JpfBackend::new();
        let stdout = "JavaPathfinder v8.0\nno errors detected\nstates: new=5";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_output_assertion_error() {
        let backend = JpfBackend::new();
        let stdout = "====== error 1\njava.lang.AssertionError: Race condition detected\nat DashProveTest.main(DashProveTest.java:15)";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        assert!(!ce.failed_checks.is_empty());
        assert!(ce.failed_checks[0].description.contains("Race condition"));
    }

    #[test]
    fn parse_output_race_detected() {
        let backend = JpfBackend::new();
        let stdout = "PreciseRaceDetector: race detected\nrace for field sharedVar at line 10";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        assert!(ce.failed_checks.iter().any(|c| c.check_id == "jpf_race"));
    }

    #[test]
    fn parse_output_deadlock() {
        let backend = JpfBackend::new();
        let stdout = "DeadlockAnalyzer: deadlock detected";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        assert!(ce
            .failed_checks
            .iter()
            .any(|c| c.check_id == "jpf_deadlock"));
    }

    #[test]
    fn parse_output_out_of_memory() {
        let backend = JpfBackend::new();
        let stderr = "java.lang.OutOfMemoryError: Java heap space";
        let (status, _, _) = backend.parse_output("", stderr);
        match status {
            VerificationStatus::Unknown { reason } => {
                assert!(reason.contains("memory"));
            }
            _ => panic!("Expected Unknown status"),
        }
    }

    #[test]
    fn parse_output_depth_limit() {
        let backend = JpfBackend::new();
        let stdout = "search constraint hit: depth limit reached";
        let (status, _, _) = backend.parse_output(stdout, "");
        match status {
            VerificationStatus::Unknown { reason } => {
                assert!(reason.contains("constraint"));
            }
            _ => panic!("Expected Unknown status"),
        }
    }

    #[test]
    fn extract_counterexample_with_stack_trace() {
        let backend = JpfBackend::new();
        let output = "error #1\njava.lang.AssertionError: test failed\nat com.example.Test.method(Test.java:42)\nat com.example.Main.main(Main.java:10)";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(!cex.trace.is_empty());
        let first = &cex.failed_checks[0];
        assert!(first.location.is_some());
        assert_eq!(first.location.as_ref().unwrap().line, 42);
    }

    #[test]
    fn extract_counterexample_thread_trace() {
        let backend = JpfBackend::new();
        let output = "error #1\nThread-0: running\nThread-1: waiting\nThread-0: blocked";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex.trace.len() >= 3);
    }

    #[test]
    fn extract_counterexample_choices() {
        let backend = JpfBackend::new();
        let output = "error #1\nchoice: 5\nchoice: 10\nchoice: 3";
        let cex = backend.extract_counterexample(output).unwrap();
        assert_eq!(cex.witness.len(), 3);
    }

    #[tokio::test]
    async fn health_check_unavailable() {
        let config = JpfConfig {
            jpf_path: Some(PathBuf::from("/nonexistent/jpf")),
            ..Default::default()
        };
        let backend = JpfBackend::with_config(config);
        let health = backend.health_check().await;
        assert!(matches!(health, HealthStatus::Unavailable { .. }));
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // =============================================
    // JpfConfig default proofs
    // =============================================

    /// Verify JpfConfig::default jpf_path is None
    #[kani::proof]
    fn proof_jpf_config_default_path_none() {
        let config = JpfConfig::default();
        kani::assert(config.jpf_path.is_none(), "Default jpf_path should be None");
    }

    /// Verify JpfConfig::default timeout is 120 seconds
    #[kani::proof]
    fn proof_jpf_config_default_timeout() {
        let config = JpfConfig::default();
        kani::assert(
            config.timeout == Duration::from_secs(120),
            "Default timeout should be 120 seconds",
        );
    }

    /// Verify JpfConfig::default search_depth is 100
    #[kani::proof]
    fn proof_jpf_config_default_search_depth() {
        let config = JpfConfig::default();
        kani::assert(
            config.search_depth == 100,
            "Default search_depth should be 100",
        );
    }

    /// Verify JpfConfig::default search_class is DFSearch
    #[kani::proof]
    fn proof_jpf_config_default_search_class() {
        let config = JpfConfig::default();
        kani::assert(
            config.search_class == "gov.nasa.jpf.search.DFSearch",
            "Default search_class should be DFSearch",
        );
    }

    /// Verify JpfConfig::default detect_races is true
    #[kani::proof]
    fn proof_jpf_config_default_detect_races() {
        let config = JpfConfig::default();
        kani::assert(config.detect_races, "Default detect_races should be true");
    }

    /// Verify JpfConfig::default detect_deadlocks is true
    #[kani::proof]
    fn proof_jpf_config_default_detect_deadlocks() {
        let config = JpfConfig::default();
        kani::assert(
            config.detect_deadlocks,
            "Default detect_deadlocks should be true",
        );
    }

    /// Verify JpfConfig::default heap_size is "4g"
    #[kani::proof]
    fn proof_jpf_config_default_heap_size() {
        let config = JpfConfig::default();
        kani::assert(config.heap_size == "4g", "Default heap_size should be 4g");
    }

    // =============================================
    // JpfBackend trait implementation proofs
    // =============================================

    /// Verify JpfBackend::id returns BackendId::JPF
    #[kani::proof]
    fn proof_jpf_backend_id() {
        let backend = JpfBackend::new();
        kani::assert(backend.id() == BackendId::JPF, "Backend ID should be JPF");
    }

    /// Verify JpfBackend::supports includes Invariant
    #[kani::proof]
    fn proof_jpf_backend_supports_invariant() {
        let backend = JpfBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::Invariant {
                found = true;
            }
        }
        kani::assert(found, "Should support Invariant");
    }

    /// Verify JpfBackend::supports includes DataRace
    #[kani::proof]
    fn proof_jpf_backend_supports_data_race() {
        let backend = JpfBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::DataRace {
                found = true;
            }
        }
        kani::assert(found, "Should support DataRace");
    }

    /// Verify JpfBackend::supports returns exactly 2 types
    #[kani::proof]
    fn proof_jpf_backend_supports_count() {
        let backend = JpfBackend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 2,
            "Should support exactly 2 property types",
        );
    }

    // =============================================
    // parse_output function proofs
    // =============================================

    /// Verify parse_output returns Proven for no errors detected
    #[kani::proof]
    fn proof_parse_output_proven_no_errors() {
        let backend = JpfBackend::new();
        let (status, _, _) = backend.parse_output("no errors detected", "");
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should return Proven for no errors detected",
        );
    }

    /// Verify parse_output returns Disproven for error #
    #[kani::proof]
    fn proof_parse_output_disproven_error() {
        let backend = JpfBackend::new();
        let (status, _, _) = backend.parse_output("error #1", "");
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should return Disproven for error #",
        );
    }

    /// Verify parse_output returns Disproven for AssertionError
    #[kani::proof]
    fn proof_parse_output_disproven_assertion_error() {
        let backend = JpfBackend::new();
        let (status, _, _) = backend.parse_output("java.lang.AssertionError: test", "");
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should return Disproven for AssertionError",
        );
    }

    /// Verify parse_output returns Disproven for race detected
    #[kani::proof]
    fn proof_parse_output_disproven_race() {
        let backend = JpfBackend::new();
        let (status, _, _) = backend.parse_output("race detected", "");
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should return Disproven for race detected",
        );
    }

    /// Verify parse_output returns Disproven for deadlock detected
    #[kani::proof]
    fn proof_parse_output_disproven_deadlock() {
        let backend = JpfBackend::new();
        let (status, _, _) = backend.parse_output("deadlock detected", "");
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should return Disproven for deadlock detected",
        );
    }

    /// Verify parse_output returns Unknown for OutOfMemoryError
    #[kani::proof]
    fn proof_parse_output_unknown_oom() {
        let backend = JpfBackend::new();
        let (status, _, _) = backend.parse_output("", "java.lang.OutOfMemoryError");
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should return Unknown for OutOfMemoryError",
        );
    }

    /// Verify parse_output returns Unknown for depth limit
    #[kani::proof]
    fn proof_parse_output_unknown_depth_limit() {
        let backend = JpfBackend::new();
        let (status, _, _) = backend.parse_output("search constraint hit: depth limit reached", "");
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should return Unknown for depth limit",
        );
    }

    // =============================================
    // JpfBackend constructor proofs
    // =============================================

    /// Verify JpfBackend::new creates backend with default config
    #[kani::proof]
    fn proof_jpf_backend_new_default_config() {
        let backend = JpfBackend::new();
        kani::assert(
            backend.config.timeout == Duration::from_secs(120),
            "New backend should have default timeout",
        );
    }

    /// Verify JpfBackend::with_config preserves config
    #[kani::proof]
    fn proof_jpf_backend_with_config() {
        let config = JpfConfig {
            timeout: Duration::from_secs(60),
            ..Default::default()
        };
        let backend = JpfBackend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(60),
            "Custom config should be preserved",
        );
    }

    /// Verify JpfBackend implements Default
    #[kani::proof]
    fn proof_jpf_backend_default() {
        let backend = JpfBackend::default();
        kani::assert(
            backend.id() == BackendId::JPF,
            "Default backend should have correct ID",
        );
    }

    /// Verify JpfBackend config search_depth can be set
    #[kani::proof]
    fn proof_jpf_config_with_search_depth() {
        let config = JpfConfig {
            search_depth: 200,
            ..Default::default()
        };
        let backend = JpfBackend::with_config(config);
        kani::assert(
            backend.config.search_depth == 200,
            "Search depth should be preserved",
        );
    }

    /// Verify JpfBackend config detect_races can be disabled
    #[kani::proof]
    fn proof_jpf_config_no_race_detection() {
        let config = JpfConfig {
            detect_races: false,
            ..Default::default()
        };
        let backend = JpfBackend::with_config(config);
        kani::assert(
            !backend.config.detect_races,
            "Race detection should be disabled",
        );
    }

    /// Verify JpfBackend config detect_deadlocks can be disabled
    #[kani::proof]
    fn proof_jpf_config_no_deadlock_detection() {
        let config = JpfConfig {
            detect_deadlocks: false,
            ..Default::default()
        };
        let backend = JpfBackend::with_config(config);
        kani::assert(
            !backend.config.detect_deadlocks,
            "Deadlock detection should be disabled",
        );
    }

    // =============================================
    // generate_jpf_config function proofs
    // =============================================

    /// Verify generate_jpf_config includes target
    #[kani::proof]
    fn proof_generate_jpf_config_has_target() {
        let backend = JpfBackend::new();
        let config = backend.generate_jpf_config("/tmp");
        kani::assert(
            config.contains("target = DashProveTest"),
            "Config should include target",
        );
    }

    /// Verify generate_jpf_config includes classpath
    #[kani::proof]
    fn proof_generate_jpf_config_has_classpath() {
        let backend = JpfBackend::new();
        let config = backend.generate_jpf_config("/tmp/classes");
        kani::assert(
            config.contains("classpath = /tmp/classes"),
            "Config should include classpath",
        );
    }

    /// Verify generate_jpf_config includes search class
    #[kani::proof]
    fn proof_generate_jpf_config_has_search_class() {
        let backend = JpfBackend::new();
        let config = backend.generate_jpf_config("/tmp");
        kani::assert(
            config.contains("search.class"),
            "Config should include search class",
        );
    }

    /// Verify generate_jpf_config includes search depth
    #[kani::proof]
    fn proof_generate_jpf_config_has_search_depth() {
        let backend = JpfBackend::new();
        let config = backend.generate_jpf_config("/tmp");
        kani::assert(
            config.contains("search.depth_limit"),
            "Config should include search depth",
        );
    }

    /// Verify generate_jpf_config includes race detector when enabled
    #[kani::proof]
    fn proof_generate_jpf_config_race_detector() {
        let backend = JpfBackend::new();
        let config = backend.generate_jpf_config("/tmp");
        kani::assert(
            config.contains("PreciseRaceDetector"),
            "Config should include race detector",
        );
    }

    /// Verify generate_jpf_config excludes race detector when disabled
    #[kani::proof]
    fn proof_generate_jpf_config_no_race_detector() {
        let cfg = JpfConfig {
            detect_races: false,
            ..Default::default()
        };
        let backend = JpfBackend::with_config(cfg);
        let config = backend.generate_jpf_config("/tmp");
        kani::assert(
            !config.contains("PreciseRaceDetector"),
            "Config should not include race detector",
        );
    }

    /// Verify generate_jpf_config includes deadlock analyzer when enabled
    #[kani::proof]
    fn proof_generate_jpf_config_deadlock_analyzer() {
        let backend = JpfBackend::new();
        let config = backend.generate_jpf_config("/tmp");
        kani::assert(
            config.contains("DeadlockAnalyzer"),
            "Config should include deadlock analyzer",
        );
    }
}
