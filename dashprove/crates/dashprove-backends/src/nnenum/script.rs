//! Nnenum script generation and output parsing

use super::config::NnenumConfig;
use crate::counterexample::StructuredCounterexample;
use crate::traits::{BackendError, VerificationStatus};
use dashprove_usl::ast::{ComparisonOp, Expr, Property};
use dashprove_usl::typecheck::TypedSpec;

/// Generate a nnenum verification script from USL spec
pub fn generate_nnenum_script(
    spec: &TypedSpec,
    config: &NnenumConfig,
) -> Result<String, BackendError> {
    let epsilon = extract_epsilon_from_spec(spec).unwrap_or(config.epsilon);
    let model_path = extract_model_path_from_spec(spec)
        .or_else(|| config.model_path.as_ref().map(|p| p.display().to_string()))
        .unwrap_or_else(|| "model.onnx".to_string());
    let strategy = config.strategy.as_str();
    let num_processes = config.num_processes;
    let exact_arithmetic = if config.exact_arithmetic {
        "True"
    } else {
        "False"
    };
    let max_lp_calls = config
        .max_lp_calls
        .map_or("None".to_string(), |n| n.to_string());

    Ok(format!(
        r#"#!/usr/bin/env python3
"""
nnenum neural network verification script
Generated by DashProve

nnenum uses exact enumeration of linear regions for complete verification.
"""

import sys
import json
import numpy as np

try:
    import nnenum
    from nnenum import enumerate_network
    from nnenum.settings import Settings
    from nnenum.network import load_network
    from nnenum.specification import Specification
except ImportError as e:
    print(f"NNENUM_ERROR: Missing dependency: {{e}}")
    print("NNENUM_ERROR: Install with: pip install nnenum")
    sys.exit(1)

def load_onnx_network(model_path: str):
    """Load network from ONNX file."""
    try:
        network = load_network(model_path)
        return network
    except Exception as e:
        print(f"NNENUM_ERROR: Failed to load network: {{e}}")
        return None

def create_test_network():
    """Create a simple test network for demonstration."""
    import torch
    import torch.nn as nn

    model = nn.Sequential(
        nn.Linear(2, 4),
        nn.ReLU(),
        nn.Linear(4, 2)
    )

    with torch.no_grad():
        model[0].weight.fill_(0.5)
        model[0].bias.fill_(0.1)
        model[2].weight.fill_(0.3)
        model[2].bias.fill_(0.0)

    return model

def create_specification(center, epsilon, true_label, num_classes):
    """Create verification specification (input bounds + output property)."""
    input_dim = len(center)

    # Input bounds: L-inf ball around center
    input_lb = center - epsilon
    input_ub = center + epsilon

    # Output specification: true_label has max output
    # For each other class i: output[true_label] > output[i]
    # This is: output[true_label] - output[i] > 0

    spec = {{
        "input_lb": input_lb.tolist(),
        "input_ub": input_ub.tolist(),
        "output_constraints": []
    }}

    for i in range(num_classes):
        if i != true_label:
            # Constraint: output[true_label] - output[i] >= 0
            constraint = [0.0] * num_classes
            constraint[true_label] = 1.0
            constraint[i] = -1.0
            spec["output_constraints"].append({{
                "coefficients": constraint,
                "rhs": 0.0,
                "type": "ge"
            }})

    return spec

def verify_with_nnenum(network, spec_dict, settings):
    """Run nnenum verification."""
    try:
        # Configure settings
        settings.PARALLEL_COUNT = {num_processes}
        settings.EXACT_ARITHMETIC = {exact_arithmetic}
        if {max_lp_calls} is not None:
            settings.MAX_LP_CALLS = {max_lp_calls}

        # Create input star from bounds
        input_lb = np.array(spec_dict["input_lb"])
        input_ub = np.array(spec_dict["input_ub"])

        # Run enumeration
        result = enumerate_network(
            network,
            input_lb,
            input_ub,
            spec_dict["output_constraints"],
            settings=settings
        )

        return result
    except Exception as e:
        print(f"NNENUM_INFO: Verification error: {{e}}")
        return None

def main():
    model_path = "{model_path}"
    epsilon = {epsilon}
    strategy = "{strategy}"
    num_processes = {num_processes}
    exact = {exact_arithmetic}

    # Load or create network
    network = load_onnx_network(model_path)

    if network is None:
        print("NNENUM_INFO: Using synthetic test network")
        network = create_test_network()
        input_dim = 2
        output_dim = 2
    else:
        input_dim = network.get_input_shape()[0]
        output_dim = network.get_output_shape()[0]

    # Configure settings
    settings = Settings()
    settings.PRINT_OUTPUT = False

    # Test samples
    np.random.seed(42)
    num_samples = 10
    test_inputs = np.random.rand(num_samples, input_dim).astype(np.float32)

    verified_count = 0
    total_count = num_samples
    counterexamples = []

    for i, x in enumerate(test_inputs):
        # Get true label
        try:
            if hasattr(network, 'forward'):
                import torch
                with torch.no_grad():
                    output = network(torch.tensor(x).unsqueeze(0))
                    true_label = output.argmax().item()
            else:
                output = network.evaluate(x)
                true_label = int(np.argmax(output))
        except Exception as e:
            print(f"NNENUM_INFO: Forward pass error: {{e}}")
            true_label = 0

        # Create specification
        spec_dict = create_specification(x, epsilon, true_label, output_dim)

        # Verify
        result = verify_with_nnenum(network, spec_dict, settings)

        if result is None:
            continue
        elif result.get("safe", False):
            verified_count += 1
        else:
            if result.get("counterexample") is not None:
                counterexamples.append({{
                    "sample_index": i,
                    "original_input": x.tolist(),
                    "true_label": int(true_label),
                    "counterexample": result["counterexample"].tolist() if hasattr(result["counterexample"], "tolist") else str(result["counterexample"])
                }})

    verification_rate = verified_count / total_count if total_count > 0 else 0.0

    # Output results
    print("NNENUM_RESULT_START")
    result = {{
        "verified_count": verified_count,
        "total_count": total_count,
        "verification_rate": float(verification_rate),
        "epsilon": float(epsilon),
        "strategy": strategy,
        "exact_arithmetic": exact,
        "input_dim": int(input_dim),
        "output_dim": int(output_dim),
        "num_counterexamples": len(counterexamples)
    }}

    if counterexamples:
        result["counterexample"] = counterexamples[0]

    print(json.dumps(result, indent=2))
    print("NNENUM_RESULT_END")

    print(f"\\nNNENUM_SUMMARY: Verified {{verified_count}}/{{total_count}} samples ({{verification_rate:.2%}})")
    print(f"NNENUM_SUMMARY: Strategy: {{strategy}}, Exact: {{exact}}, Epsilon: {{epsilon}}")

    if verification_rate >= 0.99:
        print("NNENUM_STATUS: VERIFIED")
    elif verification_rate >= 0.90:
        print("NNENUM_STATUS: PARTIALLY_VERIFIED")
    else:
        print("NNENUM_STATUS: NOT_VERIFIED")

if __name__ == "__main__":
    main()
"#
    ))
}

/// Extract epsilon value from USL spec properties
fn extract_epsilon_from_spec(spec: &TypedSpec) -> Option<f64> {
    for prop in &spec.spec.properties {
        let expr = match prop {
            Property::Invariant(inv) => Some(&inv.body),
            Property::Theorem(thm) => Some(&thm.body),
            Property::Security(sec) => Some(&sec.body),
            Property::Probabilistic(prob) => Some(&prob.condition),
            _ => None,
        };
        if let Some(e) = expr {
            if let Some(eps) = extract_epsilon(e) {
                return Some(eps);
            }
        }
    }
    None
}

/// Extract epsilon from expression
fn extract_epsilon(expr: &Expr) -> Option<f64> {
    match expr {
        Expr::Compare(lhs, op, rhs) => {
            if let Expr::Var(name) = lhs.as_ref() {
                let lower = name.to_lowercase();
                if (lower.contains("epsilon") || lower == "eps")
                    && matches!(op, ComparisonOp::Le | ComparisonOp::Lt)
                {
                    return extract_numeric_value(rhs);
                }
            }
            if let Expr::Var(name) = rhs.as_ref() {
                let lower = name.to_lowercase();
                if (lower.contains("epsilon") || lower == "eps")
                    && matches!(op, ComparisonOp::Ge | ComparisonOp::Gt)
                {
                    return extract_numeric_value(lhs);
                }
            }
            if matches!(op, ComparisonOp::Le | ComparisonOp::Lt) {
                if let Some(val) = extract_numeric_value(rhs) {
                    if val > 0.0 && val < 1.0 {
                        return Some(val);
                    }
                }
            }
            extract_epsilon(lhs).or_else(|| extract_epsilon(rhs))
        }
        Expr::And(lhs, rhs) | Expr::Or(lhs, rhs) | Expr::Implies(lhs, rhs) => {
            extract_epsilon(lhs).or_else(|| extract_epsilon(rhs))
        }
        Expr::Not(inner) | Expr::Neg(inner) => extract_epsilon(inner),
        Expr::Binary(lhs, _, rhs) => extract_epsilon(lhs).or_else(|| extract_epsilon(rhs)),
        Expr::ForAll { body, .. }
        | Expr::Exists { body, .. }
        | Expr::ForAllIn { body, .. }
        | Expr::ExistsIn { body, .. } => extract_epsilon(body),
        Expr::FieldAccess(obj, _) => extract_epsilon(obj),
        Expr::MethodCall { receiver, args, .. } => {
            extract_epsilon(receiver).or_else(|| args.iter().find_map(extract_epsilon))
        }
        Expr::App(_, args) => args.iter().find_map(extract_epsilon),
        Expr::Var(_) | Expr::Int(_) | Expr::Float(_) | Expr::String(_) | Expr::Bool(_) => None,
    }
}

/// Extract numeric value from expression
fn extract_numeric_value(expr: &Expr) -> Option<f64> {
    match expr {
        Expr::Float(f) => Some(*f),
        Expr::Int(i) => Some(*i as f64),
        Expr::Neg(inner) => extract_numeric_value(inner).map(|v| -v),
        _ => None,
    }
}

/// Extract model path from USL spec
fn extract_model_path_from_spec(spec: &TypedSpec) -> Option<String> {
    for typedef in &spec.spec.types {
        for field in &typedef.fields {
            let lower = field.name.to_lowercase();
            if lower.contains("model") || lower.contains("network") {
                if let dashprove_usl::ast::Type::Named(name) = &field.ty {
                    if name.to_lowercase().contains("path")
                        || name.to_lowercase().contains("string")
                    {
                        return Some(field.name.clone());
                    }
                }
            }
        }
    }
    None
}

/// Parse nnenum script output
pub fn parse_nnenum_output(
    stdout: &str,
    stderr: &str,
) -> (VerificationStatus, Option<StructuredCounterexample>) {
    // Check for errors
    if stdout.contains("NNENUM_ERROR:") || stderr.contains("NNENUM_ERROR:") {
        let error_msg = stdout
            .lines()
            .chain(stderr.lines())
            .find(|l| l.contains("NNENUM_ERROR:"))
            .map(|l| l.replace("NNENUM_ERROR:", "").trim().to_string())
            .unwrap_or_else(|| "Unknown nnenum error".to_string());

        return (VerificationStatus::Unknown { reason: error_msg }, None);
    }

    // Parse JSON result
    if let Some(json_str) = extract_json_result(stdout) {
        if let Ok(result) = serde_json::from_str::<serde_json::Value>(&json_str) {
            let verification_rate = result["verification_rate"].as_f64().unwrap_or(0.0);

            let counterexample =
                crate::counterexample::build_nn_verification_counterexample(&result, "Nnenum");

            if verification_rate >= 0.99 {
                return (VerificationStatus::Proven, None);
            } else if verification_rate >= 0.90 {
                return (
                    VerificationStatus::Partial {
                        verified_percentage: verification_rate * 100.0,
                    },
                    counterexample,
                );
            } else {
                return (VerificationStatus::Disproven, counterexample);
            }
        }
    }

    // Fallback: parse status line
    if stdout.contains("NNENUM_STATUS: VERIFIED") {
        (VerificationStatus::Proven, None)
    } else if stdout.contains("NNENUM_STATUS: PARTIALLY_VERIFIED") {
        (
            VerificationStatus::Partial {
                verified_percentage: 90.0,
            },
            None,
        )
    } else if stdout.contains("NNENUM_STATUS: NOT_VERIFIED") {
        (VerificationStatus::Disproven, None)
    } else {
        (
            VerificationStatus::Unknown {
                reason: "Could not parse nnenum output".to_string(),
            },
            None,
        )
    }
}

/// Extract JSON result from output
fn extract_json_result(output: &str) -> Option<String> {
    let start_marker = "NNENUM_RESULT_START";
    let end_marker = "NNENUM_RESULT_END";

    if let Some(start) = output.find(start_marker) {
        let after_start = &output[start + start_marker.len()..];
        if let Some(end) = after_start.find(end_marker) {
            return Some(after_start[..end].trim().to_string());
        }
    }
    None
}
