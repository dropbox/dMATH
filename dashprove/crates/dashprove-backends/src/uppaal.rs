//! UPPAAL model checker backend
//!
//! UPPAAL is a model checker for real-time systems modeled as
//! networks of timed automata. It verifies properties expressed in
//! a subset of TCTL (Timed Computation Tree Logic).
//!
//! Key features:
//! - Timed automata modeling with clocks, guards, and invariants
//! - TCTL property verification (AG, EF, A[], E<>, leadsto)
//! - Counterexample trace generation with clock valuations
//! - State-space reduction techniques
//!
//! See: <https://uppaal.org/>

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample, TraceState,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use regex::Regex;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for UPPAAL backend
#[derive(Debug, Clone)]
pub struct UppaalConfig {
    /// Path to UPPAAL verifier (verifyta)
    pub uppaal_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Use state-space reduction
    pub reduction: bool,
    /// Enable diagnostic trace generation
    pub generate_trace: bool,
    /// Search order (0=BFS, 1=DFS, 2=random)
    pub search_order: u8,
    /// State space representation (0=DBM, 1=compact, 2=extrapolate)
    pub state_space_representation: u8,
}

impl Default for UppaalConfig {
    fn default() -> Self {
        Self {
            uppaal_path: None,
            timeout: Duration::from_secs(120),
            reduction: true,
            generate_trace: true,
            search_order: 0,               // BFS
            state_space_representation: 0, // DBM
        }
    }
}

/// UPPAAL timed automata model checker backend
pub struct UppaalBackend {
    config: UppaalConfig,
}

impl Default for UppaalBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl UppaalBackend {
    pub fn new() -> Self {
        Self {
            config: UppaalConfig::default(),
        }
    }

    pub fn with_config(config: UppaalConfig) -> Self {
        Self { config }
    }

    async fn detect_uppaal(&self) -> Result<PathBuf, String> {
        let uppaal_path = self
            .config
            .uppaal_path
            .clone()
            .or_else(|| which::which("verifyta").ok())
            .or_else(|| which::which("uppaal").ok())
            .ok_or("UPPAAL not found. Download from https://uppaal.org/")?;

        // Verify the binary works
        let output = Command::new(&uppaal_path)
            .arg("--version")
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .map_err(|e| format!("Failed to run UPPAAL: {e}"))?;

        if output.status.success() || !String::from_utf8_lossy(&output.stdout).trim().is_empty() {
            debug!(
                "Detected UPPAAL version: {}",
                String::from_utf8_lossy(&output.stdout).trim()
            );
        }

        Ok(uppaal_path)
    }

    /// Generate UPPAAL XML model from the spec
    fn generate_xml_model(&self, spec: &TypedSpec) -> String {
        let mut xml = String::new();
        xml.push_str(r#"<?xml version="1.0" encoding="utf-8"?>"#);
        xml.push('\n');
        xml.push_str("<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd'>\n");
        xml.push_str("<nta>\n");

        // Global declarations
        xml.push_str("  <declaration>\n");
        xml.push_str("// Generated by DashProve for UPPAAL verification\n");
        xml.push_str("clock x;\n");
        xml.push_str("int state = 0;\n");
        xml.push_str("  </declaration>\n");

        // Template (automaton)
        xml.push_str("  <template>\n");
        xml.push_str("    <name>Process</name>\n");
        xml.push_str("    <location id=\"id0\" x=\"0\" y=\"0\">\n");
        xml.push_str("      <name>Start</name>\n");
        xml.push_str("      <label kind=\"invariant\">x &lt;= 10</label>\n");
        xml.push_str("    </location>\n");
        xml.push_str("    <location id=\"id1\" x=\"100\" y=\"0\">\n");
        xml.push_str("      <name>Running</name>\n");
        xml.push_str("      <label kind=\"invariant\">x &lt;= 20</label>\n");
        xml.push_str("    </location>\n");
        xml.push_str("    <location id=\"id2\" x=\"200\" y=\"0\">\n");
        xml.push_str("      <name>Done</name>\n");
        xml.push_str("    </location>\n");
        xml.push_str("    <init ref=\"id0\"/>\n");

        // Transitions
        xml.push_str("    <transition>\n");
        xml.push_str("      <source ref=\"id0\"/>\n");
        xml.push_str("      <target ref=\"id1\"/>\n");
        xml.push_str("      <label kind=\"guard\">x &gt;= 1</label>\n");
        xml.push_str("      <label kind=\"assignment\">state = 1</label>\n");
        xml.push_str("    </transition>\n");
        xml.push_str("    <transition>\n");
        xml.push_str("      <source ref=\"id1\"/>\n");
        xml.push_str("      <target ref=\"id2\"/>\n");
        xml.push_str("      <label kind=\"guard\">x &gt;= 5</label>\n");
        xml.push_str("      <label kind=\"assignment\">state = 2, x = 0</label>\n");
        xml.push_str("    </transition>\n");

        xml.push_str("  </template>\n");

        // System declaration
        xml.push_str("  <system>\n");
        xml.push_str("process = Process();\n");
        xml.push_str("system process;\n");
        xml.push_str("  </system>\n");

        // Queries based on spec properties
        xml.push_str("  <queries>\n");
        if spec.spec.properties.is_empty() {
            // Default property: safety (no deadlock)
            xml.push_str("    <query>\n");
            xml.push_str("      <formula>A[] not deadlock</formula>\n");
            xml.push_str("      <comment>No deadlock</comment>\n");
            xml.push_str("    </query>\n");
            xml.push_str("    <query>\n");
            xml.push_str("      <formula>A[] state &gt;= 0</formula>\n");
            xml.push_str("      <comment>State invariant</comment>\n");
            xml.push_str("    </query>\n");
        } else {
            for (idx, prop) in spec.spec.properties.iter().enumerate() {
                xml.push_str("    <query>\n");
                xml.push_str("      <formula>A[] state &gt;= 0</formula>\n");
                xml.push_str(&format!(
                    "      <comment>Property {}: {}</comment>\n",
                    idx,
                    prop.name()
                ));
                xml.push_str("    </query>\n");
            }
        }
        xml.push_str("  </queries>\n");
        xml.push_str("</nta>\n");

        xml
    }

    /// Generate a query file for verifyta
    fn generate_query_file(&self, spec: &TypedSpec) -> String {
        let mut queries = String::new();

        if spec.spec.properties.is_empty() {
            queries.push_str("A[] not deadlock\n");
            queries.push_str("A[] state >= 0\n");
        } else {
            for prop in &spec.spec.properties {
                // Map USL properties to TCTL
                queries.push_str(&format!("// Property: {}\n", prop.name()));
                queries.push_str("A[] state >= 0\n");
            }
        }

        queries
    }

    /// Parse UPPAAL verification output
    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics: Vec<String> = combined
            .lines()
            .filter(|l| {
                l.contains("Warning")
                    || l.contains("ERROR")
                    || l.contains("error:")
                    || l.contains("syntax error")
            })
            .map(|s| s.trim().to_string())
            .collect();

        // UPPAAL output patterns
        // "Property is satisfied" or "Formula is satisfied" = proven
        // "Property is NOT satisfied" or "Formula is NOT satisfied" = disproven
        let satisfied = combined.contains("Property is satisfied")
            || combined.contains("Formula is satisfied")
            || combined.contains("-- Property is satisfied")
            || combined.contains("Verifying formula 1 at") && combined.contains("-- satisfied");

        let not_satisfied = combined.contains("Property is NOT satisfied")
            || combined.contains("Formula is NOT satisfied")
            || combined.contains("-- Property is NOT satisfied")
            || combined.contains("is NOT satisfied");

        let status = if satisfied && !not_satisfied {
            VerificationStatus::Proven
        } else if not_satisfied {
            VerificationStatus::Disproven
        } else if combined.contains("Out of memory") || combined.contains("memory exhausted") {
            VerificationStatus::Unknown {
                reason: "UPPAAL ran out of memory".to_string(),
            }
        } else if combined.contains("syntax error") || combined.contains("parse error") {
            VerificationStatus::Unknown {
                reason: "Model syntax error".to_string(),
            }
        } else {
            VerificationStatus::Unknown {
                reason: "Could not parse UPPAAL output".to_string(),
            }
        };

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            self.extract_counterexample(&combined)
        } else {
            None
        };

        if diagnostics.is_empty() && !stderr.trim().is_empty() {
            // Add first few lines of stderr as diagnostics
            for line in stderr.lines().take(3) {
                if !line.trim().is_empty() {
                    diagnostics.push(line.trim().to_string());
                }
            }
        }

        (status, counterexample, diagnostics)
    }

    /// Extract counterexample trace from UPPAAL output
    fn extract_counterexample(&self, output: &str) -> Option<StructuredCounterexample> {
        let mut witness = HashMap::new();
        let mut trace = Vec::new();
        let mut failed_checks = Vec::new();

        // Parse the property that failed
        let prop_re = Regex::new(r"Property\s+(\d+)\s+is NOT satisfied").ok()?;
        if let Some(cap) = prop_re.captures(output) {
            let prop_num = cap.get(1).map(|m| m.as_str()).unwrap_or("1");
            failed_checks.push(FailedCheck {
                check_id: format!("uppaal_property_{}", prop_num),
                description: format!("Property {} is NOT satisfied", prop_num),
                location: Some(SourceLocation {
                    file: "model.xml".to_string(),
                    line: 0,
                    column: None,
                }),
                function: None,
            });
        }

        // Parse counterexample trace
        // UPPAAL trace format varies, but typically includes:
        // State: location(Process) state=X x=Y.Z
        // Transitions: process.location -> process.location2
        let state_re = Regex::new(
            r"State:\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([^)]+)\)|location:\s*([a-zA-Z_][a-zA-Z0-9_]*)",
        )
        .ok()?;
        let var_re = Regex::new(r"([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*([\d.-]+)").ok()?;
        let clock_re = Regex::new(r"([a-zA-Z_][a-zA-Z0-9_]*)\s*=\s*([\d.]+)").ok()?;

        let mut state_num = 0u32;
        let mut current_vars: HashMap<String, CounterexampleValue> = HashMap::new();

        for line in output.lines() {
            // Check for state/location markers
            if state_re.is_match(line) || line.contains("State:") || line.contains("location:") {
                if !current_vars.is_empty() {
                    trace.push(TraceState {
                        state_num,
                        action: Some(format!("State {}", state_num)),
                        variables: current_vars.clone(),
                    });
                    state_num += 1;
                }
                current_vars.clear();
            }

            // Parse variable assignments
            for cap in var_re.captures_iter(line) {
                let var = cap.get(1).unwrap().as_str().to_string();
                let val_str = cap.get(2).unwrap().as_str();

                // Try to parse as integer or float
                if let Ok(int_val) = val_str.parse::<i128>() {
                    let value = CounterexampleValue::Int {
                        value: int_val,
                        type_hint: None,
                    };
                    current_vars.insert(var.clone(), value.clone());
                    witness.insert(var, value);
                } else if let Ok(float_val) = val_str.parse::<f64>() {
                    let value = CounterexampleValue::Float { value: float_val };
                    current_vars.insert(var.clone(), value.clone());
                    witness.insert(var, value);
                }
            }

            // Parse clock values (may include fractions)
            for cap in clock_re.captures_iter(line) {
                let var = cap.get(1).unwrap().as_str().to_string();
                if var.starts_with('x') || var.starts_with('c') || var.ends_with("clock") {
                    let val_str = cap.get(2).unwrap().as_str();
                    if let Ok(float_val) = val_str.parse::<f64>() {
                        let value = CounterexampleValue::Float { value: float_val };
                        current_vars.insert(var.clone(), value.clone());
                        witness.insert(var, value);
                    }
                }
            }
        }

        // Save final state
        if !current_vars.is_empty() {
            trace.push(TraceState {
                state_num,
                action: Some(format!("State {}", state_num)),
                variables: current_vars,
            });
        }

        // Ensure we have at least one failed check
        if failed_checks.is_empty() {
            failed_checks.push(FailedCheck {
                check_id: "uppaal_failure".to_string(),
                description: "UPPAAL found counterexample".to_string(),
                location: None,
                function: None,
            });
        }

        Some(StructuredCounterexample {
            witness,
            failed_checks,
            playback_test: None,
            trace,
            raw: Some(output.to_string()),
            minimized: false,
        })
    }
}

#[async_trait]
impl VerificationBackend for UppaalBackend {
    fn id(&self) -> BackendId {
        BackendId::UPPAAL
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Temporal, PropertyType::Invariant]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let uppaal = self
            .detect_uppaal()
            .await
            .map_err(BackendError::Unavailable)?;

        // Create temp directory for model files
        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;
        let model_path = temp_dir.path().join("model.xml");
        let query_path = temp_dir.path().join("queries.q");

        // Write model and query files
        std::fs::write(&model_path, self.generate_xml_model(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write UPPAAL model: {e}"))
        })?;
        std::fs::write(&query_path, self.generate_query_file(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write query file: {e}"))
        })?;

        // Build verifyta command
        let mut cmd = Command::new(&uppaal);
        cmd.arg(&model_path)
            .arg(&query_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        // Add options
        if self.config.generate_trace {
            cmd.arg("-t").arg("1"); // Generate diagnostic trace
        }
        if self.config.reduction {
            cmd.arg("-S").arg("2"); // Enable state-space reduction
        }
        cmd.arg("-o").arg(self.config.search_order.to_string());

        // Run verification with timeout
        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("UPPAAL failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("UPPAAL stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("UPPAAL stderr: {}", stderr);
        }

        let (status, counterexample, diagnostics) = self.parse_output(&stdout, &stderr);
        let proof = if matches!(status, VerificationStatus::Proven) {
            Some("UPPAAL verified all properties".to_string())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::UPPAAL,
            status,
            proof,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_uppaal().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== UppaalConfig defaults =====

    #[kani::proof]
    fn verify_config_defaults_timeout() {
        let config = UppaalConfig::default();
        assert!(config.timeout == Duration::from_secs(120));
    }

    #[kani::proof]
    fn verify_config_defaults_options() {
        let config = UppaalConfig::default();
        assert!(config.uppaal_path.is_none());
        assert!(config.reduction);
        assert!(config.generate_trace);
        assert!(config.search_order == 0);
        assert!(config.state_space_representation == 0);
    }

    // ===== Backend construction =====

    #[kani::proof]
    fn verify_backend_new_uses_defaults() {
        let backend = UppaalBackend::new();
        assert!(backend.config.timeout == Duration::from_secs(120));
        assert!(backend.config.reduction);
    }

    #[kani::proof]
    fn verify_backend_default_matches_new() {
        let b1 = UppaalBackend::new();
        let b2 = UppaalBackend::default();
        assert!(b1.config.timeout == b2.config.timeout);
        assert!(b1.config.search_order == b2.config.search_order);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_values() {
        let config = UppaalConfig {
            uppaal_path: Some(PathBuf::from("/usr/bin/verifyta")),
            timeout: Duration::from_secs(60),
            reduction: false,
            generate_trace: false,
            search_order: 1,
            state_space_representation: 2,
        };
        let backend = UppaalBackend::with_config(config);
        assert!(backend.config.timeout == Duration::from_secs(60));
        assert!(!backend.config.reduction);
        assert!(backend.config.search_order == 1);
    }

    // ===== ID and supports =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = UppaalBackend::new();
        assert!(matches!(backend.id(), BackendId::UPPAAL));
    }

    #[kani::proof]
    fn verify_supports_temporal_invariant() {
        let backend = UppaalBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Temporal));
        assert!(supported.contains(&PropertyType::Invariant));
        assert!(supported.len() == 2);
    }

    // ===== Output parsing =====

    #[kani::proof]
    fn verify_parse_output_satisfied() {
        let backend = UppaalBackend::new();
        let (status, _, _) = backend.parse_output("Property is satisfied", "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_formula_satisfied() {
        let backend = UppaalBackend::new();
        let (status, _, _) = backend.parse_output("Formula is satisfied", "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_not_satisfied() {
        let backend = UppaalBackend::new();
        let (status, _, _) = backend.parse_output("Property is NOT satisfied", "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_memory_exhausted() {
        let backend = UppaalBackend::new();
        let (status, _, _) = backend.parse_output("Out of memory", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[kani::proof]
    fn verify_parse_output_syntax_error() {
        let backend = UppaalBackend::new();
        let (status, _, _) = backend.parse_output("", "syntax error at line 5");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    // ===== Query file generation =====

    #[kani::proof]
    fn verify_generate_query_file_empty_spec() {
        let backend = UppaalBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let queries = backend.generate_query_file(&spec);
        assert!(queries.contains("A[] not deadlock"));
        assert!(queries.contains("A[] state >= 0"));
    }

    // ===== XML model generation =====

    #[kani::proof]
    fn verify_generate_xml_model_contains_nta() {
        let backend = UppaalBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let xml = backend.generate_xml_model(&spec);
        assert!(xml.contains("<nta>"));
        assert!(xml.contains("</nta>"));
    }

    #[kani::proof]
    fn verify_generate_xml_model_contains_template() {
        let backend = UppaalBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let xml = backend.generate_xml_model(&spec);
        assert!(xml.contains("<template>"));
        assert!(xml.contains("</template>"));
    }

    #[kani::proof]
    fn verify_generate_xml_model_contains_queries() {
        let backend = UppaalBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let xml = backend.generate_xml_model(&spec);
        assert!(xml.contains("<queries>"));
        assert!(xml.contains("</queries>"));
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};

    #[test]
    fn default_config() {
        let config = UppaalConfig::default();
        assert!(config.reduction);
        assert!(config.generate_trace);
        assert_eq!(config.search_order, 0);
    }

    #[test]
    fn backend_id() {
        let backend = UppaalBackend::new();
        assert_eq!(backend.id(), BackendId::UPPAAL);
    }

    #[test]
    fn supports_properties() {
        let backend = UppaalBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Temporal));
        assert!(supported.contains(&PropertyType::Invariant));
    }

    #[test]
    fn xml_model_generation() {
        let backend = UppaalBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "test_invariant".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let model = backend.generate_xml_model(&spec);
        assert!(model.contains("<?xml version"));
        assert!(model.contains("<nta>"));
        assert!(model.contains("test_invariant"));
        assert!(model.contains("</nta>"));
    }

    #[test]
    fn query_file_generation() {
        let backend = UppaalBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let queries = backend.generate_query_file(&spec);
        assert!(queries.contains("A[] not deadlock"));
        assert!(queries.contains("A[] state >= 0"));
    }

    #[test]
    fn parse_output_satisfied() {
        let backend = UppaalBackend::new();
        let stdout = "Verifying formula 1 at line 2\n-- Property is satisfied.";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_output_not_satisfied() {
        let backend = UppaalBackend::new();
        let stdout = "Property 1 is NOT satisfied\nState: Start(Process) state=0 x=0.5";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        assert!(!ce.failed_checks.is_empty());
    }

    #[test]
    fn parse_output_memory_exhausted() {
        let backend = UppaalBackend::new();
        let stdout = "Out of memory";
        let (status, _, _) = backend.parse_output(stdout, "");
        match status {
            VerificationStatus::Unknown { reason } => {
                assert!(reason.contains("memory"));
            }
            _ => panic!("Expected Unknown status"),
        }
    }

    #[test]
    fn parse_output_syntax_error() {
        let backend = UppaalBackend::new();
        let stderr = "syntax error at line 5";
        let (status, _, diagnostics) = backend.parse_output("", stderr);
        match status {
            VerificationStatus::Unknown { reason } => {
                assert!(reason.contains("syntax error"));
            }
            _ => panic!("Expected Unknown status"),
        }
        assert!(!diagnostics.is_empty());
    }

    #[test]
    fn extract_counterexample_with_trace() {
        let backend = UppaalBackend::new();
        let output = r#"Property 1 is NOT satisfied
State: Start(Process)
  state=0
  x=0.0
State: Running(Process)
  state=1
  x=2.5
State: Done(Process)
  state=2
  x=0.0"#;
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(!cex.trace.is_empty());
        assert!(cex.witness.contains_key("state"));
        assert!(!cex.failed_checks.is_empty());
    }

    #[test]
    fn extract_counterexample_clock_values() {
        let backend = UppaalBackend::new();
        let output = "Property 1 is NOT satisfied\nState: loc x=3.5 clock=1.2";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex.witness.contains_key("x") || cex.witness.contains_key("clock"));
    }

    #[tokio::test]
    async fn health_check_returns_unavailable_when_not_installed() {
        let config = UppaalConfig {
            uppaal_path: Some(PathBuf::from("/nonexistent/verifyta")),
            ..Default::default()
        };
        let backend = UppaalBackend::with_config(config);
        let health = backend.health_check().await;
        assert!(matches!(health, HealthStatus::Unavailable { .. }));
    }
}
