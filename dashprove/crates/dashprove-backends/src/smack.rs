//! SMACK LLVM-to-Boogie translator backend
//!
//! SMACK is a bounded software verifier that translates LLVM IR to
//! Boogie intermediate verification language. It supports:
//! - C/C++/Rust programs via LLVM
//! - Assertion checking
//! - Memory safety verification
//! - Integer overflow detection
//!
//! SMACK uses backend solvers (Corral, Boogie, Z3) for verification.
//!
//! See: <https://github.com/smackers/smack>

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample, TraceState,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use regex::Regex;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for SMACK backend
#[derive(Debug, Clone)]
pub struct SmackConfig {
    /// Path to SMACK binary
    pub smack_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Loop unrolling bound
    pub unroll: u32,
    /// Verifier backend (corral, boogie)
    pub verifier: String,
    /// Enable memory safety checks
    pub memory_safety: bool,
    /// Enable integer overflow checks
    pub integer_overflow: bool,
    /// Bit precision (32 or 64)
    pub bit_precision: u8,
}

impl Default for SmackConfig {
    fn default() -> Self {
        Self {
            smack_path: None,
            timeout: Duration::from_secs(120),
            unroll: 10,
            verifier: "corral".to_string(),
            memory_safety: true,
            integer_overflow: true,
            bit_precision: 64,
        }
    }
}

/// SMACK LLVM verifier backend
pub struct SmackBackend {
    config: SmackConfig,
}

impl Default for SmackBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl SmackBackend {
    pub fn new() -> Self {
        Self {
            config: SmackConfig::default(),
        }
    }

    pub fn with_config(config: SmackConfig) -> Self {
        Self { config }
    }

    async fn detect_smack(&self) -> Result<PathBuf, String> {
        if let Some(path) = &self.config.smack_path {
            if path.exists() {
                return Ok(path.clone());
            }
        }

        if let Ok(path) = which::which("smack") {
            // Verify it works
            let output = Command::new(&path)
                .arg("--version")
                .stdout(Stdio::piped())
                .stderr(Stdio::piped())
                .output()
                .await
                .map_err(|e| format!("Failed to execute SMACK: {}", e))?;

            let stdout = String::from_utf8_lossy(&output.stdout);
            if stdout.contains("SMACK") || output.status.success() {
                debug!("Detected SMACK: {}", stdout.trim());
                return Ok(path);
            }
        }

        // Try common paths
        let home = std::env::var("HOME").unwrap_or_default();
        for base in &[
            "/usr/local/bin/smack",
            "/opt/smack/bin/smack",
            &format!("{}/smack/bin/smack", home),
            &format!("{}/.local/bin/smack", home),
        ] {
            let p = PathBuf::from(base);
            if p.exists() {
                return Ok(p);
            }
        }

        Err("SMACK not found. Install from https://github.com/smackers/smack".to_string())
    }

    /// Generate C code from USL spec for SMACK verification
    fn generate_c_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();

        code.push_str("// Generated by DashProve for SMACK verification\n");
        code.push_str("#include <smack.h>\n");
        code.push_str("#include <stdlib.h>\n");
        code.push('\n');

        code.push_str("int main(void) {\n");

        if spec.spec.properties.is_empty() {
            // Default: test various safety properties
            code.push_str("    int x = __VERIFIER_nondet_int();\n");
            code.push_str("    int y = __VERIFIER_nondet_int();\n");
            code.push_str("    \n");
            code.push_str("    // Memory safety test\n");
            code.push_str("    int *arr = malloc(10 * sizeof(int));\n");
            code.push_str("    if (arr != NULL) {\n");
            code.push_str("        __VERIFIER_assume(x >= 0 && x < 10);\n");
            code.push_str("        arr[x] = 42;\n");
            code.push_str("        assert(arr[x] == 42);\n");
            code.push_str("        free(arr);\n");
            code.push_str("    }\n");
            code.push_str("    \n");
            code.push_str("    return 0;\n");
        } else {
            for (idx, prop) in spec.spec.properties.iter().enumerate() {
                code.push_str(&format!("    // Property {}: {}\n", idx, prop.name()));
                code.push_str("    int value = __VERIFIER_nondet_int();\n");
                code.push_str(&format!(
                    "    assert(value >= 0); // Property: {}\n",
                    prop.name()
                ));
            }
            code.push_str("    return 0;\n");
        }

        code.push_str("}\n");
        code
    }

    /// Parse SMACK output
    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics = Vec::new();

        // Collect warnings
        for line in combined.lines() {
            if line.contains("warning:") || line.contains("Warning:") {
                diagnostics.push(line.trim().to_string());
            }
        }

        // SMACK output patterns:
        // "SMACK found no errors" or "verified" - all properties hold
        // "SMACK found an error" or "Error" - counterexample found
        // "timeout" - timeout reached

        let verified = combined.contains("SMACK found no errors")
            || combined.contains("verified")
            || combined.contains("Verification result: verified");

        let error_found = combined.contains("SMACK found an error")
            || combined.contains("ASSERTION FAILS")
            || combined.contains("Verification result: error");

        let status = if verified && !error_found {
            VerificationStatus::Proven
        } else if error_found {
            VerificationStatus::Disproven
        } else if combined.contains("timeout") || combined.contains("TIMEOUT") {
            VerificationStatus::Unknown {
                reason: "SMACK timed out".to_string(),
            }
        } else if combined.contains("out of memory") || combined.contains("OutOfMemory") {
            VerificationStatus::Unknown {
                reason: "SMACK ran out of memory".to_string(),
            }
        } else if combined.contains("error:") || combined.contains("Error:") {
            VerificationStatus::Unknown {
                reason: "SMACK encountered an error".to_string(),
            }
        } else {
            VerificationStatus::Unknown {
                reason: "Could not parse SMACK output".to_string(),
            }
        };

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            self.extract_counterexample(&combined)
        } else {
            None
        };

        (status, counterexample, diagnostics)
    }

    /// Extract counterexample from SMACK output
    fn extract_counterexample(&self, output: &str) -> Option<StructuredCounterexample> {
        let mut witness = HashMap::new();
        let mut trace = Vec::new();
        let mut failed_checks = Vec::new();

        // Parse assertion failure
        // Pattern: "ASSERTION FAILS at file:line"
        let assert_re = Regex::new(r"ASSERTION FAILS\s+at\s+(\S+):(\d+)").ok()?;
        if let Some(cap) = assert_re.captures(output) {
            let file = cap
                .get(1)
                .map(|m| m.as_str().to_string())
                .unwrap_or_default();
            let line: u32 = cap
                .get(2)
                .and_then(|m| m.as_str().parse().ok())
                .unwrap_or(0);

            failed_checks.push(FailedCheck {
                check_id: "smack_assertion".to_string(),
                description: "Assertion failure".to_string(),
                location: Some(SourceLocation {
                    file,
                    line,
                    column: None,
                }),
                function: None,
            });
        }

        // Parse memory safety violations
        if output.contains("memory safety") || output.contains("buffer overflow") {
            failed_checks.push(FailedCheck {
                check_id: "smack_memory".to_string(),
                description: "Memory safety violation".to_string(),
                location: None,
                function: None,
            });
        }

        // Parse integer overflow
        if output.contains("integer overflow") || output.contains("overflow") {
            failed_checks.push(FailedCheck {
                check_id: "smack_overflow".to_string(),
                description: "Integer overflow".to_string(),
                location: None,
                function: None,
            });
        }

        // Parse counterexample trace
        // SMACK/Boogie format: "Trace: -> (file:line) -> (file:line)"
        let trace_re = Regex::new(r"\(([^:]+):(\d+)\)").ok()?;

        for (state_num, cap) in trace_re.captures_iter(output).enumerate() {
            let file = cap.get(1).unwrap().as_str().to_string();
            let line: u32 = cap.get(2).unwrap().as_str().parse().unwrap_or(0);

            let mut vars = HashMap::new();
            vars.insert(
                "file".to_string(),
                CounterexampleValue::String(file.clone()),
            );
            vars.insert(
                "line".to_string(),
                CounterexampleValue::Int {
                    value: line as i128,
                    type_hint: None,
                },
            );

            trace.push(TraceState {
                state_num: state_num as u32,
                action: Some(format!("{}:{}", file, line)),
                variables: vars,
            });
        }

        // Parse variable assignments
        // Pattern: "x = value" or "= value =" in Boogie output
        let var_re = Regex::new(r"(\w+)\s*=\s*(-?\d+)").ok()?;
        for cap in var_re.captures_iter(output) {
            let var = cap.get(1).unwrap().as_str().to_string();
            let val_str = cap.get(2).unwrap().as_str();
            if let Ok(val) = val_str.parse::<i128>() {
                witness.insert(
                    var,
                    CounterexampleValue::Int {
                        value: val,
                        type_hint: None,
                    },
                );
            }
        }

        // Ensure we have at least one failed check
        if failed_checks.is_empty() {
            failed_checks.push(FailedCheck {
                check_id: "smack_failure".to_string(),
                description: "SMACK found a counterexample".to_string(),
                location: None,
                function: None,
            });
        }

        Some(StructuredCounterexample {
            witness,
            failed_checks,
            playback_test: None,
            trace,
            raw: Some(output.to_string()),
            minimized: false,
        })
    }
}

#[async_trait]
impl VerificationBackend for SmackBackend {
    fn id(&self) -> BackendId {
        BackendId::SMACK
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::MemorySafety, PropertyType::Contract]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let smack = self
            .detect_smack()
            .await
            .map_err(BackendError::Unavailable)?;

        // Create temp directory
        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;
        let source_path = temp_dir.path().join("input.c");

        // Write source
        std::fs::write(&source_path, self.generate_c_code(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write C source: {e}"))
        })?;

        // Build SMACK command
        let mut cmd = Command::new(&smack);
        cmd.arg(&source_path)
            .arg("--unroll")
            .arg(self.config.unroll.to_string())
            .arg("--verifier")
            .arg(&self.config.verifier)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        // Add options
        if self.config.memory_safety {
            cmd.arg("--memory-safety");
        }
        if self.config.integer_overflow {
            cmd.arg("--integer-overflow");
        }

        cmd.arg(format!("--bit-precise={}", self.config.bit_precision));

        // Run with timeout
        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("SMACK failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("SMACK stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("SMACK stderr: {}", stderr);
        }

        let (status, counterexample, diagnostics) = self.parse_output(&stdout, &stderr);
        let proof = if matches!(status, VerificationStatus::Proven) {
            Some("SMACK verified all properties within bounds".to_string())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::SMACK,
            status,
            proof,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_smack().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== SmackConfig defaults =====

    #[kani::proof]
    fn verify_config_defaults_timeout() {
        let config = SmackConfig::default();
        assert!(config.timeout == Duration::from_secs(120));
    }

    #[kani::proof]
    fn verify_config_defaults_unroll() {
        let config = SmackConfig::default();
        assert!(config.unroll == 10);
    }

    #[kani::proof]
    fn verify_config_defaults_verifier() {
        let config = SmackConfig::default();
        assert!(config.verifier == "corral");
    }

    #[kani::proof]
    fn verify_config_defaults_options() {
        let config = SmackConfig::default();
        assert!(config.smack_path.is_none());
        assert!(config.memory_safety);
        assert!(config.integer_overflow);
        assert!(config.bit_precision == 64);
    }

    // ===== Backend construction =====

    #[kani::proof]
    fn verify_backend_new_uses_defaults() {
        let backend = SmackBackend::new();
        assert!(backend.config.timeout == Duration::from_secs(120));
        assert!(backend.config.unroll == 10);
        assert!(backend.config.memory_safety);
    }

    #[kani::proof]
    fn verify_backend_default_matches_new() {
        let b1 = SmackBackend::new();
        let b2 = SmackBackend::default();
        assert!(b1.config.timeout == b2.config.timeout);
        assert!(b1.config.unroll == b2.config.unroll);
        assert!(b1.config.verifier == b2.config.verifier);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_values() {
        let config = SmackConfig {
            smack_path: Some(PathBuf::from("/usr/bin/smack")),
            timeout: Duration::from_secs(60),
            unroll: 20,
            verifier: "boogie".to_string(),
            memory_safety: false,
            integer_overflow: false,
            bit_precision: 32,
        };
        let backend = SmackBackend::with_config(config);
        assert!(backend.config.timeout == Duration::from_secs(60));
        assert!(backend.config.unroll == 20);
        assert!(backend.config.verifier == "boogie");
        assert!(!backend.config.memory_safety);
        assert!(backend.config.bit_precision == 32);
    }

    // ===== ID and supports =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = SmackBackend::new();
        assert!(matches!(backend.id(), BackendId::SMACK));
    }

    #[kani::proof]
    fn verify_supports_memory_safety_and_contract() {
        let backend = SmackBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::MemorySafety));
        assert!(supported.contains(&PropertyType::Contract));
        assert!(supported.len() == 2);
    }

    // ===== Output parsing =====

    #[kani::proof]
    fn verify_parse_output_verified() {
        let backend = SmackBackend::new();
        let (status, cex, _) = backend.parse_output("SMACK found no errors", "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[kani::proof]
    fn verify_parse_output_error() {
        let backend = SmackBackend::new();
        let (status, cex, _) =
            backend.parse_output("SMACK found an error\nASSERTION FAILS at test.c:10", "");
        assert!(matches!(status, VerificationStatus::Disproven));
        assert!(cex.is_some());
    }

    #[kani::proof]
    fn verify_parse_output_timeout() {
        let backend = SmackBackend::new();
        let (status, _, _) = backend.parse_output("TIMEOUT reached", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[kani::proof]
    fn verify_parse_output_out_of_memory() {
        let backend = SmackBackend::new();
        let (status, _, _) = backend.parse_output("OutOfMemory", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[kani::proof]
    fn verify_parse_output_unknown() {
        let backend = SmackBackend::new();
        let (status, _, _) = backend.parse_output("random output", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    // ===== Counterexample extraction =====

    #[kani::proof]
    fn verify_extract_counterexample_assertion() {
        let backend = SmackBackend::new();
        let output = "SMACK found an error\nASSERTION FAILS at input.c:25";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex
            .failed_checks
            .iter()
            .any(|c| c.check_id == "smack_assertion"));
        assert!(cex.failed_checks[0].location.is_some());
    }

    #[kani::proof]
    fn verify_extract_counterexample_memory() {
        let backend = SmackBackend::new();
        let output = "SMACK found an error\nmemory safety violation";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex
            .failed_checks
            .iter()
            .any(|c| c.check_id == "smack_memory"));
    }

    #[kani::proof]
    fn verify_extract_counterexample_overflow() {
        let backend = SmackBackend::new();
        let output = "SMACK found an error\ninteger overflow";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex
            .failed_checks
            .iter()
            .any(|c| c.check_id == "smack_overflow"));
    }

    #[kani::proof]
    fn verify_extract_counterexample_default() {
        let backend = SmackBackend::new();
        let output = "SMACK found an error";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex
            .failed_checks
            .iter()
            .any(|c| c.check_id == "smack_failure"));
    }

    // ===== Code generation =====

    #[kani::proof]
    fn verify_generate_c_code_header() {
        let backend = SmackBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let code = backend.generate_c_code(&spec);
        assert!(code.contains("Generated by DashProve"));
        assert!(code.contains("#include <smack.h>"));
    }

    #[kani::proof]
    fn verify_generate_c_code_property() {
        let backend = SmackBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let code = backend.generate_c_code(&spec);
        assert!(code.contains("Property 0: demo"));
        assert!(code.contains("assert"));
    }

    #[kani::proof]
    fn verify_generate_c_code_empty() {
        let backend = SmackBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec::default(),
            type_info: HashMap::new(),
        };
        let code = backend.generate_c_code(&spec);
        assert!(code.contains("__VERIFIER_nondet_int"));
        assert!(code.contains("malloc"));
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};

    #[test]
    fn default_config() {
        let config = SmackConfig::default();
        assert_eq!(config.unroll, 10);
        assert!(config.memory_safety);
        assert_eq!(config.verifier, "corral");
    }

    #[test]
    fn backend_id() {
        assert_eq!(SmackBackend::new().id(), BackendId::SMACK);
    }

    #[test]
    fn supports_properties() {
        let backend = SmackBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::MemorySafety));
        assert!(supported.contains(&PropertyType::Contract));
    }

    #[test]
    fn c_code_generation_empty_spec() {
        let backend = SmackBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_c_code(&spec);
        assert!(code.contains("smack.h"));
        assert!(code.contains("__VERIFIER_nondet_int"));
        assert!(code.contains("malloc"));
    }

    #[test]
    fn c_code_generation_with_property() {
        let backend = SmackBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "test_prop".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_c_code(&spec);
        assert!(code.contains("test_prop"));
        assert!(code.contains("assert"));
    }

    #[test]
    fn parse_output_verified() {
        let backend = SmackBackend::new();
        let stdout = "SMACK found no errors with unroll = 10";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_output_error() {
        let backend = SmackBackend::new();
        let stdout = "SMACK found an error\nASSERTION FAILS at input.c:15";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        assert!(!ce.failed_checks.is_empty());
    }

    #[test]
    fn parse_output_timeout() {
        let backend = SmackBackend::new();
        let stdout = "timeout reached";
        let (status, _, _) = backend.parse_output(stdout, "");
        match status {
            VerificationStatus::Unknown { reason } => {
                assert!(
                    reason.to_lowercase().contains("timeout")
                        || reason.to_lowercase().contains("timed out"),
                    "Expected reason to mention timeout, got: {}",
                    reason
                );
            }
            _ => panic!("Expected Unknown status"),
        }
    }

    #[test]
    fn extract_counterexample_assertion() {
        let backend = SmackBackend::new();
        let output = "SMACK found an error\nASSERTION FAILS at input.c:25";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex
            .failed_checks
            .iter()
            .any(|c| c.check_id == "smack_assertion"));
        let check = &cex.failed_checks[0];
        assert!(check.location.is_some());
        assert_eq!(check.location.as_ref().unwrap().line, 25);
    }

    #[test]
    fn extract_counterexample_memory() {
        let backend = SmackBackend::new();
        let output = "SMACK found an error\nmemory safety violation";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex
            .failed_checks
            .iter()
            .any(|c| c.check_id == "smack_memory"));
    }

    #[test]
    fn extract_counterexample_overflow() {
        let backend = SmackBackend::new();
        let output = "SMACK found an error\ninteger overflow detected";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex
            .failed_checks
            .iter()
            .any(|c| c.check_id == "smack_overflow"));
    }

    #[test]
    fn extract_counterexample_trace() {
        let backend = SmackBackend::new();
        let output = "Trace: -> (main.c:10) -> (main.c:15) -> (main.c:20)";
        let cex = backend.extract_counterexample(output).unwrap();
        assert_eq!(cex.trace.len(), 3);
    }

    #[test]
    fn extract_counterexample_values() {
        let backend = SmackBackend::new();
        let output = "SMACK found an error\nx = 42\ny = -10";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex.witness.contains_key("x"));
        assert!(cex.witness.contains_key("y"));
    }

    #[tokio::test]
    async fn health_check_unavailable() {
        let config = SmackConfig {
            smack_path: Some(PathBuf::from("/nonexistent/smack")),
            ..Default::default()
        };
        let backend = SmackBackend::with_config(config);
        let health = backend.health_check().await;
        assert!(matches!(health, HealthStatus::Unavailable { .. }));
    }
}
