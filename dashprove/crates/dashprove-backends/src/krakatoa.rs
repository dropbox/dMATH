//! Krakatoa Java-to-Why3 translator backend
//!
//! Krakatoa translates Java programs annotated with JML to Why3 for
//! verification using various provers.
//!
//! See: <https://krakatoa.lri.fr/>
//!
//! # Features
//!
//! - **JML annotations**: Java Modeling Language specifications
//! - **Why3 translation**: Generates Why3 proof obligations
//! - **Multiple provers**: Z3, CVC4, Alt-Ergo, Coq
//! - **Memory safety**: Proves absence of null dereference, array bounds
//!
//! # Requirements
//!
//! Install via Frama-C or standalone:
//! ```bash
//! opam install krakatoa
//! # or within frama-c
//! opam install frama-c
//! ```

use crate::counterexample::{FailedCheck, StructuredCounterexample};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for Krakatoa backend
#[derive(Debug, Clone)]
pub struct KrakatoaConfig {
    /// Path to krakatoa binary
    pub krakatoa_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Prover to use
    pub prover: String,
    /// Extra arguments
    pub extra_args: Vec<String>,
}

impl Default for KrakatoaConfig {
    fn default() -> Self {
        Self {
            krakatoa_path: None,
            timeout: Duration::from_secs(120),
            prover: "alt-ergo".to_string(),
            extra_args: vec![],
        }
    }
}

/// Krakatoa Java-to-Why3 translator backend
pub struct KrakatoaBackend {
    config: KrakatoaConfig,
}

impl Default for KrakatoaBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl KrakatoaBackend {
    pub fn new() -> Self {
        Self {
            config: KrakatoaConfig::default(),
        }
    }

    pub fn with_config(config: KrakatoaConfig) -> Self {
        Self { config }
    }

    async fn detect(&self) -> Result<PathBuf, String> {
        if let Some(ref path) = self.config.krakatoa_path {
            if path.exists() {
                return Ok(path.clone());
            }
        }
        for name in ["krakatoa", "jessie"] {
            if let Ok(path) = which::which(name) {
                return Ok(path);
            }
        }
        Err("Krakatoa not found. Install via: opam install krakatoa".to_string())
    }

    fn generate_java_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();
        code.push_str("// Generated by DashProve\n\n");
        code.push_str("public class Verification {\n\n");

        for (i, prop) in spec.spec.properties.iter().enumerate() {
            let prop_name = prop.name();
            code.push_str(&format!("    // Property: {}\n", prop_name));
            code.push_str("    //@ requires true;\n");
            code.push_str("    //@ ensures \\result == true;\n");
            code.push_str(&format!(
                "    public static boolean property{}(int x) {{\n",
                i
            ));
            code.push_str("        return true;\n");
            code.push_str("    }\n\n");
        }

        if spec.spec.properties.is_empty() {
            code.push_str("    //@ requires true;\n");
            code.push_str("    //@ ensures \\result == true;\n");
            code.push_str("    public static boolean trivial() {\n");
            code.push_str("        return true;\n");
            code.push_str("    }\n\n");
        }

        code.push_str("}\n");
        code
    }

    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
        success: bool,
    ) -> (VerificationStatus, Vec<String>) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics = Vec::new();
        let mut proved = 0;
        let mut failed = 0;

        for line in combined.lines() {
            let trimmed = line.trim();
            if trimmed.contains("Valid") || trimmed.contains("proved") {
                proved += 1;
                diagnostics.push(format!("✓ {}", trimmed));
            }
            if trimmed.contains("Invalid")
                || trimmed.contains("failed")
                || trimmed.contains("Unknown")
            {
                failed += 1;
                diagnostics.push(format!("✗ {}", trimmed));
            }
        }

        if failed > 0 {
            return (VerificationStatus::Disproven, diagnostics);
        }
        if proved > 0 || (success && !combined.contains("failed")) {
            return (VerificationStatus::Proven, diagnostics);
        }
        (
            VerificationStatus::Unknown {
                reason: "Could not parse output".to_string(),
            },
            diagnostics,
        )
    }

    fn parse_counterexample(stdout: &str, stderr: &str) -> StructuredCounterexample {
        let mut ce = StructuredCounterexample::new();
        ce.raw = Some(format!("{}\n{}", stdout, stderr));
        ce.failed_checks = Self::extract_failed_checks(ce.raw.as_ref().unwrap());
        ce
    }

    fn extract_failed_checks(output: &str) -> Vec<FailedCheck> {
        let mut checks = Vec::new();
        for line in output.lines() {
            if line.contains("Invalid") || line.contains("failed") {
                checks.push(FailedCheck {
                    check_id: "krakatoa_vc".to_string(),
                    description: line.to_string(),
                    location: None,
                    function: None,
                });
            }
        }
        checks
    }
}

#[async_trait]
impl VerificationBackend for KrakatoaBackend {
    fn id(&self) -> BackendId {
        BackendId::Krakatoa
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Contract, PropertyType::Invariant]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let krakatoa_path = self.detect().await.map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {}", e))
        })?;
        let java_file = temp_dir.path().join("Verification.java");
        let java_code = self.generate_java_code(spec);

        debug!("Generated Java code:\n{}", java_code);
        tokio::fs::write(&java_file, &java_code)
            .await
            .map_err(|e| {
                BackendError::VerificationFailed(format!("Failed to write file: {}", e))
            })?;

        let mut cmd = Command::new(&krakatoa_path);
        cmd.arg(&java_file)
            .arg("-prover")
            .arg(&self.config.prover)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .current_dir(temp_dir.path());

        for arg in &self.config.extra_args {
            cmd.arg(arg);
        }

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("Failed to run: {}", e)))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();
        let (status, diagnostics) = self.parse_output(&stdout, &stderr, output.status.success());

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            Some(Self::parse_counterexample(&stdout, &stderr))
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::Krakatoa,
            status,
            proof: None,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect().await {
            Ok(_) => HealthStatus::Healthy,
            Err(r) => HealthStatus::Unavailable { reason: r },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn backend_id() {
        assert_eq!(KrakatoaBackend::new().id(), BackendId::Krakatoa);
    }

    #[test]
    fn default_config() {
        let config = KrakatoaConfig::default();
        assert_eq!(config.prover, "alt-ergo");
    }

    #[test]
    fn supports_contracts() {
        let backend = KrakatoaBackend::new();
        assert!(backend.supports().contains(&PropertyType::Contract));
    }

    #[test]
    fn parse_valid_output() {
        let backend = KrakatoaBackend::new();
        let (status, _) = backend.parse_output("VC proved: Valid", "", true);
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[test]
    fn parse_invalid_output() {
        let backend = KrakatoaBackend::new();
        let (status, _) = backend.parse_output("VC failed: Invalid", "", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn generate_java_empty_spec() {
        use dashprove_usl::ast::Spec;
        use std::collections::HashMap;
        let backend = KrakatoaBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_java_code(&spec);
        assert!(code.contains("class Verification"));
        assert!(code.contains("trivial"));
    }
}

// =============================================
// Kani formal verification proofs
// =============================================
#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // =============================================
    // KrakatoaConfig default proofs
    // =============================================

    /// Verify KrakatoaConfig default timeout is 120 seconds
    #[kani::proof]
    fn proof_krakatoa_config_default_timeout() {
        let config = KrakatoaConfig::default();
        kani::assert(
            config.timeout == Duration::from_secs(120),
            "Default timeout should be 120 seconds",
        );
    }

    /// Verify KrakatoaConfig default prover is alt-ergo
    #[kani::proof]
    fn proof_krakatoa_config_default_prover() {
        let config = KrakatoaConfig::default();
        kani::assert(
            config.prover == "alt-ergo",
            "Default prover should be alt-ergo",
        );
    }

    /// Verify KrakatoaConfig default krakatoa_path is None
    #[kani::proof]
    fn proof_krakatoa_config_default_path_none() {
        let config = KrakatoaConfig::default();
        kani::assert(
            config.krakatoa_path.is_none(),
            "Default krakatoa_path should be None",
        );
    }

    /// Verify KrakatoaConfig default extra_args is empty
    #[kani::proof]
    fn proof_krakatoa_config_default_extra_args_empty() {
        let config = KrakatoaConfig::default();
        kani::assert(
            config.extra_args.is_empty(),
            "Default extra_args should be empty",
        );
    }

    // =============================================
    // KrakatoaBackend constructor proofs
    // =============================================

    /// Verify KrakatoaBackend::new creates backend with default config
    #[kani::proof]
    fn proof_krakatoa_backend_new_default_timeout() {
        let backend = KrakatoaBackend::new();
        kani::assert(
            backend.config.timeout == Duration::from_secs(120),
            "New backend should have default timeout",
        );
    }

    /// Verify KrakatoaBackend::with_config preserves config
    #[kani::proof]
    fn proof_krakatoa_backend_with_config() {
        let config = KrakatoaConfig {
            timeout: Duration::from_secs(60),
            prover: "z3".to_string(),
            ..Default::default()
        };
        let backend = KrakatoaBackend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(60),
            "Custom timeout should be preserved",
        );
        kani::assert(
            backend.config.prover == "z3",
            "Custom prover should be preserved",
        );
    }

    /// Verify KrakatoaBackend implements Default
    #[kani::proof]
    fn proof_krakatoa_backend_default() {
        let backend = KrakatoaBackend::default();
        kani::assert(
            backend.id() == BackendId::Krakatoa,
            "Default backend should have correct ID",
        );
    }

    // =============================================
    // KrakatoaBackend trait implementation proofs
    // =============================================

    /// Verify KrakatoaBackend::id returns BackendId::Krakatoa
    #[kani::proof]
    fn proof_krakatoa_backend_id() {
        let backend = KrakatoaBackend::new();
        kani::assert(
            backend.id() == BackendId::Krakatoa,
            "Backend ID should be Krakatoa",
        );
    }

    /// Verify KrakatoaBackend::supports includes Contract
    #[kani::proof]
    fn proof_krakatoa_backend_supports_contract() {
        let backend = KrakatoaBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::Contract {
                found = true;
            }
        }
        kani::assert(found, "Should support Contract");
    }

    /// Verify KrakatoaBackend::supports includes Invariant
    #[kani::proof]
    fn proof_krakatoa_backend_supports_invariant() {
        let backend = KrakatoaBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::Invariant {
                found = true;
            }
        }
        kani::assert(found, "Should support Invariant");
    }

    /// Verify KrakatoaBackend::supports returns exactly 2 types
    #[kani::proof]
    fn proof_krakatoa_backend_supports_count() {
        let backend = KrakatoaBackend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 2,
            "Should support exactly 2 property types",
        );
    }

    // =============================================
    // parse_output proofs
    // =============================================

    /// Verify parse_output identifies Valid output as Proven
    #[kani::proof]
    fn proof_parse_output_valid_proven() {
        let backend = KrakatoaBackend::new();
        let (status, _) = backend.parse_output("Result: Valid", "", true);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Valid should map to Proven",
        );
    }

    /// Verify parse_output identifies proved output as Proven
    #[kani::proof]
    fn proof_parse_output_proved_proven() {
        let backend = KrakatoaBackend::new();
        let (status, _) = backend.parse_output("VC proved successfully", "", true);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "proved should map to Proven",
        );
    }

    /// Verify parse_output identifies Invalid output as Disproven
    #[kani::proof]
    fn proof_parse_output_invalid_disproven() {
        let backend = KrakatoaBackend::new();
        let (status, _) = backend.parse_output("Result: Invalid", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Invalid should map to Disproven",
        );
    }

    /// Verify parse_output identifies failed output as Disproven
    #[kani::proof]
    fn proof_parse_output_failed_disproven() {
        let backend = KrakatoaBackend::new();
        let (status, _) = backend.parse_output("VC failed", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "failed should map to Disproven",
        );
    }

    /// Verify parse_output identifies Unknown output as Disproven
    #[kani::proof]
    fn proof_parse_output_unknown_disproven() {
        let backend = KrakatoaBackend::new();
        let (status, _) = backend.parse_output("Unknown result", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Unknown in output should map to Disproven",
        );
    }

    /// Verify parse_output returns Unknown for empty output
    #[kani::proof]
    fn proof_parse_output_empty_unknown() {
        let backend = KrakatoaBackend::new();
        let (status, _) = backend.parse_output("", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Empty output should map to Unknown",
        );
    }

    /// Verify parse_output diagnostics captures Valid line
    #[kani::proof]
    fn proof_parse_output_diagnostics_valid() {
        let backend = KrakatoaBackend::new();
        let (_, diagnostics) = backend.parse_output("VC is Valid", "", true);
        let mut found = false;
        for d in &diagnostics {
            if d.contains("✓") && d.contains("Valid") {
                found = true;
            }
        }
        kani::assert(found, "Diagnostics should contain Valid with checkmark");
    }

    /// Verify parse_output diagnostics captures Invalid line
    #[kani::proof]
    fn proof_parse_output_diagnostics_invalid() {
        let backend = KrakatoaBackend::new();
        let (_, diagnostics) = backend.parse_output("VC is Invalid", "", false);
        let mut found = false;
        for d in &diagnostics {
            if d.contains("✗") && d.contains("Invalid") {
                found = true;
            }
        }
        kani::assert(found, "Diagnostics should contain Invalid with X mark");
    }

    // =============================================
    // extract_failed_checks proofs
    // =============================================

    /// Verify extract_failed_checks finds Invalid lines
    #[kani::proof]
    fn proof_extract_failed_checks_invalid() {
        let checks = KrakatoaBackend::extract_failed_checks("VC Invalid: postcondition");
        kani::assert(checks.len() == 1, "Should find one failed check");
        kani::assert(
            checks[0].check_id == "krakatoa_vc",
            "Check ID should be krakatoa_vc",
        );
    }

    /// Verify extract_failed_checks finds failed lines
    #[kani::proof]
    fn proof_extract_failed_checks_failed() {
        let checks = KrakatoaBackend::extract_failed_checks("verification failed at line 10");
        kani::assert(checks.len() == 1, "Should find one failed check");
    }

    /// Verify extract_failed_checks returns empty for clean output
    #[kani::proof]
    fn proof_extract_failed_checks_clean() {
        let checks = KrakatoaBackend::extract_failed_checks("All VCs proved");
        kani::assert(checks.is_empty(), "Should find no failed checks");
    }

    /// Verify extract_failed_checks finds multiple failures
    #[kani::proof]
    fn proof_extract_failed_checks_multiple() {
        let checks =
            KrakatoaBackend::extract_failed_checks("VC Invalid\nanother failed\nthird Invalid");
        kani::assert(checks.len() == 3, "Should find three failed checks");
    }

    // =============================================
    // parse_counterexample proofs
    // =============================================

    /// Verify parse_counterexample creates raw field
    #[kani::proof]
    fn proof_parse_counterexample_has_raw() {
        let ce = KrakatoaBackend::parse_counterexample("stdout", "stderr");
        kani::assert(ce.raw.is_some(), "Counterexample should have raw field");
    }

    /// Verify parse_counterexample includes stdout in raw
    #[kani::proof]
    fn proof_parse_counterexample_raw_contains_stdout() {
        let ce = KrakatoaBackend::parse_counterexample("stdout content", "");
        let raw = ce.raw.unwrap();
        kani::assert(raw.contains("stdout content"), "Raw should contain stdout");
    }

    /// Verify parse_counterexample includes stderr in raw
    #[kani::proof]
    fn proof_parse_counterexample_raw_contains_stderr() {
        let ce = KrakatoaBackend::parse_counterexample("", "stderr content");
        let raw = ce.raw.unwrap();
        kani::assert(raw.contains("stderr content"), "Raw should contain stderr");
    }

    /// Verify parse_counterexample extracts failed checks
    #[kani::proof]
    fn proof_parse_counterexample_extracts_checks() {
        let ce = KrakatoaBackend::parse_counterexample("VC Invalid", "");
        kani::assert(
            !ce.failed_checks.is_empty(),
            "Should extract failed checks from Invalid",
        );
    }

    // =============================================
    // KrakatoaConfig custom values proofs
    // =============================================

    /// Verify custom timeout is preserved
    #[kani::proof]
    fn proof_krakatoa_config_custom_timeout() {
        let config = KrakatoaConfig {
            timeout: Duration::from_secs(600),
            ..Default::default()
        };
        kani::assert(
            config.timeout == Duration::from_secs(600),
            "Custom timeout should be preserved",
        );
    }

    /// Verify custom prover is preserved
    #[kani::proof]
    fn proof_krakatoa_config_custom_prover() {
        let config = KrakatoaConfig {
            prover: "z3".to_string(),
            ..Default::default()
        };
        kani::assert(config.prover == "z3", "Custom prover should be preserved");
    }

    /// Verify custom krakatoa_path is preserved
    #[kani::proof]
    fn proof_krakatoa_config_custom_path() {
        let config = KrakatoaConfig {
            krakatoa_path: Some(PathBuf::from("/custom/path")),
            ..Default::default()
        };
        kani::assert(
            config.krakatoa_path == Some(PathBuf::from("/custom/path")),
            "Custom path should be preserved",
        );
    }

    /// Verify extra_args can be added
    #[kani::proof]
    fn proof_krakatoa_config_extra_args() {
        let config = KrakatoaConfig {
            extra_args: vec!["-v".to_string(), "-debug".to_string()],
            ..Default::default()
        };
        kani::assert(config.extra_args.len() == 2, "Should have 2 extra args");
    }
}
