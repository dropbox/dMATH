//! SeaHorn backend
//!
//! SeaHorn is an LLVM-based verification framework that encodes programs into
//! constrained Horn clauses. This backend uses the `sea` driver to generate
//! and solve verification conditions for simple harnesses synthesized from USL.
//!
//! See: <https://seahorn.github.io/>

use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use std::path::{Path, PathBuf};
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tokio::time;
use tracing::debug;

/// Configuration for SeaHorn backend
#[derive(Debug, Clone)]
pub struct SeaHornConfig {
    /// Path to `sea` executable
    pub seahorn_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Enable Crab abstract interpretation
    pub enable_crab: bool,
    /// Additional SeaHorn options
    pub extra_options: Vec<String>,
}

impl Default for SeaHornConfig {
    fn default() -> Self {
        Self {
            seahorn_path: None,
            timeout: Duration::from_secs(300),
            enable_crab: false,
            extra_options: Vec::new(),
        }
    }
}

/// SeaHorn backend
pub struct SeaHornBackend {
    config: SeaHornConfig,
}

impl Default for SeaHornBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl SeaHornBackend {
    /// Create backend with default configuration
    pub fn new() -> Self {
        Self {
            config: SeaHornConfig::default(),
        }
    }

    /// Create backend with custom configuration
    pub fn with_config(config: SeaHornConfig) -> Self {
        Self { config }
    }

    fn seahorn_cmd(&self) -> PathBuf {
        self.config
            .seahorn_path
            .clone()
            .unwrap_or_else(|| PathBuf::from("sea"))
    }

    fn generate_harness(&self, spec: &TypedSpec, dir: &Path) -> Result<PathBuf, BackendError> {
        let mut code = String::from("/* Generated by DashProve */\n#include <assert.h>\n\n");
        code.push_str("void __VERIFIER_error(void) { while (1) {} }\n");
        code.push_str("void __VERIFIER_assume(int cond) { if (!cond) __VERIFIER_error(); }\n");
        code.push_str("void __VERIFIER_assert(int cond) { if (!cond) __VERIFIER_error(); }\n\n");

        for prop in &spec.spec.properties {
            code.push_str(&format!("// Property: {}\n", prop.name()));
        }

        code.push_str("int main(void) {\n");
        code.push_str("    int x = 0;\n");
        code.push_str("    __VERIFIER_assume(x >= 0);\n");
        code.push_str("    __VERIFIER_assert(x >= 0);\n");
        code.push_str("    return 0;\n");
        code.push_str("}\n");

        let path = dir.join("harness.c");
        std::fs::write(&path, code).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write SeaHorn harness: {}", e))
        })?;
        Ok(path)
    }

    fn parse_output(&self, stdout: &str, stderr: &str) -> (VerificationStatus, Vec<String>) {
        let combined = format!("{}\n{}", stdout, stderr);
        debug!("SeaHorn output: {}", combined.trim());
        let lower = combined.to_lowercase();

        if lower.contains("unsat") {
            (
                VerificationStatus::Proven,
                combined
                    .lines()
                    .take(6)
                    .map(|l| l.trim().to_string())
                    .collect(),
            )
        } else if lower.contains("sat") {
            (
                VerificationStatus::Disproven,
                combined
                    .lines()
                    .take(6)
                    .map(|l| l.trim().to_string())
                    .collect(),
            )
        } else {
            (
                VerificationStatus::Unknown {
                    reason: "SeaHorn returned unknown status".to_string(),
                },
                combined
                    .lines()
                    .take(6)
                    .map(|l| l.trim().to_string())
                    .collect(),
            )
        }
    }
}

#[async_trait]
impl VerificationBackend for SeaHornBackend {
    fn id(&self) -> BackendId {
        BackendId::SeaHorn
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![
            PropertyType::Contract,
            PropertyType::Invariant,
            PropertyType::MemorySafety,
        ]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {}", e))
        })?;
        let harness = self.generate_harness(spec, temp_dir.path())?;

        let mut cmd = Command::new(self.seahorn_cmd());
        cmd.arg("pf").arg(&harness);
        if self.config.enable_crab {
            cmd.arg("--crab");
        }
        for opt in &self.config.extra_options {
            cmd.arg(opt);
        }

        let output = time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| {
                BackendError::VerificationFailed(format!("Failed to run SeaHorn: {}", e))
            })?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();
        let (status, diagnostics) = self.parse_output(&stdout, &stderr);

        let proof = if matches!(&status, VerificationStatus::Proven) {
            Some(stdout.clone())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::SeaHorn,
            status,
            proof,
            counterexample: None,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match Command::new(self.seahorn_cmd())
            .arg("--version")
            .output()
            .await
        {
            Ok(output) if output.status.success() => HealthStatus::Healthy,
            Ok(_) => HealthStatus::Degraded {
                reason: "SeaHorn returned non-zero exit code".to_string(),
            },
            Err(e) => HealthStatus::Unavailable {
                reason: format!("SeaHorn not found: {}", e),
            },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== SeaHornConfig defaults =====

    #[kani::proof]
    fn verify_config_defaults_timeout() {
        let config = SeaHornConfig::default();
        assert!(config.timeout == Duration::from_secs(300));
    }

    #[kani::proof]
    fn verify_config_defaults_options() {
        let config = SeaHornConfig::default();
        assert!(config.seahorn_path.is_none());
        assert!(!config.enable_crab);
        assert!(config.extra_options.is_empty());
    }

    // ===== Backend construction =====

    #[kani::proof]
    fn verify_backend_new_uses_defaults() {
        let backend = SeaHornBackend::new();
        assert!(backend.config.timeout == Duration::from_secs(300));
        assert!(!backend.config.enable_crab);
    }

    #[kani::proof]
    fn verify_backend_default_matches_new() {
        let b1 = SeaHornBackend::new();
        let b2 = SeaHornBackend::default();
        assert!(b1.config.timeout == b2.config.timeout);
        assert!(b1.config.enable_crab == b2.config.enable_crab);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_values() {
        let config = SeaHornConfig {
            seahorn_path: Some(PathBuf::from("/usr/bin/sea")),
            timeout: Duration::from_secs(60),
            enable_crab: true,
            extra_options: vec!["--test".to_string()],
        };
        let backend = SeaHornBackend::with_config(config);
        assert!(backend.config.timeout == Duration::from_secs(60));
        assert!(backend.config.enable_crab);
        assert!(!backend.config.extra_options.is_empty());
    }

    // ===== ID and supports =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = SeaHornBackend::new();
        assert!(matches!(backend.id(), BackendId::SeaHorn));
    }

    #[kani::proof]
    fn verify_supports_contract_invariant_memory() {
        let backend = SeaHornBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Contract));
        assert!(supported.contains(&PropertyType::Invariant));
        assert!(supported.contains(&PropertyType::MemorySafety));
        assert!(supported.len() == 3);
    }

    // ===== seahorn_cmd =====

    #[kani::proof]
    fn verify_seahorn_cmd_default() {
        let backend = SeaHornBackend::new();
        let cmd = backend.seahorn_cmd();
        assert!(cmd == PathBuf::from("sea"));
    }

    #[kani::proof]
    fn verify_seahorn_cmd_custom() {
        let config = SeaHornConfig {
            seahorn_path: Some(PathBuf::from("/custom/sea")),
            ..Default::default()
        };
        let backend = SeaHornBackend::with_config(config);
        let cmd = backend.seahorn_cmd();
        assert!(cmd == PathBuf::from("/custom/sea"));
    }

    // ===== Output parsing =====

    #[kani::proof]
    fn verify_parse_output_unsat() {
        let backend = SeaHornBackend::new();
        let (status, _) = backend.parse_output("unsat", "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_sat() {
        let backend = SeaHornBackend::new();
        let (status, _) = backend.parse_output("sat", "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_unknown() {
        let backend = SeaHornBackend::new();
        let (status, _) = backend.parse_output("timeout", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    // ===== Harness generation =====

    #[kani::proof]
    fn verify_generate_harness_contains_verifier() {
        let backend = SeaHornBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let dir = std::env::temp_dir();
        let path = backend.generate_harness(&spec, &dir).unwrap();
        let contents = std::fs::read_to_string(path).unwrap();
        assert!(contents.contains("__VERIFIER_error"));
        assert!(contents.contains("__VERIFIER_assume"));
        assert!(contents.contains("__VERIFIER_assert"));
    }

    #[kani::proof]
    fn verify_generate_harness_contains_property() {
        let backend = SeaHornBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let dir = std::env::temp_dir();
        let path = backend.generate_harness(&spec, &dir).unwrap();
        let contents = std::fs::read_to_string(path).unwrap();
        assert!(contents.contains("Property: demo"));
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::parse;
    use dashprove_usl::typecheck::typecheck;
    use std::path::PathBuf;

    #[test]
    fn test_config_defaults() {
        let config = SeaHornConfig::default();
        assert!(config.seahorn_path.is_none());
        assert_eq!(config.timeout, Duration::from_secs(300));
        assert!(!config.enable_crab);
        assert!(config.extra_options.is_empty());
    }

    #[test]
    fn test_generate_harness_includes_properties() {
        let spec = typecheck(parse("invariant demo { true }").unwrap()).unwrap();
        let backend = SeaHornBackend::new();
        let dir = TempDir::new().unwrap();
        let path = backend
            .generate_harness(&spec, dir.path())
            .expect("generate harness");
        let contents = std::fs::read_to_string(path).unwrap();
        assert!(contents.contains("Property: demo"));
        assert!(contents.contains("__VERIFIER_error"));
    }

    #[test]
    fn test_parse_output_unsat() {
        let backend = SeaHornBackend::new();
        let stdout = "unsat";
        let (status, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[test]
    fn test_parse_output_sat() {
        let backend = SeaHornBackend::new();
        let stdout = "sat";
        let (status, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[tokio::test]
    async fn test_health_check_unavailable() {
        let backend = SeaHornBackend::with_config(SeaHornConfig {
            seahorn_path: Some(PathBuf::from("/no/seahorn")),
            ..Default::default()
        });
        let health = backend.health_check().await;
        assert!(matches!(health, HealthStatus::Unavailable { .. }));
    }
}
