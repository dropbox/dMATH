//! KLEE - LLVM symbolic execution backend
//!
//! KLEE is a symbolic virtual machine built on top of the LLVM compiler
//! infrastructure. It executes programs symbolically to generate test
//! cases that achieve high code coverage.
//!
//! See: <https://klee.github.io/>
//!
//! # Features
//!
//! - **Symbolic execution**: Explore all execution paths
//! - **Test generation**: Generate high-coverage test cases
//! - **Bug finding**: Detect memory errors, assertion failures
//! - **Constraint solving**: SMT-based path exploration
//! - **Coverage**: Line, branch, and path coverage metrics
//!
//! # Requirements
//!
//! Install KLEE (Docker recommended):
//! ```bash
//! # Docker (easiest)
//! docker pull klee/klee:3.0
//! docker run -it klee/klee:3.0
//!
//! # From source (requires LLVM, minisat/stp/z3)
//! git clone https://github.com/klee/klee.git
//! cd klee && mkdir build && cd build
//! cmake .. && make
//! ```

use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;

/// KLEE search heuristic
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]
pub enum KleeSearcher {
    /// Depth-first search
    DFS,
    /// Breadth-first search
    BFS,
    /// Random path selection (default)
    #[default]
    RandomPath,
    /// Non-uniform random search
    NURS,
    /// Interleaved random and DFS
    InterleavedRD,
}

/// Configuration for KLEE backend
#[derive(Debug, Clone)]
pub struct KleeConfig {
    /// Path to KLEE installation
    pub klee_path: Option<PathBuf>,
    /// Path to clang (for bitcode generation)
    pub clang_path: Option<PathBuf>,
    /// Timeout for symbolic execution
    pub timeout: Duration,
    /// Maximum time per instruction (seconds)
    pub max_instruction_time: Option<u64>,
    /// Maximum memory usage (MB)
    pub max_memory: Option<usize>,
    /// Search heuristic
    pub searcher: KleeSearcher,
    /// Enable all external calls to be concrete
    pub external_calls: bool,
    /// Only output error test cases
    pub only_output_states_covering_new: bool,
    /// Emit all errors (not just first)
    pub emit_all_errors: bool,
    /// Check division by zero
    pub check_div_zero: bool,
    /// Check pointer overflows
    pub check_overshift: bool,
    /// Additional KLEE options
    pub extra_options: Vec<String>,
}

impl Default for KleeConfig {
    fn default() -> Self {
        Self {
            klee_path: None,
            clang_path: None,
            timeout: Duration::from_secs(300),
            max_instruction_time: Some(30),
            max_memory: Some(2048), // 2GB
            searcher: KleeSearcher::default(),
            external_calls: true,
            only_output_states_covering_new: false,
            emit_all_errors: true,
            check_div_zero: true,
            check_overshift: true,
            extra_options: Vec::new(),
        }
    }
}

impl KleeConfig {
    /// Set KLEE installation path
    pub fn with_klee_path(mut self, path: PathBuf) -> Self {
        self.klee_path = Some(path);
        self
    }

    /// Set clang path
    pub fn with_clang_path(mut self, path: PathBuf) -> Self {
        self.clang_path = Some(path);
        self
    }

    /// Set timeout
    pub fn with_timeout(mut self, timeout: Duration) -> Self {
        self.timeout = timeout;
        self
    }

    /// Set maximum memory
    pub fn with_max_memory(mut self, mb: usize) -> Self {
        self.max_memory = Some(mb);
        self
    }

    /// Set search heuristic
    pub fn with_searcher(mut self, searcher: KleeSearcher) -> Self {
        self.searcher = searcher;
        self
    }

    /// Enable/disable emitting all errors
    pub fn with_emit_all_errors(mut self, enabled: bool) -> Self {
        self.emit_all_errors = enabled;
        self
    }
}

/// KLEE symbolic execution backend
pub struct KleeBackend {
    config: KleeConfig,
}

impl KleeBackend {
    /// Create a new KLEE backend with default configuration
    pub fn new() -> Self {
        Self {
            config: KleeConfig::default(),
        }
    }

    /// Create with custom configuration
    pub fn with_config(config: KleeConfig) -> Self {
        Self { config }
    }

    /// Generate C code with KLEE annotations from USL spec
    fn generate_c_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();

        code.push_str("/* Generated by DashProve from USL spec */\n\n");
        code.push_str("#include <klee/klee.h>\n");
        code.push_str("#include <assert.h>\n\n");

        // Generate code with symbolic variables
        for prop in &spec.spec.properties {
            let prop_name = prop.name();
            code.push_str(&format!("/* Property: {} */\n", prop_name));
        }

        code.push_str("\nint main() {\n");
        code.push_str("    int x;\n");
        code.push_str("    klee_make_symbolic(&x, sizeof(x), \"x\");\n");
        code.push_str("    \n");
        code.push_str("    // Constrain input\n");
        code.push_str("    klee_assume(x >= 0);\n");
        code.push_str("    klee_assume(x < 100);\n");
        code.push_str("    \n");
        code.push_str("    // Property check\n");
        code.push_str("    if (x < 0) {\n");
        code.push_str("        klee_assert(0); // Should never reach\n");
        code.push_str("    }\n");
        code.push_str("    \n");
        code.push_str("    return 0;\n");
        code.push_str("}\n");

        code
    }

    /// Parse KLEE output
    fn parse_klee_output(
        &self,
        output: &str,
        klee_out_dir: &Path,
    ) -> (VerificationStatus, Vec<String>, KleeStats) {
        let mut stats = KleeStats::default();
        let mut errors = Vec::new();

        // Parse stdout/stderr
        for line in output.lines() {
            if line.contains("KLEE: done:") {
                // Parse completion statistics
                if let Some(total) = extract_stat(line, "total instructions") {
                    stats.total_instructions = total;
                }
                if let Some(completed) = extract_stat(line, "completed paths") {
                    stats.completed_paths = completed;
                }
                if let Some(generated) = extract_stat(line, "generated tests") {
                    stats.generated_tests = generated;
                }
            }
            if line.contains("KLEE: ERROR:") {
                errors.push(line.to_string());
            }
            if line.contains("ASSERTION FAIL") {
                errors.push(line.to_string());
            }
            if line.contains("memory error") {
                errors.push(line.to_string());
            }
        }

        // Check for error files in output directory
        if klee_out_dir.exists() {
            if let Ok(entries) = std::fs::read_dir(klee_out_dir) {
                for entry in entries.flatten() {
                    let name = entry.file_name().to_string_lossy().to_string();
                    if name.ends_with(".err") {
                        stats.error_tests += 1;
                        if let Ok(content) = std::fs::read_to_string(entry.path()) {
                            errors.push(format!(
                                "Error test {}: {}",
                                name,
                                content.lines().next().unwrap_or("")
                            ));
                        }
                    } else if name.ends_with(".ktest") {
                        stats.generated_tests += 1;
                    }
                }
            }
        }

        let status = if stats.error_tests > 0 || !errors.is_empty() {
            VerificationStatus::Disproven
        } else if stats.completed_paths > 0 {
            VerificationStatus::Proven
        } else {
            VerificationStatus::Unknown {
                reason: "KLEE execution did not complete any paths".to_string(),
            }
        };

        (status, errors, stats)
    }

    /// Run KLEE on LLVM bitcode
    pub async fn analyze_bitcode(&self, bc_path: &Path) -> Result<BackendResult, BackendError> {
        let start = Instant::now();

        let klee_cmd = self
            .config
            .klee_path
            .clone()
            .unwrap_or_else(|| PathBuf::from("klee"));

        // Output directory
        let klee_out = bc_path.parent().unwrap_or(Path::new(".")).join("klee-out");

        let mut args = Vec::new();

        // Output directory
        args.push(format!("--output-dir={}", klee_out.display()));

        // Timeout options
        if let Some(mit) = self.config.max_instruction_time {
            args.push(format!("--max-instruction-time={}s", mit));
        }
        if let Some(mem) = self.config.max_memory {
            args.push(format!("--max-memory={}", mem));
        }

        // Searcher
        let searcher_name = match self.config.searcher {
            KleeSearcher::DFS => "dfs",
            KleeSearcher::BFS => "bfs",
            KleeSearcher::RandomPath => "random-path",
            KleeSearcher::NURS => "nurs:covnew",
            KleeSearcher::InterleavedRD => "random-path:dfs",
        };
        args.push(format!("--search={}", searcher_name));

        // Error handling
        if self.config.emit_all_errors {
            args.push("--emit-all-errors".to_string());
        }
        if self.config.only_output_states_covering_new {
            args.push("--only-output-states-covering-new".to_string());
        }

        // Checks
        if self.config.check_div_zero {
            args.push("--check-div-zero".to_string());
        }
        if self.config.check_overshift {
            args.push("--check-overshift".to_string());
        }

        // External calls
        if self.config.external_calls {
            args.push("--external-calls=all".to_string());
        }

        // Add bitcode file
        args.push(bc_path.to_string_lossy().to_string());

        // Extra options
        args.extend(self.config.extra_options.clone());

        // Run KLEE
        let mut cmd = Command::new(&klee_cmd);
        cmd.args(&args);

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("Failed to run KLEE: {}", e)))?;

        let duration = start.elapsed();
        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);
        let combined = format!("{}\n{}", stdout, stderr);

        let (status, errors, stats) = self.parse_klee_output(&combined, &klee_out);

        let mut diagnostics = Vec::new();

        let summary = match &status {
            VerificationStatus::Proven => format!(
                "KLEE: Symbolic execution completed ({} paths, {} tests)",
                stats.completed_paths, stats.generated_tests
            ),
            VerificationStatus::Disproven => {
                format!(
                    "KLEE: Found {} errors in {} generated tests",
                    stats.error_tests, stats.generated_tests
                )
            }
            VerificationStatus::Unknown { reason: _ } => "KLEE: Execution incomplete".to_string(),
            VerificationStatus::Partial {
                verified_percentage,
            } => {
                format!("KLEE: Partial execution ({:.1}%)", verified_percentage)
            }
        };
        diagnostics.push(summary);

        // Add statistics
        diagnostics.push(format!(
            "Statistics: {} instructions, {} paths, {} tests",
            stats.total_instructions, stats.completed_paths, stats.generated_tests
        ));

        for error in &errors {
            diagnostics.push(format!("Error: {}", error));
        }

        let counterexample = if !errors.is_empty() {
            // Use the formal verification helper to build a structured counterexample
            crate::counterexample::build_symbolic_execution_counterexample(
                &stdout, &stderr, "KLEE", &errors,
            )
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::KLEE,
            status,
            proof: None,
            counterexample,
            diagnostics,
            time_taken: duration,
        })
    }
}

impl Default for KleeBackend {
    fn default() -> Self {
        Self::new()
    }
}

/// KLEE execution statistics
#[derive(Debug, Default)]
struct KleeStats {
    total_instructions: usize,
    completed_paths: usize,
    generated_tests: usize,
    error_tests: usize,
}

/// Extract a numeric statistic from KLEE output line
fn extract_stat(line: &str, key: &str) -> Option<usize> {
    if line.contains(key) {
        line.split_whitespace()
            .find(|s| s.parse::<usize>().is_ok())
            .and_then(|s| s.parse().ok())
    } else {
        None
    }
}

#[async_trait]
impl VerificationBackend for KleeBackend {
    fn id(&self) -> BackendId {
        BackendId::KLEE
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Contract, PropertyType::MemorySafety]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();

        // Generate C code
        let c_code = self.generate_c_code(spec);

        // Write to temp file
        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {}", e))
        })?;

        let c_path = temp_dir.path().join("spec.c");
        std::fs::write(&c_path, &c_code).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write C file: {}", e))
        })?;

        // Compile to LLVM bitcode
        let clang_cmd = self
            .config
            .clang_path
            .clone()
            .unwrap_or_else(|| PathBuf::from("clang"));

        let bc_path = temp_dir.path().join("spec.bc");

        let mut compile_cmd = Command::new(&clang_cmd);
        compile_cmd
            .arg("-emit-llvm")
            .arg("-c")
            .arg("-g") // Debug info
            .arg("-O0") // No optimization
            .arg("-Xclang")
            .arg("-disable-O0-optnone")
            .arg("-o")
            .arg(&bc_path)
            .arg(&c_path);

        // Note: This will fail without KLEE includes, but shows the structure
        let compile_result = tokio::time::timeout(Duration::from_secs(60), compile_cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(Duration::from_secs(60)))?;

        match compile_result {
            Ok(output) if output.status.success() => self.analyze_bitcode(&bc_path).await,
            Ok(output) => {
                let stderr = String::from_utf8_lossy(&output.stderr);
                Ok(BackendResult {
                    backend: BackendId::KLEE,
                    status: VerificationStatus::Unknown {
                        reason: format!("Compilation failed: {}", stderr),
                    },
                    proof: None,
                    counterexample: None,
                    diagnostics: vec![format!("Compilation failed: {}", stderr)],
                    time_taken: start.elapsed(),
                })
            }
            Err(e) => Ok(BackendResult {
                backend: BackendId::KLEE,
                status: VerificationStatus::Unknown {
                    reason: format!("Failed to run clang: {}", e),
                },
                proof: None,
                counterexample: None,
                diagnostics: vec![format!("Failed to run clang: {}", e)],
                time_taken: start.elapsed(),
            }),
        }
    }

    async fn health_check(&self) -> HealthStatus {
        let klee_cmd = self
            .config
            .klee_path
            .clone()
            .unwrap_or_else(|| PathBuf::from("klee"));

        match Command::new(&klee_cmd).arg("--version").output().await {
            Ok(output) if output.status.success() => HealthStatus::Healthy,
            Ok(_) => HealthStatus::Degraded {
                reason: "KLEE returned non-zero exit code".to_string(),
            },
            Err(e) => HealthStatus::Unavailable {
                reason: format!("KLEE not found: {}", e),
            },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_klee_config_defaults() {
        let config = KleeConfig::default();
        assert_eq!(config.timeout, Duration::from_secs(300));
        assert_eq!(config.max_memory, Some(2048));
        assert_eq!(config.searcher, KleeSearcher::RandomPath);
        assert!(config.emit_all_errors);
    }

    #[test]
    fn test_klee_config_builder() {
        let config = KleeConfig::default()
            .with_timeout(Duration::from_secs(600))
            .with_max_memory(4096)
            .with_searcher(KleeSearcher::DFS);

        assert_eq!(config.timeout, Duration::from_secs(600));
        assert_eq!(config.max_memory, Some(4096));
        assert_eq!(config.searcher, KleeSearcher::DFS);
    }

    #[test]
    fn test_extract_stat() {
        assert_eq!(
            extract_stat(
                "KLEE: done: total instructions = 12345",
                "total instructions"
            ),
            Some(12345)
        );
        assert_eq!(
            extract_stat("KLEE: done: completed paths = 42", "completed paths"),
            Some(42)
        );
        assert_eq!(extract_stat("unrelated line", "total instructions"), None);
    }

    #[test]
    fn test_generate_c_code() {
        use dashprove_usl::parse;
        use dashprove_usl::typecheck::typecheck;

        let spec = parse("invariant test { true }").unwrap();
        let typed = typecheck(spec).unwrap();

        let backend = KleeBackend::new();
        let c_code = backend.generate_c_code(&typed);

        assert!(c_code.contains("klee/klee.h"));
        assert!(c_code.contains("klee_make_symbolic"));
        assert!(c_code.contains("klee_assume"));
    }

    #[tokio::test]
    async fn test_health_check_unavailable() {
        let config = KleeConfig::default().with_klee_path(PathBuf::from("/nonexistent/klee"));
        let backend = KleeBackend::with_config(config);

        let health = backend.health_check().await;
        assert!(matches!(health, HealthStatus::Unavailable { .. }));
    }

    #[test]
    fn test_backend_id() {
        let backend = KleeBackend::new();
        assert_eq!(backend.id(), BackendId::KLEE);
    }

    #[test]
    fn test_supports_property_types() {
        let backend = KleeBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Contract));
        assert!(supported.contains(&PropertyType::MemorySafety));
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // =============================================
    // KleeSearcher enum proofs
    // =============================================

    /// Verify KleeSearcher default is RandomPath
    #[kani::proof]
    fn proof_klee_searcher_default() {
        let searcher = KleeSearcher::default();
        kani::assert(
            searcher == KleeSearcher::RandomPath,
            "Default searcher should be RandomPath",
        );
    }

    /// Verify all KleeSearcher variants are distinct
    #[kani::proof]
    fn proof_klee_searcher_variants_distinct() {
        kani::assert(KleeSearcher::DFS != KleeSearcher::BFS, "DFS != BFS");
        kani::assert(
            KleeSearcher::DFS != KleeSearcher::RandomPath,
            "DFS != RandomPath",
        );
        kani::assert(KleeSearcher::DFS != KleeSearcher::NURS, "DFS != NURS");
        kani::assert(
            KleeSearcher::DFS != KleeSearcher::InterleavedRD,
            "DFS != InterleavedRD",
        );
        kani::assert(
            KleeSearcher::BFS != KleeSearcher::RandomPath,
            "BFS != RandomPath",
        );
    }

    // =============================================
    // KleeConfig default proofs
    // =============================================

    /// Verify KleeConfig::default klee_path is None
    #[kani::proof]
    fn proof_klee_config_default_path_none() {
        let config = KleeConfig::default();
        kani::assert(
            config.klee_path.is_none(),
            "Default klee_path should be None",
        );
    }

    /// Verify KleeConfig::default clang_path is None
    #[kani::proof]
    fn proof_klee_config_default_clang_path_none() {
        let config = KleeConfig::default();
        kani::assert(
            config.clang_path.is_none(),
            "Default clang_path should be None",
        );
    }

    /// Verify KleeConfig::default timeout is 300 seconds
    #[kani::proof]
    fn proof_klee_config_default_timeout() {
        let config = KleeConfig::default();
        kani::assert(
            config.timeout == Duration::from_secs(300),
            "Default timeout should be 300 seconds",
        );
    }

    /// Verify KleeConfig::default max_instruction_time is Some(30)
    #[kani::proof]
    fn proof_klee_config_default_max_instruction_time() {
        let config = KleeConfig::default();
        kani::assert(
            config.max_instruction_time == Some(30),
            "Default max_instruction_time should be Some(30)",
        );
    }

    /// Verify KleeConfig::default max_memory is Some(2048)
    #[kani::proof]
    fn proof_klee_config_default_max_memory() {
        let config = KleeConfig::default();
        kani::assert(
            config.max_memory == Some(2048),
            "Default max_memory should be Some(2048)",
        );
    }

    /// Verify KleeConfig::default searcher is RandomPath
    #[kani::proof]
    fn proof_klee_config_default_searcher() {
        let config = KleeConfig::default();
        kani::assert(
            config.searcher == KleeSearcher::RandomPath,
            "Default searcher should be RandomPath",
        );
    }

    /// Verify KleeConfig::default external_calls is true
    #[kani::proof]
    fn proof_klee_config_default_external_calls() {
        let config = KleeConfig::default();
        kani::assert(
            config.external_calls,
            "Default external_calls should be true",
        );
    }

    /// Verify KleeConfig::default emit_all_errors is true
    #[kani::proof]
    fn proof_klee_config_default_emit_all_errors() {
        let config = KleeConfig::default();
        kani::assert(
            config.emit_all_errors,
            "Default emit_all_errors should be true",
        );
    }

    /// Verify KleeConfig::default check_div_zero is true
    #[kani::proof]
    fn proof_klee_config_default_check_div_zero() {
        let config = KleeConfig::default();
        kani::assert(
            config.check_div_zero,
            "Default check_div_zero should be true",
        );
    }

    /// Verify KleeConfig::default check_overshift is true
    #[kani::proof]
    fn proof_klee_config_default_check_overshift() {
        let config = KleeConfig::default();
        kani::assert(
            config.check_overshift,
            "Default check_overshift should be true",
        );
    }

    /// Verify KleeConfig::default extra_options is empty
    #[kani::proof]
    fn proof_klee_config_default_extra_options_empty() {
        let config = KleeConfig::default();
        kani::assert(
            config.extra_options.is_empty(),
            "Default extra_options should be empty",
        );
    }

    // =============================================
    // KleeConfig builder proofs
    // =============================================

    /// Verify with_klee_path sets path
    #[kani::proof]
    fn proof_klee_config_with_klee_path() {
        let config = KleeConfig::default().with_klee_path(PathBuf::from("/usr/bin/klee"));
        kani::assert(
            config.klee_path == Some(PathBuf::from("/usr/bin/klee")),
            "klee_path should be set",
        );
    }

    /// Verify with_clang_path sets path
    #[kani::proof]
    fn proof_klee_config_with_clang_path() {
        let config = KleeConfig::default().with_clang_path(PathBuf::from("/usr/bin/clang"));
        kani::assert(
            config.clang_path == Some(PathBuf::from("/usr/bin/clang")),
            "clang_path should be set",
        );
    }

    /// Verify with_timeout sets timeout
    #[kani::proof]
    fn proof_klee_config_with_timeout() {
        let config = KleeConfig::default().with_timeout(Duration::from_secs(600));
        kani::assert(
            config.timeout == Duration::from_secs(600),
            "timeout should be set",
        );
    }

    /// Verify with_max_memory sets memory
    #[kani::proof]
    fn proof_klee_config_with_max_memory() {
        let config = KleeConfig::default().with_max_memory(4096);
        kani::assert(config.max_memory == Some(4096), "max_memory should be set");
    }

    /// Verify with_searcher sets searcher
    #[kani::proof]
    fn proof_klee_config_with_searcher() {
        let config = KleeConfig::default().with_searcher(KleeSearcher::DFS);
        kani::assert(
            config.searcher == KleeSearcher::DFS,
            "searcher should be DFS",
        );
    }

    /// Verify with_emit_all_errors sets flag
    #[kani::proof]
    fn proof_klee_config_with_emit_all_errors() {
        let config = KleeConfig::default().with_emit_all_errors(false);
        kani::assert(!config.emit_all_errors, "emit_all_errors should be false");
    }

    // =============================================
    // KleeBackend trait implementation proofs
    // =============================================

    /// Verify KleeBackend::id returns BackendId::KLEE
    #[kani::proof]
    fn proof_klee_backend_id() {
        let backend = KleeBackend::new();
        kani::assert(backend.id() == BackendId::KLEE, "Backend ID should be KLEE");
    }

    /// Verify KleeBackend::supports includes Contract
    #[kani::proof]
    fn proof_klee_backend_supports_contract() {
        let backend = KleeBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::Contract {
                found = true;
            }
        }
        kani::assert(found, "Should support Contract");
    }

    /// Verify KleeBackend::supports includes MemorySafety
    #[kani::proof]
    fn proof_klee_backend_supports_memory_safety() {
        let backend = KleeBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::MemorySafety {
                found = true;
            }
        }
        kani::assert(found, "Should support MemorySafety");
    }

    /// Verify KleeBackend::supports returns exactly 2 types
    #[kani::proof]
    fn proof_klee_backend_supports_count() {
        let backend = KleeBackend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 2,
            "Should support exactly 2 property types",
        );
    }

    // =============================================
    // extract_stat function proofs
    // =============================================

    /// Verify extract_stat finds numeric stat
    #[kani::proof]
    fn proof_extract_stat_found() {
        let result = extract_stat(
            "KLEE: done: total instructions = 12345",
            "total instructions",
        );
        kani::assert(result == Some(12345), "Should find stat 12345");
    }

    /// Verify extract_stat returns None for non-matching key
    #[kani::proof]
    fn proof_extract_stat_not_found() {
        let result = extract_stat("unrelated line", "total instructions");
        kani::assert(result.is_none(), "Should return None for non-matching key");
    }

    /// Verify extract_stat returns None for key without number
    #[kani::proof]
    fn proof_extract_stat_no_number() {
        let result = extract_stat("total instructions are many", "total instructions");
        kani::assert(result.is_none(), "Should return None when no number");
    }

    // =============================================
    // KleeBackend constructor proofs
    // =============================================

    /// Verify KleeBackend::new creates backend with default config
    #[kani::proof]
    fn proof_klee_backend_new_default_config() {
        let backend = KleeBackend::new();
        kani::assert(
            backend.config.timeout == Duration::from_secs(300),
            "New backend should have default timeout",
        );
    }

    /// Verify KleeBackend::with_config preserves config
    #[kani::proof]
    fn proof_klee_backend_with_config() {
        let config = KleeConfig {
            timeout: Duration::from_secs(600),
            ..Default::default()
        };
        let backend = KleeBackend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(600),
            "Custom config should be preserved",
        );
    }

    /// Verify KleeBackend implements Default
    #[kani::proof]
    fn proof_klee_backend_default() {
        let backend = KleeBackend::default();
        kani::assert(
            backend.id() == BackendId::KLEE,
            "Default backend should have correct ID",
        );
    }

    /// Verify KleeBackend config searcher can be set to BFS
    #[kani::proof]
    fn proof_klee_config_bfs_searcher() {
        let config = KleeConfig::default().with_searcher(KleeSearcher::BFS);
        let backend = KleeBackend::with_config(config);
        kani::assert(
            backend.config.searcher == KleeSearcher::BFS,
            "Searcher should be BFS",
        );
    }

    /// Verify KleeBackend config check_div_zero can be disabled
    #[kani::proof]
    fn proof_klee_config_no_div_zero_check() {
        let config = KleeConfig {
            check_div_zero: false,
            ..Default::default()
        };
        let backend = KleeBackend::with_config(config);
        kani::assert(
            !backend.config.check_div_zero,
            "check_div_zero should be false",
        );
    }

    /// Verify KleeBackend config check_overshift can be disabled
    #[kani::proof]
    fn proof_klee_config_no_overshift_check() {
        let config = KleeConfig {
            check_overshift: false,
            ..Default::default()
        };
        let backend = KleeBackend::with_config(config);
        kani::assert(
            !backend.config.check_overshift,
            "check_overshift should be false",
        );
    }
}
