//! PVS (Prototype Verification System) backend
//!
//! PVS is a verification system developed at SRI International, featuring
//! a specification language integrated with support tools and a theorem prover.
//!
//! Key features:
//! - Expressive specification language with dependent types
//! - Powerful decision procedures
//! - Type checking as verification
//! - Automated and interactive proving
//!
//! See: <https://pvs.csl.sri.com/>

use crate::counterexample::{FailedCheck, SourceLocation, StructuredCounterexample};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use regex::Regex;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for PVS backend
#[derive(Debug, Clone)]
pub struct PvsConfig {
    /// Path to PVS installation
    pub pvs_path: Option<PathBuf>,
    /// Timeout for proving
    pub timeout: Duration,
    /// Enable verbose output
    pub verbose: bool,
    /// Use decision procedures
    pub use_decision_procs: bool,
}

impl Default for PvsConfig {
    fn default() -> Self {
        Self {
            pvs_path: None,
            timeout: Duration::from_secs(120),
            verbose: false,
            use_decision_procs: true,
        }
    }
}

/// PVS theorem prover backend
pub struct PvsBackend {
    config: PvsConfig,
}

impl Default for PvsBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl PvsBackend {
    pub fn new() -> Self {
        Self {
            config: PvsConfig::default(),
        }
    }

    pub fn with_config(config: PvsConfig) -> Self {
        Self { config }
    }

    async fn detect_pvs(&self) -> Result<PathBuf, String> {
        if let Some(path) = &self.config.pvs_path {
            if path.exists() {
                return Ok(path.clone());
            }
        }

        // Try PVS executables
        for cmd in &["pvs", "proveit"] {
            if let Ok(path) = which::which(cmd) {
                return Ok(path);
            }
        }

        // Check PVS_DIR environment
        if let Ok(pvs_dir) = std::env::var("PVS_DIR") {
            let pvs = PathBuf::from(&pvs_dir).join("pvs");
            if pvs.exists() {
                return Ok(pvs);
            }
        }

        // Try common paths
        let home = std::env::var("HOME").unwrap_or_default();
        for base in &[
            "/usr/local/pvs",
            "/opt/pvs",
            &format!("{}/pvs", home),
            &format!("{}/.local/pvs", home),
        ] {
            let p = PathBuf::from(base);
            if p.exists() {
                let pvs = p.join("pvs");
                if pvs.exists() {
                    return Ok(pvs);
                }
            }
        }

        Err("PVS not found. Install from https://pvs.csl.sri.com/".to_string())
    }

    /// Generate PVS specification from USL spec
    fn generate_pvs_spec(&self, spec: &TypedSpec) -> String {
        let mut pvs = String::new();

        pvs.push_str("% Generated by DashProve for PVS verification\n");
        pvs.push_str("dashprove_spec: THEORY\n");
        pvs.push_str("BEGIN\n\n");

        if spec.spec.properties.is_empty() {
            // Default: simple true lemma
            pvs.push_str("  simple_truth: LEMMA TRUE\n");
        } else {
            for (idx, prop) in spec.spec.properties.iter().enumerate() {
                pvs.push_str(&format!("  % Property {}: {}\n", idx, prop.name()));
                pvs.push_str(&format!(
                    "  {}: LEMMA TRUE\n",
                    prop.name().replace('-', "_")
                ));
            }
        }

        pvs.push_str("\nEND dashprove_spec\n");
        pvs
    }

    /// Parse PVS output
    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
        exit_code: i32,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics = Vec::new();

        for line in combined.lines() {
            if line.contains("Warning") || line.contains("warning") {
                diagnostics.push(line.trim().to_string());
            }
        }

        // PVS output patterns
        let proven = combined.contains("proved")
            || combined.contains("Q.E.D.")
            || combined.contains("is PROVED");

        let failed = combined.contains("unproved")
            || (combined.contains("TCC") && combined.contains("not proved"))
            || combined.contains("typecheck error");

        let status = if proven && !failed {
            VerificationStatus::Proven
        } else if failed || (exit_code != 0 && !proven) {
            VerificationStatus::Disproven
        } else if combined.contains("Error:") {
            VerificationStatus::Unknown {
                reason: "PVS encountered an error".to_string(),
            }
        } else {
            VerificationStatus::Unknown {
                reason: "Could not parse PVS output".to_string(),
            }
        };

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            self.extract_counterexample(&combined)
        } else {
            None
        };

        (status, counterexample, diagnostics)
    }

    fn extract_counterexample(&self, output: &str) -> Option<StructuredCounterexample> {
        let mut failed_checks = Vec::new();

        // Parse TCC errors
        let tcc_re = Regex::new(r"TCC\s+(\S+)\s+.*?not proved").ok()?;
        if let Some(cap) = tcc_re.captures(output) {
            let tcc_name = cap.get(1).map(|m| m.as_str()).unwrap_or("unknown");
            failed_checks.push(FailedCheck {
                check_id: format!("pvs_tcc_{}", tcc_name),
                description: format!("Type constraint {} not proved", tcc_name),
                location: None,
                function: None,
            });
        }

        // Parse typecheck errors
        if output.contains("typecheck error") {
            let err_re = Regex::new(r"typecheck error:\s*(.+)").ok()?;
            if let Some(cap) = err_re.captures(output) {
                failed_checks.push(FailedCheck {
                    check_id: "pvs_typecheck".to_string(),
                    description: cap.get(1).unwrap().as_str().trim().to_string(),
                    location: None,
                    function: None,
                });
            }
        }

        // Parse location
        let loc_re = Regex::new(r"(\S+\.pvs):(\d+)(?::(\d+))?").ok()?;
        if let Some(cap) = loc_re.captures(output) {
            let file = cap.get(1).unwrap().as_str().to_string();
            let line: u32 = cap.get(2).unwrap().as_str().parse().unwrap_or(0);
            let col = cap.get(3).and_then(|m| m.as_str().parse().ok());

            if !failed_checks.is_empty() {
                failed_checks[0].location = Some(SourceLocation {
                    file,
                    line,
                    column: col,
                });
            }
        }

        if failed_checks.is_empty() {
            failed_checks.push(FailedCheck {
                check_id: "pvs_failure".to_string(),
                description: "PVS proof failed".to_string(),
                location: None,
                function: None,
            });
        }

        Some(StructuredCounterexample {
            witness: HashMap::new(),
            failed_checks,
            playback_test: None,
            trace: vec![],
            raw: Some(output.to_string()),
            minimized: false,
        })
    }
}

#[async_trait]
impl VerificationBackend for PvsBackend {
    fn id(&self) -> BackendId {
        BackendId::PVS
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![
            PropertyType::Theorem,
            PropertyType::Invariant,
            PropertyType::Contract,
        ]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let pvs = self.detect_pvs().await.map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;
        let spec_path = temp_dir.path().join("dashprove_spec.pvs");

        std::fs::write(&spec_path, self.generate_pvs_spec(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write PVS spec: {e}"))
        })?;

        let mut cmd = Command::new(&pvs);
        cmd.arg("-batch")
            .arg("-q")
            .arg(&spec_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("PVS failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();
        let exit_code = output.status.code().unwrap_or(-1);

        debug!("PVS stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("PVS stderr: {}", stderr);
        }

        let (status, counterexample, diagnostics) = self.parse_output(&stdout, &stderr, exit_code);
        let proof = if matches!(status, VerificationStatus::Proven) {
            Some("PVS verified all lemmas".to_string())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::PVS,
            status,
            proof,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_pvs().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== PvsConfig defaults =====

    #[kani::proof]
    fn verify_config_defaults_timeout() {
        let config = PvsConfig::default();
        assert!(config.timeout == Duration::from_secs(120));
    }

    #[kani::proof]
    fn verify_config_defaults_path() {
        let config = PvsConfig::default();
        assert!(config.pvs_path.is_none());
    }

    #[kani::proof]
    fn verify_config_defaults_verbose() {
        let config = PvsConfig::default();
        assert!(!config.verbose);
    }

    #[kani::proof]
    fn verify_config_defaults_decision_procs() {
        let config = PvsConfig::default();
        assert!(config.use_decision_procs);
    }

    // ===== Backend construction =====

    #[kani::proof]
    fn verify_backend_new_uses_defaults() {
        let backend = PvsBackend::new();
        assert!(backend.config.timeout == Duration::from_secs(120));
        assert!(backend.config.use_decision_procs);
    }

    #[kani::proof]
    fn verify_backend_default_matches_new() {
        let b1 = PvsBackend::new();
        let b2 = PvsBackend::default();
        assert!(b1.config.timeout == b2.config.timeout);
        assert!(b1.config.use_decision_procs == b2.config.use_decision_procs);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_values() {
        let config = PvsConfig {
            pvs_path: Some(PathBuf::from("/usr/local/pvs")),
            timeout: Duration::from_secs(60),
            verbose: true,
            use_decision_procs: false,
        };
        let backend = PvsBackend::with_config(config);
        assert!(backend.config.timeout == Duration::from_secs(60));
        assert!(backend.config.verbose);
        assert!(!backend.config.use_decision_procs);
    }

    // ===== ID and supports =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = PvsBackend::new();
        assert!(matches!(backend.id(), BackendId::PVS));
    }

    #[kani::proof]
    fn verify_supports_theorem_and_invariant_and_contract() {
        let backend = PvsBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Theorem));
        assert!(supported.contains(&PropertyType::Invariant));
        assert!(supported.contains(&PropertyType::Contract));
        assert!(supported.len() == 3);
    }

    // ===== Output parsing =====

    #[kani::proof]
    fn verify_parse_output_proved() {
        let backend = PvsBackend::new();
        let (status, cex, _) = backend.parse_output("Proving... Q.E.D.", "", 0);
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[kani::proof]
    fn verify_parse_output_proved_is_proved() {
        let backend = PvsBackend::new();
        let (status, _, _) = backend.parse_output("Lemma is PROVED", "", 0);
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_unproved() {
        let backend = PvsBackend::new();
        let (status, cex, _) = backend.parse_output("TCC test_tcc not proved", "", 1);
        assert!(matches!(status, VerificationStatus::Disproven));
        assert!(cex.is_some());
    }

    #[kani::proof]
    fn verify_parse_output_typecheck_error() {
        let backend = PvsBackend::new();
        let (status, cex, _) = backend.parse_output("typecheck error: bad type", "", 1);
        assert!(matches!(status, VerificationStatus::Disproven));
        assert!(cex.is_some());
    }

    #[kani::proof]
    fn verify_parse_output_error() {
        let backend = PvsBackend::new();
        let (status, _, _) = backend.parse_output("Error: something went wrong", "", 0);
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[kani::proof]
    fn verify_parse_output_unknown() {
        let backend = PvsBackend::new();
        let (status, _, _) = backend.parse_output("random output", "", 0);
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    // ===== Spec generation =====

    #[kani::proof]
    fn verify_generate_pvs_spec_header() {
        let backend = PvsBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let pvs = backend.generate_pvs_spec(&spec);
        assert!(pvs.contains("Generated by DashProve"));
        assert!(pvs.contains("THEORY"));
    }

    #[kani::proof]
    fn verify_generate_pvs_spec_structure() {
        let backend = PvsBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let pvs = backend.generate_pvs_spec(&spec);
        assert!(pvs.contains("BEGIN"));
        assert!(pvs.contains("END dashprove_spec"));
    }

    #[kani::proof]
    fn verify_generate_pvs_spec_lemma() {
        let backend = PvsBackend::new();
        let spec = dashprove_usl::typecheck::typecheck(
            dashprove_usl::parse("invariant demo { true }").unwrap(),
        )
        .unwrap();
        let pvs = backend.generate_pvs_spec(&spec);
        assert!(pvs.contains("LEMMA"));
        assert!(pvs.contains("demo"));
    }

    #[kani::proof]
    fn verify_generate_pvs_spec_empty() {
        let backend = PvsBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec::default(),
            type_info: HashMap::new(),
        };
        let pvs = backend.generate_pvs_spec(&spec);
        assert!(pvs.contains("simple_truth: LEMMA TRUE"));
    }

    // ===== Counterexample extraction =====

    #[kani::proof]
    fn verify_extract_counterexample_tcc() {
        let backend = PvsBackend::new();
        let output = "TCC positive_check not proved\nspec.pvs:15:5";
        let cex = backend.extract_counterexample(output);
        assert!(cex.is_some());
        let cex = cex.unwrap();
        assert!(!cex.failed_checks.is_empty());
        assert!(cex.failed_checks[0].check_id.contains("positive_check"));
    }

    #[kani::proof]
    fn verify_extract_counterexample_typecheck() {
        let backend = PvsBackend::new();
        let output = "typecheck error: undefined identifier";
        let cex = backend.extract_counterexample(output);
        assert!(cex.is_some());
        let cex = cex.unwrap();
        assert!(cex.failed_checks[0].check_id == "pvs_typecheck");
    }

    #[kani::proof]
    fn verify_extract_counterexample_default() {
        let backend = PvsBackend::new();
        let output = "no specific error patterns";
        let cex = backend.extract_counterexample(output);
        assert!(cex.is_some());
        let cex = cex.unwrap();
        assert!(cex.failed_checks[0].check_id == "pvs_failure");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};

    #[test]
    fn default_config() {
        let config = PvsConfig::default();
        assert_eq!(config.timeout, Duration::from_secs(120));
        assert!(config.use_decision_procs);
    }

    #[test]
    fn backend_id() {
        assert_eq!(PvsBackend::new().id(), BackendId::PVS);
    }

    #[test]
    fn supports_properties() {
        let backend = PvsBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Theorem));
        assert!(supported.contains(&PropertyType::Contract));
    }

    #[test]
    fn pvs_spec_generation_empty() {
        let backend = PvsBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let pvs = backend.generate_pvs_spec(&spec);
        assert!(pvs.contains("THEORY"));
        assert!(pvs.contains("simple_truth"));
        assert!(pvs.contains("LEMMA"));
    }

    #[test]
    fn pvs_spec_generation_with_property() {
        let backend = PvsBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "test_lemma".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let pvs = backend.generate_pvs_spec(&spec);
        assert!(pvs.contains("test_lemma"));
    }

    #[test]
    fn parse_output_proved() {
        let backend = PvsBackend::new();
        let stdout = "Proving... Q.E.D.";
        let (status, cex, _) = backend.parse_output(stdout, "", 0);
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_output_unproved() {
        let backend = PvsBackend::new();
        let stdout = "TCC test_tcc not proved";
        let (status, cex, _) = backend.parse_output(stdout, "", 1);
        assert!(matches!(status, VerificationStatus::Disproven));
        assert!(cex.is_some());
    }

    #[test]
    fn extract_counterexample_tcc() {
        let backend = PvsBackend::new();
        let output = "TCC positive_check not proved\nspec.pvs:15:5";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex.failed_checks[0].check_id.contains("positive_check"));
        assert!(cex.failed_checks[0].location.is_some());
    }

    #[tokio::test]
    async fn health_check_unavailable() {
        let config = PvsConfig {
            pvs_path: Some(PathBuf::from("/nonexistent/pvs")),
            ..Default::default()
        };
        let backend = PvsBackend::with_config(config);
        let health = backend.health_check().await;
        assert!(matches!(health, HealthStatus::Unavailable { .. }));
    }
}
