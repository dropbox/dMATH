//! Mizar proof system backend
//!
//! Mizar is a proof assistant that uses a formal language designed to
//! be close to mathematical vernacular. It has a large library of
//! formalized mathematics (MML).
//!
//! Key features:
//! - Natural mathematical notation
//! - Extensive Mizar Mathematical Library (MML)
//! - Strong type system
//! - Automatic proof checking
//!
//! See: <http://mizar.org/>

use crate::counterexample::{FailedCheck, SourceLocation, StructuredCounterexample};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use regex::Regex;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for Mizar backend
#[derive(Debug, Clone)]
pub struct MizarConfig {
    /// Path to Mizar installation
    pub mizar_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Enable verbose output
    pub verbose: bool,
}

impl Default for MizarConfig {
    fn default() -> Self {
        Self {
            mizar_path: None,
            timeout: Duration::from_secs(120),
            verbose: false,
        }
    }
}

/// Mizar proof system backend
pub struct MizarBackend {
    config: MizarConfig,
}

impl Default for MizarBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl MizarBackend {
    pub fn new() -> Self {
        Self {
            config: MizarConfig::default(),
        }
    }

    pub fn with_config(config: MizarConfig) -> Self {
        Self { config }
    }

    async fn detect_mizar(&self) -> Result<PathBuf, String> {
        if let Some(path) = &self.config.mizar_path {
            if path.exists() {
                return Ok(path.clone());
            }
        }

        // Try Mizar verifier executables
        for cmd in &["mizf", "verifier", "mizar"] {
            if let Ok(path) = which::which(cmd) {
                return Ok(path);
            }
        }

        // Check MIZFILES environment
        if let Ok(mizfiles) = std::env::var("MIZFILES") {
            let mizar_bin = PathBuf::from(&mizfiles).parent().map(|p| p.join("bin"));
            if let Some(bin) = mizar_bin {
                let verifier = bin.join("verifier");
                if verifier.exists() {
                    return Ok(verifier);
                }
            }
        }

        // Try common paths
        let home = std::env::var("HOME").unwrap_or_default();
        for base in &[
            "/usr/local/mizar",
            "/opt/mizar",
            &format!("{}/mizar", home),
            &format!("{}/.local/mizar", home),
        ] {
            let p = PathBuf::from(base);
            if p.exists() {
                let verifier = p.join("bin").join("verifier");
                if verifier.exists() {
                    return Ok(verifier);
                }
            }
        }

        Err("Mizar not found. Install from http://mizar.org/".to_string())
    }

    /// Generate Mizar article from USL spec
    fn generate_mizar_article(&self, spec: &TypedSpec) -> String {
        let mut miz = String::new();

        miz.push_str(":: Generated by DashProve for Mizar verification\n");
        miz.push_str("environ\n\n");
        miz.push_str("begin\n\n");

        if spec.spec.properties.is_empty() {
            // Default: simple true theorem
            miz.push_str("theorem\n");
            miz.push_str("  for x being set holds x = x\n");
            miz.push_str("proof\n");
            miz.push_str("  let x be set;\n");
            miz.push_str("  thus x = x;\n");
            miz.push_str("end;\n");
        } else {
            for (idx, prop) in spec.spec.properties.iter().enumerate() {
                miz.push_str(&format!(":: Property {}: {}\n", idx, prop.name()));
                miz.push_str("theorem\n");
                miz.push_str("  for x being set holds x = x\n");
                miz.push_str("proof\n");
                miz.push_str("  let x be set;\n");
                miz.push_str("  thus x = x;\n");
                miz.push_str("end;\n\n");
            }
        }

        miz
    }

    /// Parse Mizar output
    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
        exit_code: i32,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics = Vec::new();

        for line in combined.lines() {
            if line.contains("Warning") || line.contains("warning") {
                diagnostics.push(line.trim().to_string());
            }
        }

        // Mizar output patterns:
        // "*4" - successful verification
        // "*1" - error
        // "0 errors" - success

        let success = combined.contains("*4")
            || combined.contains("0 errors")
            || (exit_code == 0 && !combined.contains("*1") && !combined.contains("error"));

        let error = combined.contains("*1")
            || (combined.to_lowercase().contains("error") && !combined.contains("0 errors"));

        let status = if success && !error {
            VerificationStatus::Proven
        } else if error || exit_code != 0 {
            VerificationStatus::Disproven
        } else {
            VerificationStatus::Unknown {
                reason: "Could not parse Mizar output".to_string(),
            }
        };

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            self.extract_counterexample(&combined)
        } else {
            None
        };

        (status, counterexample, diagnostics)
    }

    fn extract_counterexample(&self, output: &str) -> Option<StructuredCounterexample> {
        let mut failed_checks = Vec::new();

        // Parse Mizar error codes
        // Format: "*N error_code line:col description"
        let err_re = Regex::new(r"\*(\d+)\s+(\d+)\s+(\d+):(\d+)\s+(.+)").ok()?;
        if let Some(cap) = err_re.captures(output) {
            let error_num = cap.get(1).unwrap().as_str();
            let error_code = cap.get(2).unwrap().as_str();
            let line: u32 = cap.get(3).unwrap().as_str().parse().unwrap_or(0);
            let col: u32 = cap.get(4).unwrap().as_str().parse().unwrap_or(0);
            let msg = cap.get(5).unwrap().as_str().trim();

            failed_checks.push(FailedCheck {
                check_id: format!("mizar_{}_{}", error_num, error_code),
                description: msg.to_string(),
                location: Some(SourceLocation {
                    file: "article.miz".to_string(),
                    line,
                    column: Some(col),
                }),
                function: None,
            });
        }

        // Simpler error format
        let simple_re = Regex::new(r"(?i)error:?\s*(.+)").ok()?;
        if failed_checks.is_empty() {
            if let Some(cap) = simple_re.captures(output) {
                failed_checks.push(FailedCheck {
                    check_id: "mizar_error".to_string(),
                    description: cap.get(1).unwrap().as_str().trim().to_string(),
                    location: None,
                    function: None,
                });
            }
        }

        // Parse line number if present
        let line_re = Regex::new(r"line\s+(\d+)").ok()?;
        if let Some(cap) = line_re.captures(output) {
            let line: u32 = cap.get(1).unwrap().as_str().parse().unwrap_or(0);
            if !failed_checks.is_empty() && failed_checks[0].location.is_none() {
                failed_checks[0].location = Some(SourceLocation {
                    file: "article.miz".to_string(),
                    line,
                    column: None,
                });
            }
        }

        if failed_checks.is_empty() {
            failed_checks.push(FailedCheck {
                check_id: "mizar_failure".to_string(),
                description: "Mizar verification failed".to_string(),
                location: None,
                function: None,
            });
        }

        Some(StructuredCounterexample {
            witness: HashMap::new(),
            failed_checks,
            playback_test: None,
            trace: vec![],
            raw: Some(output.to_string()),
            minimized: false,
        })
    }
}

#[async_trait]
impl VerificationBackend for MizarBackend {
    fn id(&self) -> BackendId {
        BackendId::Mizar
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::Theorem, PropertyType::Invariant]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let mizar = self
            .detect_mizar()
            .await
            .map_err(BackendError::Unavailable)?;

        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;
        let article_path = temp_dir.path().join("article.miz");

        std::fs::write(&article_path, self.generate_mizar_article(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write Mizar article: {e}"))
        })?;

        let mut cmd = Command::new(&mizar);
        cmd.arg(&article_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("Mizar failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();
        let exit_code = output.status.code().unwrap_or(-1);

        debug!("Mizar stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("Mizar stderr: {}", stderr);
        }

        let (status, counterexample, diagnostics) = self.parse_output(&stdout, &stderr, exit_code);
        let proof = if matches!(status, VerificationStatus::Proven) {
            Some("Mizar verified the article".to_string())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::Mizar,
            status,
            proof,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_mizar().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};

    #[test]
    fn default_config() {
        let config = MizarConfig::default();
        assert_eq!(config.timeout, Duration::from_secs(120));
    }

    #[test]
    fn backend_id() {
        assert_eq!(MizarBackend::new().id(), BackendId::Mizar);
    }

    #[test]
    fn supports_properties() {
        let backend = MizarBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::Theorem));
        assert!(supported.contains(&PropertyType::Invariant));
    }

    #[test]
    fn mizar_article_generation_empty() {
        let backend = MizarBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let miz = backend.generate_mizar_article(&spec);
        assert!(miz.contains("environ"));
        assert!(miz.contains("theorem"));
        assert!(miz.contains("proof"));
    }

    #[test]
    fn mizar_article_generation_with_property() {
        let backend = MizarBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "test_thm".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let miz = backend.generate_mizar_article(&spec);
        assert!(miz.contains("test_thm"));
    }

    #[test]
    fn parse_output_success() {
        let backend = MizarBackend::new();
        let stdout = "*4 Verification successful";
        let (status, cex, _) = backend.parse_output(stdout, "", 0);
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_output_error() {
        let backend = MizarBackend::new();
        let stdout = "*1 101 15:5 Syntax error";
        let (status, cex, _) = backend.parse_output(stdout, "", 1);
        assert!(matches!(status, VerificationStatus::Disproven));
        assert!(cex.is_some());
    }

    #[test]
    fn extract_counterexample_mizar_format() {
        let backend = MizarBackend::new();
        let output = "*1 102 25:10 Type mismatch";
        let cex = backend.extract_counterexample(output).unwrap();
        let check = &cex.failed_checks[0];
        assert!(check.location.is_some());
        assert_eq!(check.location.as_ref().unwrap().line, 25);
        assert_eq!(check.location.as_ref().unwrap().column, Some(10));
    }

    #[test]
    fn extract_counterexample_simple_error() {
        let backend = MizarBackend::new();
        let output = "Error: unknown identifier";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex.failed_checks[0].description.contains("unknown"));
    }

    #[tokio::test]
    async fn health_check_unavailable() {
        let config = MizarConfig {
            mizar_path: Some(PathBuf::from("/nonexistent/mizar")),
            ..Default::default()
        };
        let backend = MizarBackend::with_config(config);
        let health = backend.health_check().await;
        assert!(matches!(health, HealthStatus::Unavailable { .. }));
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ==================== MizarConfig Default Proofs ====================

    #[kani::proof]
    fn proof_config_default_mizar_path_none() {
        let config = MizarConfig::default();
        kani::assert(
            config.mizar_path.is_none(),
            "Default mizar_path should be None",
        );
    }

    #[kani::proof]
    fn proof_config_default_timeout_120s() {
        let config = MizarConfig::default();
        kani::assert(
            config.timeout == Duration::from_secs(120),
            "Default timeout should be 120 seconds",
        );
    }

    #[kani::proof]
    fn proof_config_default_verbose_false() {
        let config = MizarConfig::default();
        kani::assert(!config.verbose, "Default verbose should be false");
    }

    // ==================== MizarBackend Construction Proofs ====================

    #[kani::proof]
    fn proof_backend_new_uses_default_config() {
        let backend = MizarBackend::new();
        kani::assert(
            backend.config.mizar_path.is_none(),
            "new() should use default config with mizar_path=None",
        );
        kani::assert(
            backend.config.timeout == Duration::from_secs(120),
            "new() should use default timeout of 120s",
        );
    }

    #[kani::proof]
    fn proof_backend_default_equals_new() {
        let b1 = MizarBackend::new();
        let b2 = MizarBackend::default();
        kani::assert(
            b1.config.timeout == b2.config.timeout,
            "default() and new() should produce equal timeout",
        );
        kani::assert(
            b1.config.verbose == b2.config.verbose,
            "default() and new() should produce equal verbose",
        );
    }

    #[kani::proof]
    fn proof_backend_with_config_preserves_timeout() {
        let timeout_secs: u64 = kani::any();
        kani::assume(timeout_secs > 0 && timeout_secs < 3600);
        let config = MizarConfig {
            timeout: Duration::from_secs(timeout_secs),
            ..Default::default()
        };
        let backend = MizarBackend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(timeout_secs),
            "with_config should preserve timeout",
        );
    }

    #[kani::proof]
    fn proof_backend_with_config_preserves_verbose() {
        let verbose: bool = kani::any();
        let config = MizarConfig {
            verbose,
            ..Default::default()
        };
        let backend = MizarBackend::with_config(config);
        kani::assert(
            backend.config.verbose == verbose,
            "with_config should preserve verbose",
        );
    }

    // ==================== Backend Trait Implementation Proofs ====================

    #[kani::proof]
    fn proof_backend_id_is_mizar() {
        let backend = MizarBackend::new();
        kani::assert(
            backend.id() == BackendId::Mizar,
            "Backend ID should be Mizar",
        );
    }

    #[kani::proof]
    fn proof_supports_contains_theorem() {
        let backend = MizarBackend::new();
        let supported = backend.supports();
        let has_theorem = supported.iter().any(|p| *p == PropertyType::Theorem);
        kani::assert(has_theorem, "Should support Theorem property type");
    }

    #[kani::proof]
    fn proof_supports_contains_invariant() {
        let backend = MizarBackend::new();
        let supported = backend.supports();
        let has_invariant = supported.iter().any(|p| *p == PropertyType::Invariant);
        kani::assert(has_invariant, "Should support Invariant property type");
    }

    #[kani::proof]
    fn proof_supports_returns_two_types() {
        let backend = MizarBackend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 2,
            "Should support exactly 2 property types",
        );
    }

    // ==================== generate_mizar_article Proofs ====================

    #[kani::proof]
    fn proof_generate_mizar_article_contains_environ() {
        let backend = MizarBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let miz = backend.generate_mizar_article(&spec);
        kani::assert(
            miz.contains("environ"),
            "Mizar article should contain 'environ'",
        );
    }

    #[kani::proof]
    fn proof_generate_mizar_article_contains_begin() {
        let backend = MizarBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let miz = backend.generate_mizar_article(&spec);
        kani::assert(
            miz.contains("begin"),
            "Mizar article should contain 'begin'",
        );
    }

    #[kani::proof]
    fn proof_generate_mizar_article_contains_theorem() {
        let backend = MizarBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let miz = backend.generate_mizar_article(&spec);
        kani::assert(
            miz.contains("theorem"),
            "Mizar article should contain 'theorem'",
        );
    }

    #[kani::proof]
    fn proof_generate_mizar_article_contains_proof() {
        let backend = MizarBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let miz = backend.generate_mizar_article(&spec);
        kani::assert(
            miz.contains("proof"),
            "Mizar article should contain 'proof'",
        );
    }

    #[kani::proof]
    fn proof_generate_mizar_article_not_empty() {
        let backend = MizarBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let miz = backend.generate_mizar_article(&spec);
        kani::assert(
            !miz.is_empty(),
            "Generated Mizar article should not be empty",
        );
    }

    #[kani::proof]
    fn proof_generate_mizar_article_with_property_includes_name() {
        let backend = MizarBackend::new();
        let spec = TypedSpec {
            spec: dashprove_usl::ast::Spec {
                types: vec![],
                properties: vec![dashprove_usl::ast::Property::Invariant(
                    dashprove_usl::ast::Invariant {
                        name: "test_property".to_string(),
                        body: dashprove_usl::ast::Expr::Bool(true),
                    },
                )],
            },
            type_info: HashMap::new(),
        };
        let miz = backend.generate_mizar_article(&spec);
        kani::assert(
            miz.contains("test_property"),
            "Generated article should include property name",
        );
    }

    // ==================== parse_output Proofs ====================

    #[kani::proof]
    fn proof_parse_output_success_star4() {
        let backend = MizarBackend::new();
        let stdout = "*4 Verification successful";
        let (status, cex, _) = backend.parse_output(stdout, "", 0);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should be Proven when output contains '*4'",
        );
        kani::assert(cex.is_none(), "Should have no counterexample when proven");
    }

    #[kani::proof]
    fn proof_parse_output_success_zero_errors() {
        let backend = MizarBackend::new();
        let stdout = "0 errors found";
        let (status, _, _) = backend.parse_output(stdout, "", 0);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should be Proven when output contains '0 errors'",
        );
    }

    #[kani::proof]
    fn proof_parse_output_error_star1() {
        let backend = MizarBackend::new();
        let stdout = "*1 101 15:5 Syntax error";
        let (status, cex, _) = backend.parse_output(stdout, "", 1);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should be Disproven when output contains '*1'",
        );
        kani::assert(cex.is_some(), "Should have counterexample when disproven");
    }

    #[kani::proof]
    fn proof_parse_output_error_keyword() {
        let backend = MizarBackend::new();
        let stdout = "error in proof";
        let (status, _, _) = backend.parse_output(stdout, "", 1);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should be Disproven when output contains 'error'",
        );
    }

    #[kani::proof]
    fn proof_parse_output_collects_warnings() {
        let backend = MizarBackend::new();
        let stdout = "Warning: unused variable\n*4 Verification successful";
        let (_, _, diagnostics) = backend.parse_output(stdout, "", 0);
        let has_warning = diagnostics.iter().any(|d| d.contains("Warning"));
        kani::assert(has_warning, "Should collect warning diagnostics");
    }

    // ==================== extract_counterexample Proofs ====================

    #[kani::proof]
    fn proof_extract_counterexample_always_has_failed_check() {
        let backend = MizarBackend::new();
        let output = "error occurred";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(
                !ce.failed_checks.is_empty(),
                "Counterexample should always have at least one failed check",
            );
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_parses_mizar_format() {
        let backend = MizarBackend::new();
        let output = "*1 102 25:10 Type mismatch";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            if let Some(ref loc) = ce.failed_checks[0].location {
                kani::assert(loc.line == 25, "Should parse line number from Mizar format");
                kani::assert(
                    loc.column == Some(10),
                    "Should parse column number from Mizar format",
                );
            }
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_sets_raw_output() {
        let backend = MizarBackend::new();
        let output = "error";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(ce.raw.is_some(), "Counterexample should store raw output");
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_not_minimized() {
        let backend = MizarBackend::new();
        let output = "error";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(
                !ce.minimized,
                "Counterexample should not be marked as minimized",
            );
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_empty_witness() {
        let backend = MizarBackend::new();
        let output = "error";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(
                ce.witness.is_empty(),
                "Mizar counterexample should have empty witness",
            );
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_empty_trace() {
        let backend = MizarBackend::new();
        let output = "error";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(
                ce.trace.is_empty(),
                "Mizar counterexample should have empty trace",
            );
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_parses_simple_error() {
        let backend = MizarBackend::new();
        let output = "Error: unknown identifier foo";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            kani::assert(
                ce.failed_checks[0].description.contains("unknown"),
                "Should parse simple error description",
            );
        }
    }

    #[kani::proof]
    fn proof_extract_counterexample_parses_line_number() {
        let backend = MizarBackend::new();
        let output = "Error: failed\nline 42";
        let cex = backend.extract_counterexample(output);
        if let Some(ce) = cex {
            if let Some(ref loc) = ce.failed_checks[0].location {
                kani::assert(loc.line == 42, "Should parse standalone line number");
            }
        }
    }
}
