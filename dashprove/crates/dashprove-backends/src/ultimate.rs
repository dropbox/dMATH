//! Ultimate software model checker backend
//!
//! Ultimate is a program analysis framework from the University of Freiburg
//! featuring multiple verification tools:
//! - Automizer: Safety verification using trace abstraction
//! - Taipan: Termination analysis
//! - Kojak: Concurrent program verification
//!
//! It verifies C programs against memory safety, assertion violations,
//! and termination properties.
//!
//! See: <https://ultimate.informatik.uni-freiburg.de/>

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample, TraceState,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use regex::Regex;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Configuration for Ultimate backend
#[derive(Debug, Clone)]
pub struct UltimateConfig {
    /// Path to Ultimate installation directory
    pub ultimate_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Use Automizer toolchain (safety)
    pub use_automizer: bool,
    /// Use Taipan toolchain (termination)
    pub use_taipan: bool,
    /// Bit precision (32 or 64)
    pub bit_precision: u8,
    /// Enable debug output
    pub debug: bool,
}

impl Default for UltimateConfig {
    fn default() -> Self {
        Self {
            ultimate_path: None,
            timeout: Duration::from_secs(120),
            use_automizer: true,
            use_taipan: false,
            bit_precision: 32,
            debug: false,
        }
    }
}

/// Ultimate model checker backend
pub struct UltimateBackend {
    config: UltimateConfig,
}

impl Default for UltimateBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl UltimateBackend {
    pub fn new() -> Self {
        Self {
            config: UltimateConfig::default(),
        }
    }

    pub fn with_config(config: UltimateConfig) -> Self {
        Self { config }
    }

    async fn detect_ultimate(&self) -> Result<PathBuf, String> {
        // Check configured path first
        if let Some(path) = &self.config.ultimate_path {
            if path.exists() {
                return Ok(path.clone());
            }
        }

        // Try to find Ultimate or UAutomizer in PATH
        if let Ok(path) = which::which("Ultimate") {
            return Ok(path);
        }
        if let Ok(path) = which::which("UAutomizer") {
            return Ok(path);
        }

        // Try common installation paths
        let home = std::env::var("HOME").unwrap_or_default();
        for base in &[
            "/opt/ultimate",
            "/usr/local/ultimate",
            &format!("{}/ultimate", home),
            &format!("{}/.local/share/ultimate", home),
        ] {
            let p = PathBuf::from(base);
            if p.exists() {
                // Check for executable inside
                let exe = p.join("Ultimate");
                if exe.exists() {
                    return Ok(exe);
                }
                let exe = p.join("UAutomizer");
                if exe.exists() {
                    return Ok(exe);
                }
            }
        }

        Err(
            "Ultimate not found. Download from https://ultimate.informatik.uni-freiburg.de/"
                .to_string(),
        )
    }

    /// Generate C code for Ultimate from USL spec
    fn generate_c_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();

        code.push_str("// Generated by DashProve for Ultimate verification\n");
        code.push_str("#include <stdlib.h>\n");
        code.push('\n');
        code.push_str("extern void __VERIFIER_error(void);\n");
        code.push_str("extern void __VERIFIER_assume(int);\n");
        code.push_str("extern int __VERIFIER_nondet_int(void);\n");
        code.push_str("extern unsigned int __VERIFIER_nondet_uint(void);\n");
        code.push('\n');

        // Generate verification harness based on properties
        code.push_str("int main(void) {\n");

        if spec.spec.properties.is_empty() {
            // Default property: simple reachability
            code.push_str("    int x = __VERIFIER_nondet_int();\n");
            code.push_str("    int y = __VERIFIER_nondet_int();\n");
            code.push_str("    \n");
            code.push_str("    // Safety check: no integer overflow\n");
            code.push_str("    if (x > 0 && y > 0) {\n");
            code.push_str("        int sum = x + y;\n");
            code.push_str("        if (sum < 0) {\n");
            code.push_str("            __VERIFIER_error();\n");
            code.push_str("        }\n");
            code.push_str("    }\n");
        } else {
            // Generate code for each property
            for (idx, prop) in spec.spec.properties.iter().enumerate() {
                code.push_str(&format!("    // Property {}: {}\n", idx, prop.name()));
                code.push_str("    int prop_holds = 1;\n");
                code.push_str("    if (!prop_holds) {\n");
                code.push_str("        __VERIFIER_error();\n");
                code.push_str("    }\n");
            }
        }

        code.push_str("    return 0;\n");
        code.push_str("}\n");

        code
    }

    /// Generate Ultimate settings XML
    fn generate_settings(&self) -> String {
        let mut xml = String::new();

        xml.push_str("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n");
        xml.push_str("<settings>\n");
        xml.push_str("  <toolchain>\n");

        if self.config.use_automizer {
            xml.push_str("    <plugin>Automizer</plugin>\n");
        } else if self.config.use_taipan {
            xml.push_str("    <plugin>Taipan</plugin>\n");
        }

        xml.push_str("  </toolchain>\n");
        xml.push_str("  <settings>\n");
        xml.push_str(&format!(
            "    <setting key=\"BitPrecision\">{}</setting>\n",
            self.config.bit_precision
        ));
        xml.push_str("  </settings>\n");
        xml.push_str("</settings>\n");

        xml
    }

    /// Parse Ultimate output
    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
    ) -> (
        VerificationStatus,
        Option<StructuredCounterexample>,
        Vec<String>,
    ) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics = Vec::new();

        // Collect warnings and errors
        for line in combined.lines() {
            if line.contains("WARNING") || line.contains("ERROR") {
                diagnostics.push(line.trim().to_string());
            }
        }

        // Ultimate output patterns:
        // "Result: SAFE" - property holds
        // "Result: UNSAFE" - counterexample found
        // "Result: UNKNOWN" - timeout or resource limit
        // "TRUE" - property holds (alternate format)
        // "FALSE" - counterexample found (alternate format)

        let safe = combined.contains("Result: SAFE")
            || combined.contains("TRUE")
            || combined.contains("VERIFICATION SUCCESSFUL")
            || combined.contains("proved to be correct");

        let unsafe_found = combined.contains("Result: UNSAFE")
            || combined.contains("FALSE")
            || combined.contains("VERIFICATION FAILED")
            || combined.contains("counterexample");

        let status = if safe && !unsafe_found {
            VerificationStatus::Proven
        } else if unsafe_found {
            VerificationStatus::Disproven
        } else if combined.contains("TIMEOUT") || combined.contains("timeout") {
            VerificationStatus::Unknown {
                reason: "Ultimate timed out".to_string(),
            }
        } else if combined.contains("OUT OF MEMORY") || combined.contains("OutOfMemoryError") {
            VerificationStatus::Unknown {
                reason: "Ultimate ran out of memory".to_string(),
            }
        } else if combined.contains("EXCEPTION") || combined.contains("Exception") {
            VerificationStatus::Unknown {
                reason: "Ultimate encountered an error".to_string(),
            }
        } else {
            VerificationStatus::Unknown {
                reason: "Could not parse Ultimate output".to_string(),
            }
        };

        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            self.extract_counterexample(&combined)
        } else {
            None
        };

        (status, counterexample, diagnostics)
    }

    /// Extract counterexample from Ultimate output
    fn extract_counterexample(&self, output: &str) -> Option<StructuredCounterexample> {
        let mut witness = HashMap::new();
        let mut trace = Vec::new();
        let mut failed_checks = Vec::new();

        // Parse error location
        // Pattern: "Error at line X, column Y in file.c"
        let loc_re = Regex::new(r"(?i)(?:error|violation|failure)\s+at\s+(?:line\s+)?(\d+)(?:,?\s*(?:column\s+)?(\d+))?\s+(?:in\s+)?(\S+\.c)?").ok()?;
        if let Some(cap) = loc_re.captures(output) {
            let line = cap
                .get(1)
                .and_then(|m| m.as_str().parse().ok())
                .unwrap_or(0);
            let col = cap.get(2).and_then(|m| m.as_str().parse().ok());
            let file = cap
                .get(3)
                .map(|m| m.as_str().to_string())
                .unwrap_or_else(|| "input.c".to_string());

            failed_checks.push(FailedCheck {
                check_id: "ultimate_violation".to_string(),
                description: "Assertion violation found by Ultimate".to_string(),
                location: Some(SourceLocation {
                    file,
                    line,
                    column: col,
                }),
                function: None,
            });
        }

        // Parse __VERIFIER_error() reachability
        if output.contains("__VERIFIER_error") {
            failed_checks.push(FailedCheck {
                check_id: "verifier_error_reachable".to_string(),
                description: "__VERIFIER_error() is reachable".to_string(),
                location: None,
                function: Some("main".to_string()),
            });
        }

        // Parse variable assignments from trace
        // Pattern: "x = 42" or "VAL [x=42, y=10]"
        let var_re = Regex::new(r"(\w+)\s*[=:]\s*(-?\d+)").ok()?;
        let mut state_num = 0u32;
        let mut current_vars = HashMap::new();

        for line in output.lines() {
            // Check for state markers
            if line.contains("State")
                || line.contains("STEP")
                || line.contains("->")
                || line.contains("Trace")
            {
                if !current_vars.is_empty() {
                    trace.push(TraceState {
                        state_num,
                        action: Some(line.trim().to_string()),
                        variables: current_vars.clone(),
                    });
                    state_num += 1;
                }
                current_vars.clear();
            }

            // Parse variable assignments
            for cap in var_re.captures_iter(line) {
                let var_name = cap.get(1).unwrap().as_str().to_string();
                let val_str = cap.get(2).unwrap().as_str();

                if let Ok(int_val) = val_str.parse::<i128>() {
                    let value = CounterexampleValue::Int {
                        value: int_val,
                        type_hint: Some("int".to_string()),
                    };
                    current_vars.insert(var_name.clone(), value.clone());
                    witness.insert(var_name, value);
                }
            }
        }

        // Save final state
        if !current_vars.is_empty() {
            trace.push(TraceState {
                state_num,
                action: Some("Final state".to_string()),
                variables: current_vars,
            });
        }

        // Ensure we have at least one failed check
        if failed_checks.is_empty() {
            failed_checks.push(FailedCheck {
                check_id: "ultimate_failure".to_string(),
                description: "Ultimate found a counterexample".to_string(),
                location: None,
                function: None,
            });
        }

        Some(StructuredCounterexample {
            witness,
            failed_checks,
            playback_test: None,
            trace,
            raw: Some(output.to_string()),
            minimized: false,
        })
    }
}

#[async_trait]
impl VerificationBackend for UltimateBackend {
    fn id(&self) -> BackendId {
        BackendId::Ultimate
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::MemorySafety, PropertyType::Invariant]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();
        let ultimate = self
            .detect_ultimate()
            .await
            .map_err(BackendError::Unavailable)?;

        // Create temp directory for files
        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp dir: {e}"))
        })?;
        let source_path = temp_dir.path().join("input.c");
        let settings_path = temp_dir.path().join("settings.xml");

        // Write source and settings files
        std::fs::write(&source_path, self.generate_c_code(spec)).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write C source: {e}"))
        })?;
        std::fs::write(&settings_path, self.generate_settings()).map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to write settings: {e}"))
        })?;

        // Build Ultimate command
        let mut cmd = Command::new(&ultimate);
        cmd.arg("--spec")
            .arg(&source_path)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped());

        if self.config.debug {
            cmd.arg("--debug");
        }

        // Run verification with timeout
        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| BackendError::VerificationFailed(format!("Ultimate failed: {e}")))?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("Ultimate stdout: {}", stdout);
        if !stderr.trim().is_empty() {
            debug!("Ultimate stderr: {}", stderr);
        }

        let (status, counterexample, diagnostics) = self.parse_output(&stdout, &stderr);
        let proof = if matches!(status, VerificationStatus::Proven) {
            Some("Ultimate verified the program is safe".to_string())
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::Ultimate,
            status,
            proof,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect_ultimate().await {
            Ok(_) => HealthStatus::Healthy,
            Err(reason) => HealthStatus::Unavailable { reason },
        }
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // ===== UltimateConfig defaults =====

    #[kani::proof]
    fn verify_config_defaults_timeout() {
        let config = UltimateConfig::default();
        assert!(config.timeout == Duration::from_secs(120));
    }

    #[kani::proof]
    fn verify_config_defaults_toolchains() {
        let config = UltimateConfig::default();
        assert!(config.use_automizer);
        assert!(!config.use_taipan);
    }

    #[kani::proof]
    fn verify_config_defaults_options() {
        let config = UltimateConfig::default();
        assert!(config.ultimate_path.is_none());
        assert!(config.bit_precision == 32);
        assert!(!config.debug);
    }

    // ===== Backend construction =====

    #[kani::proof]
    fn verify_backend_new_uses_defaults() {
        let backend = UltimateBackend::new();
        assert!(backend.config.timeout == Duration::from_secs(120));
        assert!(backend.config.use_automizer);
    }

    #[kani::proof]
    fn verify_backend_default_matches_new() {
        let b1 = UltimateBackend::new();
        let b2 = UltimateBackend::default();
        assert!(b1.config.timeout == b2.config.timeout);
        assert!(b1.config.use_automizer == b2.config.use_automizer);
    }

    #[kani::proof]
    fn verify_backend_with_config_preserves_values() {
        let config = UltimateConfig {
            ultimate_path: Some(PathBuf::from("/opt/ultimate")),
            timeout: Duration::from_secs(60),
            use_automizer: false,
            use_taipan: true,
            bit_precision: 64,
            debug: true,
        };
        let backend = UltimateBackend::with_config(config);
        assert!(backend.config.timeout == Duration::from_secs(60));
        assert!(!backend.config.use_automizer);
        assert!(backend.config.use_taipan);
        assert!(backend.config.bit_precision == 64);
    }

    // ===== ID and supports =====

    #[kani::proof]
    fn verify_backend_id() {
        let backend = UltimateBackend::new();
        assert!(matches!(backend.id(), BackendId::Ultimate));
    }

    #[kani::proof]
    fn verify_supports_memory_safety_invariant() {
        let backend = UltimateBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::MemorySafety));
        assert!(supported.contains(&PropertyType::Invariant));
        assert!(supported.len() == 2);
    }

    // ===== Output parsing =====

    #[kani::proof]
    fn verify_parse_output_safe() {
        let backend = UltimateBackend::new();
        let (status, _, _) = backend.parse_output("Result: SAFE", "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_unsafe() {
        let backend = UltimateBackend::new();
        let (status, _, _) = backend.parse_output("Result: UNSAFE", "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_true() {
        let backend = UltimateBackend::new();
        let (status, _, _) = backend.parse_output("TRUE\nVERIFICATION SUCCESSFUL", "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[kani::proof]
    fn verify_parse_output_false() {
        let backend = UltimateBackend::new();
        let (status, _, _) = backend.parse_output("FALSE\nVERIFICATION FAILED", "");
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[kani::proof]
    fn verify_parse_output_timeout() {
        let backend = UltimateBackend::new();
        let (status, _, _) = backend.parse_output("TIMEOUT", "");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    #[kani::proof]
    fn verify_parse_output_out_of_memory() {
        let backend = UltimateBackend::new();
        let (status, _, _) = backend.parse_output("", "OutOfMemoryError");
        assert!(matches!(status, VerificationStatus::Unknown { .. }));
    }

    // ===== Settings generation =====

    #[kani::proof]
    fn verify_generate_settings_automizer() {
        let backend = UltimateBackend::new();
        let settings = backend.generate_settings();
        assert!(settings.contains("Automizer"));
    }

    #[kani::proof]
    fn verify_generate_settings_taipan() {
        let config = UltimateConfig {
            use_automizer: false,
            use_taipan: true,
            ..Default::default()
        };
        let backend = UltimateBackend::with_config(config);
        let settings = backend.generate_settings();
        assert!(settings.contains("Taipan"));
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use dashprove_usl::ast::{Expr, Invariant, Property, Spec};

    #[test]
    fn default_config() {
        let config = UltimateConfig::default();
        assert!(config.use_automizer);
        assert!(!config.use_taipan);
        assert_eq!(config.bit_precision, 32);
    }

    #[test]
    fn backend_id() {
        assert_eq!(UltimateBackend::new().id(), BackendId::Ultimate);
    }

    #[test]
    fn supports_properties() {
        let backend = UltimateBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::MemorySafety));
        assert!(supported.contains(&PropertyType::Invariant));
    }

    #[test]
    fn c_code_generation() {
        let backend = UltimateBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![Property::Invariant(Invariant {
                    name: "test_invariant".to_string(),
                    body: Expr::Bool(true),
                })],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_c_code(&spec);
        assert!(code.contains("__VERIFIER_error"));
        assert!(code.contains("int main"));
        assert!(code.contains("test_invariant"));
    }

    #[test]
    fn settings_generation_automizer() {
        let backend = UltimateBackend::new();
        let settings = backend.generate_settings();
        assert!(settings.contains("Automizer"));
        assert!(settings.contains("BitPrecision"));
    }

    #[test]
    fn settings_generation_taipan() {
        let config = UltimateConfig {
            use_automizer: false,
            use_taipan: true,
            ..Default::default()
        };
        let backend = UltimateBackend::with_config(config);
        let settings = backend.generate_settings();
        assert!(settings.contains("Taipan"));
    }

    #[test]
    fn parse_output_safe() {
        let backend = UltimateBackend::new();
        let stdout = "Ultimate started\nResult: SAFE\nUltimate finished";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(cex.is_none());
    }

    #[test]
    fn parse_output_unsafe() {
        let backend = UltimateBackend::new();
        let stdout = "Result: UNSAFE\ncounterexample found\nx = 42";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        let ce = cex.expect("expected counterexample");
        assert!(!ce.failed_checks.is_empty());
    }

    #[test]
    fn parse_output_true() {
        let backend = UltimateBackend::new();
        let stdout = "VERIFICATION SUCCESSFUL\nTRUE";
        let (status, _, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Proven));
    }

    #[test]
    fn parse_output_false() {
        let backend = UltimateBackend::new();
        let stdout = "VERIFICATION FAILED\nFALSE";
        let (status, cex, _) = backend.parse_output(stdout, "");
        assert!(matches!(status, VerificationStatus::Disproven));
        assert!(cex.is_some());
    }

    #[test]
    fn parse_output_timeout() {
        let backend = UltimateBackend::new();
        let stdout = "TIMEOUT reached";
        let (status, _, _) = backend.parse_output(stdout, "");
        match status {
            VerificationStatus::Unknown { reason } => {
                assert!(
                    reason.to_lowercase().contains("timeout")
                        || reason.to_lowercase().contains("timed out"),
                    "Expected reason to mention timeout, got: {}",
                    reason
                );
            }
            _ => panic!("Expected Unknown status"),
        }
    }

    #[test]
    fn parse_output_out_of_memory() {
        let backend = UltimateBackend::new();
        let stderr = "java.lang.OutOfMemoryError";
        let (status, _, _) = backend.parse_output("", stderr);
        match status {
            VerificationStatus::Unknown { reason } => {
                assert!(reason.contains("memory"));
            }
            _ => panic!("Expected Unknown status"),
        }
    }

    #[test]
    fn extract_counterexample_with_location() {
        let backend = UltimateBackend::new();
        let output =
            "Result: UNSAFE\nError at line 10, column 5 in input.c\n__VERIFIER_error reachable";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(!cex.failed_checks.is_empty());
        let check = &cex.failed_checks[0];
        assert!(check.location.is_some());
        let loc = check.location.as_ref().unwrap();
        assert_eq!(loc.line, 10);
        assert_eq!(loc.column, Some(5));
    }

    #[test]
    fn extract_counterexample_with_variables() {
        let backend = UltimateBackend::new();
        let output = "Result: UNSAFE\nState 0:\nx = 42\ny = -10\nState 1:\nx = 100";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex.witness.contains_key("x"));
        assert!(cex.witness.contains_key("y"));
    }

    #[test]
    fn extract_counterexample_verifier_error() {
        let backend = UltimateBackend::new();
        let output = "FALSE\n__VERIFIER_error() is reachable";
        let cex = backend.extract_counterexample(output).unwrap();
        assert!(cex
            .failed_checks
            .iter()
            .any(|c| c.check_id == "verifier_error_reachable"));
    }

    #[tokio::test]
    async fn health_check_unavailable() {
        let config = UltimateConfig {
            ultimate_path: Some(PathBuf::from("/nonexistent/Ultimate")),
            ..Default::default()
        };
        let backend = UltimateBackend::with_config(config);
        let health = backend.health_check().await;
        assert!(matches!(health, HealthStatus::Unavailable { .. }));
    }
}
