//! Jasmin cryptographic implementation verification backend
//!
//! Jasmin is a language for high-assurance and high-speed cryptographic implementations.
//! It provides formally verified compilation to assembly and supports
//! functional correctness proofs via EasyCrypt.
//!
//! See: <https://github.com/jasmin-lang/jasmin>
//!
//! # Features
//!
//! - **Assembly generation**: Produce verified x86-64 assembly
//! - **Safety checking**: Memory safety, constant-time execution
//! - **EasyCrypt integration**: Export to EasyCrypt for proofs
//! - **Type safety**: Strong type system preventing common errors
//!
//! # Requirements
//!
//! Install Jasmin compiler:
//! ```bash
//! opam install jasmin
//! # or build from source
//! ```

use crate::counterexample::{
    CounterexampleValue, FailedCheck, SourceLocation, StructuredCounterexample,
};
use crate::traits::{
    BackendError, BackendId, BackendResult, HealthStatus, PropertyType, VerificationBackend,
    VerificationStatus,
};
use async_trait::async_trait;
use dashprove_usl::typecheck::TypedSpec;
use std::collections::HashMap;
use std::path::PathBuf;
use std::process::Stdio;
use std::time::{Duration, Instant};
use tempfile::TempDir;
use tokio::process::Command;
use tracing::debug;

/// Compilation target for Jasmin
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum JasminTarget {
    /// x86-64 assembly
    #[default]
    X86_64,
    /// ARM assembly
    Arm,
    /// EasyCrypt for proofs
    EasyCrypt,
}

/// Configuration for Jasmin backend
#[derive(Debug, Clone)]
pub struct JasminConfig {
    /// Path to jasminc binary
    pub jasmin_path: Option<PathBuf>,
    /// Timeout for verification
    pub timeout: Duration,
    /// Compilation target
    pub target: JasminTarget,
    /// Check for constant-time execution
    pub check_ct: bool,
    /// Check for memory safety
    pub check_safety: bool,
    /// Additional Jasmin options
    pub extra_args: Vec<String>,
}

impl Default for JasminConfig {
    fn default() -> Self {
        Self {
            jasmin_path: None,
            timeout: Duration::from_secs(120),
            target: JasminTarget::default(),
            check_ct: true,
            check_safety: true,
            extra_args: vec![],
        }
    }
}

/// Jasmin cryptographic implementation backend
pub struct JasminBackend {
    config: JasminConfig,
}

impl Default for JasminBackend {
    fn default() -> Self {
        Self::new()
    }
}

impl JasminBackend {
    /// Create a new Jasmin backend with default configuration
    pub fn new() -> Self {
        Self {
            config: JasminConfig::default(),
        }
    }

    /// Create with custom configuration
    pub fn with_config(config: JasminConfig) -> Self {
        Self { config }
    }

    async fn detect(&self) -> Result<PathBuf, String> {
        // Check configured path first
        if let Some(ref path) = self.config.jasmin_path {
            if path.exists() {
                return Ok(path.clone());
            }
        }

        // Try common binary names
        for name in ["jasminc", "jasmin"] {
            if let Ok(path) = which::which(name) {
                // Verify it works
                let output = Command::new(&path)
                    .arg("-help")
                    .stdout(Stdio::piped())
                    .stderr(Stdio::piped())
                    .output()
                    .await;

                if let Ok(out) = output {
                    let stdout = String::from_utf8_lossy(&out.stdout);
                    let stderr = String::from_utf8_lossy(&out.stderr);
                    if stdout.contains("jasmin")
                        || stderr.contains("jasmin")
                        || stdout.contains("Jasmin")
                    {
                        debug!("Detected Jasmin at: {:?}", path);
                        return Ok(path);
                    }
                }
            }
        }

        // Check JASMIN_HOME environment variable
        if let Ok(jasmin_home) = std::env::var("JASMIN_HOME") {
            let jasminc = PathBuf::from(&jasmin_home).join("bin").join("jasminc");
            if jasminc.exists() {
                return Ok(jasminc);
            }
        }

        Err("Jasmin not found. Install via: opam install jasmin".to_string())
    }

    /// Generate Jasmin code from USL spec
    fn generate_jasmin_code(&self, spec: &TypedSpec) -> String {
        let mut code = String::new();
        code.push_str("/* Generated by DashProve */\n\n");

        // Declare parameters
        code.push_str("param int N = 32;\n\n");

        // Type aliases
        for type_def in &spec.spec.types {
            let safe_name = Self::sanitize_name(&type_def.name);
            code.push_str(&format!("/* type {} */\n", safe_name));
        }

        // Generate a simple function to verify
        code.push_str("export fn verify() -> reg u64 {\n");
        code.push_str("  reg u64 result;\n");
        code.push_str("  result = 1;\n");

        // Add assertions for properties
        for (i, prop) in spec.spec.properties.iter().enumerate() {
            let prop_name = prop.name();
            code.push_str(&format!("  /* Property {}: {} */\n", i, prop_name));
        }

        code.push_str("  return result;\n");
        code.push_str("}\n");

        code
    }

    /// Sanitize a name for use in Jasmin
    fn sanitize_name(name: &str) -> String {
        name.replace([' ', '-', ':', '/', '\\', '.', '(', ')', '[', ']'], "_")
            .chars()
            .filter(|c| c.is_alphanumeric() || *c == '_')
            .collect::<String>()
            .to_lowercase()
    }

    fn parse_output(
        &self,
        stdout: &str,
        stderr: &str,
        success: bool,
    ) -> (VerificationStatus, Vec<String>) {
        let combined = format!("{}\n{}", stdout, stderr);
        let mut diagnostics = Vec::new();

        // Parse Jasmin output
        for line in combined.lines() {
            let trimmed = line.trim();

            // Check for successful compilation/verification
            if trimmed.contains("compiled")
                || trimmed.contains("verified")
                || trimmed.contains("OK")
            {
                diagnostics.push(format!("✓ {}", trimmed));
            }

            // Check for errors
            if trimmed.contains("error") || trimmed.contains("Error") {
                diagnostics.push(format!("✗ {}", trimmed));
            }

            // Capture warnings
            if trimmed.contains("warning") || trimmed.contains("Warning") {
                diagnostics.push(format!("⚠ {}", trimmed));
            }

            // Capture safety check results
            if trimmed.contains("safety") || trimmed.contains("constant-time") {
                diagnostics.push(trimmed.to_string());
            }
        }

        // Check for explicit success
        if combined.contains("compilation successful")
            || combined.contains("verification passed")
            || (success && !combined.contains("error") && !combined.contains("Error"))
        {
            return (VerificationStatus::Proven, diagnostics);
        }

        // Check for safety violations
        if combined.contains("safety violation")
            || combined.contains("not constant-time")
            || combined.contains("memory error")
        {
            return (VerificationStatus::Disproven, diagnostics);
        }

        // Check for parse errors
        if combined.contains("parse error") || combined.contains("syntax error") {
            return (
                VerificationStatus::Unknown {
                    reason: "Parse error in Jasmin code".to_string(),
                },
                diagnostics,
            );
        }

        // Check for type errors
        if combined.contains("type error") || combined.contains("Type error") {
            return (
                VerificationStatus::Unknown {
                    reason: "Type error in Jasmin code".to_string(),
                },
                diagnostics,
            );
        }

        // Check exit status
        if !success {
            let error_lines: Vec<_> = combined
                .lines()
                .filter(|l| l.contains("error") || l.contains("Error"))
                .take(3)
                .collect();

            if !error_lines.is_empty() {
                return (
                    VerificationStatus::Unknown {
                        reason: format!("Jasmin error: {}", error_lines.join("; ")),
                    },
                    diagnostics,
                );
            }

            return (
                VerificationStatus::Unknown {
                    reason: "Jasmin returned non-zero exit code".to_string(),
                },
                diagnostics,
            );
        }

        (
            VerificationStatus::Unknown {
                reason: "Could not parse Jasmin output".to_string(),
            },
            diagnostics,
        )
    }

    /// Parse counterexample from Jasmin output
    fn parse_counterexample(stdout: &str, stderr: &str) -> StructuredCounterexample {
        let mut ce = StructuredCounterexample::new();
        let combined = format!("{}\n{}", stdout, stderr);
        ce.raw = Some(combined.clone());

        // Extract failed checks
        ce.failed_checks = Self::extract_failed_checks(&combined);

        // Extract witness values
        ce.witness = Self::extract_witness_values(&combined);

        ce
    }

    /// Extract failed checks from Jasmin output
    fn extract_failed_checks(output: &str) -> Vec<FailedCheck> {
        let mut checks = Vec::new();

        for line in output.lines() {
            let trimmed = line.trim();

            if trimmed.contains("error")
                || trimmed.contains("violation")
                || trimmed.contains("failed")
            {
                let check_type = if trimmed.contains("safety") {
                    "jasmin_safety"
                } else if trimmed.contains("constant-time") || trimmed.contains("ct") {
                    "jasmin_ct"
                } else if trimmed.contains("type") {
                    "jasmin_type"
                } else if trimmed.contains("memory") {
                    "jasmin_memory"
                } else {
                    "jasmin_error"
                };

                let (location, description) = Self::parse_error_location(trimmed);

                checks.push(FailedCheck {
                    check_id: check_type.to_string(),
                    description,
                    location,
                    function: None,
                });
            }
        }

        checks
    }

    /// Parse error location from Jasmin error line
    fn parse_error_location(line: &str) -> (Option<SourceLocation>, String) {
        // Jasmin format: "file.jazz:line:col: message" or "at file.jazz:line"
        if let Some(colon_pos) = line.find(':') {
            let prefix = &line[..colon_pos];

            if prefix.ends_with(".jazz") || prefix.ends_with(".jasm") || prefix.contains('/') {
                let rest = &line[colon_pos + 1..];

                if let Some(next_colon) = rest.find(':') {
                    if let Ok(line_num) = rest[..next_colon].trim().parse::<u32>() {
                        let message = rest[next_colon + 1..].trim().to_string();
                        return (
                            Some(SourceLocation {
                                file: prefix.to_string(),
                                line: line_num,
                                column: None,
                            }),
                            message,
                        );
                    }
                }
            }
        }

        (None, line.to_string())
    }

    /// Extract witness values from Jasmin output
    fn extract_witness_values(output: &str) -> HashMap<String, CounterexampleValue> {
        let mut values = HashMap::new();

        for line in output.lines() {
            let trimmed = line.trim();

            // Parse "var = value" patterns in error context
            if trimmed.contains(" = ") && trimmed.contains("value") {
                let parts: Vec<&str> = trimmed.splitn(2, " = ").collect();
                if parts.len() == 2 {
                    let var_name = parts[0].trim().to_string();
                    let value_str = parts[1].trim();
                    values.insert(var_name, Self::parse_jasmin_value(value_str));
                }
            }
        }

        values
    }

    /// Parse a Jasmin value string
    fn parse_jasmin_value(value_str: &str) -> CounterexampleValue {
        let trimmed = value_str.trim();

        // Boolean
        if trimmed == "true" {
            return CounterexampleValue::Bool(true);
        }
        if trimmed == "false" {
            return CounterexampleValue::Bool(false);
        }

        // Hex integer
        if let Some(hex) = trimmed.strip_prefix("0x") {
            if let Ok(n) = i128::from_str_radix(hex, 16) {
                return CounterexampleValue::Int {
                    value: n,
                    type_hint: Some("hex".to_string()),
                };
            }
        }

        // Decimal integer
        if let Ok(n) = trimmed.parse::<i128>() {
            return CounterexampleValue::Int {
                value: n,
                type_hint: None,
            };
        }

        // Default to string
        CounterexampleValue::String(trimmed.to_string())
    }
}

#[async_trait]
impl VerificationBackend for JasminBackend {
    fn id(&self) -> BackendId {
        BackendId::Jasmin
    }

    fn supports(&self) -> Vec<PropertyType> {
        vec![PropertyType::SecurityProtocol, PropertyType::Contract]
    }

    async fn verify(&self, spec: &TypedSpec) -> Result<BackendResult, BackendError> {
        let start = Instant::now();

        let jasmin_path = self.detect().await.map_err(BackendError::Unavailable)?;

        // Create temp directory
        let temp_dir = TempDir::new().map_err(|e| {
            BackendError::VerificationFailed(format!("Failed to create temp directory: {}", e))
        })?;

        let jazz_file = temp_dir.path().join("spec.jazz");
        let jazz_code = self.generate_jasmin_code(spec);

        debug!("Generated Jasmin code:\n{}", jazz_code);

        tokio::fs::write(&jazz_file, &jazz_code)
            .await
            .map_err(|e| {
                BackendError::VerificationFailed(format!("Failed to write Jasmin file: {}", e))
            })?;

        // Build command
        let mut cmd = Command::new(&jasmin_path);
        cmd.arg(&jazz_file)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .current_dir(temp_dir.path());

        // Add target-specific options
        match self.config.target {
            JasminTarget::X86_64 => {
                // Default target
            }
            JasminTarget::Arm => {
                cmd.arg("-arm");
            }
            JasminTarget::EasyCrypt => {
                cmd.arg("-ec");
            }
        }

        // Safety checks
        if self.config.check_safety {
            cmd.arg("-checksafety");
        }

        // Constant-time checks
        if self.config.check_ct {
            cmd.arg("-checkCT");
        }

        // Extra args
        for arg in &self.config.extra_args {
            cmd.arg(arg);
        }

        let output = tokio::time::timeout(self.config.timeout, cmd.output())
            .await
            .map_err(|_| BackendError::Timeout(self.config.timeout))?
            .map_err(|e| {
                BackendError::VerificationFailed(format!("Failed to run jasminc: {}", e))
            })?;

        let stdout = String::from_utf8_lossy(&output.stdout).to_string();
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();

        debug!("Jasmin stdout: {}", stdout);
        debug!("Jasmin stderr: {}", stderr);

        let (status, diagnostics) = self.parse_output(&stdout, &stderr, output.status.success());

        // Generate counterexample for failures
        let counterexample = if matches!(status, VerificationStatus::Disproven) {
            Some(Self::parse_counterexample(&stdout, &stderr))
        } else {
            None
        };

        Ok(BackendResult {
            backend: BackendId::Jasmin,
            status,
            proof: None,
            counterexample,
            diagnostics,
            time_taken: start.elapsed(),
        })
    }

    async fn health_check(&self) -> HealthStatus {
        match self.detect().await {
            Ok(_) => HealthStatus::Healthy,
            Err(r) => HealthStatus::Unavailable { reason: r },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn backend_id() {
        assert_eq!(JasminBackend::new().id(), BackendId::Jasmin);
    }

    #[test]
    fn default_config() {
        let config = JasminConfig::default();
        assert_eq!(config.timeout, Duration::from_secs(120));
        assert_eq!(config.target, JasminTarget::X86_64);
        assert!(config.check_ct);
        assert!(config.check_safety);
    }

    #[test]
    fn supports_security_and_contract() {
        let backend = JasminBackend::new();
        let supported = backend.supports();
        assert!(supported.contains(&PropertyType::SecurityProtocol));
        assert!(supported.contains(&PropertyType::Contract));
    }

    #[test]
    fn sanitize_name() {
        assert_eq!(JasminBackend::sanitize_name("Hello-World"), "hello_world");
        assert_eq!(JasminBackend::sanitize_name("test:prop"), "test_prop");
    }

    #[test]
    fn parse_success_output() {
        let backend = JasminBackend::new();
        let stdout = "compilation successful\nverified";
        let (status, diag) = backend.parse_output(stdout, "", true);
        assert!(matches!(status, VerificationStatus::Proven));
        assert!(!diag.is_empty());
    }

    #[test]
    fn parse_safety_violation() {
        let backend = JasminBackend::new();
        let stdout = "safety violation at line 10";
        let (status, _diag) = backend.parse_output(stdout, "", false);
        assert!(matches!(status, VerificationStatus::Disproven));
    }

    #[test]
    fn parse_error_location() {
        let line = "spec.jazz:10:5: type error here";
        let (loc, desc) = JasminBackend::parse_error_location(line);
        assert!(loc.is_some());
        let loc = loc.unwrap();
        assert_eq!(loc.file, "spec.jazz");
        assert_eq!(loc.line, 10);
        assert!(desc.contains("type error"));
    }

    #[test]
    fn extract_failed_checks() {
        let output = "safety violation\nconstant-time check failed\nmemory error";
        let checks = JasminBackend::extract_failed_checks(output);
        assert_eq!(checks.len(), 3);
        assert_eq!(checks[0].check_id, "jasmin_safety");
        assert_eq!(checks[1].check_id, "jasmin_ct");
        assert_eq!(checks[2].check_id, "jasmin_memory");
    }

    #[test]
    fn parse_jasmin_values() {
        assert!(matches!(
            JasminBackend::parse_jasmin_value("true"),
            CounterexampleValue::Bool(true)
        ));
        assert!(matches!(
            JasminBackend::parse_jasmin_value("0xff"),
            CounterexampleValue::Int { value: 255, .. }
        ));
        assert!(matches!(
            JasminBackend::parse_jasmin_value("42"),
            CounterexampleValue::Int { value: 42, .. }
        ));
    }

    #[test]
    fn generate_jasmin_empty_spec() {
        use dashprove_usl::ast::Spec;

        let backend = JasminBackend::new();
        let spec = TypedSpec {
            spec: Spec {
                types: vec![],
                properties: vec![],
            },
            type_info: HashMap::new(),
        };
        let code = backend.generate_jasmin_code(&spec);
        assert!(code.contains("Generated by DashProve"));
        assert!(code.contains("export fn verify"));
    }

    #[test]
    fn config_with_arm_target() {
        let config = JasminConfig {
            target: JasminTarget::Arm,
            check_ct: false,
            ..Default::default()
        };
        let backend = JasminBackend::with_config(config);
        assert_eq!(backend.config.target, JasminTarget::Arm);
        assert!(!backend.config.check_ct);
    }
}

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    // =============================================
    // JasminTarget enum proofs
    // =============================================

    /// Verify JasminTarget default is X86_64
    #[kani::proof]
    fn proof_jasmin_target_default_is_x86_64() {
        let target = JasminTarget::default();
        kani::assert(
            target == JasminTarget::X86_64,
            "Default target should be X86_64",
        );
    }

    /// Verify all JasminTarget variants are distinct
    #[kani::proof]
    fn proof_jasmin_target_variants_distinct() {
        kani::assert(JasminTarget::X86_64 != JasminTarget::Arm, "X86_64 != Arm");
        kani::assert(
            JasminTarget::X86_64 != JasminTarget::EasyCrypt,
            "X86_64 != EasyCrypt",
        );
        kani::assert(
            JasminTarget::Arm != JasminTarget::EasyCrypt,
            "Arm != EasyCrypt",
        );
    }

    // =============================================
    // JasminConfig default proofs
    // =============================================

    /// Verify JasminConfig::default jasmin_path is None
    #[kani::proof]
    fn proof_jasmin_config_default_path_none() {
        let config = JasminConfig::default();
        kani::assert(
            config.jasmin_path.is_none(),
            "Default jasmin_path should be None",
        );
    }

    /// Verify JasminConfig::default timeout is 120 seconds
    #[kani::proof]
    fn proof_jasmin_config_default_timeout() {
        let config = JasminConfig::default();
        kani::assert(
            config.timeout == Duration::from_secs(120),
            "Default timeout should be 120 seconds",
        );
    }

    /// Verify JasminConfig::default target is X86_64
    #[kani::proof]
    fn proof_jasmin_config_default_target() {
        let config = JasminConfig::default();
        kani::assert(
            config.target == JasminTarget::X86_64,
            "Default target should be X86_64",
        );
    }

    /// Verify JasminConfig::default check_ct is true
    #[kani::proof]
    fn proof_jasmin_config_default_check_ct() {
        let config = JasminConfig::default();
        kani::assert(config.check_ct, "Default check_ct should be true");
    }

    /// Verify JasminConfig::default check_safety is true
    #[kani::proof]
    fn proof_jasmin_config_default_check_safety() {
        let config = JasminConfig::default();
        kani::assert(config.check_safety, "Default check_safety should be true");
    }

    /// Verify JasminConfig::default extra_args is empty
    #[kani::proof]
    fn proof_jasmin_config_default_extra_args_empty() {
        let config = JasminConfig::default();
        kani::assert(
            config.extra_args.is_empty(),
            "Default extra_args should be empty",
        );
    }

    // =============================================
    // JasminBackend trait implementation proofs
    // =============================================

    /// Verify JasminBackend::id returns BackendId::Jasmin
    #[kani::proof]
    fn proof_jasmin_backend_id() {
        let backend = JasminBackend::new();
        kani::assert(
            backend.id() == BackendId::Jasmin,
            "Backend ID should be Jasmin",
        );
    }

    /// Verify JasminBackend::supports includes SecurityProtocol
    #[kani::proof]
    fn proof_jasmin_backend_supports_security_protocol() {
        let backend = JasminBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::SecurityProtocol {
                found = true;
            }
        }
        kani::assert(found, "Should support SecurityProtocol");
    }

    /// Verify JasminBackend::supports includes Contract
    #[kani::proof]
    fn proof_jasmin_backend_supports_contract() {
        let backend = JasminBackend::new();
        let supported = backend.supports();
        let mut found = false;
        for pt in supported {
            if pt == PropertyType::Contract {
                found = true;
            }
        }
        kani::assert(found, "Should support Contract");
    }

    /// Verify JasminBackend::supports returns exactly 2 types
    #[kani::proof]
    fn proof_jasmin_backend_supports_count() {
        let backend = JasminBackend::new();
        let supported = backend.supports();
        kani::assert(
            supported.len() == 2,
            "Should support exactly 2 property types",
        );
    }

    // =============================================
    // sanitize_name function proofs
    // =============================================

    /// Verify sanitize_name produces lowercase output
    #[kani::proof]
    fn proof_sanitize_name_produces_lowercase() {
        let result = JasminBackend::sanitize_name("ABC");
        for c in result.chars() {
            kani::assert(
                !c.is_uppercase(),
                "Output should not contain uppercase characters",
            );
        }
    }

    /// Verify sanitize_name handles empty string
    #[kani::proof]
    fn proof_sanitize_name_empty_string() {
        let result = JasminBackend::sanitize_name("");
        kani::assert(result.is_empty(), "Empty input should produce empty output");
    }

    /// Verify sanitize_name converts dash to underscore
    #[kani::proof]
    fn proof_sanitize_name_converts_dash() {
        let result = JasminBackend::sanitize_name("a-b");
        kani::assert(
            result.contains('_'),
            "Dash should be converted to underscore",
        );
        kani::assert(!result.contains('-'), "Output should not contain dash");
    }

    /// Verify sanitize_name preserves alphanumeric and underscore
    #[kani::proof]
    fn proof_sanitize_name_preserves_valid_chars() {
        let result = JasminBackend::sanitize_name("abc_123");
        kani::assert(result == "abc_123", "Valid chars should be preserved");
    }

    // =============================================
    // parse_output function proofs
    // =============================================

    /// Verify parse_output returns Proven for compilation successful
    #[kani::proof]
    fn proof_parse_output_proven_compilation_successful() {
        let backend = JasminBackend::new();
        let (status, _) = backend.parse_output("compilation successful", "", true);
        kani::assert(
            matches!(status, VerificationStatus::Proven),
            "Should return Proven for compilation successful",
        );
    }

    /// Verify parse_output returns Disproven for safety violation
    #[kani::proof]
    fn proof_parse_output_disproven_safety_violation() {
        let backend = JasminBackend::new();
        let (status, _) = backend.parse_output("safety violation", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should return Disproven for safety violation",
        );
    }

    /// Verify parse_output returns Disproven for not constant-time
    #[kani::proof]
    fn proof_parse_output_disproven_not_ct() {
        let backend = JasminBackend::new();
        let (status, _) = backend.parse_output("not constant-time", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Disproven),
            "Should return Disproven for not constant-time",
        );
    }

    /// Verify parse_output returns Unknown for parse error
    #[kani::proof]
    fn proof_parse_output_unknown_parse_error() {
        let backend = JasminBackend::new();
        let (status, _) = backend.parse_output("parse error at line 5", "", false);
        kani::assert(
            matches!(status, VerificationStatus::Unknown { .. }),
            "Should return Unknown for parse error",
        );
    }

    // =============================================
    // parse_jasmin_value function proofs
    // =============================================

    /// Verify parse_jasmin_value returns Bool(true) for "true"
    #[kani::proof]
    fn proof_parse_jasmin_value_true() {
        let value = JasminBackend::parse_jasmin_value("true");
        kani::assert(
            matches!(value, CounterexampleValue::Bool(true)),
            "Should return Bool(true) for 'true'",
        );
    }

    /// Verify parse_jasmin_value returns Bool(false) for "false"
    #[kani::proof]
    fn proof_parse_jasmin_value_false() {
        let value = JasminBackend::parse_jasmin_value("false");
        kani::assert(
            matches!(value, CounterexampleValue::Bool(false)),
            "Should return Bool(false) for 'false'",
        );
    }

    /// Verify parse_jasmin_value parses hex values
    #[kani::proof]
    fn proof_parse_jasmin_value_hex() {
        let value = JasminBackend::parse_jasmin_value("0xff");
        kani::assert(
            matches!(value, CounterexampleValue::Int { value: 255, .. }),
            "Should parse hex 0xff as 255",
        );
    }

    /// Verify parse_jasmin_value parses decimal integers
    #[kani::proof]
    fn proof_parse_jasmin_value_decimal() {
        let value = JasminBackend::parse_jasmin_value("42");
        kani::assert(
            matches!(value, CounterexampleValue::Int { value: 42, .. }),
            "Should parse decimal 42",
        );
    }

    /// Verify parse_jasmin_value returns String for unparseable input
    #[kani::proof]
    fn proof_parse_jasmin_value_string_fallback() {
        let value = JasminBackend::parse_jasmin_value("unknown");
        kani::assert(
            matches!(value, CounterexampleValue::String(_)),
            "Should return String for unparseable input",
        );
    }

    // =============================================
    // extract_failed_checks function proofs
    // =============================================

    /// Verify extract_failed_checks finds safety violations
    #[kani::proof]
    fn proof_extract_failed_checks_safety() {
        let checks = JasminBackend::extract_failed_checks("safety violation");
        kani::assert(!checks.is_empty(), "Should find safety violation");
        kani::assert(
            checks[0].check_id == "jasmin_safety",
            "Check ID should be jasmin_safety",
        );
    }

    /// Verify extract_failed_checks finds ct violations
    #[kani::proof]
    fn proof_extract_failed_checks_ct() {
        let checks = JasminBackend::extract_failed_checks("constant-time failed");
        kani::assert(!checks.is_empty(), "Should find ct violation");
        kani::assert(
            checks[0].check_id == "jasmin_ct",
            "Check ID should be jasmin_ct",
        );
    }

    /// Verify extract_failed_checks finds memory errors
    #[kani::proof]
    fn proof_extract_failed_checks_memory() {
        let checks = JasminBackend::extract_failed_checks("memory error detected");
        kani::assert(!checks.is_empty(), "Should find memory error");
        kani::assert(
            checks[0].check_id == "jasmin_memory",
            "Check ID should be jasmin_memory",
        );
    }

    /// Verify extract_failed_checks returns empty for clean output
    #[kani::proof]
    fn proof_extract_failed_checks_empty() {
        let checks = JasminBackend::extract_failed_checks("compilation successful");
        kani::assert(checks.is_empty(), "Should return empty for clean output");
    }

    // =============================================
    // parse_error_location function proofs
    // =============================================

    /// Verify parse_error_location parses file:line:col format
    #[kani::proof]
    fn proof_parse_error_location_with_location() {
        let (loc, desc) = JasminBackend::parse_error_location("spec.jazz:10:5: type error");
        kani::assert(loc.is_some(), "Should parse location");
        if let Some(l) = loc {
            kani::assert(l.file == "spec.jazz", "File should be spec.jazz");
            kani::assert(l.line == 10, "Line should be 10");
        }
        kani::assert(
            desc.contains("type error"),
            "Description should contain error message",
        );
    }

    /// Verify parse_error_location handles no location
    #[kani::proof]
    fn proof_parse_error_location_no_location() {
        let (loc, desc) = JasminBackend::parse_error_location("just a message");
        kani::assert(loc.is_none(), "Should have no location");
        kani::assert(
            desc == "just a message",
            "Description should be the original line",
        );
    }

    // =============================================
    // JasminBackend constructor proofs
    // =============================================

    /// Verify JasminBackend::new creates backend with default config
    #[kani::proof]
    fn proof_jasmin_backend_new_default_config() {
        let backend = JasminBackend::new();
        kani::assert(
            backend.config.timeout == Duration::from_secs(120),
            "New backend should have default timeout",
        );
    }

    /// Verify JasminBackend::with_config preserves config
    #[kani::proof]
    fn proof_jasmin_backend_with_config() {
        let config = JasminConfig {
            timeout: Duration::from_secs(60),
            ..Default::default()
        };
        let backend = JasminBackend::with_config(config);
        kani::assert(
            backend.config.timeout == Duration::from_secs(60),
            "Custom config should be preserved",
        );
    }

    /// Verify JasminBackend implements Default
    #[kani::proof]
    fn proof_jasmin_backend_default() {
        let backend = JasminBackend::default();
        kani::assert(
            backend.id() == BackendId::Jasmin,
            "Default backend should have correct ID",
        );
    }
}
