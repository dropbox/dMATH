//! Tests for Verifpal backend

use super::config::{VerifpalAnalysis, VerifpalConfig};
use super::model::{
    compile_query_term, extract_security_patterns, generate_verifpal_model, to_verifpal_ident,
};
use super::parsing::parse_output;
use super::VerifpalBackend;
use crate::traits::{PropertyType, VerificationBackend, VerificationStatus};
use dashprove_usl::ast::Expr;
use dashprove_usl::typecheck::{typecheck, TypedSpec};
use dashprove_usl::{parse, Spec};
use std::collections::HashSet;

fn create_typed_spec(input: &str) -> TypedSpec {
    let spec = parse(input).expect("should parse");
    typecheck(spec).expect("should typecheck")
}

#[test]
fn default_config() {
    let config = VerifpalConfig::default();
    assert!(matches!(config.analysis, VerifpalAnalysis::Active));
    assert!(config.json_output);
}

#[test]
fn parse_pass_result() {
    let status = parse_output("All queries PASS\n", "");
    assert!(matches!(status, VerificationStatus::Proven));
}

#[test]
fn parse_attack_found() {
    let status = parse_output("Attack found: confidentiality of na violated\n", "");
    assert!(matches!(status, VerificationStatus::Disproven));
}

#[test]
fn parse_verified_result() {
    let status = parse_output("confidentiality verified\nauthentication verified\n", "");
    assert!(matches!(status, VerificationStatus::Proven));
}

#[test]
fn test_generate_model_confidentiality() {
    let input = r#"
        security confidentiality {
            forall s: Secret, a: Agent .
                not authorized(a, s) implies not knows(a, s.content)
        }
    "#;
    let typed_spec = create_typed_spec(input);
    let backend = VerifpalBackend::new();
    let model = generate_verifpal_model(&backend.config, &typed_spec);

    // Check basic structure
    assert!(model.contains("// Generated by DashProve"));
    assert!(model.contains("attacker[active]"));

    // Check for principals
    assert!(model.contains("principal Alice["));
    assert!(model.contains("principal Bob["));

    // Check for secret derived from `s.content`
    assert!(model.contains("content"));

    // Check for confidentiality query
    assert!(model.contains("// Property: confidentiality"));
    assert!(model.contains("confidentiality?"));

    // Check for queries section
    assert!(model.contains("queries["));
}

#[test]
fn test_generate_model_tenant_isolation() {
    let input = r#"
        type Tenant = { id: String }

        security tenant_isolation {
            forall t1: Tenant, t2: Tenant .
                t1.id != t2.id implies not can_observe(t1, actions(t2))
        }
    "#;
    let typed_spec = create_typed_spec(input);
    let backend = VerifpalBackend::new();
    let model = generate_verifpal_model(&backend.config, &typed_spec);

    // Check for property comment
    assert!(model.contains("// Property: tenant_isolation"));

    // Check for basic model structure
    assert!(model.contains("attacker[active]"));
    assert!(model.contains("principal Alice["));
}

#[test]
fn test_generate_model_integrity() {
    let input = r#"
        security data_integrity {
            forall r: Record, a: Agent .
                modified(a, r) implies authorized(a, r)
        }
    "#;
    let typed_spec = create_typed_spec(input);
    let backend = VerifpalBackend::new();
    let model = generate_verifpal_model(&backend.config, &typed_spec);

    // Check for property comment
    assert!(model.contains("// Property: data_integrity"));

    // Check for authentication query (integrity maps to authentication in Verifpal)
    assert!(model.contains("authentication?"));
}

#[test]
fn test_generate_model_authentication() {
    let input = r#"
        security authentication_required {
            forall a: Action, u: User .
                performed(u, a) implies authenticated(u)
        }
    "#;
    let typed_spec = create_typed_spec(input);
    let backend = VerifpalBackend::new();
    let model = generate_verifpal_model(&backend.config, &typed_spec);

    // Check for property comment
    assert!(model.contains("// Property: authentication_required"));

    // Check for authentication queries
    assert!(model.contains("authentication?"));
}

#[test]
fn test_generate_model_noninterference() {
    let input = r#"
        security noninterference {
            forall h1: HighInput, h2: HighInput, l: LowInput .
                output(h1, l) == output(h2, l)
        }
    "#;
    let typed_spec = create_typed_spec(input);
    let backend = VerifpalBackend::new();
    let model = generate_verifpal_model(&backend.config, &typed_spec);

    // Check for property comment
    assert!(model.contains("// Property: noninterference"));

    // For non-interference, we use confidentiality to verify
    // that high-security data doesn't leak
    assert!(model.contains("confidentiality?"));
}

#[test]
fn test_generate_model_multiple_properties() {
    let input = r#"
        security prop1 {
            forall x: Int . true
        }

        security prop2 {
            forall y: Bool . true
        }
    "#;
    let typed_spec = create_typed_spec(input);
    let backend = VerifpalBackend::new();
    let model = generate_verifpal_model(&backend.config, &typed_spec);

    // Check both properties are included
    assert!(model.contains("// Property: prop1"));
    assert!(model.contains("// Property: prop2"));
}

#[test]
fn test_to_verifpal_ident() {
    // Test lowercase conversion of first character
    assert_eq!(to_verifpal_ident("Agent"), "agent");
    assert_eq!(to_verifpal_ident("Secret"), "secret");
    assert_eq!(to_verifpal_ident("myVar"), "myVar");
    assert_eq!(to_verifpal_ident("ABC"), "aBC");
    assert_eq!(to_verifpal_ident(""), "x");
}

#[test]
fn test_compile_query_term() {
    // Test variable
    let var = Expr::Var("secret".to_string());
    assert_eq!(compile_query_term(&var), "secret");

    // Test field access
    let field = Expr::FieldAccess(Box::new(Expr::Var("s".to_string())), "content".to_string());
    assert_eq!(compile_query_term(&field), "s_content");

    // Test function application (returns first arg for Verifpal)
    let func = Expr::App("hash".to_string(), vec![Expr::Var("msg".to_string())]);
    assert_eq!(compile_query_term(&func), "msg");
}

#[test]
fn test_extract_secrets_from_knows_pattern() {
    let mut secrets = HashSet::new();
    let mut integrity = Vec::new();
    let mut authentication = Vec::new();

    // `not knows(agent, secretVar)` should extract secretVar
    let expr = Expr::Not(Box::new(Expr::App(
        "knows".to_string(),
        vec![
            Expr::Var("agent".to_string()),
            Expr::Var("secretVar".to_string()),
        ],
    )));

    extract_security_patterns(&expr, &mut secrets, &mut integrity, &mut authentication);
    assert!(secrets.contains("secretVar"));
}

#[test]
fn test_extract_secrets_from_field_access() {
    let mut secrets = HashSet::new();
    let mut integrity = Vec::new();
    let mut authentication = Vec::new();

    // `not knows(a, s.content)` should extract "content"
    let expr = Expr::Not(Box::new(Expr::App(
        "knows".to_string(),
        vec![
            Expr::Var("a".to_string()),
            Expr::FieldAccess(Box::new(Expr::Var("s".to_string())), "content".to_string()),
        ],
    )));

    extract_security_patterns(&expr, &mut secrets, &mut integrity, &mut authentication);
    assert!(secrets.contains("content"));
}

#[test]
fn test_extract_integrity_predicates() {
    let mut secrets = HashSet::new();
    let mut integrity = Vec::new();
    let mut authentication = Vec::new();

    // `authorized(a, r) implies modified(a, r)` should extract integrity predicate
    let expr = Expr::Implies(
        Box::new(Expr::App(
            "authorized".to_string(),
            vec![Expr::Var("a".to_string()), Expr::Var("r".to_string())],
        )),
        Box::new(Expr::App(
            "modified".to_string(),
            vec![Expr::Var("a".to_string()), Expr::Var("r".to_string())],
        )),
    );

    extract_security_patterns(&expr, &mut secrets, &mut integrity, &mut authentication);
    assert_eq!(integrity.len(), 1);
    assert_eq!(integrity[0], ("a".to_string(), "r".to_string()));
    assert!(authentication.contains(&"a".to_string()));
}

#[test]
fn test_extract_authentication_from_performed_implies_authenticated() {
    let mut secrets = HashSet::new();
    let mut integrity = Vec::new();
    let mut authentication = Vec::new();

    // `performed(u, a) implies authenticated(u)` should extract authentication
    let expr = Expr::Implies(
        Box::new(Expr::App(
            "performed".to_string(),
            vec![Expr::Var("u".to_string()), Expr::Var("a".to_string())],
        )),
        Box::new(Expr::App(
            "authenticated".to_string(),
            vec![Expr::Var("u".to_string())],
        )),
    );

    extract_security_patterns(&expr, &mut secrets, &mut integrity, &mut authentication);
    assert!(authentication.contains(&"u".to_string()));
}

#[test]
fn test_model_without_security_properties() {
    // Test that an empty spec still generates a valid model
    let typed_spec = TypedSpec {
        spec: Spec::default(),
        type_info: Default::default(),
    };
    let backend = VerifpalBackend::new();
    let model = generate_verifpal_model(&backend.config, &typed_spec);

    // Should still have basic structure
    assert!(model.contains("// Generated by DashProve"));
    assert!(model.contains("attacker[active]"));
    assert!(model.contains("principal Alice["));
    assert!(model.contains("principal Bob["));
    assert!(model.contains("queries["));
    // Should have default queries
    assert!(model.contains("confidentiality? secretData"));
    assert!(model.contains("authentication?"));
}

#[test]
fn test_model_with_multiple_secrets() {
    let input = r#"
        security multi_secret {
            forall a: Agent .
                not knows(a, secret1) and not knows(a, secret2)
        }
    "#;
    let typed_spec = create_typed_spec(input);
    let backend = VerifpalBackend::new();
    let model = generate_verifpal_model(&backend.config, &typed_spec);

    // Check that both secrets are declared
    assert!(model.contains("secret1") || model.contains("secret2"));

    // Check for confidentiality queries
    assert!(model.contains("confidentiality?"));
}

#[test]
fn test_passive_attacker_mode() {
    let typed_spec = TypedSpec {
        spec: Spec::default(),
        type_info: Default::default(),
    };

    let config = VerifpalConfig {
        analysis: VerifpalAnalysis::Passive,
        ..Default::default()
    };
    let backend = VerifpalBackend::with_config(config);
    let model = generate_verifpal_model(&backend.config, &typed_spec);

    assert!(model.contains("attacker[passive]"));
}

#[test]
fn verifpal_backend_supports_security_protocol() {
    let backend = VerifpalBackend::new();
    let supports = backend.supports();
    assert!(supports.contains(&PropertyType::SecurityProtocol));
}
