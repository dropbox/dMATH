//! Verifpal model generation from USL specs

use super::config::VerifpalConfig;
use dashprove_usl::ast::{ComparisonOp, Expr, Property, Type};
use dashprove_usl::typecheck::TypedSpec;
use std::collections::HashSet;

/// Generate Verifpal model from USL spec
///
/// Compiles USL types, functions, and security properties to Verifpal syntax.
pub fn generate_verifpal_model(config: &VerifpalConfig, spec: &TypedSpec) -> String {
    let mut model = String::new();
    model.push_str("// Generated by DashProve\n");
    model.push_str("// USL to Verifpal compilation\n\n");

    // Collect all referenced types and functions from properties
    let mut types_used: HashSet<String> = HashSet::new();
    let mut functions_used: HashSet<String> = HashSet::new();
    let mut secrets: HashSet<String> = HashSet::new();
    let mut integrity_predicates: Vec<(String, String)> = Vec::new();
    let mut authentication_predicates: Vec<String> = Vec::new();

    for property in &spec.spec.properties {
        if let Property::Security(sec) = property {
            collect_from_expr(&sec.body, &mut types_used, &mut functions_used);
            extract_security_patterns(
                &sec.body,
                &mut secrets,
                &mut integrity_predicates,
                &mut authentication_predicates,
            );
        }
    }

    // Attacker model
    model.push_str(&format!("attacker[{}]\n\n", config.analysis.as_arg()));

    // Generate principal declarations based on USL types
    model.push_str("// Principals from USL spec\n");

    // Alice is the initiator/client
    model.push_str("principal Alice[\n");
    model.push_str("    knows private skA\n");
    model.push_str("    pkA = G^skA\n");

    // Generate secrets for Alice to protect
    if !secrets.is_empty() {
        model.push_str("    // Secrets from USL properties\n");
        for secret in &secrets {
            let secret_name = to_verifpal_ident(secret);
            model.push_str(&format!("    knows private {}\n", secret_name));
        }
    } else {
        model.push_str("    knows private secretData\n");
    }
    model.push_str("]\n\n");

    // Bob is the responder/server
    model.push_str("principal Bob[\n");
    model.push_str("    knows private skB\n");
    model.push_str("    pkB = G^skB\n");
    model.push_str("]\n\n");

    // Public key exchange phase
    model.push_str("// Public key exchange\n");
    model.push_str("Alice -> Bob: pkA\n");
    model.push_str("Bob -> Alice: pkB\n\n");

    // Generate protocol operations from USL properties
    model.push_str("// Protocol operations\n");
    model.push_str("principal Alice[\n");
    model.push_str("    generates na\n");
    model.push_str("    sharedKey = pkB^skA\n");

    // Encrypt secrets for transmission
    if !secrets.is_empty() {
        for secret in &secrets {
            let secret_name = to_verifpal_ident(secret);
            model.push_str(&format!(
                "    enc_{} = ENC(sharedKey, {})\n",
                secret_name, secret_name
            ));
        }
        // Message combines nonce and first encrypted secret
        let first_secret = to_verifpal_ident(secrets.iter().next().unwrap());
        model.push_str(&format!("    msgToB = CONCAT(na, enc_{})\n", first_secret));
    } else {
        model.push_str("    enc_secretData = ENC(sharedKey, secretData)\n");
        model.push_str("    msgToB = CONCAT(na, enc_secretData)\n");
    }
    model.push_str("]\n\n");

    model.push_str("Alice -> Bob: msgToB\n\n");

    // Bob's response
    model.push_str("principal Bob[\n");
    model.push_str("    sharedKey = pkA^skB\n");
    model.push_str("    na_received, encrypted_data = SPLIT(msgToB)\n");
    model.push_str("    received_data = DEC(sharedKey, encrypted_data)\n");
    model.push_str("    generates nb\n");
    model.push_str("    response = SIGN(skB, CONCAT(na_received, nb))\n");
    model.push_str("    msgToA = CONCAT(nb, response)\n");
    model.push_str("]\n\n");

    model.push_str("Bob -> Alice: msgToA\n\n");

    // Alice verifies Bob's response
    model.push_str("principal Alice[\n");
    model.push_str("    nb_received, signature = SPLIT(msgToA)\n");
    model.push_str("    _ = SIGNVERIF(pkB, CONCAT(na, nb_received), signature)?\n");
    model.push_str("]\n\n");

    // Generate queries from USL security properties
    model.push_str("// Security queries from USL properties\n");
    model.push_str("queries[\n");

    let queries = compile_security_queries(spec, &secrets, &authentication_predicates);
    for query in &queries {
        model.push_str(&format!("    {}\n", query));
    }

    // Ensure at least default queries if none generated
    if queries.is_empty() {
        model.push_str("    confidentiality? secretData\n");
        model.push_str("    authentication? Alice -> Bob: msgToB\n");
    }

    model.push_str("]\n");

    model
}

/// Convert USL identifier to valid Verifpal identifier
pub fn to_verifpal_ident(name: &str) -> String {
    // Verifpal uses lowercase identifiers
    let clean: String = name
        .chars()
        .filter(|c| c.is_alphanumeric() || *c == '_')
        .collect();
    if clean.is_empty() {
        "x".to_string()
    } else {
        // Ensure first character is lowercase
        let mut result = String::new();
        for (i, c) in clean.chars().enumerate() {
            if i == 0 {
                result.push(c.to_lowercase().next().unwrap_or(c));
            } else {
                result.push(c);
            }
        }
        result
    }
}

/// Collect types and functions referenced in an expression
fn collect_from_expr(expr: &Expr, types: &mut HashSet<String>, functions: &mut HashSet<String>) {
    match expr {
        Expr::ForAll { ty, body, .. } | Expr::Exists { ty, body, .. } => {
            if let Some(t) = ty {
                collect_type(t, types);
            }
            collect_from_expr(body, types, functions);
        }
        Expr::ForAllIn {
            collection, body, ..
        }
        | Expr::ExistsIn {
            collection, body, ..
        } => {
            collect_from_expr(collection, types, functions);
            collect_from_expr(body, types, functions);
        }
        Expr::App(name, args) => {
            functions.insert(name.clone());
            for arg in args {
                collect_from_expr(arg, types, functions);
            }
        }
        Expr::MethodCall { receiver, args, .. } => {
            collect_from_expr(receiver, types, functions);
            for arg in args {
                collect_from_expr(arg, types, functions);
            }
        }
        Expr::Not(inner) | Expr::Neg(inner) => collect_from_expr(inner, types, functions),
        Expr::And(left, right)
        | Expr::Or(left, right)
        | Expr::Implies(left, right)
        | Expr::Compare(left, _, right)
        | Expr::Binary(left, _, right) => {
            collect_from_expr(left, types, functions);
            collect_from_expr(right, types, functions);
        }
        Expr::FieldAccess(object, _) => {
            collect_from_expr(object, types, functions);
        }
        _ => {}
    }
}

/// Collect type names from a type annotation
fn collect_type(ty: &Type, types: &mut HashSet<String>) {
    match ty {
        Type::Named(name) => {
            types.insert(name.clone());
        }
        Type::Set(inner) | Type::List(inner) | Type::Result(inner) => {
            collect_type(inner, types);
        }
        Type::Map(k, v) | Type::Relation(k, v) | Type::Function(k, v) => {
            collect_type(k, types);
            collect_type(v, types);
        }
        Type::Graph(n, e) => {
            collect_type(n, types);
            collect_type(e, types);
        }
        Type::Path(n) => {
            collect_type(n, types);
        }
        Type::Unit => {}
    }
}

/// Extract security-relevant patterns from expression
///
/// Identifies:
/// - Secrets that should not be leaked (from `not knows(_, x)` patterns)
/// - Integrity predicates (from `authorized implies modified` patterns)
/// - Authentication requirements
pub fn extract_security_patterns(
    expr: &Expr,
    secrets: &mut HashSet<String>,
    integrity: &mut Vec<(String, String)>,
    authentication: &mut Vec<String>,
) {
    match expr {
        // `not knows(agent, secret)` → secret should be protected
        Expr::Not(inner) => {
            if let Expr::App(name, args) = inner.as_ref() {
                if name == "knows" && args.len() == 2 {
                    if let Expr::Var(secret_name) = &args[1] {
                        secrets.insert(secret_name.clone());
                    } else if let Expr::FieldAccess(_, field) = &args[1] {
                        secrets.insert(field.clone());
                    }
                }
            }
            extract_security_patterns(inner, secrets, integrity, authentication);
        }
        // `authorized(a, r) implies modified(a, r)` or similar → integrity/authentication
        Expr::Implies(left, right) => {
            if let (Expr::App(left_name, left_args), Expr::App(right_name, _)) =
                (left.as_ref(), right.as_ref())
            {
                // Pattern: authorized/authenticated implies action
                if (left_name == "authorized" || left_name == "authenticated")
                    && (right_name == "modified" || right_name == "performed")
                {
                    let subject = left_args.first().map(expr_to_string).unwrap_or_default();
                    let object = left_args.get(1).map(expr_to_string).unwrap_or_default();
                    integrity.push((subject.clone(), object));
                    authentication.push(subject);
                }
                // Pattern: performed implies authenticated
                if (left_name == "modified" || left_name == "performed")
                    && (right_name == "authorized" || right_name == "authenticated")
                {
                    let subject = left_args.first().map(expr_to_string).unwrap_or_default();
                    authentication.push(subject);
                }
            }
            extract_security_patterns(left, secrets, integrity, authentication);
            extract_security_patterns(right, secrets, integrity, authentication);
        }
        Expr::ForAll { body, .. }
        | Expr::Exists { body, .. }
        | Expr::ForAllIn { body, .. }
        | Expr::ExistsIn { body, .. } => {
            extract_security_patterns(body, secrets, integrity, authentication);
        }
        Expr::And(left, right) | Expr::Or(left, right) => {
            extract_security_patterns(left, secrets, integrity, authentication);
            extract_security_patterns(right, secrets, integrity, authentication);
        }
        _ => {}
    }
}

/// Convert expression to simple string for variable naming
fn expr_to_string(expr: &Expr) -> String {
    match expr {
        Expr::Var(name) => name.clone(),
        Expr::FieldAccess(object, field) => {
            format!("{}_{}", expr_to_string(object), field)
        }
        _ => "x".to_string(),
    }
}

/// Compile security properties to Verifpal queries
fn compile_security_queries(
    spec: &TypedSpec,
    secrets: &HashSet<String>,
    authentication: &[String],
) -> Vec<String> {
    let mut queries = Vec::new();

    for property in &spec.spec.properties {
        if let Property::Security(sec) = property {
            queries.push(format!("// Property: {}", sec.name));
            let prop_queries = compile_property_query(&sec.body, &sec.name, secrets);
            queries.extend(prop_queries);
        }
    }

    // Generate confidentiality queries for identified secrets
    if secrets.is_empty() {
        // Add default secretData confidentiality when no secrets identified
        if !queries.iter().any(|q| q.contains("confidentiality?")) {
            queries.push("confidentiality? secretData".to_string());
        }
    } else {
        for secret in secrets {
            let secret_name = to_verifpal_ident(secret);
            if !queries
                .iter()
                .any(|q| q.contains(&format!("confidentiality? {}", secret_name)))
            {
                queries.push(format!("confidentiality? {}", secret_name));
            }
        }
    }

    // Generate authentication queries
    if !authentication.is_empty() || !queries.iter().any(|q| q.contains("authentication?")) {
        queries.push("authentication? Alice -> Bob: msgToB".to_string());
        queries.push("authentication? Bob -> Alice: msgToA".to_string());
    }

    queries
}

/// Compile a single property body to Verifpal queries
fn compile_property_query(expr: &Expr, _prop_name: &str, secrets: &HashSet<String>) -> Vec<String> {
    let mut queries = Vec::new();

    match expr {
        Expr::ForAll { body, .. } => {
            queries.extend(compile_property_query(body, _prop_name, secrets));
        }
        Expr::Not(inner) => {
            if let Expr::App(name, args) = inner.as_ref() {
                if name == "knows" && args.len() == 2 {
                    // `not knows(agent, secret)` → confidentiality query
                    let secret = compile_query_term(&args[1]);
                    queries.push(format!("confidentiality? {}", secret));
                } else if name == "can_observe" {
                    // Non-observation → use default secret confidentiality
                    if secrets.is_empty() {
                        queries.push("confidentiality? secretData".to_string());
                    }
                }
            }
        }
        Expr::Implies(left, right) => {
            // Check for authentication patterns
            if let Expr::App(left_name, _) = left.as_ref() {
                if let Expr::App(right_name, _) = right.as_ref() {
                    if (left_name == "modified" || left_name == "performed")
                        && (right_name == "authorized" || right_name == "authenticated")
                    {
                        queries.push("authentication? Alice -> Bob: msgToB".to_string());
                    }
                }
            }
        }
        Expr::Compare(left, op, right) => {
            // Non-interference: output(h1, l) == output(h2, l)
            if matches!(op, ComparisonOp::Eq) {
                if let (Expr::App(l_name, _), Expr::App(r_name, _)) =
                    (left.as_ref(), right.as_ref())
                {
                    if l_name == "output" && r_name == "output" {
                        // For non-interference, we verify that high-security data
                        // doesn't leak to low-security outputs
                        if secrets.is_empty() {
                            queries.push("confidentiality? secretData".to_string());
                        }
                    }
                }
            }
        }
        Expr::And(left, right) => {
            queries.extend(compile_property_query(left, _prop_name, secrets));
            queries.extend(compile_property_query(right, _prop_name, secrets));
        }
        _ => {}
    }

    queries
}

/// Compile an expression to a Verifpal term for use in queries
pub fn compile_query_term(expr: &Expr) -> String {
    match expr {
        Expr::Var(name) => to_verifpal_ident(name),
        Expr::FieldAccess(object, field) => {
            format!("{}_{}", compile_query_term(object), field)
        }
        Expr::App(name, args) => {
            if args.is_empty() {
                to_verifpal_ident(name)
            } else {
                // Verifpal doesn't have complex function terms in queries,
                // so we just use the first argument
                compile_query_term(&args[0])
            }
        }
        _ => "secretData".to_string(),
    }
}
