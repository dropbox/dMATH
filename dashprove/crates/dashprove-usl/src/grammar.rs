//! USL Parser
//!
//! Parses USL source code into AST using pest.
//! See docs/DESIGN.md for the grammar specification.

use crate::ast::{
    ActionMapping, ApiState, ApiTransition, BinaryOp, Bisimulation, BisimulationPropertyExpr,
    BisimulationTolerance, CapabilityAbility, CapabilityClause, CapabilitySpec, ComparisonOp,
    ComposedTheorem, Contract, DistributedInvariant, DistributedTemporal, Expr, FairnessConstraint,
    FairnessKind, Field, GateCheck, ImprovementProposal, Invariant, Param, PlatformApi,
    PreservesClause, Probabilistic, Property, Refinement, RollbackAction, RollbackSpec, Security,
    SemanticProperty, Spec, StateEnum, Temporal, TemporalExpr, Theorem, Type, TypeDef,
    VariableMapping, VerificationGate, VersionSpec,
};
use pest::iterators::{Pair, Pairs};
use pest::Parser;
use pest_derive::Parser;
use thiserror::Error;

/// USL parser generated by pest
#[derive(Parser)]
#[grammar = "usl.pest"]
#[allow(missing_docs)]
struct UslParser;

/// Parse errors for USL source code
#[derive(Error, Debug)]
pub enum ParseError {
    /// Pest parsing error (syntax error)
    #[error("Parse error: {0}")]
    PestError(#[from] Box<pest::error::Error<Rule>>),
    /// Parser expected one rule but found another
    #[error("Unexpected rule: expected {expected}, found {found:?}")]
    UnexpectedRule {
        /// Expected rule name
        expected: &'static str,
        /// Actual rule found
        found: Rule,
    },
    /// Required element was missing
    #[error("Missing required element: {0}")]
    Missing(&'static str),
    /// Number could not be parsed
    #[error("Invalid number: {0}")]
    InvalidNumber(String),
    /// Generic invalid value error
    #[error("Invalid value: {0}")]
    Invalid(String),
}

impl From<pest::error::Error<Rule>> for ParseError {
    fn from(err: pest::error::Error<Rule>) -> Self {
        Self::PestError(Box::new(err))
    }
}

/// Parse USL source code into AST.
///
/// # Errors
///
/// Returns a [`ParseError`] if the source contains syntax errors,
/// unexpected rules, missing elements, or invalid numbers.
pub fn parse(source: &str) -> Result<Spec, ParseError> {
    let pairs = UslParser::parse(Rule::spec, source)?;
    build_spec(pairs)
}

fn build_spec(pairs: Pairs<Rule>) -> Result<Spec, ParseError> {
    let mut spec = Spec::default();

    // The pairs contains a single `spec` rule, we need to iterate its inner content
    for pair in pairs {
        let items = match pair.as_rule() {
            Rule::spec => pair.into_inner(),
            _ => continue,
        };

        for item in items {
            match item.as_rule() {
                // item and property are silent rules, so we see their children directly
                Rule::type_def => {
                    spec.types.push(build_type_def(item)?);
                }
                Rule::theorem => {
                    spec.properties
                        .push(Property::Theorem(build_theorem(item)?));
                }
                Rule::temporal => {
                    spec.properties
                        .push(Property::Temporal(build_temporal(item)?));
                }
                Rule::contract => {
                    spec.properties
                        .push(Property::Contract(build_contract(item)?));
                }
                Rule::invariant => {
                    spec.properties
                        .push(Property::Invariant(build_invariant(item)?));
                }
                Rule::refinement => {
                    spec.properties
                        .push(Property::Refinement(build_refinement(item)?));
                }
                Rule::probabilistic => {
                    spec.properties
                        .push(Property::Probabilistic(build_probabilistic(item)?));
                }
                Rule::security => {
                    spec.properties
                        .push(Property::Security(build_security(item)?));
                }
                Rule::semantic_property => {
                    spec.properties
                        .push(Property::Semantic(build_semantic_property(item)?));
                }
                Rule::platform_api => {
                    spec.properties
                        .push(Property::PlatformApi(build_platform_api(item)?));
                }
                Rule::bisimulation => {
                    spec.properties
                        .push(Property::Bisimulation(build_bisimulation(item)?));
                }
                Rule::version_spec => {
                    spec.properties
                        .push(Property::Version(build_version_spec(item)?));
                }
                Rule::capability_spec => {
                    spec.properties
                        .push(Property::Capability(build_capability_spec(item)?));
                }
                Rule::distributed_invariant => {
                    spec.properties.push(Property::DistributedInvariant(
                        build_distributed_invariant(item)?,
                    ));
                }
                Rule::distributed_temporal => {
                    spec.properties.push(Property::DistributedTemporal(
                        build_distributed_temporal(item)?,
                    ));
                }
                Rule::composed_theorem => {
                    spec.properties
                        .push(Property::Composed(build_composed_theorem(item)?));
                }
                Rule::improvement_proposal => {
                    spec.properties.push(Property::ImprovementProposal(
                        build_improvement_proposal(item)?,
                    ));
                }
                Rule::verification_gate => {
                    spec.properties
                        .push(Property::VerificationGate(build_verification_gate(item)?));
                }
                Rule::rollback_spec => {
                    spec.properties
                        .push(Property::Rollback(build_rollback_spec(item)?));
                }
                _ => {}
            }
        }
    }

    Ok(spec)
}

fn build_type_def(pair: Pair<Rule>) -> Result<TypeDef, ParseError> {
    let mut inner = pair.into_inner();
    let name = inner
        .next()
        .ok_or(ParseError::Missing("type name"))?
        .as_str()
        .to_string();

    let type_body = inner.next().ok_or(ParseError::Missing("type body"))?;
    let field_list = type_body
        .into_inner()
        .next()
        .ok_or(ParseError::Missing("field list"))?;

    let mut fields = Vec::new();
    for field_pair in field_list.into_inner() {
        if field_pair.as_rule() == Rule::field {
            fields.push(build_field(field_pair)?);
        }
    }

    Ok(TypeDef { name, fields })
}

fn build_field(pair: Pair<Rule>) -> Result<Field, ParseError> {
    let mut inner = pair.into_inner();
    let name = inner
        .next()
        .ok_or(ParseError::Missing("field name"))?
        .as_str()
        .to_string();
    let ty = build_type(inner.next().ok_or(ParseError::Missing("field type"))?)?;
    Ok(Field { name, ty })
}

fn build_type(pair: Pair<Rule>) -> Result<Type, ParseError> {
    match pair.as_rule() {
        Rule::type_expr | Rule::type_atom => {
            let inner = pair
                .into_inner()
                .next()
                .ok_or(ParseError::Missing("type"))?;
            build_type(inner)
        }
        Rule::type_function => {
            let mut inner = pair.into_inner();
            let left = build_type(
                inner
                    .next()
                    .ok_or(ParseError::Missing("function arg type"))?,
            )?;
            let right = build_type(
                inner
                    .next()
                    .ok_or(ParseError::Missing("function return type"))?,
            )?;
            Ok(Type::Function(Box::new(left), Box::new(right)))
        }
        Rule::type_unit => Ok(Type::Unit),
        Rule::type_named => {
            let name = pair.as_str().to_string();
            Ok(Type::Named(name))
        }
        Rule::type_result => {
            let inner_type = pair
                .into_inner()
                .next()
                .ok_or(ParseError::Missing("Result inner type"))?;
            Ok(Type::Result(Box::new(build_type(inner_type)?)))
        }
        Rule::type_set => {
            let inner_type = pair
                .into_inner()
                .next()
                .ok_or(ParseError::Missing("Set inner type"))?;
            Ok(Type::Set(Box::new(build_type(inner_type)?)))
        }
        Rule::type_list => {
            let inner_type = pair
                .into_inner()
                .next()
                .ok_or(ParseError::Missing("List inner type"))?;
            Ok(Type::List(Box::new(build_type(inner_type)?)))
        }
        Rule::type_map => {
            let mut inner = pair.into_inner();
            let key = build_type(inner.next().ok_or(ParseError::Missing("Map key type"))?)?;
            let value = build_type(inner.next().ok_or(ParseError::Missing("Map value type"))?)?;
            Ok(Type::Map(Box::new(key), Box::new(value)))
        }
        Rule::type_relation => {
            let mut inner = pair.into_inner();
            let left = build_type(
                inner
                    .next()
                    .ok_or(ParseError::Missing("Relation left type"))?,
            )?;
            let right = build_type(
                inner
                    .next()
                    .ok_or(ParseError::Missing("Relation right type"))?,
            )?;
            Ok(Type::Relation(Box::new(left), Box::new(right)))
        }
        Rule::type_graph => {
            let mut inner = pair.into_inner();
            let node_type =
                build_type(inner.next().ok_or(ParseError::Missing("Graph node type"))?)?;
            let edge_type =
                build_type(inner.next().ok_or(ParseError::Missing("Graph edge type"))?)?;
            Ok(Type::Graph(Box::new(node_type), Box::new(edge_type)))
        }
        Rule::type_graph_path => {
            let inner_type = pair
                .into_inner()
                .next()
                .ok_or(ParseError::Missing("Path inner type"))?;
            Ok(Type::Path(Box::new(build_type(inner_type)?)))
        }
        _ => Err(ParseError::UnexpectedRule {
            expected: "type",
            found: pair.as_rule(),
        }),
    }
}

fn build_theorem(pair: Pair<Rule>) -> Result<Theorem, ParseError> {
    let mut inner = pair.into_inner();
    let name = inner
        .next()
        .ok_or(ParseError::Missing("theorem name"))?
        .as_str()
        .to_string();
    let body = build_expr(inner.next().ok_or(ParseError::Missing("theorem body"))?)?;
    Ok(Theorem { name, body })
}

fn build_temporal(pair: Pair<Rule>) -> Result<Temporal, ParseError> {
    let mut inner = pair.into_inner();
    let name = inner
        .next()
        .ok_or(ParseError::Missing("temporal name"))?
        .as_str()
        .to_string();

    // Parse optional fairness clauses and the body
    let mut fairness = Vec::new();
    let mut body = None;

    for item in inner {
        match item.as_rule() {
            Rule::fairness_clause => {
                fairness.push(build_fairness_clause(item)?);
            }
            // All other rules are temporal expressions
            _ => {
                body = Some(build_temporal_expr(item)?);
            }
        }
    }

    let body = body.ok_or(ParseError::Missing("temporal body"))?;
    Ok(Temporal {
        name,
        body,
        fairness,
    })
}

fn build_fairness_clause(pair: Pair<Rule>) -> Result<FairnessConstraint, ParseError> {
    let mut inner = pair.into_inner();

    // Parse fairness kind (weak or strong)
    let kind_pair = inner.next().ok_or(ParseError::Missing("fairness kind"))?;
    let kind = match kind_pair.as_str() {
        "weak" => FairnessKind::Weak,
        "strong" => FairnessKind::Strong,
        _ => {
            return Err(ParseError::UnexpectedRule {
                expected: "weak or strong",
                found: kind_pair.as_rule(),
            });
        }
    };

    // Parse action name
    let action = inner
        .next()
        .ok_or(ParseError::Missing("fairness action"))?
        .as_str()
        .to_string();

    // Parse optional vars (e.g., "on vars")
    let vars = inner.next().map(|p| p.as_str().to_string());

    Ok(FairnessConstraint { kind, action, vars })
}

fn build_param_list(pair: Pair<Rule>) -> Result<Vec<Param>, ParseError> {
    let mut params = Vec::new();
    for param_pair in pair.into_inner() {
        if param_pair.as_rule() == Rule::param {
            let mut param_inner = param_pair.into_inner();
            let param_name = param_inner
                .next()
                .ok_or(ParseError::Missing("param name"))?
                .as_str()
                .to_string();
            let param_ty = build_type(
                param_inner
                    .next()
                    .ok_or(ParseError::Missing("param type"))?,
            )?;
            params.push(Param {
                name: param_name,
                ty: param_ty,
            });
        }
    }
    Ok(params)
}

fn build_contract(pair: Pair<Rule>) -> Result<Contract, ParseError> {
    let mut inner = pair.into_inner();

    // Parse function signature
    let sig = inner
        .next()
        .ok_or(ParseError::Missing("function signature"))?;
    let mut sig_inner = sig.into_inner();

    // Type path (e.g., Graph::add_node)
    let type_path_pair = sig_inner.next().ok_or(ParseError::Missing("type path"))?;
    let type_path: Vec<String> = type_path_pair
        .into_inner()
        .map(|p| p.as_str().to_string())
        .collect();

    // Parameters
    let param_list_pair = sig_inner.next().ok_or(ParseError::Missing("param list"))?;
    let params = build_param_list(param_list_pair)?;

    // Return type (optional)
    let return_type = sig_inner.next().map(|p| build_type(p)).transpose()?;

    // Contract body
    let body = inner.next().ok_or(ParseError::Missing("contract body"))?;
    let mut requires = Vec::new();
    let mut ensures = Vec::new();
    let mut ensures_err = Vec::new();

    for clause in body.into_inner() {
        match clause.as_rule() {
            Rule::requires_clause => {
                let block = clause
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("requires block"))?;
                let expr = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("requires expr"))?;
                requires.push(build_expr(expr)?);
            }
            Rule::ensures_clause => {
                let block = clause
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("ensures block"))?;
                let expr = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("ensures expr"))?;
                ensures.push(build_expr(expr)?);
            }
            Rule::ensures_err_clause => {
                let block = clause
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("ensures_err block"))?;
                let expr = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("ensures_err expr"))?;
                ensures_err.push(build_expr(expr)?);
            }
            _ => {}
        }
    }

    Ok(Contract {
        type_path,
        params,
        return_type,
        requires,
        ensures,
        ensures_err,
        assigns: Vec::new(),
        allocates: Vec::new(),
        frees: Vec::new(),
        terminates: None,
        decreases: None,
        behaviors: Vec::new(),
        complete_behaviors: false,
        disjoint_behaviors: false,
    })
}

fn build_invariant(pair: Pair<Rule>) -> Result<Invariant, ParseError> {
    let mut inner = pair.into_inner();
    let name = inner
        .next()
        .ok_or(ParseError::Missing("invariant name"))?
        .as_str()
        .to_string();
    let body = build_expr(inner.next().ok_or(ParseError::Missing("invariant body"))?)?;
    Ok(Invariant { name, body })
}

fn build_refinement(pair: Pair<Rule>) -> Result<Refinement, ParseError> {
    let mut inner = pair.into_inner();
    let name = inner
        .next()
        .ok_or(ParseError::Missing("refinement name"))?
        .as_str()
        .to_string();
    let refines = inner
        .next()
        .ok_or(ParseError::Missing("refines target"))?
        .as_str()
        .to_string();

    let body = inner.next().ok_or(ParseError::Missing("refinement body"))?;

    let mut mappings = Vec::new();
    let mut invariants = Vec::new();
    let mut abstraction = None;
    let mut simulation = None;
    let mut actions = Vec::new();

    for clause in body.into_inner() {
        match clause.as_rule() {
            Rule::refinement_mapping_clause => {
                // Parse variable mappings
                for var_map in clause.into_inner() {
                    if var_map.as_rule() == Rule::var_mapping {
                        mappings.push(build_var_mapping(var_map)?);
                    }
                }
            }
            Rule::refinement_invariant_clause => {
                // Parse invariant expression from block
                let block = clause
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("invariant block"))?;
                let expr = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("invariant expr"))?;
                invariants.push(build_expr(expr)?);
            }
            Rule::abstraction_clause => {
                let block = clause
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("abstraction block"))?;
                let expr = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("abstraction expr"))?;
                abstraction = Some(build_expr(expr)?);
            }
            Rule::simulation_clause => {
                let block = clause
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("simulation block"))?;
                let expr = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("simulation expr"))?;
                simulation = Some(build_expr(expr)?);
            }
            Rule::action_mapping_clause => {
                actions.push(build_action_mapping(clause)?);
            }
            _ => {}
        }
    }

    Ok(Refinement {
        name,
        refines,
        mappings,
        invariants,
        abstraction: abstraction.ok_or(ParseError::Missing("abstraction clause"))?,
        simulation: simulation.ok_or(ParseError::Missing("simulation clause"))?,
        actions,
    })
}

fn build_var_mapping(pair: Pair<Rule>) -> Result<VariableMapping, ParseError> {
    let mut inner = pair.into_inner();

    let spec_var = build_access_expr(
        inner
            .next()
            .ok_or(ParseError::Missing("spec variable in mapping"))?,
    )?;
    let impl_var = build_access_expr(
        inner
            .next()
            .ok_or(ParseError::Missing("impl variable in mapping"))?,
    )?;

    Ok(VariableMapping { spec_var, impl_var })
}

fn build_action_mapping(pair: Pair<Rule>) -> Result<ActionMapping, ParseError> {
    let mut inner = pair.into_inner();

    let name = inner
        .next()
        .ok_or(ParseError::Missing("action name"))?
        .as_str()
        .to_string();

    let mut spec_action = None;
    let mut impl_action = None;
    let mut guard = None;

    for clause in inner {
        match clause.as_rule() {
            Rule::action_spec_clause => {
                spec_action = Some(
                    clause
                        .into_inner()
                        .next()
                        .ok_or(ParseError::Missing("spec action name"))?
                        .as_str()
                        .to_string(),
                );
            }
            Rule::action_impl_clause => {
                let type_path = clause
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("impl action path"))?;
                impl_action = Some(
                    type_path
                        .into_inner()
                        .map(|p| p.as_str().to_string())
                        .collect(),
                );
            }
            Rule::action_guard_clause => {
                let block = clause
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("guard block"))?;
                let expr = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("guard expr"))?;
                guard = Some(build_expr(expr)?);
            }
            _ => {}
        }
    }

    Ok(ActionMapping {
        name,
        spec_action: spec_action.ok_or(ParseError::Missing("spec action"))?,
        impl_action: impl_action.ok_or(ParseError::Missing("impl action"))?,
        guard,
    })
}

fn build_probabilistic(pair: Pair<Rule>) -> Result<Probabilistic, ParseError> {
    let mut inner = pair.into_inner();
    let name = inner
        .next()
        .ok_or(ParseError::Missing("probabilistic name"))?
        .as_str()
        .to_string();

    let prob_expr = inner
        .next()
        .ok_or(ParseError::Missing("probability expression"))?;
    let mut prob_inner = prob_expr.into_inner();

    let condition = build_expr(
        prob_inner
            .next()
            .ok_or(ParseError::Missing("probability condition"))?,
    )?;

    let cmp_op = prob_inner
        .next()
        .ok_or(ParseError::Missing("comparison operator"))?;
    let comparison = parse_cmp_op(cmp_op.as_str())?;

    let bound_str = prob_inner
        .next()
        .ok_or(ParseError::Missing("probability bound"))?
        .as_str();
    let bound = bound_str
        .parse::<f64>()
        .map_err(|_| ParseError::InvalidNumber(bound_str.to_string()))?;

    Ok(Probabilistic {
        name,
        condition,
        comparison,
        bound,
    })
}

fn build_security(pair: Pair<Rule>) -> Result<Security, ParseError> {
    let mut inner = pair.into_inner();
    let name = inner
        .next()
        .ok_or(ParseError::Missing("security name"))?
        .as_str()
        .to_string();
    let body = build_expr(inner.next().ok_or(ParseError::Missing("security body"))?)?;
    Ok(Security { name, body })
}

fn build_semantic_property(pair: Pair<Rule>) -> Result<SemanticProperty, ParseError> {
    let mut inner = pair.into_inner();
    let name = inner
        .next()
        .ok_or(ParseError::Missing("semantic property name"))?
        .as_str()
        .to_string();
    let body_expr = inner
        .next()
        .ok_or(ParseError::Missing("semantic property body"))?;
    let body = build_expr(body_expr)?;
    Ok(SemanticProperty { name, body })
}

fn build_platform_api(pair: Pair<Rule>) -> Result<PlatformApi, ParseError> {
    let mut inner = pair.into_inner();
    let name = inner
        .next()
        .ok_or(ParseError::Missing("platform_api name"))?
        .as_str()
        .to_string();

    let mut states = Vec::new();
    for state_pair in inner {
        if state_pair.as_rule() == Rule::api_state {
            states.push(build_api_state(state_pair)?);
        }
    }

    Ok(PlatformApi { name, states })
}

fn build_api_state(pair: Pair<Rule>) -> Result<ApiState, ParseError> {
    let mut inner = pair.into_inner();
    let name = inner
        .next()
        .ok_or(ParseError::Missing("state name"))?
        .as_str()
        .to_string();

    let body = inner.next().ok_or(ParseError::Missing("state body"))?;

    let mut status_enum = None;
    let mut transitions = Vec::new();
    let mut invariants = Vec::new();

    for item in body.into_inner() {
        match item.as_rule() {
            Rule::state_enum => {
                status_enum = Some(build_state_enum(item)?);
            }
            Rule::api_transition => {
                transitions.push(build_api_transition(item)?);
            }
            Rule::api_invariant => {
                // api_invariant contains a block, which contains an expr
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("invariant block"))?;
                let expr = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("invariant expr"))?;
                invariants.push(build_expr(expr)?);
            }
            _ => {}
        }
    }

    Ok(ApiState {
        name,
        status_enum,
        transitions,
        invariants,
    })
}

fn build_state_enum(pair: Pair<Rule>) -> Result<StateEnum, ParseError> {
    let mut inner = pair.into_inner();
    let name = inner
        .next()
        .ok_or(ParseError::Missing("enum name"))?
        .as_str()
        .to_string();

    let ident_list = inner.next().ok_or(ParseError::Missing("enum variants"))?;
    let variants = ident_list
        .into_inner()
        .map(|p| p.as_str().to_string())
        .collect();

    Ok(StateEnum { name, variants })
}

fn build_api_transition(pair: Pair<Rule>) -> Result<ApiTransition, ParseError> {
    let mut inner = pair.into_inner();

    let name = inner
        .next()
        .ok_or(ParseError::Missing("transition name"))?
        .as_str()
        .to_string();

    let param_list = inner.next().ok_or(ParseError::Missing("param_list"))?;
    let params = build_param_list(param_list)?;

    let body = inner.next().ok_or(ParseError::Missing("transition body"))?;

    let mut requires = Vec::new();
    let mut ensures = Vec::new();

    for item in body.into_inner() {
        match item.as_rule() {
            Rule::transition_requires => {
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("requires block"))?;
                let expr = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("requires expr"))?;
                requires.push(build_expr(expr)?);
            }
            Rule::transition_ensures => {
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("ensures block"))?;
                let expr = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("ensures expr"))?;
                ensures.push(build_expr(expr)?);
            }
            _ => {}
        }
    }

    Ok(ApiTransition {
        name,
        params,
        requires,
        ensures,
    })
}

fn build_bisimulation(pair: Pair<Rule>) -> Result<Bisimulation, ParseError> {
    let mut inner = pair.into_inner();

    let name = inner
        .next()
        .ok_or(ParseError::Missing("bisimulation name"))?
        .as_str()
        .to_string();

    let body = inner
        .next()
        .ok_or(ParseError::Missing("bisimulation body"))?;

    let mut oracle = String::new();
    let mut subject = String::new();
    let mut equivalent_on = Vec::new();
    let mut tolerance = None;
    let mut property = None;

    for item in body.into_inner() {
        match item.as_rule() {
            Rule::bisim_oracle => {
                let string_lit = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("oracle path"))?;
                oracle = parse_string_literal(string_lit.as_str());
            }
            Rule::bisim_subject => {
                let string_lit = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("subject path"))?;
                subject = parse_string_literal(string_lit.as_str());
            }
            Rule::bisim_equivalent => {
                let ident_list = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("equivalent on list"))?;
                for ident in ident_list.into_inner() {
                    equivalent_on.push(ident.as_str().to_string());
                }
            }
            Rule::bisim_tolerance => {
                let mut tol = BisimulationTolerance::default();
                for tol_item in item.into_inner() {
                    if tol_item.as_rule() == Rule::tolerance_item_list {
                        for tolerance_item in tol_item.into_inner() {
                            if tolerance_item.as_rule() == Rule::tolerance_item {
                                let mut parts = tolerance_item.into_inner();
                                let key = parts
                                    .next()
                                    .ok_or(ParseError::Missing("tolerance key"))?
                                    .as_str();
                                let value_str = parts
                                    .next()
                                    .ok_or(ParseError::Missing("tolerance value"))?
                                    .as_str();
                                let value: f64 = value_str.parse().map_err(|_| {
                                    ParseError::Invalid(format!(
                                        "invalid tolerance value: {}",
                                        value_str
                                    ))
                                })?;

                                match key {
                                    "timing" => tol.timing = Some(value),
                                    "semantic" => tol.semantic = Some(value),
                                    _ => tol.other.push((key.to_string(), value)),
                                }
                            }
                        }
                    }
                }
                tolerance = Some(tol);
            }
            Rule::bisim_property => {
                let mut prop_inner = item.into_inner();
                let typed_var = prop_inner.next().ok_or(ParseError::Missing("typed_var"))?;
                let mut var_inner = typed_var.into_inner();
                let var_name = var_inner
                    .next()
                    .ok_or(ParseError::Missing("var name"))?
                    .as_str()
                    .to_string();
                let var_type_pair = var_inner.next().ok_or(ParseError::Missing("var type"))?;
                let var_type = build_type(var_type_pair)?;

                let bisim_expr = prop_inner.next().ok_or(ParseError::Missing("bisim_expr"))?;
                let mut expr_inner = bisim_expr.into_inner();

                let oracle_expr_pair = expr_inner
                    .next()
                    .ok_or(ParseError::Missing("oracle expr"))?;
                let oracle_expr = build_expr(oracle_expr_pair)?;

                let subject_expr_pair = expr_inner
                    .next()
                    .ok_or(ParseError::Missing("subject expr"))?;
                let subject_expr = build_expr(subject_expr_pair)?;

                property = Some(BisimulationPropertyExpr {
                    var_name,
                    var_type,
                    oracle_expr,
                    subject_expr,
                });
            }
            _ => {}
        }
    }

    Ok(Bisimulation {
        name,
        oracle,
        subject,
        equivalent_on,
        tolerance,
        property,
    })
}

fn build_version_spec(pair: Pair<Rule>) -> Result<VersionSpec, ParseError> {
    let mut inner = pair.into_inner();

    let name = inner
        .next()
        .ok_or(ParseError::Missing("version name"))?
        .as_str()
        .to_string();

    let improves = inner
        .next()
        .ok_or(ParseError::Missing("improves target"))?
        .as_str()
        .to_string();

    let body = inner.next().ok_or(ParseError::Missing("version body"))?;

    let mut capabilities = Vec::new();
    let mut preserves = Vec::new();

    for item in body.into_inner() {
        match item.as_rule() {
            Rule::version_capability => {
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("capability block"))?;
                let expr = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("capability expr"))?;
                capabilities.push(CapabilityClause {
                    expr: build_expr(expr)?,
                });
            }
            Rule::version_preserves => {
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("preserves block"))?;
                let expr = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("preserves expr"))?;
                preserves.push(PreservesClause {
                    property: build_expr(expr)?,
                });
            }
            _ => {}
        }
    }

    Ok(VersionSpec {
        name,
        improves,
        capabilities,
        preserves,
    })
}

fn build_capability_spec(pair: Pair<Rule>) -> Result<CapabilitySpec, ParseError> {
    let mut inner = pair.into_inner();

    let name = inner
        .next()
        .ok_or(ParseError::Missing("capability name"))?
        .as_str()
        .to_string();

    let body = inner.next().ok_or(ParseError::Missing("capability body"))?;

    let mut abilities = Vec::new();
    let mut requires = Vec::new();

    for item in body.into_inner() {
        match item.as_rule() {
            Rule::capability_can => {
                abilities.push(build_capability_ability(item)?);
            }
            Rule::capability_requires => {
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("requires block"))?;
                let expr = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("requires expr"))?;
                requires.push(build_expr(expr)?);
            }
            _ => {}
        }
    }

    Ok(CapabilitySpec {
        name,
        abilities,
        requires,
    })
}

fn build_capability_ability(pair: Pair<Rule>) -> Result<CapabilityAbility, ParseError> {
    let mut inner = pair.into_inner();

    let name = inner
        .next()
        .ok_or(ParseError::Missing("ability name"))?
        .as_str()
        .to_string();

    let param_list = inner.next().ok_or(ParseError::Missing("ability params"))?;
    let params = build_param_list(param_list)?;

    // Return type is optional
    let return_type = inner.next().map(|p| build_type(p)).transpose()?;

    Ok(CapabilityAbility {
        name,
        params,
        return_type,
    })
}

fn build_distributed_invariant(pair: Pair<Rule>) -> Result<DistributedInvariant, ParseError> {
    let mut inner = pair.into_inner();

    let name = inner
        .next()
        .ok_or(ParseError::Missing("distributed invariant name"))?
        .as_str()
        .to_string();

    let body_expr = inner
        .next()
        .ok_or(ParseError::Missing("distributed invariant body"))?;
    let body = build_expr(body_expr)?;

    Ok(DistributedInvariant { name, body })
}

fn build_distributed_temporal(pair: Pair<Rule>) -> Result<DistributedTemporal, ParseError> {
    let mut inner = pair.into_inner();

    let name = inner
        .next()
        .ok_or(ParseError::Missing("distributed temporal name"))?
        .as_str()
        .to_string();

    let mut fairness = Vec::new();
    let mut body = None;

    for item in inner {
        match item.as_rule() {
            Rule::fairness_clause => {
                fairness.push(build_fairness_clause(item)?);
            }
            Rule::temporal_expr => {
                body = Some(build_temporal_expr(item)?);
            }
            _ => {}
        }
    }

    Ok(DistributedTemporal {
        name,
        body: body.ok_or(ParseError::Missing("distributed temporal body"))?,
        fairness,
    })
}

fn build_composed_theorem(pair: Pair<Rule>) -> Result<ComposedTheorem, ParseError> {
    let mut inner = pair.into_inner();

    let name = inner
        .next()
        .ok_or(ParseError::Missing("composed theorem name"))?
        .as_str()
        .to_string();

    // Parse uses clause
    let uses_clause = inner.next().ok_or(ParseError::Missing("uses clause"))?;

    let mut uses = Vec::new();
    for item in uses_clause.into_inner() {
        match item.as_rule() {
            Rule::ident_list => {
                for ident in item.into_inner() {
                    if ident.as_rule() == Rule::ident {
                        uses.push(ident.as_str().to_string());
                    }
                }
            }
            Rule::ident => {
                uses.push(item.as_str().to_string());
            }
            _ => {}
        }
    }

    // Parse body expression
    let body = build_expr(
        inner
            .next()
            .ok_or(ParseError::Missing("composed theorem body"))?,
    )?;

    Ok(ComposedTheorem { name, uses, body })
}

fn build_improvement_proposal(pair: Pair<Rule>) -> Result<ImprovementProposal, ParseError> {
    let mut inner = pair.into_inner();

    let name = inner
        .next()
        .ok_or(ParseError::Missing("improvement proposal name"))?
        .as_str()
        .to_string();

    // Parse improvement_body
    let body = inner
        .next()
        .ok_or(ParseError::Missing("improvement body"))?;

    let mut target = None;
    let mut improves = Vec::new();
    let mut preserves = Vec::new();
    let mut requires = Vec::new();

    for item in body.into_inner() {
        match item.as_rule() {
            Rule::improvement_target => {
                // target { expr }
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("target block"))?;
                let expr_pair = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("target expression"))?;
                target = Some(build_expr(expr_pair)?);
            }
            Rule::improvement_improves => {
                // improves { expr }
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("improves block"))?;
                let expr_pair = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("improves expression"))?;
                improves.push(build_expr(expr_pair)?);
            }
            Rule::improvement_preserves => {
                // preserves { expr }
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("preserves block"))?;
                let expr_pair = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("preserves expression"))?;
                preserves.push(build_expr(expr_pair)?);
            }
            Rule::improvement_requires => {
                // requires { expr }
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("requires block"))?;
                let expr_pair = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("requires expression"))?;
                requires.push(build_expr(expr_pair)?);
            }
            _ => {}
        }
    }

    Ok(ImprovementProposal {
        name,
        target: target.ok_or(ParseError::Missing("improvement target"))?,
        improves,
        preserves,
        requires,
    })
}

fn build_verification_gate(pair: Pair<Rule>) -> Result<VerificationGate, ParseError> {
    let mut inner = pair.into_inner();

    let name = inner
        .next()
        .ok_or(ParseError::Missing("verification gate name"))?
        .as_str()
        .to_string();

    // Parse gate_body
    let body = inner.next().ok_or(ParseError::Missing("gate body"))?;

    let mut inputs = Vec::new();
    let mut checks = Vec::new();
    let mut on_pass = None;
    let mut on_fail = None;

    for item in body.into_inner() {
        match item.as_rule() {
            Rule::gate_inputs => {
                // inputs { param_list }
                for param_item in item.into_inner() {
                    if param_item.as_rule() == Rule::param_list {
                        inputs = build_param_list(param_item)?;
                    }
                }
            }
            Rule::gate_checks => {
                // checks { check* }
                for check_item in item.into_inner() {
                    if check_item.as_rule() == Rule::gate_check {
                        let mut check_inner = check_item.into_inner();
                        let check_name = check_inner
                            .next()
                            .ok_or(ParseError::Missing("check name"))?
                            .as_str()
                            .to_string();
                        let block = check_inner
                            .next()
                            .ok_or(ParseError::Missing("check block"))?;
                        let expr_pair = block
                            .into_inner()
                            .next()
                            .ok_or(ParseError::Missing("check expression"))?;
                        checks.push(GateCheck {
                            name: check_name,
                            condition: build_expr(expr_pair)?,
                        });
                    }
                }
            }
            Rule::gate_on_pass => {
                // on_pass { expr }
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("on_pass block"))?;
                let expr_pair = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("on_pass expression"))?;
                on_pass = Some(build_expr(expr_pair)?);
            }
            Rule::gate_on_fail => {
                // on_fail { expr }
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("on_fail block"))?;
                let expr_pair = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("on_fail expression"))?;
                on_fail = Some(build_expr(expr_pair)?);
            }
            _ => {}
        }
    }

    Ok(VerificationGate {
        name,
        inputs,
        checks,
        on_pass: on_pass.ok_or(ParseError::Missing("on_pass clause"))?,
        on_fail: on_fail.ok_or(ParseError::Missing("on_fail clause"))?,
    })
}

fn build_rollback_spec(pair: Pair<Rule>) -> Result<RollbackSpec, ParseError> {
    let mut inner = pair.into_inner();

    let name = inner
        .next()
        .ok_or(ParseError::Missing("rollback spec name"))?
        .as_str()
        .to_string();

    // Parse rollback_body
    let body = inner.next().ok_or(ParseError::Missing("rollback body"))?;

    let mut state = Vec::new();
    let mut invariants = Vec::new();
    let mut trigger = None;
    let mut action = None;
    let mut guarantees = Vec::new();

    for item in body.into_inner() {
        match item.as_rule() {
            Rule::rollback_state => {
                // state { param_list }
                for param_item in item.into_inner() {
                    if param_item.as_rule() == Rule::param_list {
                        state = build_param_list(param_item)?;
                    }
                }
            }
            Rule::rollback_invariant => {
                // invariant { expr }
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("rollback invariant block"))?;
                let expr_pair = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("rollback invariant expression"))?;
                invariants.push(build_expr(expr_pair)?);
            }
            Rule::rollback_trigger => {
                // trigger { expr }
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("trigger block"))?;
                let expr_pair = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("trigger expression"))?;
                trigger = Some(build_expr(expr_pair)?);
            }
            Rule::rollback_action => {
                // action { assignments* ensure? }
                let assignments = Vec::new();
                let mut ensure = None;

                for action_item in item.into_inner() {
                    if action_item.as_rule() == Rule::rollback_action_body {
                        for body_item in action_item.into_inner() {
                            if body_item.as_rule() == Rule::block {
                                // This is the ensure block
                                let expr_pair = body_item
                                    .into_inner()
                                    .next()
                                    .ok_or(ParseError::Missing("ensure expression"))?;
                                ensure = Some(build_expr(expr_pair)?);
                            }
                            // Skip ident and expr rules - assignment parsing is simplified
                        }
                    }
                }

                action = Some(RollbackAction {
                    assignments,
                    ensure,
                });
            }
            Rule::rollback_guarantee => {
                // guarantee { expr }
                let block = item
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("guarantee block"))?;
                let expr_pair = block
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("guarantee expression"))?;
                guarantees.push(build_expr(expr_pair)?);
            }
            _ => {}
        }
    }

    Ok(RollbackSpec {
        name,
        state,
        invariants,
        trigger: trigger.ok_or(ParseError::Missing("rollback trigger"))?,
        action: action.ok_or(ParseError::Missing("rollback action"))?,
        guarantees,
    })
}

/// Parse a string literal, removing surrounding quotes
fn parse_string_literal(s: &str) -> String {
    if s.starts_with('"') && s.ends_with('"') {
        s[1..s.len() - 1].to_string()
    } else {
        s.to_string()
    }
}

fn build_temporal_expr(pair: Pair<Rule>) -> Result<TemporalExpr, ParseError> {
    match pair.as_rule() {
        Rule::temporal_expr => {
            let inner = pair
                .into_inner()
                .next()
                .ok_or(ParseError::Missing("temporal expr"))?;
            build_temporal_expr(inner)
        }
        Rule::temporal_binary => {
            let mut inner = pair.into_inner();
            let left =
                build_temporal_expr(inner.next().ok_or(ParseError::Missing("leads-to left"))?)?;
            let right =
                build_temporal_expr(inner.next().ok_or(ParseError::Missing("leads-to right"))?)?;
            Ok(TemporalExpr::LeadsTo(Box::new(left), Box::new(right)))
        }
        Rule::temporal_always => {
            let inner = pair
                .into_inner()
                .next()
                .ok_or(ParseError::Missing("always body"))?;
            let operand = build_temporal_expr(inner)?;
            Ok(TemporalExpr::Always(Box::new(operand)))
        }
        Rule::temporal_eventually => {
            let inner = pair
                .into_inner()
                .next()
                .ok_or(ParseError::Missing("eventually body"))?;
            let operand = build_temporal_expr(inner)?;
            Ok(TemporalExpr::Eventually(Box::new(operand)))
        }
        Rule::temporal_paren => {
            let inner = pair
                .into_inner()
                .next()
                .ok_or(ParseError::Missing("paren body"))?;
            build_temporal_expr(inner)
        }
        Rule::temporal_atom_expr => {
            let inner = pair
                .into_inner()
                .next()
                .ok_or(ParseError::Missing("atom expr"))?;
            Ok(TemporalExpr::Atom(build_expr(inner)?))
        }
        _ => {
            // Try to build as expression
            Ok(TemporalExpr::Atom(build_expr(pair)?))
        }
    }
}

fn build_expr(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    match pair.as_rule() {
        Rule::expr => {
            let inner = pair
                .into_inner()
                .next()
                .ok_or(ParseError::Missing("expr"))?;
            build_expr(inner)
        }
        Rule::implies_expr => build_implies_expr(pair),
        Rule::or_expr => build_or_expr(pair),
        Rule::and_expr => build_and_expr(pair),
        Rule::not_expr => build_not_expr(pair),
        Rule::comparison_expr => build_comparison_expr(pair),
        Rule::additive_expr => build_additive_expr(pair),
        Rule::multiplicative_expr => build_multiplicative_expr(pair),
        Rule::unary_expr => build_unary_expr(pair),
        Rule::atom => build_atom(pair),
        _ => Err(ParseError::UnexpectedRule {
            expected: "expression",
            found: pair.as_rule(),
        }),
    }
}

fn build_quantified_expr(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    let mut inner = pair.into_inner();

    let quantifier = inner
        .next()
        .ok_or(ParseError::Missing("quantifier"))?
        .as_str();
    let is_forall = quantifier == "forall";

    let binding_list = inner.next().ok_or(ParseError::Missing("binding list"))?;

    let body = build_expr(inner.next().ok_or(ParseError::Missing("quantified body"))?)?;

    // Process bindings in reverse to build nested quantifiers
    let bindings: Vec<_> = binding_list.into_inner().collect();
    let mut result = body;

    for binding_pair in bindings.into_iter().rev() {
        let mut binding_inner = binding_pair.into_inner();
        let var = binding_inner
            .next()
            .ok_or(ParseError::Missing("binding var"))?
            .as_str()
            .to_string();

        if let Some(next) = binding_inner.next() {
            match next.as_rule() {
                Rule::type_expr => {
                    let ty = build_type(next)?;
                    result = if is_forall {
                        Expr::ForAll {
                            var,
                            ty: Some(ty),
                            body: Box::new(result),
                        }
                    } else {
                        Expr::Exists {
                            var,
                            ty: Some(ty),
                            body: Box::new(result),
                        }
                    };
                }
                Rule::binding_collection => {
                    let collection = build_binding_collection(next)?;
                    result = if is_forall {
                        Expr::ForAllIn {
                            var,
                            collection: Box::new(collection),
                            body: Box::new(result),
                        }
                    } else {
                        Expr::ExistsIn {
                            var,
                            collection: Box::new(collection),
                            body: Box::new(result),
                        }
                    };
                }
                _ => {
                    // Try to build whatever it is as an expression
                    let collection = build_expr(next)?;
                    result = if is_forall {
                        Expr::ForAllIn {
                            var,
                            collection: Box::new(collection),
                            body: Box::new(result),
                        }
                    } else {
                        Expr::ExistsIn {
                            var,
                            collection: Box::new(collection),
                            body: Box::new(result),
                        }
                    };
                }
            }
        } else {
            result = if is_forall {
                Expr::ForAll {
                    var,
                    ty: None,
                    body: Box::new(result),
                }
            } else {
                Expr::Exists {
                    var,
                    ty: None,
                    body: Box::new(result),
                }
            };
        }
    }

    Ok(result)
}

fn build_implies_expr(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    let mut inner = pair.into_inner();
    let mut left = build_expr(inner.next().ok_or(ParseError::Missing("implies left"))?)?;

    for right_pair in inner {
        let right = build_expr(right_pair)?;
        left = Expr::Implies(Box::new(left), Box::new(right));
    }

    Ok(left)
}

fn build_or_expr(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    let mut inner = pair.into_inner();
    let mut left = build_expr(inner.next().ok_or(ParseError::Missing("or left"))?)?;

    for right_pair in inner {
        let right = build_expr(right_pair)?;
        left = Expr::Or(Box::new(left), Box::new(right));
    }

    Ok(left)
}

fn build_and_expr(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    let mut inner = pair.into_inner();
    let mut left = build_expr(inner.next().ok_or(ParseError::Missing("and left"))?)?;

    for right_pair in inner {
        let right = build_expr(right_pair)?;
        left = Expr::And(Box::new(left), Box::new(right));
    }

    Ok(left)
}

fn build_not_expr(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    let mut inner = pair.into_inner();
    let first = inner.next().ok_or(ParseError::Missing("not expr"))?;

    // Check if this is just forwarding to additive_expr (not comparison_expr - grammar changed)
    if first.as_rule() == Rule::additive_expr {
        return build_expr(first);
    }

    // Otherwise it's a "not" expression (the inner is the operand)
    let operand = build_expr(first)?;
    Ok(Expr::Not(Box::new(operand)))
}

fn build_comparison_expr(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    let mut inner = pair.into_inner();
    let left = build_expr(inner.next().ok_or(ParseError::Missing("comparison left"))?)?;

    if let Some(op_pair) = inner.next() {
        let op = parse_cmp_op(op_pair.as_str())?;
        let right = build_expr(
            inner
                .next()
                .ok_or(ParseError::Missing("comparison right"))?,
        )?;
        Ok(Expr::Compare(Box::new(left), op, Box::new(right)))
    } else {
        Ok(left)
    }
}

fn parse_cmp_op(s: &str) -> Result<ComparisonOp, ParseError> {
    match s {
        "==" => Ok(ComparisonOp::Eq),
        "!=" => Ok(ComparisonOp::Ne),
        "<" => Ok(ComparisonOp::Lt),
        "<=" => Ok(ComparisonOp::Le),
        ">" => Ok(ComparisonOp::Gt),
        ">=" => Ok(ComparisonOp::Ge),
        _ => Err(ParseError::Missing("valid comparison operator")),
    }
}

fn build_additive_expr(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    let mut inner = pair.into_inner();
    let mut left = build_expr(inner.next().ok_or(ParseError::Missing("additive left"))?)?;

    while let Some(op_pair) = inner.next() {
        if op_pair.as_rule() == Rule::add_op {
            let op = match op_pair.as_str() {
                "-" => BinaryOp::Sub,
                // "+" and any other operator default to Add
                _ => BinaryOp::Add,
            };
            let right = build_expr(inner.next().ok_or(ParseError::Missing("additive right"))?)?;
            left = Expr::Binary(Box::new(left), op, Box::new(right));
        } else {
            let right = build_expr(op_pair)?;
            left = Expr::Binary(Box::new(left), BinaryOp::Add, Box::new(right));
        }
    }

    Ok(left)
}

fn build_multiplicative_expr(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    let mut inner = pair.into_inner();
    let mut left = build_expr(inner.next().ok_or(ParseError::Missing("mult left"))?)?;

    while let Some(op_pair) = inner.next() {
        if op_pair.as_rule() == Rule::mul_op {
            let op = match op_pair.as_str() {
                "/" => BinaryOp::Div,
                "%" => BinaryOp::Mod,
                // "*" and any other operator default to Mul
                _ => BinaryOp::Mul,
            };
            let right = build_expr(inner.next().ok_or(ParseError::Missing("mult right"))?)?;
            left = Expr::Binary(Box::new(left), op, Box::new(right));
        } else {
            let right = build_expr(op_pair)?;
            left = Expr::Binary(Box::new(left), BinaryOp::Mul, Box::new(right));
        }
    }

    Ok(left)
}

fn build_unary_expr(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    let mut inner = pair.into_inner();
    let first = inner.next().ok_or(ParseError::Missing("unary expr"))?;

    match first.as_rule() {
        Rule::neg_op => {
            let operand = build_expr(inner.next().ok_or(ParseError::Missing("unary operand"))?)?;
            Ok(Expr::Neg(Box::new(operand)))
        }
        // Atoms and other expressions are handled by build_expr
        _ => build_expr(first),
    }
}

fn build_atom(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    let inner = pair
        .into_inner()
        .next()
        .ok_or(ParseError::Missing("atom"))?;

    match inner.as_rule() {
        Rule::quantified_expr => build_quantified_expr(inner),
        Rule::number => build_number(&inner),
        Rule::string => Ok(build_string(&inner)),
        Rule::bool_lit => Ok(Expr::Bool(inner.as_str() == "true")),
        Rule::access_expr => build_access_expr(inner),
        Rule::expr => build_expr(inner),
        _ => Err(ParseError::UnexpectedRule {
            expected: "atom",
            found: inner.as_rule(),
        }),
    }
}

fn build_binding_collection(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    let inner = pair
        .into_inner()
        .next()
        .ok_or(ParseError::Missing("binding collection"))?;

    match inner.as_rule() {
        Rule::ident => Ok(Expr::Var(inner.as_str().to_string())),
        Rule::expr => build_expr(inner),
        _ => Err(ParseError::UnexpectedRule {
            expected: "binding collection",
            found: inner.as_rule(),
        }),
    }
}

fn build_access_expr(pair: Pair<Rule>) -> Result<Expr, ParseError> {
    let mut inner = pair.into_inner();

    let base_name = inner
        .next()
        .ok_or(ParseError::Missing("access base"))?
        .as_str()
        .to_string();
    let mut result = Expr::Var(base_name);

    // Process accessors (accessor is silent, so we see call_accessor or field_accessor directly)
    for accessor in inner {
        match accessor.as_rule() {
            Rule::call_accessor => {
                // Function/method call
                let arg_list = accessor
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("arg list"))?;
                let args: Result<Vec<Expr>, _> = arg_list.into_inner().map(build_expr).collect();

                // If result is a simple Var, convert to App
                match result {
                    Expr::Var(name) => {
                        result = Expr::App(name, args?);
                    }
                    Expr::FieldAccess(receiver, method) => {
                        result = Expr::MethodCall {
                            receiver,
                            method,
                            args: args?,
                        };
                    }
                    _ => {
                        result = Expr::MethodCall {
                            receiver: Box::new(result),
                            method: "apply".to_string(),
                            args: args?,
                        };
                    }
                }
            }
            Rule::field_accessor => {
                // Field access
                let field_name = accessor
                    .into_inner()
                    .next()
                    .ok_or(ParseError::Missing("field name"))?
                    .as_str()
                    .to_string();
                result = Expr::FieldAccess(Box::new(result), field_name);
            }
            _ => {}
        }
    }

    Ok(result)
}

fn build_number(pair: &Pair<Rule>) -> Result<Expr, ParseError> {
    let s = pair.as_str();
    if s.contains('.') {
        let f = s
            .parse::<f64>()
            .map_err(|_| ParseError::InvalidNumber(s.to_string()))?;
        Ok(Expr::Float(f))
    } else {
        let i = s
            .parse::<i64>()
            .map_err(|_| ParseError::InvalidNumber(s.to_string()))?;
        Ok(Expr::Int(i))
    }
}

fn build_string(pair: &Pair<Rule>) -> Expr {
    let s = pair.as_str();
    // Remove quotes
    let content = &s[1..s.len() - 1];
    Expr::String(content.to_string())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_simple_theorem() {
        let source = r#"
            theorem simple {
                forall x: Int . x == x
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Theorem(t) => {
                assert_eq!(t.name, "simple");
            }
            _ => panic!("expected theorem"),
        }
    }

    #[test]
    fn test_parse_theorem_with_implies() {
        let source = r#"
            theorem acyclic_terminates {
                forall g: Graph, s: State .
                    acyclic(g) implies
                    exists s': State . executes(g, s, s') and is_terminal(s')
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Theorem(t) => {
                assert_eq!(t.name, "acyclic_terminates");
            }
            _ => panic!("expected theorem"),
        }
    }

    #[test]
    fn test_parse_temporal() {
        // Note: for "in" bindings, field access must be parenthesized: (g.nodes)
        let source = r#"
            temporal no_deadlock {
                always(exists agent in agents . enabled(agent))
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Temporal(t) => {
                assert_eq!(t.name, "no_deadlock");
                assert!(t.fairness.is_empty(), "no fairness constraints");
                match &t.body {
                    TemporalExpr::Always(_) => {}
                    _ => panic!("expected always"),
                }
            }
            _ => panic!("expected temporal"),
        }
    }

    #[test]
    fn test_parse_temporal_with_weak_fairness() {
        let source = r#"
            temporal eventually_served {
                fair weak Next
                eventually(served)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Temporal(t) => {
                assert_eq!(t.name, "eventually_served");
                assert_eq!(t.fairness.len(), 1);
                assert_eq!(t.fairness[0].kind, FairnessKind::Weak);
                assert_eq!(t.fairness[0].action, "Next");
                assert!(t.fairness[0].vars.is_none());
                match &t.body {
                    TemporalExpr::Eventually(_) => {}
                    _ => panic!("expected eventually"),
                }
            }
            _ => panic!("expected temporal"),
        }
    }

    #[test]
    fn test_parse_temporal_with_strong_fairness() {
        let source = r#"
            temporal no_starvation {
                fair strong Acquire
                always(eventually(released))
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Temporal(t) => {
                assert_eq!(t.name, "no_starvation");
                assert_eq!(t.fairness.len(), 1);
                assert_eq!(t.fairness[0].kind, FairnessKind::Strong);
                assert_eq!(t.fairness[0].action, "Acquire");
                match &t.body {
                    TemporalExpr::Always(inner) => match inner.as_ref() {
                        TemporalExpr::Eventually(_) => {}
                        _ => panic!("expected eventually inside always"),
                    },
                    _ => panic!("expected always"),
                }
            }
            _ => panic!("expected temporal"),
        }
    }

    #[test]
    fn test_parse_temporal_with_multiple_fairness() {
        let source = r#"
            temporal termination {
                fair weak Next
                fair strong Acquire
                eventually(done)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Temporal(t) => {
                assert_eq!(t.name, "termination");
                assert_eq!(t.fairness.len(), 2);
                assert_eq!(t.fairness[0].kind, FairnessKind::Weak);
                assert_eq!(t.fairness[0].action, "Next");
                assert_eq!(t.fairness[1].kind, FairnessKind::Strong);
                assert_eq!(t.fairness[1].action, "Acquire");
            }
            _ => panic!("expected temporal"),
        }
    }

    #[test]
    fn test_parse_temporal_with_fairness_vars() {
        let source = r#"
            temporal bounded_wait {
                fair weak Next on state
                eventually(done)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Temporal(t) => {
                assert_eq!(t.fairness.len(), 1);
                assert_eq!(t.fairness[0].kind, FairnessKind::Weak);
                assert_eq!(t.fairness[0].action, "Next");
                assert_eq!(t.fairness[0].vars, Some("state".to_string()));
            }
            _ => panic!("expected temporal"),
        }
    }

    #[test]
    fn test_parse_contract() {
        let source = r#"
            contract Graph::add_node(self: Graph, node: Node) -> Result<()> {
                requires { not self.contains(node.id) }
                ensures { self'.contains(node.id) }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Contract(c) => {
                assert_eq!(c.type_path, vec!["Graph", "add_node"]);
                assert_eq!(c.params.len(), 2);
                assert_eq!(c.requires.len(), 1);
                assert_eq!(c.ensures.len(), 1);
            }
            _ => panic!("expected contract"),
        }
    }

    #[test]
    fn test_parse_invariant() {
        // Note: for "in" bindings with field access, use parentheses: (g.nodes)
        let source = r#"
            invariant graph_connectivity {
                forall g: Graph . forall n in (g.nodes) .
                    reachable(g.entry, n, g.edges) or n == g.entry
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Invariant(i) => {
                assert_eq!(i.name, "graph_connectivity");
            }
            _ => panic!("expected invariant"),
        }
    }

    #[test]
    fn test_parse_type_def() {
        let source = r#"
            type Node = { id: String, execute: State -> Result<State> }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.types.len(), 1);
        assert_eq!(spec.types[0].name, "Node");
        assert_eq!(spec.types[0].fields.len(), 2);
        assert_eq!(spec.types[0].fields[0].name, "id");
        assert_eq!(spec.types[0].fields[1].name, "execute");
    }

    #[test]
    fn test_parse_refinement() {
        let source = r#"
            refinement optimized_graph refines graph_spec {
                abstraction {
                    to_graph(og) == g
                }
                simulation {
                    forall og: OptimizedGraph, action: Action .
                        step(to_graph(og), action) == to_graph(step(og, action))
                }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Refinement(r) => {
                assert_eq!(r.name, "optimized_graph");
                assert_eq!(r.refines, "graph_spec");
                assert!(r.mappings.is_empty(), "no variable mappings");
                assert!(r.invariants.is_empty(), "no invariants");
                assert!(r.actions.is_empty(), "no action mappings");
            }
            _ => panic!("expected refinement"),
        }
    }

    #[test]
    fn test_parse_refinement_with_mappings() {
        let source = r#"
            refinement stream_pool_impl refines stream_pool_spec {
                mapping {
                    spec.streams <-> impl.m_streams
                    spec.bindings <-> impl.thread_local_slots
                }
                abstraction {
                    to_abstract(impl) == spec
                }
                simulation {
                    forall impl: Impl, action: Action .
                        step(to_abstract(impl), action) == to_abstract(step(impl, action))
                }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Refinement(r) => {
                assert_eq!(r.name, "stream_pool_impl");
                assert_eq!(r.refines, "stream_pool_spec");
                assert_eq!(r.mappings.len(), 2);
                // First mapping: spec.streams <-> impl.m_streams
                match &r.mappings[0].spec_var {
                    Expr::FieldAccess(_, field) => assert_eq!(field, "streams"),
                    _ => panic!("expected field access for spec_var"),
                }
                match &r.mappings[0].impl_var {
                    Expr::FieldAccess(_, field) => assert_eq!(field, "m_streams"),
                    _ => panic!("expected field access for impl_var"),
                }
            }
            _ => panic!("expected refinement"),
        }
    }

    #[test]
    fn test_parse_refinement_with_invariants() {
        let source = r#"
            refinement impl_refines_spec refines spec {
                invariant { size == MAX_SIZE }
                invariant { count > 0 }
                abstraction {
                    abstract_fn(impl)
                }
                simulation {
                    sim_relation(impl, spec)
                }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Refinement(r) => {
                assert_eq!(r.name, "impl_refines_spec");
                assert_eq!(r.invariants.len(), 2);
            }
            _ => panic!("expected refinement"),
        }
    }

    #[test]
    fn test_parse_refinement_with_action_mappings() {
        let source = r#"
            refinement stream_impl refines stream_spec {
                abstraction {
                    to_abstract(impl)
                }
                simulation {
                    sim(impl, spec)
                }
                action acquire_stream {
                    spec: AcquireStream
                    impl: MPSStreamPool::acquireStream()
                }
                action release_stream {
                    spec: ReleaseStream
                    impl: MPSStreamPool::releaseStream()
                    guard { stream.is_acquired }
                }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Refinement(r) => {
                assert_eq!(r.actions.len(), 2);
                // First action
                assert_eq!(r.actions[0].name, "acquire_stream");
                assert_eq!(r.actions[0].spec_action, "AcquireStream");
                assert_eq!(
                    r.actions[0].impl_action,
                    vec!["MPSStreamPool", "acquireStream"]
                );
                assert!(r.actions[0].guard.is_none());
                // Second action
                assert_eq!(r.actions[1].name, "release_stream");
                assert_eq!(r.actions[1].spec_action, "ReleaseStream");
                assert!(r.actions[1].guard.is_some());
            }
            _ => panic!("expected refinement"),
        }
    }

    #[test]
    fn test_parse_refinement_full() {
        let source = r#"
            refinement complete_impl refines complete_spec {
                mapping {
                    spec.state <-> impl.internal_state
                }
                invariant { impl.internal_state.valid }
                abstraction {
                    to_abstract(impl) == spec
                }
                simulation {
                    forall i: Impl, a: Action .
                        step(to_abstract(i), a) == to_abstract(step(i, a))
                }
                action do_work {
                    spec: DoWork
                    impl: Worker::doWork()
                }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Refinement(r) => {
                assert_eq!(r.name, "complete_impl");
                assert_eq!(r.refines, "complete_spec");
                assert_eq!(r.mappings.len(), 1);
                assert_eq!(r.invariants.len(), 1);
                assert_eq!(r.actions.len(), 1);
            }
            _ => panic!("expected refinement"),
        }
    }

    #[test]
    fn test_parse_probabilistic() {
        let source = r#"
            probabilistic response_bound {
                probability(response_time < 100) >= 0.99
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Probabilistic(p) => {
                assert_eq!(p.name, "response_bound");
                assert_eq!(p.comparison, ComparisonOp::Ge);
                assert!((p.bound - 0.99).abs() < 0.001);
            }
            _ => panic!("expected probabilistic"),
        }
    }

    #[test]
    fn test_parse_semantic_property() {
        let source = r#"
            semantic_property output_helpful {
                forall response: Response, query: Query .
                    addresses_question(response, query) and
                    semantic_similarity(response, expected) >= 0.8
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Semantic(prop) => {
                assert_eq!(prop.name, "output_helpful");
            }
            _ => panic!("expected semantic_property"),
        }
    }

    #[test]
    fn test_parse_multiple_items() {
        let source = r#"
            type State = { value: Int }

            theorem simple { forall x: Int . x == x }

            invariant positive { forall s: State . s.value >= 0 }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.types.len(), 1);
        assert_eq!(spec.properties.len(), 2);
    }

    #[test]
    fn test_parse_field_access() {
        let source = r#"
            theorem field_test {
                forall g: Graph . g.nodes.len() > 0
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
    }

    #[test]
    fn test_parse_complex_type() {
        let source = r#"
            type Graph = {
                nodes: Set<Node>,
                edges: Relation<Node, Node>,
                data: Map<String, List<Int>>
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.types.len(), 1);
        assert_eq!(spec.types[0].fields.len(), 3);

        match &spec.types[0].fields[0].ty {
            Type::Set(_) => {}
            _ => panic!("expected Set type"),
        }
        match &spec.types[0].fields[1].ty {
            Type::Relation(_, _) => {}
            _ => panic!("expected Relation type"),
        }
        match &spec.types[0].fields[2].ty {
            Type::Map(_, _) => {}
            _ => panic!("expected Map type"),
        }
    }

    #[test]
    fn test_parse_graph_and_path_types() {
        // Test Graph<N, E> type for DashFlow execution graphs
        let source = r#"
            type ExecutionState = {
                graph: Graph<TaskNode, Dependency>,
                current_path: Path<TaskNode>,
                completed: Set<TaskNode>
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.types.len(), 1);
        assert_eq!(spec.types[0].name, "ExecutionState");
        assert_eq!(spec.types[0].fields.len(), 3);

        // Check Graph type
        match &spec.types[0].fields[0].ty {
            Type::Graph(node_type, edge_type) => {
                match node_type.as_ref() {
                    Type::Named(name) => assert_eq!(name, "TaskNode"),
                    _ => panic!("expected Named node type"),
                }
                match edge_type.as_ref() {
                    Type::Named(name) => assert_eq!(name, "Dependency"),
                    _ => panic!("expected Named edge type"),
                }
            }
            _ => panic!("expected Graph type"),
        }

        // Check Path type
        match &spec.types[0].fields[1].ty {
            Type::Path(inner) => match inner.as_ref() {
                Type::Named(name) => assert_eq!(name, "TaskNode"),
                _ => panic!("expected Named inner type"),
            },
            _ => panic!("expected Path type"),
        }

        // Check Set type still works
        match &spec.types[0].fields[2].ty {
            Type::Set(_) => {}
            _ => panic!("expected Set type"),
        }
    }

    #[test]
    fn test_parse_nested_graph_types() {
        // Test Graph with complex nested types
        let source = r#"
            type ComplexGraph = {
                nested_graph: Graph<Graph<Int, String>, Map<String, Int>>
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.types.len(), 1);

        match &spec.types[0].fields[0].ty {
            Type::Graph(node_type, edge_type) => {
                // Node type is Graph<Int, String>
                match node_type.as_ref() {
                    Type::Graph(inner_n, inner_e) => {
                        assert!(matches!(inner_n.as_ref(), Type::Named(n) if n == "Int"));
                        assert!(matches!(inner_e.as_ref(), Type::Named(n) if n == "String"));
                    }
                    _ => panic!("expected nested Graph type"),
                }
                // Edge type is Map<String, Int>
                match edge_type.as_ref() {
                    Type::Map(k, v) => {
                        assert!(matches!(k.as_ref(), Type::Named(n) if n == "String"));
                        assert!(matches!(v.as_ref(), Type::Named(n) if n == "Int"));
                    }
                    _ => panic!("expected Map type"),
                }
            }
            _ => panic!("expected Graph type"),
        }
    }

    #[test]
    fn test_parse_platform_api_simple() {
        let source = r#"
            platform_api Metal {
                state MTLCommandBuffer {
                    enum Status { Created, Encoding, Committed, Completed }

                    transition commit() {
                        requires { status == Created or status == Encoding }
                        ensures { status == Committed }
                    }
                }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::PlatformApi(api) => {
                assert_eq!(api.name, "Metal");
                assert_eq!(api.states.len(), 1);
                assert_eq!(api.states[0].name, "MTLCommandBuffer");

                // Check enum
                let status_enum = api.states[0].status_enum.as_ref().expect("expected enum");
                assert_eq!(status_enum.name, "Status");
                assert_eq!(
                    status_enum.variants,
                    vec!["Created", "Encoding", "Committed", "Completed"]
                );

                // Check transition
                assert_eq!(api.states[0].transitions.len(), 1);
                assert_eq!(api.states[0].transitions[0].name, "commit");
                assert!(api.states[0].transitions[0].params.is_empty());
                assert_eq!(api.states[0].transitions[0].requires.len(), 1);
                assert_eq!(api.states[0].transitions[0].ensures.len(), 1);
            }
            _ => panic!("expected platform_api"),
        }
    }

    #[test]
    fn test_parse_platform_api_with_params() {
        let source = r#"
            platform_api Metal {
                state MTLCommandBuffer {
                    transition addCompletedHandler(block: Block) {
                        requires { status == Created or status == Encoding }
                    }
                }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::PlatformApi(api) => {
                assert_eq!(api.states[0].transitions.len(), 1);
                let t = &api.states[0].transitions[0];
                assert_eq!(t.name, "addCompletedHandler");
                assert_eq!(t.params.len(), 1);
                assert_eq!(t.params[0].name, "block");
                match &t.params[0].ty {
                    Type::Named(name) => assert_eq!(name, "Block"),
                    _ => panic!("expected named type"),
                }
            }
            _ => panic!("expected platform_api"),
        }
    }

    #[test]
    fn test_parse_platform_api_multiple_states() {
        let source = r#"
            platform_api CUDA {
                state CUstream {
                    enum Status { Created, Running, Synchronized }

                    transition synchronize() {
                        ensures { status == Synchronized }
                    }
                }

                state CUevent {
                    enum Status { Created, Recorded, Synced }

                    transition record(stream: CUstream) {
                        requires { status == Created }
                        ensures { status == Recorded }
                    }

                    transition synchronize() {
                        requires { status == Recorded }
                        ensures { status == Synced }
                    }
                }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::PlatformApi(api) => {
                assert_eq!(api.name, "CUDA");
                assert_eq!(api.states.len(), 2);
                assert_eq!(api.states[0].name, "CUstream");
                assert_eq!(api.states[1].name, "CUevent");
                assert_eq!(api.states[1].transitions.len(), 2);
            }
            _ => panic!("expected platform_api"),
        }
    }

    #[test]
    fn test_parse_platform_api_with_invariants() {
        let source = r#"
            platform_api Metal {
                state MTLBuffer {
                    enum Status { Allocated, Mapped, Unmapped }

                    transition map() {
                        requires { status == Allocated or status == Unmapped }
                        ensures { status == Mapped }
                    }

                    invariant { length > 0 }
                }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::PlatformApi(api) => {
                assert_eq!(api.states[0].invariants.len(), 1);
            }
            _ => panic!("expected platform_api"),
        }
    }

    #[test]
    fn test_parse_platform_api_empty() {
        let source = r#"
            platform_api Empty {
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::PlatformApi(api) => {
                assert_eq!(api.name, "Empty");
                assert!(api.states.is_empty());
            }
            _ => panic!("expected platform_api"),
        }
    }

    #[test]
    fn test_parse_platform_api_no_enum() {
        let source = r#"
            platform_api POSIX {
                state FileDescriptor {
                    transition close() {
                        requires { fd >= 0 }
                    }
                }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::PlatformApi(api) => {
                assert!(api.states[0].status_enum.is_none());
                assert_eq!(api.states[0].transitions.len(), 1);
            }
            _ => panic!("expected platform_api"),
        }
    }

    #[test]
    fn test_parse_bisimulation_simple() {
        let source = r#"
            bisimulation ClaudeCodeParity {
                oracle: "./claude-code"
                subject: "./claude-code-rs"
                equivalent on { api_requests, tool_calls, output }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Bisimulation(b) => {
                assert_eq!(b.name, "ClaudeCodeParity");
                assert_eq!(b.oracle, "./claude-code");
                assert_eq!(b.subject, "./claude-code-rs");
                assert_eq!(b.equivalent_on.len(), 3);
                assert!(b.equivalent_on.contains(&"api_requests".to_string()));
                assert!(b.tolerance.is_none());
                assert!(b.property.is_none());
            }
            _ => panic!("expected bisimulation"),
        }
    }

    #[test]
    fn test_parse_bisimulation_with_tolerance() {
        let source = r#"
            bisimulation AgentParity {
                oracle: "./reference"
                subject: "./test"
                equivalent on { output }
                tolerance { timing: 0.1, semantic: 0.95 }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Bisimulation(b) => {
                assert_eq!(b.name, "AgentParity");
                let tol = b.tolerance.as_ref().expect("expected tolerance");
                assert_eq!(tol.timing, Some(0.1));
                assert_eq!(tol.semantic, Some(0.95));
            }
            _ => panic!("expected bisimulation"),
        }
    }

    #[test]
    fn test_parse_bisimulation_with_property() {
        let source = r#"
            bisimulation FullParity {
                oracle: "./oracle"
                subject: "./subject"
                equivalent on { api_requests }
                forall input: TestInput . traces_equivalent(oracle(input), subject(input))
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Bisimulation(b) => {
                assert_eq!(b.name, "FullParity");
                let prop = b.property.as_ref().expect("expected property");
                assert_eq!(prop.var_name, "input");
            }
            _ => panic!("expected bisimulation"),
        }
    }

    // =========================================================================
    // Mutation-killing tests for expression parsing
    // These tests target specific match arms that were missed by mutation testing
    // =========================================================================

    #[test]
    fn test_parse_bool_literal_true() {
        // Tests bool_lit parsing in build_atom (true/false discrimination)
        let source = r#"theorem bool_test { true }"#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Theorem(t) => match &t.body {
                Expr::Bool(val) => assert!(*val, "true should parse as true"),
                other => panic!("expected Bool, got {:?}", other),
            },
            _ => panic!("expected theorem"),
        }
    }

    #[test]
    fn test_parse_bool_literal_false() {
        // Tests bool_lit parsing in build_atom (true/false discrimination)
        let source = r#"theorem bool_test { false }"#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Theorem(t) => match &t.body {
                Expr::Bool(val) => assert!(!*val, "false should parse as false"),
                other => panic!("expected Bool, got {:?}", other),
            },
            _ => panic!("expected theorem"),
        }
    }

    #[test]
    fn test_parse_number_literal() {
        // Tests number parsing in build_atom
        let source = r#"theorem num_test { 42 > 0 }"#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Theorem(t) => match &t.body {
                Expr::Compare(lhs, _, _) => match lhs.as_ref() {
                    Expr::Int(n) => assert_eq!(*n, 42),
                    other => panic!("expected Int, got {:?}", other),
                },
                other => panic!("expected Compare, got {:?}", other),
            },
            _ => panic!("expected theorem"),
        }
    }

    #[test]
    fn test_parse_string_literal_direct() {
        // Tests string parsing in build_atom
        let source = r#"theorem str_test { "hello" == "hello" }"#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Theorem(t) => match &t.body {
                Expr::Compare(lhs, _, _) => match lhs.as_ref() {
                    Expr::String(s) => assert_eq!(s, "hello"),
                    other => panic!("expected String, got {:?}", other),
                },
                other => panic!("expected Compare, got {:?}", other),
            },
            _ => panic!("expected theorem"),
        }
    }

    #[test]
    fn test_parse_ident_in_expr() {
        // Tests identifier parsing in access_expr
        let source = r#"theorem ident_test { x > 0 }"#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Theorem(t) => match &t.body {
                Expr::Compare(lhs, _, _) => match lhs.as_ref() {
                    Expr::Var(name) => assert_eq!(name, "x"),
                    other => panic!("expected Var, got {:?}", other),
                },
                other => panic!("expected Compare, got {:?}", other),
            },
            _ => panic!("expected theorem"),
        }
    }

    #[test]
    fn test_parse_quantified_expr() {
        // Tests quantified expression parsing in build_atom
        let source = r#"theorem quant_test { forall x: Int . x == x }"#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Theorem(t) => match &t.body {
                Expr::ForAll { var, .. } => assert_eq!(var, "x"),
                other => panic!("expected ForAll, got {:?}", other),
            },
            _ => panic!("expected theorem"),
        }
    }

    #[test]
    fn test_parse_atom_access_expr() {
        // Tests field access parsing via access_expr in build_atom
        let source = r#"theorem access_test { obj.field == 0 }"#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Theorem(t) => match &t.body {
                Expr::Compare(lhs, _, _) => match lhs.as_ref() {
                    Expr::FieldAccess(_, field) => assert_eq!(field, "field"),
                    other => panic!("expected FieldAccess, got {:?}", other),
                },
                other => panic!("expected Compare, got {:?}", other),
            },
            _ => panic!("expected theorem"),
        }
    }

    #[test]
    fn test_parse_negation_expr() {
        // Tests negation operator parsing in build_unary_expr
        let source = r#"theorem neg_test { -x > 0 }"#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Theorem(t) => match &t.body {
                Expr::Compare(lhs, _, _) => match lhs.as_ref() {
                    Expr::Neg(inner) => match inner.as_ref() {
                        Expr::Var(name) => assert_eq!(name, "x"),
                        other => panic!("expected Var(x), got {:?}", other),
                    },
                    other => panic!("expected Neg, got {:?}", other),
                },
                other => panic!("expected Compare, got {:?}", other),
            },
            _ => panic!("expected theorem"),
        }
    }

    #[test]
    fn test_parse_atom_in_unary() {
        // Tests atom parsing via build_unary_expr (non-negated expression)
        let source = r#"theorem atom_test { x }"#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Theorem(t) => match &t.body {
                Expr::Var(name) => assert_eq!(name, "x"),
                other => panic!("expected Var, got {:?}", other),
            },
            _ => panic!("expected theorem"),
        }
    }

    #[test]
    fn test_parse_method_call_in_access() {
        // Tests chained method call parsing in build_access_expr
        let source = r#"theorem method_test { obj.method().result > 0 }"#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Theorem(t) => {
                match &t.body {
                    Expr::Compare(lhs, _, _) => {
                        // Should be a chained field access: (obj.method()).result
                        match lhs.as_ref() {
                            Expr::FieldAccess(inner, field) => {
                                assert_eq!(field, "result");
                                // inner should be a method call
                                match inner.as_ref() {
                                    Expr::MethodCall {
                                        receiver,
                                        method,
                                        args,
                                    } => {
                                        assert_eq!(method, "method");
                                        assert!(args.is_empty());
                                        match receiver.as_ref() {
                                            Expr::Var(name) => assert_eq!(name, "obj"),
                                            other => panic!("expected Var(obj), got {:?}", other),
                                        }
                                    }
                                    other => panic!("expected MethodCall, got {:?}", other),
                                }
                            }
                            other => panic!("expected FieldAccess, got {:?}", other),
                        }
                    }
                    other => panic!("expected Compare, got {:?}", other),
                }
            }
            _ => panic!("expected theorem"),
        }
    }

    #[test]
    fn test_parse_temporal_always_mutation() {
        // Tests temporal_always parsing in build_temporal_expr
        let source = r#"
            temporal always_test {
                always(invariant_holds)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Temporal(t) => match &t.body {
                TemporalExpr::Always(inner) => match inner.as_ref() {
                    TemporalExpr::Atom(expr) => match expr {
                        Expr::Var(name) => assert_eq!(name, "invariant_holds"),
                        other => panic!("expected Var, got {:?}", other),
                    },
                    other => panic!("expected Atom, got {:?}", other),
                },
                other => panic!("expected Always, got {:?}", other),
            },
            _ => panic!("expected temporal"),
        }
    }

    #[test]
    fn test_parse_temporal_eventually_mutation() {
        // Tests temporal_eventually parsing in build_temporal_expr
        let source = r#"
            temporal eventually_test {
                eventually(goal_reached)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Temporal(t) => match &t.body {
                TemporalExpr::Eventually(inner) => match inner.as_ref() {
                    TemporalExpr::Atom(expr) => match expr {
                        Expr::Var(name) => assert_eq!(name, "goal_reached"),
                        other => panic!("expected Var, got {:?}", other),
                    },
                    other => panic!("expected Atom, got {:?}", other),
                },
                other => panic!("expected Eventually, got {:?}", other),
            },
            _ => panic!("expected temporal"),
        }
    }

    #[test]
    fn test_parse_temporal_leads_to() {
        // Tests temporal_binary parsing (leads-to operator) in build_temporal_expr
        let source = r#"
            temporal leads_to_test {
                request ~> response
            }
        "#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Temporal(t) => {
                match &t.body {
                    TemporalExpr::LeadsTo(lhs, rhs) => {
                        // Verify both sides are atoms
                        match (lhs.as_ref(), rhs.as_ref()) {
                            (
                                TemporalExpr::Atom(Expr::Var(l)),
                                TemporalExpr::Atom(Expr::Var(r)),
                            ) => {
                                assert_eq!(l, "request");
                                assert_eq!(r, "response");
                            }
                            other => panic!("expected Atom vars, got {:?}", other),
                        }
                    }
                    other => panic!("expected LeadsTo, got {:?}", other),
                }
            }
            _ => panic!("expected temporal"),
        }
    }

    #[test]
    fn test_parse_temporal_paren() {
        // Tests parenthesized temporal expression parsing in build_temporal_expr
        let source = r#"
            temporal paren_test {
                (always(stable)) ~> eventually(done)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Temporal(t) => {
                // The outer expr should be a LeadsTo
                match &t.body {
                    TemporalExpr::LeadsTo(lhs, _) => {
                        // lhs is the parenthesized always
                        match lhs.as_ref() {
                            TemporalExpr::Always(_) => {}
                            other => panic!("expected Always inside parens, got {:?}", other),
                        }
                    }
                    other => panic!("expected LeadsTo, got {:?}", other),
                }
            }
            _ => panic!("expected temporal"),
        }
    }

    #[test]
    fn test_parse_type_named() {
        // Tests that custom type names are correctly parsed via type_named rule
        let source = r#"
            type MyType = { field: CustomType }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.types.len(), 1);
        match &spec.types[0].fields[0].ty {
            Type::Named(name) => assert_eq!(name, "CustomType"),
            other => panic!("expected Named type, got {:?}", other),
        }
    }

    #[test]
    fn test_parse_string_literal_mutation_killer() {
        // This test ensures parse_string_literal requires BOTH quotes
        // to strip them (tests && vs || mutation on line 917)

        // Valid quoted string - should strip quotes
        assert_eq!(parse_string_literal(r#""hello""#), "hello");

        // Only starting quote - should return unchanged (the && condition fails)
        assert_eq!(parse_string_literal(r#""hello"#), r#""hello"#);

        // Only ending quote - should return unchanged
        assert_eq!(parse_string_literal(r#"hello""#), r#"hello""#);

        // No quotes - should return unchanged
        assert_eq!(parse_string_literal("hello"), "hello");

        // Empty quoted string
        assert_eq!(parse_string_literal(r#""""#), "");

        // Single char in quotes
        assert_eq!(parse_string_literal(r#""x""#), "x");
    }

    // ========== Phase 17.6: Self-Improvement Verification Loop Tests ==========

    #[test]
    fn test_parse_improvement_proposal_basic() {
        let source = r#"
            improvement_proposal CodeOptimization {
                target { Dasher.verify_rust_code }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::ImprovementProposal(p) => {
                assert_eq!(p.name, "CodeOptimization");
            }
            _ => panic!("expected improvement proposal"),
        }
    }

    #[test]
    fn test_parse_improvement_proposal_with_improves() {
        let source = r#"
            improvement_proposal SpeedImprovement {
                target { Dasher.verify }
                improves { speed >= baseline }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::ImprovementProposal(p) => {
                assert_eq!(p.name, "SpeedImprovement");
                assert_eq!(p.improves.len(), 1);
            }
            _ => panic!("expected improvement proposal"),
        }
    }

    #[test]
    fn test_parse_improvement_proposal_with_preserves() {
        let source = r#"
            improvement_proposal SafeUpgrade {
                target { Dasher.self_modify }
                preserves { soundness }
                preserves { completeness }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::ImprovementProposal(p) => {
                assert_eq!(p.preserves.len(), 2);
            }
            _ => panic!("expected improvement proposal"),
        }
    }

    #[test]
    fn test_parse_improvement_proposal_full() {
        let source = r#"
            improvement_proposal FullProposal {
                target { Dasher.verify_code }
                improves { speed >= 1.1 * baseline }
                improves { accuracy >= baseline }
                preserves { soundness }
                requires { valid_syntax(code) }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::ImprovementProposal(p) => {
                assert_eq!(p.name, "FullProposal");
                assert_eq!(p.improves.len(), 2);
                assert_eq!(p.preserves.len(), 1);
                assert_eq!(p.requires.len(), 1);
            }
            _ => panic!("expected improvement proposal"),
        }
    }

    #[test]
    fn test_parse_verification_gate_basic() {
        let source = r#"
            verification_gate SimpleGate {
                inputs { current: DasherVersion, proposed: Improvement }
                checks {
                    check soundness { verify_soundness(current, proposed) }
                }
                on_pass { apply(proposed) }
                on_fail { reject(proposed) }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::VerificationGate(g) => {
                assert_eq!(g.name, "SimpleGate");
                assert_eq!(g.inputs.len(), 2);
                assert_eq!(g.checks.len(), 1);
                assert_eq!(g.checks[0].name, "soundness");
            }
            _ => panic!("expected verification gate"),
        }
    }

    #[test]
    fn test_parse_verification_gate_multiple_checks() {
        let source = r#"
            verification_gate MultiCheckGate {
                inputs { v: Version }
                checks {
                    check soundness { sound(v) }
                    check complete { complete(v) }
                    check terminating { terminates(v) }
                }
                on_pass { accept(v) }
                on_fail { reject_with_error(v) }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::VerificationGate(g) => {
                assert_eq!(g.checks.len(), 3);
                assert_eq!(g.checks[0].name, "soundness");
                assert_eq!(g.checks[1].name, "complete");
                assert_eq!(g.checks[2].name, "terminating");
            }
            _ => panic!("expected verification gate"),
        }
    }

    #[test]
    fn test_parse_rollback_spec_basic() {
        let source = r#"
            rollback_spec SafeRollback {
                state { current: Version }
                trigger { verification_failed }
                action {
                    ensure { verified(current) }
                }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Rollback(r) => {
                assert_eq!(r.name, "SafeRollback");
                assert_eq!(r.state.len(), 1);
            }
            _ => panic!("expected rollback spec"),
        }
    }

    #[test]
    fn test_parse_rollback_spec_with_invariants() {
        let source = r#"
            rollback_spec InvariantRollback {
                state { current: Version, history: List }
                invariant { not_empty(history) }
                trigger { error_detected }
                action {
                    ensure { safe(current) }
                }
                guarantee { always_safe }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        match &spec.properties[0] {
            Property::Rollback(r) => {
                assert_eq!(r.invariants.len(), 1);
                assert_eq!(r.guarantees.len(), 1);
            }
            _ => panic!("expected rollback spec"),
        }
    }

    #[test]
    fn test_improvement_proposal_property_kind() {
        let source = r#"
            improvement_proposal Test {
                target { x }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties[0].property_kind(), "improvement_proposal");
    }

    #[test]
    fn test_verification_gate_property_kind() {
        let source = r#"
            verification_gate Test {
                inputs { x: T }
                checks { check c { true } }
                on_pass { ok }
                on_fail { err }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties[0].property_kind(), "verification_gate");
    }

    #[test]
    fn test_rollback_property_kind() {
        let source = r#"
            rollback_spec Test {
                state { x: T }
                trigger { fail }
                action { ensure { ok } }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties[0].property_kind(), "rollback");
    }
}

// ============================================================================
// KANI PROOFS
// ============================================================================
// These proofs formally verify critical invariants of the parser functions.
// Run with: cargo kani -p dashprove-usl

#[cfg(kani)]
mod kani_proofs {
    use super::*;

    /// Prove that parse_cmp_op correctly maps all valid operators to their enum variants.
    /// This verifies:
    /// 1. Each operator string maps to exactly one enum variant
    /// 2. The mapping is exhaustive for all valid operators
    #[kani::proof]
    fn verify_parse_cmp_op_valid_operators() {
        // Verify all valid comparison operators map correctly
        assert!(matches!(parse_cmp_op("=="), Ok(ComparisonOp::Eq)));
        assert!(matches!(parse_cmp_op("!="), Ok(ComparisonOp::Ne)));
        assert!(matches!(parse_cmp_op("<"), Ok(ComparisonOp::Lt)));
        assert!(matches!(parse_cmp_op("<="), Ok(ComparisonOp::Le)));
        assert!(matches!(parse_cmp_op(">"), Ok(ComparisonOp::Gt)));
        assert!(matches!(parse_cmp_op(">="), Ok(ComparisonOp::Ge)));
    }

    /// Prove that parse_cmp_op returns an error for invalid operators.
    /// This verifies the function rejects strings that are not valid operators.
    #[kani::proof]
    fn verify_parse_cmp_op_invalid_operators() {
        // These should all fail - verify the function returns Err
        assert!(parse_cmp_op("").is_err());
        assert!(parse_cmp_op("=").is_err());
        assert!(parse_cmp_op("<>").is_err());
        assert!(parse_cmp_op("===").is_err());
    }

    /// Prove that parse_cmp_op enum variants are distinct.
    /// This ensures each valid operator maps to a different variant.
    #[kani::proof]
    fn verify_parse_cmp_op_distinct_results() {
        let eq = parse_cmp_op("==").unwrap();
        let ne = parse_cmp_op("!=").unwrap();
        let lt = parse_cmp_op("<").unwrap();
        let le = parse_cmp_op("<=").unwrap();
        let gt = parse_cmp_op(">").unwrap();
        let ge = parse_cmp_op(">=").unwrap();

        // Verify all results are distinct
        assert!(eq != ne && eq != lt && eq != le && eq != gt && eq != ge);
        assert!(ne != lt && ne != le && ne != gt && ne != ge);
        assert!(lt != le && lt != gt && lt != ge);
        assert!(le != gt && le != ge);
        assert!(gt != ge);
    }

    /// Prove that parse_string_literal preserves string length invariants.
    /// For valid quoted strings ("..."), the result length is exactly 2 less than input.
    #[kani::proof]
    fn verify_parse_string_literal_length_invariant() {
        // Test with a valid quoted string
        let input = r#""test""#;
        let output = parse_string_literal(input);
        // "test" has length 6, output "test" has length 4
        assert_eq!(input.len(), output.len() + 2);
    }

    /// Prove that parse_string_literal is idempotent for non-quoted strings.
    /// If a string doesn't have quotes on both ends, it's returned unchanged.
    #[kani::proof]
    fn verify_parse_string_literal_idempotent_unquoted() {
        // Unquoted strings should be returned unchanged
        let input = "hello";
        let output = parse_string_literal(input);
        assert_eq!(input, output);
    }

    /// Prove parse_string_literal handles edge case of minimum valid quoted string.
    /// The minimum valid quoted string is "" (empty content).
    #[kani::proof]
    fn verify_parse_string_literal_empty_quotes() {
        let input = r#""""#; // Two quotes: ""
        let output = parse_string_literal(input);
        assert!(output.is_empty());
    }

    /// Prove parse_string_literal requires BOTH quotes (tests && condition).
    /// This catches if && is mutated to ||.
    #[kani::proof]
    fn verify_parse_string_literal_both_quotes_required() {
        // Only starting quote
        let input1 = r#""hello"#;
        let output1 = parse_string_literal(input1);
        assert_eq!(input1, output1); // Unchanged

        // Only ending quote
        let input2 = r#"hello""#;
        let output2 = parse_string_literal(input2);
        assert_eq!(input2, output2); // Unchanged
    }

    /// Prove that valid comparison operators form a closed set.
    /// All 6 operators succeed, anything else fails.
    #[kani::proof]
    fn verify_cmp_op_coverage() {
        // Count of valid operators
        let valid_count = [
            parse_cmp_op("==").is_ok(),
            parse_cmp_op("!=").is_ok(),
            parse_cmp_op("<").is_ok(),
            parse_cmp_op("<=").is_ok(),
            parse_cmp_op(">").is_ok(),
            parse_cmp_op(">=").is_ok(),
        ]
        .iter()
        .filter(|&&x| x)
        .count();

        // Exactly 6 valid operators
        assert_eq!(valid_count, 6);
    }

    // =========================================================================
    // Version specification tests
    // =========================================================================

    #[test]
    fn test_parse_version_spec_basic() {
        let source = r#"
            version DasherV2 improves DasherV1 {
                capability { V2.speed >= V1.speed }
                preserves { V1.soundness }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Version(v) => {
                assert_eq!(v.name, "DasherV2");
                assert_eq!(v.improves, "DasherV1");
                assert_eq!(v.capabilities.len(), 1);
                assert_eq!(v.preserves.len(), 1);
            }
            _ => panic!("expected version"),
        }
    }

    #[test]
    fn test_parse_version_spec_multiple_capabilities() {
        let source = r#"
            version AgentV3 improves AgentV2 {
                capability { V3.speed >= V2.speed }
                capability { V3.accuracy >= V2.accuracy }
                capability { V3.memory_usage <= V2.memory_usage }
                preserves { V2.correctness }
                preserves { V2.termination }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Version(v) => {
                assert_eq!(v.name, "AgentV3");
                assert_eq!(v.improves, "AgentV2");
                assert_eq!(v.capabilities.len(), 3);
                assert_eq!(v.preserves.len(), 2);
            }
            _ => panic!("expected version"),
        }
    }

    #[test]
    fn test_parse_version_spec_empty_body() {
        let source = r#"
            version NewVersion improves OldVersion {
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Version(v) => {
                assert_eq!(v.name, "NewVersion");
                assert_eq!(v.improves, "OldVersion");
                assert_eq!(v.capabilities.len(), 0);
                assert_eq!(v.preserves.len(), 0);
            }
            _ => panic!("expected version"),
        }
    }

    // =========================================================================
    // Capability specification tests
    // =========================================================================

    #[test]
    fn test_parse_capability_spec_basic() {
        let source = r#"
            capability DasherCapability {
                can verify_code(code: RustCode) -> VerificationResult
                requires { soundness_preserved }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Capability(c) => {
                assert_eq!(c.name, "DasherCapability");
                assert_eq!(c.abilities.len(), 1);
                assert_eq!(c.abilities[0].name, "verify_code");
                assert_eq!(c.abilities[0].params.len(), 1);
                assert_eq!(c.abilities[0].params[0].name, "code");
                assert!(c.abilities[0].return_type.is_some());
                assert_eq!(c.requires.len(), 1);
            }
            _ => panic!("expected capability"),
        }
    }

    #[test]
    fn test_parse_capability_spec_multiple_abilities() {
        let source = r#"
            capability VerifierCapability {
                can verify_usl(spec: UslSpec) -> VerificationResult
                can verify_rust(code: RustCode) -> VerificationResult
                can improve_self(delta: Improvement) -> Version
                requires { soundness }
                requires { termination }
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Capability(c) => {
                assert_eq!(c.name, "VerifierCapability");
                assert_eq!(c.abilities.len(), 3);
                assert_eq!(c.requires.len(), 2);
            }
            _ => panic!("expected capability"),
        }
    }

    #[test]
    fn test_parse_capability_spec_no_return_type() {
        let source = r#"
            capability SideEffectCapability {
                can log_message(msg: String)
                can emit_event(event: Event)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Capability(c) => {
                assert_eq!(c.abilities.len(), 2);
                assert!(c.abilities[0].return_type.is_none());
                assert!(c.abilities[1].return_type.is_none());
            }
            _ => panic!("expected capability"),
        }
    }

    #[test]
    fn test_parse_capability_spec_empty() {
        let source = r#"
            capability EmptyCapability {
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Capability(c) => {
                assert_eq!(c.name, "EmptyCapability");
                assert_eq!(c.abilities.len(), 0);
                assert_eq!(c.requires.len(), 0);
            }
            _ => panic!("expected capability"),
        }
    }

    // =========================================================================
    // Distributed invariant tests
    // =========================================================================

    #[test]
    fn test_parse_distributed_invariant_basic() {
        let source = r#"
            distributed invariant proof_consensus {
                forall d1: Dasher, d2: Dasher .
                    d1.result == d2.result
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::DistributedInvariant(d) => {
                assert_eq!(d.name, "proof_consensus");
                // Check it has a forall expression
                match &d.body {
                    Expr::ForAll { var, .. } => {
                        assert_eq!(var, "d1");
                    }
                    _ => panic!("expected forall expression"),
                }
            }
            _ => panic!("expected distributed invariant"),
        }
    }

    #[test]
    fn test_parse_distributed_invariant_simple() {
        let source = r#"
            distributed invariant no_split_brain {
                can_communicate(d1, d2)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::DistributedInvariant(d) => {
                assert_eq!(d.name, "no_split_brain");
                // Check it's a function application
                match &d.body {
                    Expr::App(name, args) => {
                        assert_eq!(name, "can_communicate");
                        assert_eq!(args.len(), 2);
                    }
                    _ => panic!("expected function application"),
                }
            }
            _ => panic!("expected distributed invariant"),
        }
    }

    #[test]
    fn test_parse_distributed_invariant_with_implies() {
        let source = r#"
            distributed invariant agreement {
                forall d1: Dasher, d2: Dasher, prop: Property .
                    (d1.proves(prop) and d2.proves(prop)) implies (d1.result == d2.result)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::DistributedInvariant(d) => {
                assert_eq!(d.name, "agreement");
            }
            _ => panic!("expected distributed invariant"),
        }
    }

    // =========================================================================
    // Distributed temporal tests
    // =========================================================================

    #[test]
    fn test_parse_distributed_temporal_basic() {
        let source = r#"
            distributed temporal version_convergence {
                eventually(forall d1: Dasher, d2: Dasher . d1.version == d2.version)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::DistributedTemporal(d) => {
                assert_eq!(d.name, "version_convergence");
                assert!(d.fairness.is_empty());
                // Check it's an eventually expression
                match &d.body {
                    TemporalExpr::Eventually(_) => {}
                    _ => panic!("expected eventually expression"),
                }
            }
            _ => panic!("expected distributed temporal"),
        }
    }

    #[test]
    fn test_parse_distributed_temporal_with_fairness() {
        let source = r#"
            distributed temporal eventual_agreement {
                fair weak Next
                eventually(forall d: Dasher . d.agreed)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::DistributedTemporal(d) => {
                assert_eq!(d.name, "eventual_agreement");
                assert_eq!(d.fairness.len(), 1);
                assert_eq!(d.fairness[0].kind, FairnessKind::Weak);
                assert_eq!(d.fairness[0].action, "Next");
            }
            _ => panic!("expected distributed temporal"),
        }
    }

    #[test]
    fn test_parse_distributed_temporal_always() {
        let source = r#"
            distributed temporal global_safety {
                always(forall d: Dasher . d.is_valid)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::DistributedTemporal(d) => {
                assert_eq!(d.name, "global_safety");
                match &d.body {
                    TemporalExpr::Always(_) => {}
                    _ => panic!("expected always expression"),
                }
            }
            _ => panic!("expected distributed temporal"),
        }
    }

    #[test]
    fn test_parse_distributed_temporal_leads_to() {
        let source = r#"
            distributed temporal request_response {
                forall d: Dasher . d.requested ~> d.served
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::DistributedTemporal(d) => {
                assert_eq!(d.name, "request_response");
                match &d.body {
                    TemporalExpr::Atom(Expr::ForAll { body, .. }) => match body.as_ref() {
                        Expr::FieldAccess(_, _) => {
                            // The leads-to is parsed differently - this test just checks parsing works
                        }
                        _ => {}
                    },
                    _ => {}
                }
            }
            _ => panic!("expected distributed temporal"),
        }
    }

    #[test]
    fn test_parse_distributed_temporal_multiple_fairness() {
        let source = r#"
            distributed temporal coordination {
                fair weak Propose
                fair strong Decide
                eventually(forall d: Dasher . d.decided)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::DistributedTemporal(d) => {
                assert_eq!(d.name, "coordination");
                assert_eq!(d.fairness.len(), 2);
                assert_eq!(d.fairness[0].kind, FairnessKind::Weak);
                assert_eq!(d.fairness[0].action, "Propose");
                assert_eq!(d.fairness[1].kind, FairnessKind::Strong);
                assert_eq!(d.fairness[1].action, "Decide");
            }
            _ => panic!("expected distributed temporal"),
        }
    }

    // =========================================================================
    // COMPOSED THEOREM TESTS
    // =========================================================================

    #[test]
    fn test_parse_composed_theorem_basic() {
        let source = r#"
            composed theorem modular_safety {
                uses { safety_lemma, liveness_lemma }
                safety_lemma and liveness_lemma implies overall_safety
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Composed(c) => {
                assert_eq!(c.name, "modular_safety");
                assert_eq!(c.uses.len(), 2);
                assert!(c.uses.contains(&"safety_lemma".to_string()));
                assert!(c.uses.contains(&"liveness_lemma".to_string()));
            }
            _ => panic!("expected composed theorem"),
        }
    }

    #[test]
    fn test_parse_composed_theorem_single_dep() {
        let source = r#"
            composed theorem derived_safety {
                uses { base_theorem }
                base_theorem implies safe
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Composed(c) => {
                assert_eq!(c.name, "derived_safety");
                assert_eq!(c.uses.len(), 1);
                assert_eq!(c.uses[0], "base_theorem");
            }
            _ => panic!("expected composed theorem"),
        }
    }

    #[test]
    fn test_parse_composed_theorem_many_deps() {
        let source = r#"
            composed theorem combined_proof {
                uses { lemma1, lemma2, lemma3, invariant1 }
                lemma1 and lemma2 and lemma3 and invariant1
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Composed(c) => {
                assert_eq!(c.name, "combined_proof");
                assert_eq!(c.uses.len(), 4);
            }
            _ => panic!("expected composed theorem"),
        }
    }

    #[test]
    fn test_parse_composed_theorem_with_quantifier() {
        let source = r#"
            composed theorem graph_safety {
                uses { acyclic_property, connected_property }
                forall g: Graph . acyclic_property and connected_property implies safe(g)
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 1);
        match &spec.properties[0] {
            Property::Composed(c) => {
                assert_eq!(c.name, "graph_safety");
                assert_eq!(c.uses.len(), 2);
                // Verify body contains forall
                assert!(c.body.contains_quantifier());
            }
            _ => panic!("expected composed theorem"),
        }
    }

    #[test]
    fn test_parse_composed_theorem_with_theorem() {
        // Verify composed theorem can coexist with regular theorems
        let source = r#"
            theorem base_theorem {
                forall x: Int . x >= 0
            }

            composed theorem derived {
                uses { base_theorem }
                base_theorem implies result
            }
        "#;
        let spec = parse(source).expect("parse failed");
        assert_eq!(spec.properties.len(), 2);
        assert!(matches!(&spec.properties[0], Property::Theorem(_)));
        assert!(matches!(&spec.properties[1], Property::Composed(_)));
    }
}
