{
  "tool": "mizar",
  "version": "8.x",
  "last_updated": "2025-12-23",
  "errors": [
    {
      "id": "unknown_identifier",
      "pattern": "*4",
      "message": "Unknown identifier (error *4)",
      "cause": "Using undefined symbol",
      "solutions": [
        {
          "approach": "Import required article",
          "code": "environ\n  vocabularies XBOOLE_0, SUBSET_1;",
          "when": "Symbol defined in other article"
        },
        {
          "approach": "Check spelling",
          "code": "(:: Mizar is case-sensitive ::)",
          "when": "Typo in identifier"
        },
        {
          "approach": "Define locally",
          "code": "definition\n  let x be set;\n  func my_op(x) -> set means ...",
          "when": "Need local definition"
        }
      ]
    },
    {
      "id": "type_error",
      "pattern": "*60",
      "message": "Type mismatch (error *60)",
      "cause": "Expression has wrong type",
      "solutions": [
        {
          "approach": "Check mode",
          "code": "let x be Element of NAT;",
          "when": "Wrong mode declaration"
        },
        {
          "approach": "Add reconsider",
          "code": "reconsider y = x as Nat;",
          "when": "Need type cast"
        },
        {
          "approach": "Use cluster",
          "code": "(:: Check registered clusters ::)",
          "when": "Missing type cluster"
        }
      ]
    },
    {
      "id": "justification_error",
      "pattern": "*1",
      "message": "This inference is not accepted (error *1)",
      "cause": "Proof step not justified",
      "solutions": [
        {
          "approach": "Add explicit reference",
          "code": "hence thesis by XBOOLE_0:def 1;",
          "when": "Missing theorem reference"
        },
        {
          "approach": "Use then/hence chain",
          "code": "then A1 by A2, THEOREM:1;",
          "when": "Need chained reasoning"
        },
        {
          "approach": "Add intermediate step",
          "code": "(:: Break into smaller steps ::)",
          "when": "Step too large"
        }
      ]
    },
    {
      "id": "syntax_error",
      "pattern": "*100",
      "message": "Syntax error",
      "cause": "Invalid Mizar syntax",
      "solutions": [
        {
          "approach": "Check semicolons",
          "code": "let x be set;  (:: ends with semicolon ::)",
          "when": "Missing semicolon"
        },
        {
          "approach": "Check keywords",
          "code": "theorem, definition, registration, scheme",
          "when": "Wrong keyword"
        },
        {
          "approach": "Verify structure",
          "code": "proof ... end;  (:: proof blocks need end ::)",
          "when": "Unclosed block"
        }
      ]
    },
    {
      "id": "scheme_error",
      "pattern": "*134",
      "message": "Scheme application error",
      "cause": "Cannot apply scheme with given arguments",
      "solutions": [
        {
          "approach": "Check scheme premises",
          "code": "(:: Verify all scheme premises are satisfied ::)",
          "when": "Missing premise"
        },
        {
          "approach": "Check functor types",
          "code": "(:: Functors must match scheme signature ::)",
          "when": "Type mismatch in scheme"
        },
        {
          "approach": "Use explicit scheme",
          "code": "from SCHEME_NAME(A1, A2);",
          "when": "Need explicit scheme reference"
        }
      ]
    },
    {
      "id": "cluster_error",
      "pattern": "*140",
      "message": "Cluster registration error",
      "cause": "Cluster conditions not satisfied",
      "solutions": [
        {
          "approach": "Check cluster conditions",
          "code": "cluster -> non empty for set;",
          "when": "Wrong cluster declaration"
        },
        {
          "approach": "Add existence proof",
          "code": "existence by ...;",
          "when": "Missing existence"
        },
        {
          "approach": "Check coherence",
          "code": "coherence by ...;",
          "when": "Coherence not proven"
        }
      ]
    },
    {
      "id": "environ_error",
      "pattern": "*201",
      "message": "Environment directive error",
      "cause": "Invalid environ section",
      "solutions": [
        {
          "approach": "Check article name",
          "code": "vocabularies XBOOLE_0, SUBSET_1;",
          "when": "Article not found"
        },
        {
          "approach": "Order directives",
          "code": "(:: vocabularies before notations before ... ::)",
          "when": "Wrong directive order"
        },
        {
          "approach": "Check MML version",
          "code": "(:: Ensure articles exist in your MML version ::)",
          "when": "MML compatibility issue"
        }
      ]
    },
    {
      "id": "definition_error",
      "pattern": "*160",
      "message": "Definition error",
      "cause": "Invalid definition form",
      "solutions": [
        {
          "approach": "Check definiens",
          "code": "means :Def1: condition;",
          "when": "Missing means clause"
        },
        {
          "approach": "Prove existence",
          "code": "existence proof ... end;",
          "when": "Missing existence proof"
        },
        {
          "approach": "Prove uniqueness",
          "code": "uniqueness proof ... end;",
          "when": "Missing uniqueness for func"
        }
      ]
    },
    {
      "id": "reference_error",
      "pattern": "*3",
      "message": "Unknown reference",
      "cause": "Referenced label not found",
      "solutions": [
        {
          "approach": "Check label spelling",
          "code": "A1, A2, Def1, Th1",
          "when": "Typo in label"
        },
        {
          "approach": "Check scope",
          "code": "(:: Labels have local scope ::)",
          "when": "Label out of scope"
        },
        {
          "approach": "Use full reference",
          "code": "by ARTICLE:1, ARTICLE:def 2;",
          "when": "External reference"
        }
      ]
    }
  ]
}
