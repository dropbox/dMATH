{
  "tool": "isabelle",
  "version": "2024",
  "last_updated": "2025-12-22",
  "errors": [
    {
      "id": "type_unification",
      "pattern": "Type unification failed",
      "message": "Type unification failed: X and Y",
      "cause": "Two types cannot be unified",
      "solutions": [
        {
          "approach": "Add type annotation",
          "code": "(term :: type)",
          "when": "Isabelle infers wrong type"
        },
        {
          "approach": "Check type variables",
          "code": "term :: 'a => 'b  (* Check polymorphic types *)",
          "when": "Polymorphic types don't match"
        },
        {
          "approach": "Use type classes",
          "code": "fixes x :: \"'a::ord\"  (* Require type class *)",
          "when": "Need constrained polymorphism"
        }
      ]
    },
    {
      "id": "failed_proof",
      "pattern": "Failed to finish proof",
      "message": "Failed to finish proof",
      "cause": "Proof method did not solve all goals",
      "solutions": [
        {
          "approach": "Use sledgehammer",
          "code": "sledgehammer  (* Find proof automatically *)",
          "when": "Not sure what lemmas to use"
        },
        {
          "approach": "Try auto/simp",
          "code": "apply (auto simp: lemma1 lemma2)",
          "when": "Need simplification"
        },
        {
          "approach": "Use Isar",
          "code": "proof -\n  show ?thesis by ...\nqed",
          "when": "Need structured proof"
        },
        {
          "approach": "Check goal",
          "code": "(* Look at current goal in output *)",
          "when": "Need to understand what remains"
        }
      ]
    },
    {
      "id": "inner_syntax",
      "pattern": "Inner syntax error",
      "message": "Inner syntax error at",
      "cause": "Invalid Isabelle term syntax",
      "solutions": [
        {
          "approach": "Check operator precedence",
          "code": "(a + b) * c  (* Add parentheses *)",
          "when": "Operator binding is wrong"
        },
        {
          "approach": "Check notation",
          "code": "(* Look up notation in theory *)",
          "when": "Using wrong notation"
        },
        {
          "approach": "Quote identifiers",
          "code": "\"long.name.with.dots\"",
          "when": "Identifier contains special chars"
        }
      ]
    },
    {
      "id": "undefined_fact",
      "pattern": "Undefined fact",
      "message": "Undefined fact: name",
      "cause": "Lemma or theorem not found",
      "solutions": [
        {
          "approach": "Check spelling",
          "code": "find_theorems name:\"pattern\"",
          "when": "Name might be misspelled"
        },
        {
          "approach": "Import theory",
          "code": "imports Main \"~~/src/HOL/Library/...\"",
          "when": "Fact is in another theory"
        },
        {
          "approach": "Use find_theorems",
          "code": "find_theorems \"_ + _ = _ + _\"",
          "when": "Not sure of exact name"
        }
      ]
    },
    {
      "id": "termination",
      "pattern": "Could not prove termination",
      "message": "Could not prove termination",
      "cause": "Function recursion not well-founded",
      "solutions": [
        {
          "approach": "Add termination proof",
          "code": "function f where ...\nby pat_completeness auto\ntermination by (relation \"measure size\") auto",
          "when": "Custom termination argument needed"
        },
        {
          "approach": "Use fun",
          "code": "fun f :: ... where ...",
          "when": "Recursion is obviously terminating"
        },
        {
          "approach": "Use partial_function",
          "code": "partial_function (tailrec) f :: ...",
          "when": "Function may not terminate"
        }
      ]
    },
    {
      "id": "no_subgoals",
      "pattern": "No subgoals",
      "message": "No subgoals!",
      "cause": "Proof already complete but not closed",
      "solutions": [
        {
          "approach": "Close proof",
          "code": "done  (* or qed, by, . *)",
          "when": "Proof is complete"
        }
      ]
    },
    {
      "id": "ambiguous_parse",
      "pattern": "Ambiguous input",
      "message": "Ambiguous input produces multiple parse trees",
      "cause": "Term can be parsed multiple ways",
      "solutions": [
        {
          "approach": "Add parentheses",
          "code": "(a op b) op c",
          "when": "Need to resolve ambiguity"
        },
        {
          "approach": "Use type annotation",
          "code": "(term :: specific_type)",
          "when": "Type determines parsing"
        }
      ]
    },
    {
      "id": "method_failed",
      "pattern": "proof \\(prove\\) failed",
      "message": "Method application failed",
      "cause": "Proof method couldn't be applied",
      "solutions": [
        {
          "approach": "Check method applicability",
          "code": "(* induct needs inductive type *)",
          "when": "Wrong method for goal"
        },
        {
          "approach": "Prepare goal",
          "code": "apply (intro allI impI)  (* then other method *)",
          "when": "Goal needs preprocessing"
        },
        {
          "approach": "Use safer variant",
          "code": "apply auto?  (* ? = don't fail *)",
          "when": "Want to try without failing"
        }
      ]
    },
    {
      "id": "primrec_error",
      "pattern": "Primrec definition error",
      "message": "Bad primitive recursive definition",
      "cause": "primrec doesn't accept this recursion pattern",
      "solutions": [
        {
          "approach": "Use fun instead",
          "code": "fun f :: ... where ...",
          "when": "Pattern matching is more complex"
        },
        {
          "approach": "Simplify patterns",
          "code": "(* primrec requires constructor patterns *)",
          "when": "Can simplify to primitive recursion"
        }
      ]
    }
  ]
}
