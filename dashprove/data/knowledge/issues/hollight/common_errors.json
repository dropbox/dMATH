{
  "tool": "hollight",
  "version": "latest",
  "last_updated": "2025-12-23",
  "errors": [
    {
      "id": "type_error",
      "pattern": "typechecking error",
      "message": "Type checking failed",
      "cause": "Expression has type mismatch",
      "solutions": [
        {
          "approach": "Check type annotations",
          "code": "let x:real = &1",
          "when": "Type inference failed"
        },
        {
          "approach": "Use explicit coercion",
          "code": "real_of_num (x:num)",
          "when": "Need type conversion"
        },
        {
          "approach": "Check function signature",
          "code": ":t term;;  (* Show type of term *)",
          "when": "Unsure of term type"
        }
      ]
    },
    {
      "id": "parse_error",
      "pattern": "parse error",
      "message": "Parse error in term",
      "cause": "Syntax error in HOL Light term",
      "solutions": [
        {
          "approach": "Check backtick syntax",
          "code": "`x + y`  (* terms in backticks *)",
          "when": "Missing term delimiters"
        },
        {
          "approach": "Check operator precedence",
          "code": "`(x + y) * z`  (* use parens *)",
          "when": "Precedence ambiguity"
        },
        {
          "approach": "Verify identifiers",
          "code": "(* Names must be alphanumeric or symbolic *)",
          "when": "Invalid identifier"
        }
      ]
    },
    {
      "id": "unknown_constant",
      "pattern": "unknown constant",
      "message": "Constant not defined",
      "cause": "Using undefined constant",
      "solutions": [
        {
          "approach": "Load required library",
          "code": "needs \"Library/analysis.ml\";;",
          "when": "Constant in unloaded library"
        },
        {
          "approach": "Define the constant",
          "code": "let MY_CONST = new_definition `my_const = 42`;;",
          "when": "Need to define new constant"
        },
        {
          "approach": "Check spelling",
          "code": "(* Constants are case-sensitive *)",
          "when": "Typo in constant name"
        }
      ]
    },
    {
      "id": "tactic_failure",
      "pattern": "no_tac",
      "message": "Tactic failed",
      "cause": "Tactic doesn't apply to current goal",
      "solutions": [
        {
          "approach": "Check goal shape",
          "code": "p();;  (* Print current goal *)",
          "when": "Tactic requires different goal form"
        },
        {
          "approach": "Try different tactic",
          "code": "e (REWRITE_TAC[theorem]);;",
          "when": "Need different approach"
        },
        {
          "approach": "Simplify first",
          "code": "e SIMP_TAC[];;",
          "when": "Goal needs simplification"
        }
      ]
    },
    {
      "id": "goal_not_proved",
      "pattern": "not proved",
      "message": "Goal not fully proved",
      "cause": "Proof incomplete",
      "solutions": [
        {
          "approach": "Check remaining subgoals",
          "code": "p();;  (* Show remaining goals *)",
          "when": "Subgoals remain"
        },
        {
          "approach": "Use ASM_REWRITE",
          "code": "e (ASM_REWRITE_TAC[]);;",
          "when": "Need to use assumptions"
        },
        {
          "approach": "Complete with ARITH",
          "code": "e ARITH_TAC;;",
          "when": "Goal is arithmetic"
        }
      ]
    },
    {
      "id": "definition_rejected",
      "pattern": "definition",
      "message": "Definition rejected",
      "cause": "Invalid definition form",
      "solutions": [
        {
          "approach": "Check definition syntax",
          "code": "let def = new_definition `f x = x + 1`;;",
          "when": "Wrong definition syntax"
        },
        {
          "approach": "Use recursive definition",
          "code": "let rec_def = define `f 0 = a /\\ f (SUC n) = g (f n)`;;",
          "when": "Need recursive definition"
        },
        {
          "approach": "Check variable capture",
          "code": "(* Ensure free variables are on LHS *)",
          "when": "Free variable issues"
        }
      ]
    },
    {
      "id": "rewrite_loop",
      "pattern": "loop",
      "message": "Rewriting seems to loop",
      "cause": "Rewrite rule causes infinite loop",
      "solutions": [
        {
          "approach": "Use ONCE_REWRITE",
          "code": "e (ONCE_REWRITE_TAC[theorem]);;",
          "when": "Prevent repeated rewriting"
        },
        {
          "approach": "Add guards",
          "code": "(* Use conditional rewriting *)",
          "when": "Need conditional application"
        },
        {
          "approach": "Different strategy",
          "code": "e (GEN_REWRITE_TAC DEPTH_CONV [theorem]);;",
          "when": "Need controlled rewriting"
        }
      ]
    },
    {
      "id": "instantiation_error",
      "pattern": "instantiation",
      "message": "Cannot instantiate theorem",
      "cause": "Wrong instantiation type or variable",
      "solutions": [
        {
          "approach": "Check theorem variables",
          "code": "theorem;;  (* Print theorem to see variables *)",
          "when": "Wrong variable name"
        },
        {
          "approach": "Use INST_TYPE",
          "code": "INST_TYPE [`:real`,`:A`] theorem",
          "when": "Need type instantiation"
        },
        {
          "approach": "Use SPECL",
          "code": "SPECL [`a`;`b`] theorem",
          "when": "Need term instantiation"
        }
      ]
    }
  ]
}
