{
  "tool": "dart",
  "version": "3.3.0",
  "last_updated": "2025-12-23",
  "errors": [
    {
      "id": "type_error",
      "pattern": "type '.*' is not a subtype|TypeError|type mismatch",
      "message": "Type error at runtime",
      "cause": "Runtime type doesn't match expected type",
      "solutions": [
        {
          "approach": "Use type cast",
          "code": "final data = json['key'] as String;\nfinal list = (json['items'] as List).cast<String>();",
          "when": "JSON parsing"
        },
        {
          "approach": "Use type check",
          "code": "if (value is String) {\n  print(value.length);\n}",
          "when": "Unknown type"
        },
        {
          "approach": "Use generics",
          "code": "T getValue<T>(Map<String, dynamic> map, String key) {\n  return map[key] as T;\n}",
          "when": "Generic function"
        }
      ]
    },
    {
      "id": "null_error",
      "pattern": "Null check operator|null was thrown|NoSuchMethodError: The getter .* was called on null",
      "message": "Null reference error",
      "cause": "Accessing property/method on null value",
      "solutions": [
        {
          "approach": "Use null-aware operators",
          "code": "final name = user?.name ?? 'Unknown';\nfinal length = text?.length ?? 0;",
          "when": "Possibly null"
        },
        {
          "approach": "Use late",
          "code": "late final String name;\n// Initialize before use\nname = fetchName();",
          "when": "Delayed initialization"
        },
        {
          "approach": "Use required",
          "code": "void greet({required String name}) {\n  print('Hello $name');\n}",
          "when": "Required parameter"
        }
      ]
    },
    {
      "id": "import_error",
      "pattern": "Target of URI doesn't exist|Undefined name|import",
      "message": "Import error",
      "cause": "Package not found or wrong import path",
      "solutions": [
        {
          "approach": "Run pub get",
          "code": "dart pub get",
          "when": "Dependencies not fetched"
        },
        {
          "approach": "Check import path",
          "code": "import 'package:my_package/src/file.dart';\nimport '../relative/path.dart';",
          "when": "Wrong path"
        },
        {
          "approach": "Export from library",
          "code": "// lib/my_package.dart\nexport 'src/public_api.dart';",
          "when": "Internal file"
        }
      ]
    },
    {
      "id": "async_error",
      "pattern": "Future|await|async|Unhandled exception|not completed",
      "message": "Async operation error",
      "cause": "Improper async/await handling",
      "solutions": [
        {
          "approach": "Add await",
          "code": "Future<void> loadData() async {\n  final data = await fetchData();\n  processData(data);\n}",
          "when": "Missing await"
        },
        {
          "approach": "Handle errors",
          "code": "try {\n  await riskyOperation();\n} catch (e) {\n  print('Error: $e');\n}",
          "when": "Unhandled exception"
        },
        {
          "approach": "Use FutureBuilder",
          "code": "FutureBuilder<Data>(\n  future: loadData(),\n  builder: (context, snapshot) {\n    if (snapshot.hasData) return DataWidget(snapshot.data!);\n    if (snapshot.hasError) return ErrorWidget(snapshot.error!);\n    return LoadingWidget();\n  },\n)",
          "when": "In widget"
        }
      ]
    },
    {
      "id": "pub_error",
      "pattern": "pub|pubspec|version solving|dependency",
      "message": "Package management error",
      "cause": "pubspec.yaml issue or dependency conflict",
      "solutions": [
        {
          "approach": "Fix pubspec syntax",
          "code": "# pubspec.yaml\nname: my_app\ndescription: My app\nversion: 1.0.0\n\nenvironment:\n  sdk: '>=3.0.0 <4.0.0'\n\ndependencies:\n  http: ^1.1.0",
          "when": "YAML syntax"
        },
        {
          "approach": "Upgrade dependencies",
          "code": "dart pub upgrade --major-versions",
          "when": "Version conflicts"
        },
        {
          "approach": "Use dependency override",
          "code": "dependency_overrides:\n  some_package: ^2.0.0",
          "when": "Force version"
        }
      ]
    },
    {
      "id": "analysis_error",
      "pattern": "analysis_options|lint|warning|info|error",
      "message": "Static analysis error",
      "cause": "Code doesn't follow analysis rules",
      "solutions": [
        {
          "approach": "Fix lint issue",
          "code": "// ignore: unused_local_variable\nfinal unused = 'value';",
          "when": "Ignore specific"
        },
        {
          "approach": "Configure analysis",
          "code": "# analysis_options.yaml\ninclude: package:lints/recommended.yaml\nlinter:\n  rules:\n    prefer_const_constructors: true",
          "when": "Project rules"
        },
        {
          "approach": "Run analyzer",
          "code": "dart analyze\ndart fix --apply",
          "when": "Fix issues"
        }
      ]
    },
    {
      "id": "platform_error",
      "pattern": "Platform|Unsupported operation|dart:io|dart:html",
      "message": "Platform-specific error",
      "cause": "Using platform-specific API on wrong platform",
      "solutions": [
        {
          "approach": "Check platform",
          "code": "import 'dart:io' show Platform;\nif (Platform.isIOS) {\n  // iOS specific\n} else if (Platform.isAndroid) {\n  // Android specific\n}",
          "when": "Mobile platforms"
        },
        {
          "approach": "Conditional import",
          "code": "// web_impl.dart for web\n// io_impl.dart for mobile\nexport 'src/stub.dart'\n  if (dart.library.io) 'src/io_impl.dart'\n  if (dart.library.html) 'src/web_impl.dart';",
          "when": "Cross-platform"
        },
        {
          "approach": "Use kIsWeb",
          "code": "import 'package:flutter/foundation.dart';\nif (kIsWeb) {\n  // Web specific\n}",
          "when": "Flutter web"
        }
      ]
    },
    {
      "id": "json_error",
      "pattern": "FormatException|JSON|json\\.decode|Unexpected character",
      "message": "JSON parsing error",
      "cause": "Invalid JSON format",
      "solutions": [
        {
          "approach": "Validate JSON",
          "code": "try {\n  final data = jsonDecode(jsonString) as Map<String, dynamic>;\n} on FormatException catch (e) {\n  print('Invalid JSON: $e');\n}",
          "when": "Parse with error handling"
        },
        {
          "approach": "Use json_serializable",
          "code": "@JsonSerializable()\nclass User {\n  final String name;\n  User(this.name);\n  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);\n  Map<String, dynamic> toJson() => _$UserToJson(this);\n}",
          "when": "Type-safe parsing"
        },
        {
          "approach": "Handle encoding",
          "code": "final jsonString = utf8.decode(bytes);\nfinal data = jsonDecode(jsonString);",
          "when": "Encoding issue"
        }
      ]
    }
  ]
}
