{
  "tool": "cirq",
  "version": "1.3.0",
  "last_updated": "2025-12-23",
  "errors": [
    {
      "id": "qubit_not_adjacent",
      "pattern": "qubits.*not adjacent|non-local.*gate|GridQubit.*error",
      "message": "Two-qubit gate on non-adjacent qubits",
      "cause": "Gate requires adjacent qubits on device topology",
      "solutions": [
        {
          "approach": "Use router",
          "code": "import cirq\nfrom cirq.contrib.routing import route_circuit\n\ndevice = cirq.google.Sycamore\nrouted = route_circuit(circuit, device)",
          "when": "Auto-route circuit"
        },
        {
          "approach": "Use adjacent qubits",
          "code": "import cirq\nq0, q1 = cirq.GridQubit(5, 4), cirq.GridQubit(5, 5)  # Adjacent\ncircuit = cirq.Circuit(cirq.CNOT(q0, q1))",
          "when": "Manual placement"
        },
        {
          "approach": "Check device topology",
          "code": "import cirq\ndevice = cirq.google.Sycamore\nprint(device.qubits)  # Available qubits\nprint(device.qubit_set())  # Connectivity",
          "when": "See device layout"
        }
      ]
    },
    {
      "id": "gate_not_supported",
      "pattern": "gate.*not supported|cannot implement|UnsupportedGateError",
      "message": "Gate not in device gate set",
      "cause": "Device doesn't support this gate natively",
      "solutions": [
        {
          "approach": "Decompose gate",
          "code": "import cirq\ngateset = cirq.google.SycamoreGateset()\noptimized = cirq.optimize_for_target_gateset(\n    circuit, gateset=gateset\n)",
          "when": "Convert to native gates"
        },
        {
          "approach": "Use transformer",
          "code": "import cirq\ntransformed = cirq.google.optimized_for_sycamore(\n    circuit,\n    optimizer_type='sqrt_iswap'\n)",
          "when": "Google hardware"
        },
        {
          "approach": "Check supported gates",
          "code": "gateset = cirq.google.SycamoreGateset()\nprint(gateset.gates)  # Native gates",
          "when": "See available gates"
        }
      ]
    },
    {
      "id": "measurement_key_collision",
      "pattern": "measurement key.*collision|duplicate.*key|MeasurementKeyError",
      "message": "Duplicate measurement keys",
      "cause": "Multiple measurements use same key",
      "solutions": [
        {
          "approach": "Use unique keys",
          "code": "import cirq\nq = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(\n    cirq.H(q[0]),\n    cirq.measure(q[0], key='m0'),\n    cirq.measure(q[1], key='m1')\n)",
          "when": "Separate keys"
        },
        {
          "approach": "Use measurement gate",
          "code": "circuit = cirq.Circuit(\n    cirq.H.on_each(*q),\n    cirq.measure(*q, key='all')  # Combined measurement\n)",
          "when": "Measure together"
        }
      ]
    },
    {
      "id": "circuit_validation",
      "pattern": "validate.*failed|Invalid circuit|CircuitValidationError",
      "message": "Circuit validation failed",
      "cause": "Circuit violates device constraints",
      "solutions": [
        {
          "approach": "Validate explicitly",
          "code": "import cirq\ntry:\n    device.validate_circuit(circuit)\nexcept ValueError as e:\n    print(f'Validation error: {e}')",
          "when": "Debug issues"
        },
        {
          "approach": "Check moment structure",
          "code": "for i, moment in enumerate(circuit):\n    print(f'Moment {i}: {moment}')\n    for op in moment:\n        print(f'  {op}')",
          "when": "Inspect circuit"
        }
      ]
    },
    {
      "id": "import_error_cirq",
      "pattern": "ImportError|ModuleNotFoundError|cirq.*import",
      "message": "Cirq import error",
      "cause": "Missing Cirq package or component",
      "solutions": [
        {
          "approach": "Install Cirq",
          "code": "pip install cirq",
          "when": "Basic install"
        },
        {
          "approach": "Install Google components",
          "code": "pip install cirq-google\n# Includes Google hardware support",
          "when": "Need Google Quantum"
        },
        {
          "approach": "Install all extras",
          "code": "pip install cirq[all]\n# Includes all optional dependencies",
          "when": "Full functionality"
        }
      ]
    },
    {
      "id": "simulation_memory",
      "pattern": "MemoryError|out of memory|too many qubits.*simulate",
      "message": "Simulation ran out of memory",
      "cause": "State vector simulation scales exponentially",
      "solutions": [
        {
          "approach": "Use different simulator",
          "code": "import cirq\n# Density matrix (slower but more memory efficient for noise)\nsimulator = cirq.DensityMatrixSimulator()\n# Or Clifford (fast but limited gates)\nsimulator = cirq.CliffordSimulator()",
          "when": "Different simulation type"
        },
        {
          "approach": "Use tensor network",
          "code": "import cirq\nimport quimb.tensor as qtn\nsimulator = cirq.contrib.quimb.MPSSimulator()",
          "when": "Low-entanglement circuits"
        },
        {
          "approach": "Use sampling",
          "code": "result = cirq.sample(circuit, repetitions=1000)\n# Doesn't store full state vector",
          "when": "Only need measurement results"
        }
      ]
    },
    {
      "id": "api_credentials_google",
      "pattern": "credentials|authentication|Google.*error|EngineException",
      "message": "Google Quantum Engine authentication failed",
      "cause": "Missing or invalid Google Cloud credentials",
      "solutions": [
        {
          "approach": "Set up authentication",
          "code": "# Install gcloud CLI and authenticate:\ngcloud auth application-default login\n# Or set service account:\nexport GOOGLE_APPLICATION_CREDENTIALS=/path/to/key.json",
          "when": "First time setup"
        },
        {
          "approach": "Configure project",
          "code": "import cirq_google as cg\nengine = cg.Engine(\n    project_id='your-project-id'\n)",
          "when": "Specify project"
        }
      ]
    },
    {
      "id": "result_parsing_cirq",
      "pattern": "result.*error|histogram|measurements",
      "message": "Error parsing simulation results",
      "cause": "Wrong method for accessing results",
      "solutions": [
        {
          "approach": "Get measurement results",
          "code": "import cirq\nresult = cirq.Simulator().run(circuit, repetitions=100)\nprint(result.measurements)  # Dict of arrays\nprint(result.histogram(key='m'))  # Counter",
          "when": "After measurement"
        },
        {
          "approach": "Get state vector",
          "code": "result = cirq.Simulator().simulate(circuit)\nprint(result.final_state_vector)",
          "when": "No measurement"
        },
        {
          "approach": "Get density matrix",
          "code": "result = cirq.DensityMatrixSimulator().simulate(circuit)\nprint(result.final_density_matrix)",
          "when": "Mixed states"
        }
      ]
    },
    {
      "id": "parameter_resolver",
      "pattern": "Symbol.*unresolved|resolver|ParameterError",
      "message": "Circuit has unresolved parameters",
      "cause": "Symbolic parameters not resolved before execution",
      "solutions": [
        {
          "approach": "Resolve parameters",
          "code": "import cirq\nimport sympy\ntheta = sympy.Symbol('theta')\nq = cirq.LineQubit(0)\ncircuit = cirq.Circuit(cirq.rx(theta).on(q))\n\nresolver = cirq.ParamResolver({'theta': 0.5})\nresult = cirq.Simulator().simulate(circuit, resolver)",
          "when": "Single value"
        },
        {
          "approach": "Sweep parameters",
          "code": "import cirq\nimport numpy as np\nsweep = cirq.Linspace('theta', 0, 2*np.pi, 10)\nresults = cirq.Simulator().run_sweep(circuit, sweep, repetitions=100)",
          "when": "Multiple values"
        }
      ]
    },
    {
      "id": "noise_model",
      "pattern": "noise.*error|NoiseModel|depolarizing",
      "message": "Noise model configuration error",
      "cause": "Invalid noise model or parameters",
      "solutions": [
        {
          "approach": "Add depolarizing noise",
          "code": "import cirq\nnoise_model = cirq.ConstantQubitNoiseModel(\n    cirq.depolarize(p=0.01)\n)\nnoisy_circuit = circuit.with_noise(noise_model)",
          "when": "Simple noise"
        },
        {
          "approach": "Device-specific noise",
          "code": "import cirq_google as cg\nnoise_props = cg.engine.load_average_processor_properties('rainbow')\nnoise_model = cg.NoiseModelFromGoogleNoiseProperties(noise_props)\nsimulator = cirq.DensityMatrixSimulator(noise=noise_model)",
          "when": "Realistic noise"
        },
        {
          "approach": "Custom noise per gate",
          "code": "class MyNoiseModel(cirq.NoiseModel):\n    def noisy_moment(self, moment, system_qubits):\n        for op in moment:\n            yield op\n            yield cirq.depolarize(0.01).on_each(op.qubits)",
          "when": "Fine-grained control"
        }
      ]
    }
  ]
}
