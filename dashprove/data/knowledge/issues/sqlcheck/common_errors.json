{
  "tool": "sqlcheck",
  "version": "1.3.0",
  "last_updated": "2025-12-23",
  "errors": [
    {
      "id": "select_star",
      "pattern": "SELECT \\*|select all columns|anti-pattern.*SELECT",
      "message": "SELECT * used instead of explicit columns",
      "cause": "Query retrieves all columns when subset is needed",
      "solutions": [
        {
          "approach": "List explicit columns",
          "code": "SELECT id, name, email FROM users\n-- Instead of: SELECT * FROM users",
          "when": "Know which columns needed"
        },
        {
          "approach": "Use view for common projections",
          "code": "CREATE VIEW user_summary AS\nSELECT id, name, email FROM users;\n\nSELECT * FROM user_summary;",
          "when": "Reused column set"
        }
      ]
    },
    {
      "id": "implicit_columns_insert",
      "pattern": "INSERT.*without column|implicit column|INSERT INTO.*VALUES",
      "message": "INSERT without explicit column list",
      "cause": "INSERT relies on column order instead of names",
      "solutions": [
        {
          "approach": "Add column list",
          "code": "INSERT INTO users (name, email, created_at)\nVALUES ('John', 'john@example.com', NOW());\n-- Instead of: INSERT INTO users VALUES (...)",
          "when": "Always specify columns"
        }
      ]
    },
    {
      "id": "null_in_not_in",
      "pattern": "NOT IN.*NULL|NULL.*NOT IN|anti-pattern.*NULL",
      "message": "NOT IN with nullable column",
      "cause": "NOT IN returns NULL if subquery contains NULL",
      "solutions": [
        {
          "approach": "Use NOT EXISTS",
          "code": "SELECT * FROM orders o\nWHERE NOT EXISTS (\n  SELECT 1 FROM cancelled c\n  WHERE c.order_id = o.id\n);\n-- Instead of: WHERE o.id NOT IN (SELECT order_id FROM cancelled)",
          "when": "Safer approach"
        },
        {
          "approach": "Filter NULLs",
          "code": "WHERE id NOT IN (\n  SELECT order_id FROM cancelled\n  WHERE order_id IS NOT NULL\n)",
          "when": "Keep NOT IN"
        }
      ]
    },
    {
      "id": "missing_where",
      "pattern": "UPDATE.*without WHERE|DELETE.*without WHERE|dangerous.*statement",
      "message": "UPDATE/DELETE without WHERE clause",
      "cause": "Statement affects all rows in table",
      "solutions": [
        {
          "approach": "Add WHERE clause",
          "code": "UPDATE users SET active = false\nWHERE last_login < '2024-01-01';\n-- Instead of: UPDATE users SET active = false;",
          "when": "Filter rows"
        },
        {
          "approach": "Use transaction",
          "code": "BEGIN;\nUPDATE users SET active = false WHERE id = 123;\n-- Verify: SELECT * FROM users WHERE id = 123;\nCOMMIT; -- or ROLLBACK;",
          "when": "Test before commit"
        }
      ]
    },
    {
      "id": "implicit_join",
      "pattern": "implicit.*join|comma.*join|WHERE.*=.*join",
      "message": "Implicit join using comma syntax",
      "cause": "Old-style join syntax in FROM clause",
      "solutions": [
        {
          "approach": "Use explicit JOIN",
          "code": "SELECT u.name, o.total\nFROM users u\nJOIN orders o ON u.id = o.user_id;\n-- Instead of: FROM users u, orders o WHERE u.id = o.user_id",
          "when": "Clearer intent"
        },
        {
          "approach": "Use appropriate join type",
          "code": "SELECT u.name, o.total\nFROM users u\nLEFT JOIN orders o ON u.id = o.user_id;",
          "when": "Need all left rows"
        }
      ]
    },
    {
      "id": "redundant_distinct",
      "pattern": "DISTINCT.*unnecessary|redundant.*DISTINCT|GROUP BY.*DISTINCT",
      "message": "Unnecessary DISTINCT clause",
      "cause": "DISTINCT used when results already unique",
      "solutions": [
        {
          "approach": "Remove DISTINCT",
          "code": "SELECT id FROM users WHERE active = true;\n-- Instead of: SELECT DISTINCT id FROM users...",
          "when": "Primary key in SELECT"
        },
        {
          "approach": "Use GROUP BY instead",
          "code": "SELECT category, COUNT(*) FROM products\nGROUP BY category;\n-- Instead of: SELECT DISTINCT category...",
          "when": "Need aggregation"
        }
      ]
    },
    {
      "id": "function_on_indexed_column",
      "pattern": "function.*index|index.*not used|WHERE.*FUNCTION",
      "message": "Function applied to indexed column",
      "cause": "Function prevents index usage",
      "solutions": [
        {
          "approach": "Avoid function on column",
          "code": "SELECT * FROM orders\nWHERE created_at >= '2024-01-01'\n  AND created_at < '2025-01-01';\n-- Instead of: WHERE YEAR(created_at) = 2024",
          "when": "Date range"
        },
        {
          "approach": "Create functional index",
          "code": "CREATE INDEX idx_year ON orders (YEAR(created_at));",
          "when": "Must use function"
        },
        {
          "approach": "Rewrite condition",
          "code": "SELECT * FROM users\nWHERE email = LOWER('John@Example.COM');\n-- Instead of: WHERE LOWER(email) = 'john@example.com'",
          "when": "Move function to constant"
        }
      ]
    },
    {
      "id": "or_instead_of_in",
      "pattern": "multiple OR|OR.*OR.*OR|anti-pattern.*OR",
      "message": "Multiple OR conditions instead of IN",
      "cause": "Verbose OR chain for same column",
      "solutions": [
        {
          "approach": "Use IN clause",
          "code": "SELECT * FROM products\nWHERE category IN ('electronics', 'books', 'toys');\n-- Instead of: WHERE category = 'electronics' OR category = 'books' OR...",
          "when": "Same column"
        },
        {
          "approach": "Use ANY/SOME",
          "code": "SELECT * FROM products\nWHERE category = ANY(ARRAY['electronics', 'books', 'toys']);",
          "when": "PostgreSQL"
        }
      ]
    },
    {
      "id": "order_by_rand",
      "pattern": "ORDER BY RAND|RANDOM.*ORDER|anti-pattern.*random",
      "message": "ORDER BY RAND() is slow",
      "cause": "Database must sort all rows randomly",
      "solutions": [
        {
          "approach": "Use offset with count",
          "code": "SELECT * FROM products\nWHERE id >= (SELECT FLOOR(RAND() * (SELECT MAX(id) FROM products)))\nLIMIT 1;",
          "when": "Get random row"
        },
        {
          "approach": "Pre-computed random column",
          "code": "ALTER TABLE products ADD COLUMN rand_sort FLOAT;\nUPDATE products SET rand_sort = RAND();\nCREATE INDEX idx_rand ON products (rand_sort);",
          "when": "Frequent random access"
        },
        {
          "approach": "Application-side sampling",
          "code": "SELECT id FROM products;\n-- Then randomly select IDs in application\nSELECT * FROM products WHERE id IN (?, ?, ?);",
          "when": "Better performance"
        }
      ]
    },
    {
      "id": "storing_list_in_column",
      "pattern": "comma.*separated|list.*column|multi.*value.*column",
      "message": "Storing comma-separated values in column",
      "cause": "Violates first normal form",
      "solutions": [
        {
          "approach": "Create junction table",
          "code": "CREATE TABLE product_tags (\n  product_id INT,\n  tag_id INT,\n  PRIMARY KEY (product_id, tag_id)\n);\n-- Instead of: tags VARCHAR(255) with 'tag1,tag2,tag3'",
          "when": "Many-to-many"
        },
        {
          "approach": "Use array type",
          "code": "-- PostgreSQL:\nCREATE TABLE products (\n  id SERIAL PRIMARY KEY,\n  tags TEXT[]\n);\nSELECT * FROM products WHERE 'electronics' = ANY(tags);",
          "when": "PostgreSQL arrays"
        },
        {
          "approach": "Use JSON column",
          "code": "-- MySQL 8+:\nALTER TABLE products ADD tags JSON;\nSELECT * FROM products WHERE JSON_CONTAINS(tags, '\"electronics\"');",
          "when": "JSON support"
        }
      ]
    },
    {
      "id": "count_star_vs_count_column",
      "pattern": "COUNT\\(column\\)|count.*null|anti-pattern.*COUNT",
      "message": "COUNT(column) may exclude NULLs",
      "cause": "COUNT(column) only counts non-NULL values",
      "solutions": [
        {
          "approach": "Use COUNT(*)",
          "code": "SELECT COUNT(*) FROM orders;\n-- Instead of: COUNT(order_id) if order_id is always non-NULL",
          "when": "Count all rows"
        },
        {
          "approach": "Use COUNT(1)",
          "code": "SELECT COUNT(1) FROM orders;",
          "when": "Equivalent to COUNT(*)"
        },
        {
          "approach": "Be explicit about NULL handling",
          "code": "SELECT COUNT(CASE WHEN status IS NOT NULL THEN 1 END) FROM orders;",
          "when": "Document NULL behavior"
        }
      ]
    },
    {
      "id": "not_using_limit",
      "pattern": "without LIMIT|no pagination|large result",
      "message": "Query without LIMIT on large table",
      "cause": "Could return millions of rows",
      "solutions": [
        {
          "approach": "Add LIMIT",
          "code": "SELECT * FROM logs\nWHERE created_at > '2024-01-01'\nORDER BY created_at DESC\nLIMIT 100;",
          "when": "Limit result size"
        },
        {
          "approach": "Use pagination",
          "code": "SELECT * FROM logs\nORDER BY id\nLIMIT 100 OFFSET 200;  -- Page 3",
          "when": "Paginated results"
        },
        {
          "approach": "Keyset pagination",
          "code": "SELECT * FROM logs\nWHERE id > ? -- last_seen_id\nORDER BY id\nLIMIT 100;",
          "when": "Better performance"
        }
      ]
    }
  ]
}
