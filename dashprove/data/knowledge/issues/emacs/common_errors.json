{
  "tool": "emacs",
  "version": "29.4",
  "last_updated": "2025-12-23",
  "errors": [
    {
      "id": "package_not_found",
      "pattern": "Package.*not available|unable to find package",
      "message": "Package not available for installation",
      "cause": "Package archives not refreshed or package doesn't exist",
      "solutions": [
        {
          "approach": "Refresh package list",
          "code": "M-x package-refresh-contents",
          "when": "Package list outdated"
        },
        {
          "approach": "Add MELPA",
          "code": "(add-to-list 'package-archives '(\"melpa\" . \"https://melpa.org/packages/\"))",
          "when": "MELPA not configured"
        },
        {
          "approach": "Use use-package with ensure",
          "code": "(use-package magit :ensure t)",
          "when": "Auto-install on startup"
        }
      ]
    },
    {
      "id": "void_function",
      "pattern": "Symbol's function definition is void",
      "message": "Symbol's function definition is void",
      "cause": "Function not defined or package not loaded",
      "solutions": [
        {
          "approach": "Require the package",
          "code": "(require 'package-name)",
          "when": "Package not loaded"
        },
        {
          "approach": "Check installation",
          "code": "M-x describe-function RET function-name",
          "when": "Verify function exists"
        },
        {
          "approach": "Autoload function",
          "code": "(autoload 'function-name \"package-name\")",
          "when": "Delay loading"
        }
      ]
    },
    {
      "id": "void_variable",
      "pattern": "Symbol's value as variable is void",
      "message": "Symbol's value as variable is void",
      "cause": "Variable not defined or package not loaded",
      "solutions": [
        {
          "approach": "Define variable",
          "code": "(defvar variable-name nil)",
          "when": "Variable should exist"
        },
        {
          "approach": "Check with boundp",
          "code": "(when (boundp 'variable-name) ...)",
          "when": "Conditional access"
        },
        {
          "approach": "Load defining package",
          "code": "(require 'package-that-defines-var)",
          "when": "Variable from package"
        }
      ]
    },
    {
      "id": "native_comp_error",
      "pattern": "native-comp|eln-cache.*error|native compilation",
      "message": "Native compilation error",
      "cause": "Native compilation failed for elisp file",
      "solutions": [
        {
          "approach": "Clear eln cache",
          "code": "rm -rf ~/.emacs.d/eln-cache/",
          "when": "Corrupted cache"
        },
        {
          "approach": "Disable native-comp",
          "code": "(setq native-comp-deferred-compilation nil)",
          "when": "Avoid native compilation"
        },
        {
          "approach": "Reinstall package",
          "code": "M-x package-reinstall RET package-name",
          "when": "Package compilation failed"
        }
      ]
    },
    {
      "id": "file_locked",
      "pattern": "file is locked|locked by",
      "message": "File is locked by another Emacs",
      "cause": "Another Emacs instance is editing the file",
      "solutions": [
        {
          "approach": "Steal lock",
          "code": "Type 's' when prompted",
          "when": "Other process not active"
        },
        {
          "approach": "Proceed anyway",
          "code": "Type 'p' when prompted",
          "when": "Edit anyway (risky)"
        },
        {
          "approach": "Remove lock manually",
          "code": "rm .#filename",
          "when": "Lock file is stale"
        }
      ]
    },
    {
      "id": "recursive_minibuffer",
      "pattern": "Command attempted to use minibuffer.*in minibuffer",
      "message": "Command attempted to use minibuffer while in minibuffer",
      "cause": "Trying to run minibuffer command from within minibuffer",
      "solutions": [
        {
          "approach": "Enable recursive minibuffers",
          "code": "(setq enable-recursive-minibuffers t)",
          "when": "Need nested minibuffers"
        },
        {
          "approach": "Exit minibuffer first",
          "code": "Press C-g to abort current minibuffer",
          "when": "Accidentally triggered"
        },
        {
          "approach": "Use different command",
          "code": "Complete current operation first",
          "when": "Sequence operations"
        }
      ]
    },
    {
      "id": "wrong_type_argument",
      "pattern": "Wrong type argument",
      "message": "Wrong type argument",
      "cause": "Function received argument of unexpected type",
      "solutions": [
        {
          "approach": "Check argument types",
          "code": "M-x describe-function RET function-name",
          "when": "Verify expected types"
        },
        {
          "approach": "Type check before call",
          "code": "(when (stringp arg) (do-something arg))",
          "when": "Defensive programming"
        },
        {
          "approach": "Convert types",
          "code": "(number-to-string n) or (string-to-number s)",
          "when": "Need type conversion"
        }
      ]
    }
  ]
}
