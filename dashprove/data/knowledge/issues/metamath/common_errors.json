{
  "tool": "metamath",
  "version": "0.x",
  "last_updated": "2025-12-23",
  "errors": [
    {
      "id": "syntax_error",
      "pattern": "syntax error",
      "message": "Syntax error at statement",
      "cause": "Invalid Metamath syntax",
      "solutions": [
        {
          "approach": "Check statement format",
          "code": "label $a wff ( ph -> ps ) $.",
          "when": "Missing or wrong delimiters"
        },
        {
          "approach": "Verify label uniqueness",
          "code": "(* Labels must be unique in database *)",
          "when": "Duplicate label"
        },
        {
          "approach": "Check whitespace",
          "code": "(* Tokens must be separated by whitespace *)",
          "when": "Missing spaces"
        }
      ]
    },
    {
      "id": "proof_error",
      "pattern": "proof incomplete",
      "message": "Proof verification failed",
      "cause": "Proof does not justify conclusion",
      "solutions": [
        {
          "approach": "Check proof labels",
          "code": "label $p statement $= ref1 ref2 ref3 $.",
          "when": "Missing proof step"
        },
        {
          "approach": "Verify substitutions",
          "code": "(* Ensure substitutions are consistent *)",
          "when": "Substitution mismatch"
        },
        {
          "approach": "Use proof assistant",
          "code": "metamath 'read set.mm' 'prove label' 'show proof label'",
          "when": "Need to debug proof"
        }
      ]
    },
    {
      "id": "undefined_label",
      "pattern": "undefined label",
      "message": "Label not found",
      "cause": "Reference to non-existent label",
      "solutions": [
        {
          "approach": "Check label existence",
          "code": "metamath 'read set.mm' 'search * label'",
          "when": "Label may be misspelled"
        },
        {
          "approach": "Check scope",
          "code": "(* Label must be in scope at point of use *)",
          "when": "Label out of scope"
        },
        {
          "approach": "Check database",
          "code": "(* Ensure required .mm file is loaded *)",
          "when": "Label in different database"
        }
      ]
    },
    {
      "id": "distinct_variable_violation",
      "pattern": "distinct variable",
      "message": "Distinct variable violation",
      "cause": "Variables required to be distinct are not",
      "solutions": [
        {
          "approach": "Check $d requirements",
          "code": "$d ph ps $.  (* Declare ph, ps distinct *)",
          "when": "Missing $d statement"
        },
        {
          "approach": "Use fresh variables",
          "code": "(* Use different variable names *)",
          "when": "Can avoid collision"
        },
        {
          "approach": "Review theorem requirements",
          "code": "metamath 'show statement label /full'",
          "when": "Need to see $d requirements"
        }
      ]
    },
    {
      "id": "type_mismatch",
      "pattern": "type mismatch",
      "message": "Expression type mismatch",
      "cause": "Expression has wrong syntactic type",
      "solutions": [
        {
          "approach": "Check type constants",
          "code": "$c wff class set $.",
          "when": "Using wrong type"
        },
        {
          "approach": "Add type hypothesis",
          "code": "$e wff ph $.",
          "when": "Missing type declaration"
        },
        {
          "approach": "Verify syntax axiom",
          "code": "(* Check corresponding syntax axiom *)",
          "when": "Wrong syntactic form"
        }
      ]
    },
    {
      "id": "unification_failure",
      "pattern": "unification",
      "message": "Unification failed",
      "cause": "Cannot match pattern to expression",
      "solutions": [
        {
          "approach": "Check expression form",
          "code": "(* Ensure expression matches theorem pattern *)",
          "when": "Wrong expression structure"
        },
        {
          "approach": "Apply definition",
          "code": "(* May need to expand or fold definitions *)",
          "when": "Definition blocking match"
        },
        {
          "approach": "Use different theorem",
          "code": "(* Find theorem with matching pattern *)",
          "when": "Theorem doesn't apply"
        }
      ]
    },
    {
      "id": "scope_error",
      "pattern": "scope",
      "message": "Statement out of scope",
      "cause": "Statement referenced outside its scope",
      "solutions": [
        {
          "approach": "Check block structure",
          "code": "${ ... $} (* Blocks define scope *)",
          "when": "Label defined in closed block"
        },
        {
          "approach": "Move statement",
          "code": "(* Move label before the ${ or after $} *)",
          "when": "Need wider scope"
        }
      ]
    },
    {
      "id": "compressed_proof_error",
      "pattern": "compressed proof",
      "message": "Error in compressed proof",
      "cause": "Invalid compressed proof format",
      "solutions": [
        {
          "approach": "Check proof format",
          "code": "$= ( ref1 ref2 ) ABCD $.",
          "when": "Wrong compressed format"
        },
        {
          "approach": "Expand proof",
          "code": "metamath 'read set.mm' 'save proof label /normal'",
          "when": "Debug with uncompressed form"
        },
        {
          "approach": "Recompress",
          "code": "metamath 'save proof label /compressed'",
          "when": "After fixing, recompress"
        }
      ]
    }
  ]
}
