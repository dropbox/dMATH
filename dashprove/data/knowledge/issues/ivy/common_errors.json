{
  "tool": "ivy",
  "version": "1.x",
  "last_updated": "2025-12-23",
  "errors": [
    {
      "id": "type_error",
      "pattern": "type error",
      "message": "Type checking failed",
      "cause": "Expression has wrong type",
      "solutions": [
        {
          "approach": "Check sort declarations",
          "code": "type node\nindividual n: node",
          "when": "Undeclared sort"
        },
        {
          "approach": "Check relation arity",
          "code": "relation link(node, node)",
          "when": "Wrong number of arguments"
        },
        {
          "approach": "Check function return type",
          "code": "function owner(file): node",
          "when": "Return type mismatch"
        }
      ]
    },
    {
      "id": "invariant_violation",
      "pattern": "invariant",
      "message": "Invariant check failed",
      "cause": "State violates invariant",
      "solutions": [
        {
          "approach": "Examine counterexample",
          "code": "# Ivy generates a trace showing violation",
          "when": "Understanding failure"
        },
        {
          "approach": "Strengthen invariant",
          "code": "invariant forall X, Y. link(X,Y) -> node(X) & node(Y)",
          "when": "Invariant too weak"
        },
        {
          "approach": "Add auxiliary invariant",
          "code": "# Inductive invariants may need strengthening",
          "when": "Invariant not inductive"
        }
      ]
    },
    {
      "id": "stratification_error",
      "pattern": "stratification",
      "message": "Stratification error",
      "cause": "Non-stratified negation or recursion",
      "solutions": [
        {
          "approach": "Break circular dependency",
          "code": "# Ensure no cycles through negation",
          "when": "Negation in cycle"
        },
        {
          "approach": "Use explicit stratification",
          "code": "after init { ... }  # temporal ordering",
          "when": "Need explicit ordering"
        }
      ]
    },
    {
      "id": "decidability_error",
      "pattern": "decidable",
      "message": "Verification problem undecidable",
      "cause": "Outside decidable fragment",
      "solutions": [
        {
          "approach": "Use EPR fragment",
          "code": "# Effectively Propositional: no function symbols",
          "when": "Using functions"
        },
        {
          "approach": "Add finite bounds",
          "code": "interpret node -> bv[3]  # 3-bit bounded",
          "when": "Infinite sorts"
        },
        {
          "approach": "Use stratified quantifiers",
          "code": "# Quantifiers must be stratified",
          "when": "Complex quantification"
        }
      ]
    },
    {
      "id": "syntax_error",
      "pattern": "syntax error",
      "message": "Parse error",
      "cause": "Invalid Ivy syntax",
      "solutions": [
        {
          "approach": "Check keywords",
          "code": "type, relation, function, action, invariant",
          "when": "Wrong keyword"
        },
        {
          "approach": "Check braces",
          "code": "action foo = { ... }",
          "when": "Missing braces"
        },
        {
          "approach": "Check operators",
          "code": "& (and), | (or), ~ (not), -> (implies)",
          "when": "Wrong operator"
        }
      ]
    },
    {
      "id": "uninitialized",
      "pattern": "uninitialized",
      "message": "Uninitialized variable",
      "cause": "Variable used before initialization",
      "solutions": [
        {
          "approach": "Add initialization",
          "code": "after init {\n    x := 0\n}",
          "when": "Missing init action"
        },
        {
          "approach": "Use assume",
          "code": "assume x > 0  # constrain initial state",
          "when": "Need constraint"
        }
      ]
    },
    {
      "id": "liveness_error",
      "pattern": "liveness",
      "message": "Liveness property violation",
      "cause": "Progress property not satisfied",
      "solutions": [
        {
          "approach": "Add fairness",
          "code": "fairness forall X. eventually foo(X)",
          "when": "Need fairness constraint"
        },
        {
          "approach": "Check temporal property",
          "code": "temporal property eventually P",
          "when": "Wrong temporal formula"
        }
      ]
    },
    {
      "id": "isolate_error",
      "pattern": "isolate",
      "message": "Isolate verification failed",
      "cause": "Isolate assumptions violated",
      "solutions": [
        {
          "approach": "Check interface",
          "code": "specification {\n    invariant ...\n}",
          "when": "Interface spec wrong"
        },
        {
          "approach": "Add assume/guarantee",
          "code": "# Ensure assumes are satisfied",
          "when": "Assumption violation"
        }
      ]
    }
  ]
}
