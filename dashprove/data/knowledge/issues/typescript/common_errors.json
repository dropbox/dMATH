{
  "tool": "typescript",
  "version": "5.3.0",
  "last_updated": "2025-12-23",
  "errors": [
    {
      "id": "ts2322",
      "pattern": "TS2322|Type .* is not assignable to type",
      "message": "Type assignment error",
      "cause": "Assigning incompatible type to variable/parameter",
      "solutions": [
        {
          "approach": "Fix the type",
          "code": "const value: string = String(numValue);",
          "when": "Need type conversion"
        },
        {
          "approach": "Use type assertion",
          "code": "const value = someValue as ExpectedType;",
          "when": "Know type better than TS"
        },
        {
          "approach": "Update type definition",
          "code": "type MyType = string | number;",
          "when": "Type should be broader"
        }
      ]
    },
    {
      "id": "ts2339",
      "pattern": "TS2339|Property .* does not exist on type",
      "message": "Property access error",
      "cause": "Accessing property not defined on type",
      "solutions": [
        {
          "approach": "Add type guard",
          "code": "if ('property' in obj) {\n  console.log(obj.property);\n}",
          "when": "Property may not exist"
        },
        {
          "approach": "Update interface",
          "code": "interface MyType {\n  property: string;\n}",
          "when": "Property should be defined"
        },
        {
          "approach": "Use optional chaining",
          "code": "const value = obj?.property;",
          "when": "Property is optional"
        }
      ]
    },
    {
      "id": "ts2345",
      "pattern": "TS2345|Argument of type .* is not assignable to parameter",
      "message": "Function argument type mismatch",
      "cause": "Passing wrong type to function",
      "solutions": [
        {
          "approach": "Convert argument",
          "code": "myFunc(value.toString());",
          "when": "Can convert type"
        },
        {
          "approach": "Update function signature",
          "code": "function myFunc(value: string | number) { ... }",
          "when": "Function should accept type"
        },
        {
          "approach": "Check null/undefined",
          "code": "if (value !== undefined) {\n  myFunc(value);\n}",
          "when": "Possible undefined"
        }
      ]
    },
    {
      "id": "ts2304",
      "pattern": "TS2304|Cannot find name",
      "message": "Undefined identifier",
      "cause": "Using variable/type not in scope",
      "solutions": [
        {
          "approach": "Import module",
          "code": "import { MyType } from './types';",
          "when": "Need to import"
        },
        {
          "approach": "Declare global",
          "code": "declare global {\n  interface Window {\n    myGlobal: string;\n  }\n}",
          "when": "Global variable"
        },
        {
          "approach": "Install types",
          "code": "npm install --save-dev @types/lodash",
          "when": "Missing type definitions"
        }
      ]
    },
    {
      "id": "ts7006",
      "pattern": "TS7006|Parameter .* implicitly has an 'any' type",
      "message": "Implicit any parameter",
      "cause": "Function parameter missing type annotation",
      "solutions": [
        {
          "approach": "Add type annotation",
          "code": "function foo(param: string) { ... }",
          "when": "Know the type"
        },
        {
          "approach": "Use generic",
          "code": "function foo<T>(param: T): T { return param; }",
          "when": "Type should be flexible"
        },
        {
          "approach": "Disable noImplicitAny",
          "code": "// tsconfig.json: \"noImplicitAny\": false",
          "when": "Migrating JS codebase"
        }
      ]
    },
    {
      "id": "ts2531",
      "pattern": "TS2531|Object is possibly 'null'",
      "message": "Possible null/undefined value",
      "cause": "Accessing property on potentially null value",
      "solutions": [
        {
          "approach": "Add null check",
          "code": "if (value !== null) {\n  value.property;\n}",
          "when": "Value might be null"
        },
        {
          "approach": "Use optional chaining",
          "code": "const prop = value?.property;",
          "when": "Want undefined fallback"
        },
        {
          "approach": "Use non-null assertion",
          "code": "const prop = value!.property;",
          "when": "Know value is not null"
        },
        {
          "approach": "Use nullish coalescing",
          "code": "const prop = value?.property ?? 'default';",
          "when": "Have default value"
        }
      ]
    },
    {
      "id": "ts1005",
      "pattern": "TS1005|.* expected",
      "message": "Syntax error",
      "cause": "Missing or extra syntax token",
      "solutions": [
        {
          "approach": "Check brackets",
          "code": "// Ensure matching { }, [ ], ( )",
          "when": "Mismatched brackets"
        },
        {
          "approach": "Check semicolons",
          "code": "// Add or remove semicolon",
          "when": "Missing semicolon"
        },
        {
          "approach": "Check arrow syntax",
          "code": "const fn = (x: number) => x * 2;",
          "when": "Arrow function error"
        }
      ]
    },
    {
      "id": "ts2307",
      "pattern": "TS2307|Cannot find module",
      "message": "Module not found",
      "cause": "Import path incorrect or module not installed",
      "solutions": [
        {
          "approach": "Install package",
          "code": "npm install package-name",
          "when": "Package not installed"
        },
        {
          "approach": "Fix path",
          "code": "import { foo } from './relative/path';",
          "when": "Wrong import path"
        },
        {
          "approach": "Configure paths",
          "code": "// tsconfig.json: \"paths\": { \"@/*\": [\"src/*\"] }",
          "when": "Using path aliases"
        }
      ]
    }
  ]
}
