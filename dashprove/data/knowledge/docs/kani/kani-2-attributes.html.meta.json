{
  "id": "kani-2-attributes.html",
  "source": "https://model-checking.github.io/kani/reference/attributes.html",
  "backend": "Kani",
  "title": "Attributes - The Kani Rust Verifier",
  "content": "# [Attributes][1]\n\nIn Kani, attributes are used to mark functions as harnesses and control their\nexecution. This section explains the attributes available in Kani and how they\naffect the verification process.\n\nAt present, the available Kani attributes are the following:\n\n* [`#[kani::proof]`][2]\n* [`#[kani::should_panic]`][3]\n* [`#[kani::unwind(<number>)]`][4]\n* [`#[kani::solver(<solver>)]`][5]\n* [`#[kani::stub(<original>, <replacement>)]`][6]\n* [Contract-related attributes][7]\n\n## [`#[kani::proof]`][8]\n\n**The `#[kani::proof]` attribute specifies that a [function][9] is a proof\nharness.**\n\nProof harnesses are similar to test harnesses, especially property-based test\nharnesses, and they may use functions from the Kani API (e.g., `kani::any()`). A\nproof harness is the smallest verification unit in Kani.\n\nWhen Kani is run, either through `kani` or `cargo kani`, it'll first collect all\nproof harnesses (i.e., functions with the attribute `#[kani::proof]`) and then\nattempt to verify them.\n\n### [Example][10]\n\nIf we run Kani on this example:\n\n`#[kani::proof]\nfn my_harness() {\n    assert!(1 + 1 == 2);\n}\n`\n\nWe should see a line in the output that says `Checking harness my_harness...`\n(assuming `my_harness` is the only harness in our code). This will be followed\nby multiple messages that come from CBMC (the verification engine used by Kani)\nand the [verification results][11].\n\nUsing any other Kani attribute without `#[kani::proof]` will result in\ncompilation errors.\n\n### [Limitations][12]\n\nThe `#[kani::proof]` attribute can only be added to functions without\nparameters.\n\n## [`#[kani::should_panic]`][13]\n\n**The `#[kani::should_panic]` attribute specifies that a proof harness is\nexpected to panic.**\n\nThis attribute allows users to exercise *negative verification*. It's analogous\nto how [`#[should_panic]`][14] allows users to exercise [negative testing][15]\nfor Rust unit tests.\n\nThis attribute **only affects the overall verification result**. In particular,\nusing the `#[kani::should_panic]` attribute will return one of the following\nresults:\n\n* `VERIFICATION:- FAILED (encountered no panics, but at least one was expected)`\n  if there were no failed checks.\n* `VERIFICATION:- FAILED (encountered failures other than panics, which were\n  unexpected)` if there were failed checks but not all them were related to\n  panics.\n* `VERIFICATION:- SUCCESSFUL (encountered one or more panics as expected)`\n  otherwise.\n\nAt the moment, to determine if a check is related to a panic, we check if its\nclass is `assertion`. The class is the second member in the property name, the\ntriple that's printed after `Check X: `: `<function>.<class>.<number>`. For\nexample, the class in `Check 1: my_harness.assertion.1` is `assertion`, so this\ncheck is considered to be related to a panic.\n\n> **NOTE**: The `#[kani::should_panic]` is only recommended for writing\n> harnesses which complement existing harnesses that don't use the same\n> attribute. In other words, it's only recommended to write *negative harnesses*\n> after having written *positive* harnesses that successfully verify interesting\n> properties about the function under verification.\n\n### [Limitations][16]\n\nThe `#[kani::should_panic]` attribute verifies that there are one or more failed\nchecks related to panics. At the moment, it's not possible to pin it down to\nspecific panics. Therefore, **it's possible that the panics detected with\n`#[kani::should_panic]` aren't the ones that were originally expected** after a\nchange in the code under verification.\n\n### [Example][17]\n\nLet's assume we're using the `Device` from this example:\n\n`struct Device {\n    is_init: bool,\n}\n\nimpl Device {\n    fn new() -> Self {\n        Device { is_init: false }\n    }\n\n    fn init(&mut self) {\n        assert!(!self.is_init);\n        self.is_init = true;\n    }\n}\n`\n\nWe may want to verify that calling `device.init()` more than once should result\nin a panic. We can do so with the following harness:\n\n`#[kani::proof]\n#[kani::should_panic]\nfn cannot_init_device_twice() {\n    let mut device = Device::new();\n    device.init();\n    device.init();\n}\n`\n\nRunning Kani on it will produce the result `VERIFICATION:- SUCCESSFUL\n(encountered one or more panics as expected)`\n\n## [`#[kani::unwind(<number>)]`][18]\n\n**The `#[kani::unwind(<number>)]` attribute specifies that all loops must be\nunwound up to `<number>` times.**\n\nBy default, Kani attempts to unwind all loops automatically. However, this\nunwinding process doesn't always terminate. The `#[kani::unwind(<number>)]`\nattribute will:\n\n1. Disable automatic unwinding.\n2. Unwind all loops up to `<number>` times.\n\nAfter the unwinding stage, Kani will attempt to verify the harness. If the\n`#[kani::unwind(<number>)]` attribute was specified, there's a chance that one\nor more loops weren't unwound enough times. In that case, there will be at least\none failed unwinding assertion (there's one unwinding assertion for each loop),\ncausing verification to fail.\n\nCheck the [*Loops, unwinding and bounds* section][19] for more information about\nunwinding.\n\n### [Example][20]\n\nLet's assume we've written this code which contains a loop:\n\n`fn my_sum(vec: &Vec<u32>) -> u32 {\n    let mut sum = 0;\n    for elem in vec {\n        sum += elem;\n    }\n    sum\n}\n\n#[kani::proof]\nfn my_harness() {\n    let vec = vec![1, 2, 3];\n    let sum = my_sum(&vec);\n    assert!(sum == 6);\n}\n`\n\nRunning this example on Kani will produce a successful verification result. In\nthis case, Kani automatically finds the required unwinding value (i.e., the\nnumber of times it needs to unwind all loops). This means that the\n`#[kani::unwind(<number>)]` attribute isn't needed, as we'll see soon. In\ngeneral, the required unwinding value is equal to the maximum number of\niterations for all loops, plus one. The required unwinding value in this example\nis 4: the 3 iterations in the `for elem in vec` loop, plus 1.\n\nLet's see what happens if we force a lower unwinding value with\n`#[kani::unwind(3)]`:\n\n`#[kani::proof]\n#[kani::unwind(3)]\nfn my_harness() {\n    let vec = vec![1, 2, 3];\n    let sum = my_sum(&vec);\n    assert!(sum == 6);\n}\n`\n\nAs we mentioned, trying to verify this harness causes an unwinding failure:\n\n`SUMMARY:\n ** 1 of 187 failed (186 undetermined)\nFailed Checks: unwinding assertion loop 0\n File: \"/home/ubuntu/devices/src/main.rs\", line 32, in my_sum\n\nVERIFICATION:- FAILED\n[Kani] info: Verification output shows one or more unwinding failures.\n[Kani] tip: Consider increasing the unwinding value or disabling `--unwinding-as\nsertions`.\n`\n\nKani cannot verify the harness because there is at least one unwinding assertion\nfailure. But, if we use `#[kani::unwind(4)]`, which is the right unwinding value\nwe computed earlier:\n\n`#[kani::proof]\n#[kani::unwind(4)]\nfn my_harness() {\n    let vec = vec![1, 2, 3];\n    let sum = my_sum(&vec);\n    assert!(sum == 6);\n}\n`\n\nWe'll get a successful result again:\n\n`SUMMARY:\n ** 0 of 186 failed\n\nVERIFICATION:- SUCCESSFUL\n`\n\n## [`#[kani::solver(<solver>)]`][21]\n\n**Changes the solver to be used by Kani's verification engine (CBMC).**\n\nThis may change the verification time required to verify a harness.\n\nAt present, `<solver>` can be one of:\n\n* `minisat`: [MiniSat][22].\n* `cadical` (default): [CaDiCaL][23].\n* `kissat`: [kissat][24].\n* `z3`: [Z3][25].\n* `bitwuzla`: [Bitwuzla][26].\n* `cvc5`: [cvc5][27].\n* `bin=\"<SAT_SOLVER_BINARY>\"`: A custom solver binary, `\"<SAT_SOLVER_BINARY>\"`,\n  that must be in path.\n\n### [Example][28]\n\nKani will use the CaDiCaL solver in the following example:\n\n`#[kani::proof]\n#[kani::solver(cadical)]\nfn check() {\n    let mut a = [2, 3, 1];\n    a.sort();\n    assert_eq!(a[0], 1);\n    assert_eq!(a[1], 2);\n    assert_eq!(a[2], 3);\n}\n`\n\nChanging the solver may result in different verification times depending on the\nharness.\n\nNote that the default solver may vary depending on Kani's version. We highly\nrecommend users to annotate their harnesses if the choice of solver has a major\nimpact on performance, even if the solver used is the current default one.\n\n## [`#[kani::stub(<original>, <replacement>)]`][29]\n\n**Replaces the function/method with name with the function/method with name\nduring compilation**\n\nCheck the [*Stubbing* section][30] for more information about stubbing.\n\n## [Contract Attributes][31]\n\nThere are numerous attributes for function and loop contracts. At present, these\nare:\n\n* Proof harness for contracts: `#[kani::proof_for_contract(name-of-function)]`\n* Verified stubbing: `#[kani::stub_verified]`\n* Function contract specification: `#[kani::requires]`, `#[kani::modifies]`,\n  `#[kani::ensures]`, `#[kani::recursion]`\n* Loop contract specification: `#[kani::loop_invariant]`,\n  `#[kani::loop_modifies]`.\n\nSee the documentation on [function contracts][32] and [loop contracts][33] for\ndetails.\n\n[1]: #attributes\n[2]: #kaniproof\n[3]: #kanishould_panic\n[4]: #kaniunwindnumber\n[5]: #kanisolversolver\n[6]: #kanistuboriginal-replacement\n[7]: #contract-attributes\n[8]: #kaniproof\n[9]: https://doc.rust-lang.org/reference/items/functions.html\n[10]: #example\n[11]: ../verification-results.html\n[12]: #limitations\n[13]: #kanishould_panic\n[14]: https://doc.rust-lang.org/rust-by-example/testing/unit_testing.html#testin\ng-panics\n[15]: https://en.wikipedia.org/wiki/Negative_testing\n[16]: #limitations-1\n[17]: #example-1\n[18]: #kaniunwindnumber\n[19]: ../tutorial-loop-unwinding.html\n[20]: #example-2\n[21]: #kanisolversolver\n[22]: http://minisat.se/\n[23]: https://github.com/arminbiere/cadical\n[24]: https://github.com/arminbiere/kissat\n[25]: https://github.com/Z3Prover/z3/\n[26]: https://github.com/bitwuzla/bitwuzla\n[27]: https://github.com/cvc5/cvc5\n[28]: #example-3\n[29]: #kanistuboriginal-replacement\n[30]: ../reference/experimental/stubbing.html\n[31]: #contract-attributes\n[32]: ./experimental/contracts.html\n[33]: ./experimental/loop-contracts.html\n",
  "content_type": "Api",
  "fetched_at": "2025-12-19T17:31:23.391061Z",
  "metadata": {
    "sections": [
      "The Kani Rust Verifier",
      "Attributes",
      "#[kani::proof]",
      "Example",
      "Limitations",
      "#[kani::should_panic]",
      "Limitations",
      "Example",
      "#[kani::unwind(<number>)]",
      "Example",
      "#[kani::solver(<solver>)]",
      "Example",
      "#[kani::stub(<original>, <replacement>)]",
      "Contract Attributes"
    ],
    "tags": [],
    "code_blocks": [
      {
        "language": "rust",
        "code": "#[kani::proof]\nfn my_harness() {\n    assert!(1 + 1 == 2);\n}\n",
        "description": null
      },
      {
        "language": "rust",
        "code": "struct Device {\n    is_init: bool,\n}\n\nimpl Device {\n    fn new() -> Self {\n        Device { is_init: false }\n    }\n\n    fn init(&mut self) {\n        assert!(!self.is_init);\n        self.is_init = true;\n    }\n}\n",
        "description": null
      },
      {
        "language": "rust",
        "code": "#[kani::proof]\n#[kani::should_panic]\nfn cannot_init_device_twice() {\n    let mut device = Device::new();\n    device.init();\n    device.init();\n}\n",
        "description": null
      },
      {
        "language": "rust",
        "code": "fn my_sum(vec: &Vec<u32>) -> u32 {\n    let mut sum = 0;\n    for elem in vec {\n        sum += elem;\n    }\n    sum\n}\n\n#[kani::proof]\nfn my_harness() {\n    let vec = vec![1, 2, 3];\n    let sum = my_sum(&vec);\n    assert!(sum == 6);\n}\n",
        "description": null
      },
      {
        "language": "rust",
        "code": "#[kani::proof]\n#[kani::unwind(3)]\nfn my_harness() {\n    let vec = vec![1, 2, 3];\n    let sum = my_sum(&vec);\n    assert!(sum == 6);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "SUMMARY:\n ** 1 of 187 failed (186 undetermined)\nFailed Checks: unwinding assertion loop 0\n File: \"/home/ubuntu/devices/src/main.rs\", line 32, in my_sum\n\nVERIFICATION:- FAILED\n[Kani] info: Verification output shows one or more unwinding failures.\n[Kani] tip: Consider increasing the unwinding value or disabling `--unwinding-assertions`.\n",
        "description": null
      },
      {
        "language": "rust",
        "code": "#[kani::proof]\n#[kani::unwind(4)]\nfn my_harness() {\n    let vec = vec![1, 2, 3];\n    let sum = my_sum(&vec);\n    assert!(sum == 6);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "SUMMARY:\n ** 0 of 186 failed\n\nVERIFICATION:- SUCCESSFUL\n",
        "description": null
      },
      {
        "language": "rust",
        "code": "#[kani::proof]\n#[kani::solver(cadical)]\nfn check() {\n    let mut a = [2, 3, 1];\n    a.sort();\n    assert_eq!(a[0], 1);\n    assert_eq!(a[1], 2);\n    assert_eq!(a[2], 3);\n}\n",
        "description": null
      }
    ],
    "original_format": "html",
    "word_count": 1277
  }
}