{
  "id": "verus-0-",
  "source": "https://verus-lang.github.io/verus/guide/",
  "backend": "Verus",
  "title": "Verus overview - Verus Tutorial and Reference",
  "content": "# [Verus overview][1]\n\nVerus is a tool for verifying the correctness of code written in Rust. The main\ngoal is to verify full functional correctness of low-level systems code,\nbuilding on ideas from existing verification frameworks like [Dafny][2],\n[Boogie][3], [F*][4], [VCC][5], [Prusti][6], [Creusot][7], [Aeneas][8],\n[Cogent][9], [Rocq][10], and [Isabelle/HOL][11]. Verification is static: Verus\nadds no run-time checks, but instead uses computer-aided theorem proving to\nstatically verify that executable Rust code will always satisfy some\nuser-provided specifications for all possible executions of the code.\n\nIn more detail, Verus aims to:\n\n* provide a pure mathematical language for expressing specifications (like\n  Dafny, Creusot, F*, Coq, Isabelle/HOL)\n* provide a mathematical language for expressing proofs (like Dafny, F*, Coq,\n  Isabelle/HOL) based exclusively on classical logic (like Dafny)\n* provide a low-level, imperative language for expressing executable code (like\n  VCC), based on Rust (like Prusti, Creusot, and Aeneas)\n* generate small, simple verification conditions that an SMT solver like\n  [Z3][12] can solve efficiently, based on the following principles:\n  \n  * keep the mathematical specification language close to the SMT solver’s\n    mathematical language (like Boogie)\n  * use lightweight linear type checking, rather than SMT solving, to reason\n    about memory and aliasing (like Cogent, Creusot, Aeneas, and [linear\n    Dafny][13])\n\nWe believe that Rust is a good language for achieving these goals. Rust combines\nlow-level data manipulation, including manual memory management, with an\nadvanced, high-level, safe type system. The type system includes features\ncommonly found in higher-level verification languages, including algebraic\ndatatypes (with pattern matching), type classes, and first-class functions. This\nmakes it easy to express specifications and proofs in a natural way. More\nimportantly, Rust’s type system includes sophisticated support for linear types\nand borrowing, which takes care of much of the reasoning about memory and\naliasing. As a result, the remaining reasoning can ignore most memory and\naliasing issues, and treat the Rust code as if it were code written in a purely\nfunctional language, which makes verification easier.\n\nAt present, we do not intend to:\n\n* support all Rust features and libraries (instead, we will focus a high-value\n  features and libraries needed to support our users)\n* verify the verifier itself\n* verify the Rust/LLVM compilers\n\n# [This guide][14]\n\nThis guide assumes that you’re already somewhat familiar with the basics of Rust\nprogramming. (If you’re not, we recommend spending a couple hours on the [Learn\nRust][15] page.) Familiarity with Rust is useful for Verus, because Verus builds\non Rust’s syntax and Rust’s type system to express specifications, proofs, and\nexecutable code. In fact, there is no separate language for specifications and\nproofs; instead, specifications and proofs are written in Rust syntax and\ntype-checked with Rust’s type checker. So if you already know Rust, you’ll have\nan easier time getting started with Verus.\n\nNevertheless, verifying the correctness of Rust code requires concepts and\ntechniques beyond just writing ordinary executable Rust code. For example, Verus\nextends Rust’s syntax (via macros) with new concepts for writing specifications\nand proofs, such as `forall`, `exists`, `requires`, and `ensures`, as well as\nintroducing new types, like the mathematical integer types `int` and `nat`. It\ncan be challenging to prove that a Rust function satisfies its postconditions\n(its `ensures` clauses) or that a call to a function satisfies the function’s\npreconditions (its `requires` clauses). Therefore, this guide’s tutorial will\nwalk you through the various concepts and techniques, starting with relatively\nsimple concepts (basic proofs about integers), moving on to more moderately\ndifficult challenges (inductive proofs about data structures), and then on to\nmore advanced topics such as proofs about arrays using `forall` and `exists` and\nproofs about concurrent code.\n\nAll of these proofs are aided by an automated theorem prover (specifically,\n[Z3][16], a satisfiability-modulo-theories solver, or “SMT solver” for short).\nThe SMT solver will often be able to prove simple properties, such as basic\nproperties about booleans or integer arithmetic, with no additional help from\nthe programmer. However, more complex proofs often require effort from both the\nprogrammer and the SMT solver. Therefore, this guide will also help you\nunderstand the strengths and limitations of SMT solving, and give advice on how\nto fill in the parts of proofs that SMT solvers cannot handle automatically.\n(For example, SMT solvers usually cannot automatically perform proofs by\ninduction, but you can write a proof by induction simply by writing a recursive\nRust function whose `ensures` clause expresses the induction hypothesis.)\n\n[1]: #verus-overview\n[2]: https://github.com/dafny-lang/dafny\n[3]: https://github.com/boogie-org/boogie\n[4]: https://github.com/FStarLang/FStar\n[5]: https://www.microsoft.com/en-us/research/project/vcc-a-verifier-for-concurr\nent-c/\n[6]: https://github.com/viperproject/prusti-dev\n[7]: https://github.com/xldenis/creusot\n[8]: https://github.com/AeneasVerif/aeneas\n[9]: https://github.com/NICTA/cogent\n[10]: https://rocq-prover.org/\n[11]: https://isabelle.in.tum.de/overview.html\n[12]: https://microsoft.github.io/z3guide/docs/logic/intro\n[13]: https://github.com/secure-foundations/dafny/tree/betr/docs/Linear\n[14]: #this-guide\n[15]: https://www.rust-lang.org/learn\n[16]: https://microsoft.github.io/z3guide/docs/logic/intro\n",
  "content_type": "Reference",
  "fetched_at": "2025-12-19T17:32:16.556763Z",
  "metadata": {
    "sections": [
      "Verus Tutorial and Reference",
      "Verus overview",
      "This guide"
    ],
    "tags": [],
    "code_blocks": [],
    "original_format": "html",
    "word_count": 758
  }
}