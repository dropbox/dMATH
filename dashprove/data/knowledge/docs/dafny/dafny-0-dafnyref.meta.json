{
  "id": "dafny-0-dafnyref",
  "source": "https://dafny.org/dafny/DafnyRef/DafnyRef",
  "backend": "Dafny",
  "title": "Dafny Documentation",
  "content": "Dafny Reference Manual\n\nThe dafny-lang community\n\nDevelopment version\n\n**Abstract:** This is the Dafny reference manual; it describes the Dafny\nprogramming language and how to use the Dafny verification system. Parts of this\nmanual are more tutorial in nature in order to help the user understand how to\ndo proofs with Dafny.\n\n[(Link to current document as html)][1]\n\n* [1. Introduction][2]\n  \n  * [1.1. Dafny 4.0][3]\n  * [1.2. Dafny Example][4]\n* [2. Lexical and Low Level Grammar][5]\n  \n  * [2.1. Dafny Input][6]\n  * [2.2. Tokens and whitespace][7]\n  * [2.3. Character Classes][8]\n  * [2.4. Comments][9]\n  * [2.5. Documentation comments][10]\n  * [2.6. Tokens (grammar)][11]\n    \n    * [2.6.1. Reserved Words][12]\n    * [2.6.2. Identifiers][13]\n    * [2.6.3. Digits][14]\n    * [2.6.4. Escaped Character][15]\n    * [2.6.5. Character Constant Token][16]\n    * [2.6.6. String Constant Token][17]\n    * [2.6.7. Ellipsis][18]\n  * [2.7. Low Level Grammar Productions][19]\n    \n    * [2.7.1. Identifier Variations][20]\n      \n      * [2.7.1.1. Identifier][21]\n      * [2.7.1.2. No-underscore-identifier][22]\n      * [2.7.1.3. Wild identifier][23]\n    * [2.7.2. Qualified Names][24]\n    * [2.7.3. Identifier-Type Combinations][25]\n    * [2.7.4. Quantifier Domains (grammar)][26]\n    * [2.7.5. Numeric Literals (grammar)][27]\n* [3. Programs (grammar)][28]\n  \n  * [3.1. Include Directives (grammar)][29]\n  * [3.2. Top Level Declarations (grammar)][30]\n  * [3.3. Declaration Modifiers (grammar)][31]\n  * [3.4. Executable programs][32]\n* [4. Modules (grammar)][33]\n  \n  * [4.1. Declaring New Modules (grammar)][34]\n  * [4.2. Declaring nested modules standalone][35]\n  * [4.3. Importing Modules (grammar)][36]\n  * [4.4. Opening Modules][37]\n  * [4.5. Export Sets and Access Control (grammar)][38]\n    \n    * [4.5.1. Provided and revealed names][39]\n    * [4.5.2. Extends list][40]\n  * [4.6. Module Abstraction][41]\n  * [4.7. Module Ordering and Dependencies][42]\n  * [4.8. Name Resolution][43]\n    \n    * [4.8.1. Modules and name spaces][44]\n    * [4.8.2. Module Id Context Name Resolution][45]\n    * [4.8.3. Expression Context Name Resolution][46]\n    * [4.8.4. Type Context Name Resolution][47]\n* [5. Types][48]\n  \n  * [5.1. Kinds of types][49]\n    \n    * [5.1.1. Value Types][50]\n    * [5.1.2. Reference Types][51]\n    * [5.1.3. Named Types (grammar)][52]\n  * [5.2. Basic types][53]\n    \n    * [5.2.1. Booleans (grammar)][54]\n      \n      * [5.2.1.1. Equivalence Operator][55]\n      * [5.2.1.2. Conjunction and Disjunction][56]\n      * [5.2.1.3. Implication and Reverse Implication][57]\n    * [5.2.2. Numeric Types (grammar)][58]\n    * [5.2.3. Floating-point Types (fp32 and fp64)][59]\n      \n      * [5.2.3.1. Literals][60]\n      * [5.2.3.2. Special Values][61]\n      * [5.2.3.3. Classification Predicates][62]\n      * [5.2.3.4. Arithmetic Operations][63]\n      * [5.2.3.5. Equality][64]\n      * [5.2.3.6. Unchecked Arithmetic and Comparison Methods][65]\n      * [5.2.3.7. Mathematical Functions][66]\n      * [5.2.3.8. Type Conversions][67]\n      * [5.2.3.9. Inexact Conversion Methods][68]\n      * [5.2.3.10. Comparison of Numeric Types][69]\n    * [5.2.4. Bit-vector Types (grammar)][70]\n    * [5.2.5. Ordinal type (grammar)][71]\n    * [5.2.6. Characters (grammar)][72]\n  * [5.3. Type parameters (grammar)][73]\n    \n    * [5.3.1. Declaring restrictions on type parameters][74]\n      \n      * [5.3.1.1. Equality-supporting type parameters: `T(==)`][75]\n      * [5.3.1.2. Auto-initializable types: `T(0)`][76]\n      * [5.3.1.3. Nonempty types: `T(00)`][77]\n      * [5.3.1.4. Non-heap based: `T(!new)`][78]\n    * [5.3.2. Type parameter variance][79]\n  * [5.4. Generic Instantiation (grammar)][80]\n  * [5.5. Collection types][81]\n    \n    * [5.5.1. Sets (grammar)][82]\n    * [5.5.2. Multisets (grammar)][83]\n    * [5.5.3. Sequences (grammar)][84]\n      \n      * [5.5.3.1. Sequence Displays][85]\n      * [5.5.3.2. Sequence Relational Operators][86]\n      * [5.5.3.3. Sequence Concatenation][87]\n      * [5.5.3.4. Other Sequence Expressions][88]\n      * [5.5.3.5. Strings (grammar)][89]\n    * [5.5.4. Finite and Infinite Maps (grammar)][90]\n    * [5.5.5. Iterating over collections][91]\n      \n      * [5.5.5.1. Sequences and arrays][92]\n      * [5.5.5.2. Sets][93]\n      * [5.5.5.3. Maps][94]\n  * [5.6. Types that stand for other types (grammar)][95]\n    \n    * [5.6.1. Type synonyms (grammar)][96]\n    * [5.6.2. Abstract types (grammar)][97]\n    * [5.6.3. Subset types (grammar)][98]\n      \n      * [5.6.3.1. Type `nat`][99]\n      * [5.6.3.2. Non-null types][100]\n      * [5.6.3.3. Arrow types: `->`, `-->`, and `~>`][101]\n      * [5.6.3.4. Witness clauses][102]\n  * [5.7. Newtypes (grammar)][103]\n    \n    * [5.7.1. Conversion operations][104]\n  * [5.8. Class types (grammar)][105]\n  * [5.9. Trait types (grammar)][106]\n    \n    * [5.9.1. Type `object` (grammar)][107]\n    * [5.9.2. Inheritance][108]\n    * [5.9.3. Example of traits][109]\n  * [5.10. Array types (grammar)][110]\n    \n    * [5.10.1. One-dimensional arrays][111]\n    * [5.10.2. Converting arrays to sequences][112]\n    * [5.10.3. Multi-dimensional arrays][113]\n  * [5.11. Iterator types (grammar)][114]\n  * [5.12. Arrow types (grammar)][115]\n  * [5.13. Tuple types][116]\n  * [5.14. Algebraic Datatypes (grammar)][117]\n    \n    * [5.14.1. Inductive datatypes][118]\n    * [5.14.2. Coinductive datatypes][119]\n    * [5.14.3. Coinduction][120]\n      \n      * [5.14.3.1. Well-Founded Function/Method Definitions][121]\n      * [5.14.3.2. Defining Coinductive Datatypes][122]\n      * [5.14.3.3. Creating Values of Co-datatypes][123]\n      * [5.14.3.4. Co-Equality][124]\n      * [5.14.3.5. Greatest predicates][125]\n      * [5.14.3.6. Coinductive Proofs][126]\n        \n        * [5.14.3.6.1. Properties of Prefix Predicates][127]\n        * [5.14.3.6.2. Greatest lemmas][128]\n        * [5.14.3.6.3. Prefix Lemmas][129]\n      * [5.14.3.7. Abstemious and voracious functions][130]\n* [6. Member declarations][131]\n  \n  * [6.1. Field Declarations (grammar)][132]\n  * [6.2. Constant Field Declarations (grammar)][133]\n  * [6.3. Method Declarations (grammar)][134]\n    \n    * [6.3.1. Ordinary methods][135]\n    * [6.3.2. Constructors][136]\n      \n      * [6.3.2.1. Classes with no explicit constructors][137]\n      * [6.3.2.2. Classes with one or more constructors][138]\n      * [6.3.2.3. Two-phase constructors][139]\n    * [6.3.3. Lemmas][140]\n    * [6.3.4. Two-state lemmas and functions][141]\n  * [6.4. Function Declarations (grammar)][142]\n    \n    * [6.4.1. Functions][143]\n    * [6.4.2. Predicates][144]\n    * [6.4.3. Function-by-method][145]\n    * [6.4.4. Function Hiding][146]\n    * [6.4.5. Extreme (Least or Greatest) Predicates and Lemmas][147]\n    * [6.4.6. `older` parameters in predicates][148]\n  * [6.5. Nameonly Formal Parameters and Default-Value Expressions][149]\n* [7. Specifications][150]\n  \n  * [7.1. Specification Clauses][151]\n    \n    * [7.1.1. Requires Clause (grammar)][152]\n    * [7.1.2. Ensures Clause (grammar)][153]\n    * [7.1.3. Decreases Clause (grammar)][154]\n    * [7.1.4. Framing (grammar)][155]\n    * [7.1.5. Reads Clause (grammar)][156]\n    * [7.1.6. Modifies Clause (grammar)][157]\n    * [7.1.7. Invariant Clause (grammar)][158]\n  * [7.2. Method Specification (grammar)][159]\n  * [7.3. Function Specification (grammar)][160]\n  * [7.4. Lambda Specification (grammar)][161]\n  * [7.5. Iterator Specification (grammar)][162]\n  * [7.6. Loop Specification (grammar)][163]\n  * [7.7. Auto-generated boilerplate specifications][164]\n  * [7.8. Well-formedness of specifications][165]\n* [8. Statements (grammar)][166]\n  \n  * [8.1. Labeled Statement (grammar)][167]\n  * [8.2. Block Statement (grammar)][168]\n  * [8.3. Return Statement (grammar)][169]\n  * [8.4. Yield Statement (grammar)][170]\n  * [8.5. Update and Call Statements (grammar)][171]\n    \n    * [8.5.1. Method call with no out-parameters][172]\n    * [8.5.2. Method call with out-parameters][173]\n    * [8.5.3. Parallel assignment][174]\n    * [8.5.4. Havoc assignment][175]\n    * [8.5.5. Such-that assignment][176]\n    * [8.5.6. Method call with a `by` proof][177]\n  * [8.6. Update with Failure Statement (`:-`) (grammar)][178]\n    \n    * [8.6.1. Failure compatible types][179]\n    * [8.6.2. Simple status return with no other outputs][180]\n    * [8.6.3. Status return with additional outputs][181]\n    * [8.6.4. Failure-returns with additional data][182]\n    * [8.6.5. RHS with expression list][183]\n    * [8.6.6. Failure with initialized declaration.][184]\n    * [8.6.7. Keyword alternative][185]\n    * [8.6.8. Key points][186]\n    * [8.6.9. Failure returns and exceptions][187]\n  * [8.7. Variable Declaration Statement (grammar)][188]\n  * [8.8. Guards (grammar)][189]\n  * [8.9. Binding Guards (grammar)][190]\n  * [8.10. If Statement (grammar)][191]\n  * [8.11. Match Statement (grammar)][192]\n  * [8.12. While Statement (grammar)][193]\n  * [8.13. For Loops (grammar)][194]\n  * [8.14. Break and Continue Statements (grammar)][195]\n  * [8.15. Loop Specifications][196]\n    \n    * [8.15.1. Loop invariants][197]\n    * [8.15.2. Loop termination][198]\n    * [8.15.3. Loop framing][199]\n    * [8.15.4. Body-less methods, functions, loops, and aggregate\n      statements][200]\n  * [8.16. Print Statement (grammar)][201]\n  * [8.17. Assert statement (grammar)][202]\n  * [8.18. Assume Statement (grammar)][203]\n  * [8.19. Expect Statement (grammar)][204]\n  * [8.20. Reveal Statement (grammar)][205]\n    \n    * [8.20.1. Revealing assertions][206]\n    * [8.20.2. Revealing preconditions][207]\n    * [8.20.3. Hiding and revealing function bodies][208]\n    * [8.20.4. Revealing constants][209]\n  * [8.21. Forall Statement (grammar)][210]\n  * [8.22. Modify Statement (grammar)][211]\n  * [8.23. Calc Statement (grammar)][212]\n  * [8.24. Opaque Block (grammar)][213]\n* [9. Expressions][214]\n  \n  * [9.1. Lemma-call expressions (grammar)][215]\n  * [9.2. Equivalence Expressions (grammar)][216]\n  * [9.3. Implies or Explies Expressions (grammar)][217]\n  * [9.4. Logical Expressions (grammar)][218]\n  * [9.5. Relational Expressions (grammar)][219]\n  * [9.6. Bit Shifts (grammar)][220]\n  * [9.7. Terms (grammar)][221]\n  * [9.8. Factors (grammar)][222]\n  * [9.9. Bit-vector Operations (grammar)][223]\n  * [9.10. As (Conversion) and Is (type test) Expressions (grammar)][224]\n  * [9.11. Unary Expressions (grammar)][225]\n  * [9.12. Primary Expressions (grammar)][226]\n  * [9.13. Lambda expressions (grammar)][227]\n  * [9.14. Left-Hand-Side Expressions (grammar)][228]\n  * [9.15. Right-Hand-Side Expressions (grammar)][229]\n  * [9.16. Array Allocation (grammar)][230]\n  * [9.17. Object Allocation (grammar)][231]\n  * [9.18. Havoc Right-Hand-Side (grammar)][232]\n  * [9.19. Constant Or Atomic Expressions (grammar)][233]\n  * [9.20. Literal Expressions (grammar}][234]\n  * [9.21. `this` Expression (grammar)][235]\n  * [9.22. Old and Old@ Expressions (grammar)][236]\n  * [9.23. Fresh Expressions (grammar)][237]\n  * [9.24. Allocated Expressions (grammar)][238]\n  * [9.25. Unchanged Expressions (grammar)][239]\n  * [9.26. Cardinality Expressions (grammar)][240]\n  * [9.27. Parenthesized Expressions (grammar)][241]\n  * [9.28. Sequence Display Expression (grammar)][242]\n  * [9.29. Set Display Expression (grammar)][243]\n  * [9.30. Map Display Expression (grammar)][244]\n  * [9.31. Endless Expression (grammar)][245]\n    \n    * [9.31.1. If Expression (grammar)][246]\n    * [9.31.2. Case and Extended Patterns (grammar)][247]\n    * [9.31.3. Match Expression (grammar)][248]\n    * [9.31.4. Quantifier Expression (grammar)][249]\n    * [9.31.5. Set Comprehension Expressions (grammar)][250]\n    * [9.31.6. Statements in an Expression (grammar)][251]\n    * [9.31.7. Let and Let or Fail Expression (grammar)][252]\n    * [9.31.8. Map Comprehension Expression (grammar)][253]\n  * [9.32. Name Segment (grammar)][254]\n  * [9.33. Hash call (grammar)][255]\n  * [9.34. Suffix (grammar)][256]\n    \n    * [9.34.1. Augmented Dot Suffix (grammar)][257]\n    * [9.34.2. Datatype Update Suffix (grammar)][258]\n    * [9.34.3. Subsequence Suffix (grammar)][259]\n    * [9.34.4. Subsequence Slices Suffix (grammar)][260]\n    * [9.34.5. Sequence Update Suffix (grammar)][261]\n    * [9.34.6. Selection Suffix (grammar)][262]\n    * [9.34.7. Argument List Suffix (grammar)][263]\n  * [9.35. Expression Lists (grammar)][264]\n  * [9.36. Parameter Bindings (grammar)][265]\n  * [9.37. Assigned Expressions][266]\n  * [9.38. Termination Ordering Expressions][267]\n  * [9.39. Compile-Time Constants][268]\n  * [9.40. List of specification expressions][269]\n* [10. Refinement][270]\n  \n  * [10.1. Export set declarations][271]\n  * [10.2. Import declarations][272]\n  * [10.3. Sub-module declarations][273]\n  * [10.4. Const declarations][274]\n  * [10.5. Method declarations][275]\n  * [10.6. Lemma declarations][276]\n  * [10.7. Function and predicate declarations][277]\n  * [10.8. Class, trait and iterator declarations][278]\n  * [10.9. Type declarations][279]\n  * [10.10. Statements][280]\n* [11. Attributes][281]\n  \n  * [11.1. Attributes on top-level declarations][282]\n    \n    * [11.1.1. `{:autocontracts}`][283]\n    * [11.1.2. `{:nativeType}`][284]\n    * [11.1.3. `{:ignore}` (deprecated)][285]\n    * [11.1.4. `{:extern}`][286]\n    * [11.1.5. `{:disableNonlinearArithmetic}`][287]\n  * [11.2. Attributes on functions and methods][288]\n    \n    * [11.2.1. `{:abstemious}`][289]\n    * [11.2.2. `{:autoReq}`][290]\n    * [11.2.3. `{:autoRevealDependencies k}`][291]\n    * [11.2.4. `{:axiom}`][292]\n    * [11.2.5. `{:compile}`][293]\n    * [11.2.6. `{:concurrent}`][294]\n    * [11.2.7. `{:extern <name>}`][295]\n    * [11.2.8. `{:fuel X}`][296]\n    * [11.2.9. `{:id <string>}`][297]\n    * [11.2.10. `{:induction}`][298]\n    * [11.2.11. `{:inductionTrigger}`][299]\n    * [11.2.12. `{:only}`][300]\n    * [11.2.13. `{:print}`][301]\n    * [11.2.14. `{:priority}`][302]\n    * [11.2.15. `{:resource_limit}` and `{:rlimit}`][303]\n    * [11.2.16. `{:selective_checking}`][304]\n    * [11.2.17. `{:tailrecursion}`][305]\n    * [11.2.18. `{:test}`][306]\n    * [11.2.19. `{:timeLimit N}`][307]\n    * [11.2.20. `{:timeLimitMultiplier X}`][308]\n    * [11.2.21. `{:transparent}`][309]\n    * [11.2.22. `{:verify false}`][310]\n    * [11.2.23. `{:vcs_max_cost N}`][311]\n    * [11.2.24. `{:vcs_max_keep_going_splits N}`][312]\n    * [11.2.25. `{:vcs_max_splits N}`][313]\n    * [11.2.26. `{:isolate_assertions}`][314]\n    * [11.2.27. `{:synthesize}`][315]\n    * [11.2.28. `{:options OPT0, OPT1, ... }`][316]\n  * [11.3. Attributes on reads and modifies clauses][317]\n    \n    * [11.3.1. `{:assume_concurrent}`][318]\n  * [11.4. Attributes on assertions, preconditions and postconditions][319]\n    \n    * [11.4.1. `{:only}`][320]\n    * [11.4.2. `{:focus}`][321]\n    * [11.4.3. `{:split_here}`][322]\n    * [11.4.4. `{:subsumption n}`][323]\n    * [11.4.5. `{:error \"errorMessage\", \"successMessage\"}`][324]\n    * [11.4.6. `{:contradiction}`][325]\n  * [11.5. Attributes on variable declarations][326]\n    \n    * [11.5.1. `{:assumption}`][327]\n  * [11.6. Attributes on quantifier expressions (forall, exists)][328]\n    \n    * [11.6.1. `{:heapQuantifier}`][329]\n    * [11.6.2. `{:induction}`][330]\n    * [11.6.3. `{:trigger}`][331]\n  * [11.7. Deprecated attributes][332]\n  * [11.8. Other undocumented verification attributes][333]\n  * [11.9. New attribute syntax][334]\n* [12. Advanced Topics][335]\n  \n  * [12.1. Type Parameter Completion][336]\n  * [12.2. Type Inference][337]\n  * [12.3. Ghost Inference][338]\n  * [12.4. Well-founded Functions and Extreme Predicates][339]\n    \n    * [12.4.1. Function Definitions][340]\n      \n      * [12.4.1.1. Well-founded Functions][341]\n      * [12.4.1.2. Example with Well-founded Functions][342]\n      * [12.4.1.3. Extreme Solutions][343]\n    * [12.4.2. Working with Extreme Predicates][344]\n      \n      * [12.4.2.1. Example with Least Solution][345]\n      * [12.4.2.2. Example with Greatest Solution][346]\n    * [12.4.3. Other Techniques][347]\n  * [12.5. Functions in Dafny][348]\n    \n    * [12.5.1. Well-founded Functions in Dafny][349]\n    * [12.5.2. Proofs in Dafny][350]\n    * [12.5.3. Extreme Predicates in Dafny][351]\n    * [12.5.4. Proofs about Extreme Predicates][352]\n    * [12.5.5. Nicer Proofs of Extreme Predicates][353]\n  * [12.6. Variable Initialization and Definite Assignment][354]\n  * [12.7. Well-founded Orders][355]\n  * [12.8. Quantifier instantiation rules][356]\n* [13. Dafny User’s Guide][357]\n  \n  * [13.1. Introduction][358]\n  * [13.2. Installing Dafny][359]\n    \n    * [13.2.1. Command-line tools][360]\n    * [13.2.2. IDEs for Dafny][361]\n  * [13.3. Dafny Programs and Files][362]\n    \n    * [13.3.1. Dafny Verification Artifacts: the Library Backend and .doo\n      Files][363]\n    * [13.3.2. Dafny Translation Artifacts: .dtr Files][364]\n  * [13.4. Dafny Standard Libraries][365]\n  * [13.5. Dafny Code Style][366]\n  * [13.6. Using Dafny From the Command Line][367]\n    \n    * [13.6.1. dafny commands][368]\n      \n      * [13.6.1.1. Options that are not associated with a command][369]\n      * [13.6.1.2. `dafny resolve`][370]\n      * [13.6.1.3. `dafny verify`][371]\n      * [13.6.1.4. `dafny translate <language>`][372]\n      * [13.6.1.5. `dafny build`][373]\n      * [13.6.1.6. `dafny run`][374]\n      * [13.6.1.7. `dafny server`][375]\n      * [13.6.1.8. `dafny audit`][376]\n      * [13.6.1.9. `dafny format`][377]\n      * [13.6.1.10. `dafny test`][378]\n      * [13.6.1.11. `dafny doc` [Experimental]][379]\n      * [13.6.1.12. `dafny generate-tests`][380]\n      * [13.6.1.13. `Inlining`][381]\n      * [13.6.1.14. `Command Line Options`][382]\n      * [13.6.1.15. `dafny find-dead-code`][383]\n      * [13.6.1.16. `dafny measure-complexity`][384]\n      * [13.6.1.17. Plugins][385]\n      * [13.6.1.18. Legacy operation][386]\n    * [13.6.2. In-tool help][387]\n    * [13.6.3. dafny exit codes][388]\n    * [13.6.4. dafny output][389]\n    * [13.6.5. Project files][390]\n  * [13.7. Verification][391]\n    \n    * [13.7.1. Verification debugging when verification fails][392]\n      \n      * [13.7.1.1. Failing postconditions][393]\n      * [13.7.1.2. Failing asserts][394]\n      * [13.7.1.3. Failing asserts cases][395]\n      * [13.7.1.4. Counterexamples][396]\n    * [13.7.2. Verification debugging when verification is slow][397]\n      \n      * [13.7.2.1. `assume false;`][398]\n      * [13.7.2.2. `assert ... by {}`][399]\n      * [13.7.2.3. Labeling and revealing assertions][400]\n      * [13.7.2.4. Non-opaque `function method`][401]\n      * [13.7.2.5. Conversion to and from bitvectors][402]\n      * [13.7.2.6. Nested loops][403]\n    * [13.7.3. Assertion batches, well-formedness, correctness][404]\n      \n      * [13.7.3.1. Controlling assertion batches][405]\n    * [13.7.4. Command-line options and other attributes to control\n      verification][406]\n    * [13.7.5. Analyzing proof dependencies][407]\n    * [13.7.6. Debugging brittle verification][408]\n      \n      * [13.7.6.1. Measuring proof brittleness][409]\n      * [13.7.6.2. Improving proof brittleness][410]\n  * [13.8. Compilation][411]\n    \n    * [13.8.1.1 Built-in declarations][412]\n    * [13.8.2. `extern` declarations][413]\n    * [13.8.3. Replaceable modules][414]\n    * [13.8.4. C#][415]\n    * [13.8.5. Java][416]\n    * [13.8.6. Javascript][417]\n    * [13.8.7. Go][418]\n    * [13.8.8. Python][419]\n    * [13.8.9. C++][420]\n    * [13.8.10. Supported features by target language][421]\n  * [13.9. Dafny Command Line Options][422]\n    \n    * [13.9.1. Help and version information][423]\n    * [13.9.2. Controlling input][424]\n    * [13.9.3. Controlling plugins][425]\n    * [13.9.4. Controlling output][426]\n    * [13.9.5. Controlling language features][427]\n    * [13.9.6. Controlling warnings][428]\n    * [13.9.7. Controlling verification][429]\n    * [13.9.8. Controlling compilation][430]\n    * [13.9.9. Controlling Boogie][431]\n    * [13.9.10. Controlling the prover][432]\n    * [13.9.11. Controlling test generation][433]\n* [14. Dafny VSCode extension and the Dafny Language Server][434]\n  \n  * [14.1. Dafny functionality within VSCode][435]\n  * [14.2. Gutter highlights][436]\n  * [14.3. The Dafny Server][437]\n* [15. Plugins to Dafny][438]\n  \n  * [15.1. Language Server plugin tutorial][439]\n    \n    * [15.1.1. Create plugin project][440]\n    * [15.1.2. Implement plugin][441]\n      \n      * [15.1.2.1. Code actions plugin][442]\n      * [15.1.2.2. Request handler plugin][443]\n    * [15.1.3. Building plugin][444]\n* [16. Full list of legacy command-line options {#sec-full-command-line-options}\n  ][445]\n* [17. Dafny Grammar][446]\n  \n  * [17.1. Dafny Syntax][447]\n    \n    * [17.1.1. Classes of characters][448]\n    * [17.1.2. Definitions of tokens][449]\n  * [17.2. Dafny Grammar productions][450]\n    \n    * [17.2.1. Programs][451]\n      \n      * [17.2.1.1. Include directives][452]\n      * [17.2.1.2. Top-level declarations][453]\n      * [17.2.1.3. Declaration modifiers][454]\n    * [17.2.2. Modules][455]\n      \n      * [17.2.2.1. Module Definitions][456]\n      * [17.2.2.2. Module Imports][457]\n      * [17.2.2.3. Module Export Definitions][458]\n    * [17.2.3. Types][459]\n      \n      * [17.2.3.1. Basic types][460]\n      * [17.2.3.2. Generic instantiation][461]\n      * [17.2.3.3. Type parameter][462]\n      * [17.2.3.4. Collection types][463]\n      * [17.2.3.5. Type definitions][464]\n      * [17.2.3.6. Class type][465]\n      * [17.2.3.7. Trait types][466]\n      * [17.2.3.8. Object type][467]\n      * [17.2.3.9. Array types][468]\n      * [17.2.3.10. Iterator types][469]\n      * [17.2.3.11. Arrow types][470]\n      * [17.2.3.12. Algebraic datatypes][471]\n    * [17.2.4. Type member declarations][472]\n      \n      * [17.2.4.1. Fields][473]\n      * [17.2.4.2. Constant fields][474]\n      * [17.2.4.3. Method declarations][475]\n      * [17.2.4.4. Function declarations][476]\n    * [17.2.5. Specifications][477]\n      \n      * [17.2.5.1. Method specifications][478]\n      * [17.2.5.2. Function specifications][479]\n      * [17.2.5.3. Lambda function specifications][480]\n      * [17.2.5.4. Iterator specifications][481]\n      * [17.2.5.5. Loop specifications][482]\n      * [17.2.5.6. Requires clauses][483]\n      * [17.2.5.7. Ensures clauses][484]\n      * [17.2.5.8. Decreases clauses][485]\n      * [17.2.5.9. Modifies clauses][486]\n      * [17.2.5.10. Invariant clauses][487]\n      * [17.2.5.11. Reads clauses][488]\n      * [17.2.5.12. Frame expressions][489]\n    * [17.2.6. Statements][490]\n      \n      * [17.2.6.1. Labeled statement][491]\n      * [17.2.6.2. Non-Labeled statement][492]\n      * [17.2.6.3. Break and continue statements][493]\n      * [17.2.6.4. Block statement][494]\n      * [17.2.6.5. Return statement][495]\n      * [17.2.6.6. Yield statement][496]\n      * [17.2.6.7. Update and call statement][497]\n      * [17.2.6.8. Update with failure statement][498]\n      * [17.2.6.9. Variable declaration statement][499]\n      * [17.2.6.10. Guards][500]\n      * [17.2.6.11. Binding guards][501]\n      * [17.2.6.12. If statement][502]\n      * [17.2.6.13. While Statement][503]\n      * [17.2.6.14. For statement][504]\n      * [17.2.6.15. Match statement][505]\n      * [17.2.6.16. Assert statement][506]\n      * [17.2.6.17. Assume statement][507]\n      * [17.2.6.18. Expect statement][508]\n      * [17.2.6.19. Print statement][509]\n      * [17.2.6.20. Reveal statement][510]\n      * [17.2.6.21. Forall statement][511]\n      * [17.2.6.22. Modify statement][512]\n      * [17.2.6.23. Calc statement][513]\n      * [17.2.6.24. Opaque block][514]\n    * [17.2.7. Expressions][515]\n      \n      * [17.2.7.1. Top-level expression][516]\n      * [17.2.7.2. Equivalence expression][517]\n      * [17.2.7.3. Implies expression][518]\n      * [17.2.7.4. Logical expression][519]\n      * [17.2.7.5. Relational expression][520]\n      * [17.2.7.6. Bit-shift expression][521]\n      * [17.2.7.7. Term (addition operations)][522]\n      * [17.2.7.8. Factor (multiplication operations)][523]\n      * [17.2.7.9. Bit-vector expression][524]\n      * [17.2.7.10. As/Is expression][525]\n      * [17.2.7.11. Unary expression][526]\n      * [17.2.7.12. Primary expression][527]\n      * [17.2.7.13. Lambda expression][528]\n      * [17.2.7.14. Left-hand-side expression][529]\n      * [17.2.7.15. Right-hand-side expression][530]\n      * [17.2.7.16. Array allocation right-hand-side expression][531]\n      * [17.2.7.17. Object allocation right-hand-side expression][532]\n      * [17.2.7.18. Havoc right-hand-side expression][533]\n      * [17.2.7.19. Atomic expressions][534]\n      * [17.2.7.20. Literal expressions][535]\n      * [17.2.7.21. This expression][536]\n      * [17.2.7.22. Old and Old@ Expressions][537]\n      * [17.2.7.23. Fresh Expressions][538]\n      * [17.2.7.24. Allocated Expressions][539]\n      * [17.2.7.25. Unchanged Expressions][540]\n      * [17.2.7.26. Cardinality Expressions][541]\n      * [17.2.7.27. Parenthesized Expression][542]\n      * [17.2.7.28. Sequence Display Expression][543]\n      * [17.2.7.29. Set Display Expression][544]\n      * [17.2.7.30. Map Display Expression][545]\n      * [17.2.7.31. Endless Expression][546]\n      * [17.2.7.32. If expression][547]\n      * [17.2.7.33. Match Expression][548]\n      * [17.2.7.34. Case and Extended Patterns][549]\n      * [17.2.7.35. Quantifier expression][550]\n      * [17.2.7.36. Set Comprehension Expressions][551]\n      * [17.2.7.37. Map Comprehension Expression][552]\n      * [17.2.7.38. Statements in an Expression][553]\n      * [17.2.7.39. Let and Let or Fail Expression][554]\n      * [17.2.7.40. Name Segment][555]\n      * [17.2.7.41. Hash Call][556]\n      * [17.2.7.42. Suffix][557]\n      * [17.2.7.43. Augmented Dot Suffix][558]\n      * [17.2.7.44. Datatype Update Suffix][559]\n      * [17.2.7.45. Subsequence Suffix][560]\n      * [17.2.7.46. Subsequence Slices Suffix][561]\n      * [17.2.7.47. Sequence Update Suffix][562]\n      * [17.2.7.48. Selection Suffix][563]\n      * [17.2.7.49. Argument List Suffix][564]\n      * [17.2.7.50. Expression Lists][565]\n      * [17.2.7.51. Parameter Bindings][566]\n      * [17.2.7.52. Quantifier domains][567]\n      * [17.2.7.53. Basic name and type combinations][568]\n* [18. Testing syntax rendering][569]\n* [19. References][570]\n\n## 1. Introduction\n\nDafny [@Leino:Dafny:LPAR16] is a programming language with built-in\nspecification constructs, so that verifying a program’s correctness with respect\nto those specifications is a natural part of writing software. The Dafny static\nprogram verifier can be used to verify the functional correctness of programs.\nThis document is a reference manual for the programming language and a user\nguide for the `dafny` tool that performs verification and compilation to an\nexecutable form.\n\nThe Dafny programming language is designed to support the static verification of\nprograms. It is imperative, sequential, supports generic classes, inheritance\nand abstraction, methods and functions, dynamic allocation, inductive and\ncoinductive datatypes, and specification constructs. The specifications include\npre- and postconditions, frame specifications (read and write sets), and\ntermination metrics. To further support specifications, the language also offers\nupdatable ghost variables, recursive functions, and types like sets and\nsequences. Specifications and ghost constructs are used only during\nverification; the compiler omits them from the executable code.\n\nThe `dafny` verifier is run as part of the compiler. As such, a programmer\ninteracts with it in much the same way as with the static type checker—when the\ntool produces errors, the programmer responds by changing the program’s type\ndeclarations, specifications, and statements.\n\n(This document typically uses “Dafny” to refer to the programming language and\n`dafny` to refer to the software tool that verifies and compiles programs in the\nDafny language.)\n\nThe easiest way to try out the Dafny language is to [download the supporting\ntools and documentation][571] and run `dafny` on your machine as you follow\nalong with the [Dafny tutorial][572]. The `dafny` tool can be run from the\ncommand line (on Linux, MacOS, Windows or other platforms) or from IDEs such as\nemacs and VSCode, which can provide syntax highlighting and code manipulation\ncapabilities.\n\nThe verifier is powered by [Boogie][573]\n[@Boogie:Architecture;@Leino:Boogie2-RefMan;@LeinoRuemmer:Boogie2] and [Z3][574]\n[@deMouraBjorner:Z3:overview].\n\nFrom verified programs, the `dafny` compiler can produce code for a number of\ndifferent backends: the .NET platform via intermediate C# files, Java,\nJavascript, Go, and C++. Each language provides a basic Foreign Function\nInterface (through uses of `:extern`) and a supporting runtime library.\n\nThis reference manual for the Dafny verification system is based on the\nfollowing references: [@Leino:Dafny:LPAR16], [@MSR:dafny:main],\n[@LEINO:Dafny:Calc], [@LEINO:Dafny:Coinduction], [Co-induction Simply][575].\n\nThe main part of the reference manual is in top down order except for an initial\nsection that deals with the lowest level constructs.\n\nThe details of using (and contributing to) the dafny tool are described in the\nUser Guide ([Section 13][576]).\n\n### 1.1. Dafny 4.0\n\nThe most recent major version of the Dafny language is Dafny 4.0, released in\nFebruary 2023. It has some backwards incompatibilities with Dafny 3, as decribed\nin the [migration guide][577].\n\nThe user documentation has been expanded with more examples, a FAQ, and an error\nexplanation catalog. There is even a new book, [Program Proofs][578] by Dafny\ndesigner Rustan Leino.\n\nThe IDE now has a framework for showing error explanation information and\ncorresponding quick fixes are being added, with refactoring operations on the\nhorizon.\n\nMore details of 4.0 functionality are described in the release notes.\n\n### 1.2. Dafny Example\n\nTo give a flavor of Dafny, here is the solution to a competition problem.\n\n`// VSComp 2010, problem 3, find a 0 in a linked list and return\n// how many nodes were skipped until the first 0 (or end-of-list)\n// was found.\n// Rustan Leino, 18 August 2010.\n//\n// The difficulty in this problem lies in specifying what the\n// return value 'r' denotes and in proving that the program\n// terminates.  Both of these are addressed by declaring a ghost\n// field 'List' in each linked-list node, abstractly representing\n// the linked-list elements from the node to the end of the linked\n// list.  The specification can now talk about that sequence of\n// elements and can use 'r' as an index into the sequence, and\n// termination can be proved from the fact that all sequences in\n// Dafny are finite.\n//\n// We only want to deal with linked lists whose 'List' field is\n// properly filled in (which can only happen in an acyclic list,\n// for example).  To that end, the standard idiom in Dafny is to\n// declare a predicate 'Valid()' that is true of an object when\n// the data structure representing that object's abstract value\n// is properly formed.  The definition of 'Valid()' is what one\n// intuitively would think of as the ''object invariant'', and\n// it is mentioned explicitly in method pre- and postconditions.\n//\n// As part of this standard idiom, one also declares a ghost\n// variable 'Repr' that is maintained as the set of objects that\n// make up the representation of the aggregate object--in this\n// case, the Node itself and all its successors.\nmodule {:options \"--function-syntax:4\"} M {\nclass Node {\n  ghost var List: seq<int>\n  ghost var Repr: set<Node>\n  var head: int\n  var next: Node? // Node? means a Node value or null\n\n  ghost predicate Valid()\n    reads this, Repr\n  {\n    this in Repr &&\n    1 <= |List| && List[0] == head &&\n    (next == null ==> |List| == 1) &&\n    (next != null ==>\n      next in Repr && next.Repr <= Repr && this !in next.Repr &&\n      next.Valid() && next.List == List[1..])\n  }\n\n  static method Cons(x: int, tail: Node?) returns (n: Node)\n    requires tail == null || tail.Valid()\n    ensures n.Valid()\n    ensures if tail == null then n.List == [x]\n                            else n.List == [x] + tail.List\n  {\n    n := new Node;\n    n.head, n.next := x, tail;\n    if (tail == null) {\n      n.List := [x];\n      n.Repr := {n};\n    } else {\n      n.List := [x] + tail.List;\n      n.Repr := {n} + tail.Repr;\n    }\n  }\n}\n\nmethod Search(ll: Node?) returns (r: int)\n  requires ll == null || ll.Valid()\n  ensures ll == null ==> r == 0\n  ensures ll != null ==>\n            0 <= r && r <= |ll.List| &&\n            (r < |ll.List| ==>\n              ll.List[r] == 0 && 0 !in ll.List[..r]) &&\n            (r == |ll.List| ==> 0 !in ll.List)\n{\n  if (ll == null) {\n    r := 0;\n  } else {\n    var jj,i := ll,0;\n    while (jj != null && jj.head != 0)\n      invariant jj != null ==>\n            jj.Valid() &&\n            i + |jj.List| == |ll.List| &&\n            ll.List[i..] == jj.List\n      invariant jj == null ==> i == |ll.List|\n      invariant 0 !in ll.List[..i]\n      decreases |ll.List| - i\n    {\n      jj := jj.next;\n      i := i + 1;\n    }\n    r := i;\n  }\n}\n\nmethod Main()\n{\n  var list: Node? := null;\n  list := list.Cons(0, list);\n  list := list.Cons(5, list);\n  list := list.Cons(0, list);\n  list := list.Cons(8, list);\n  var r := Search(list);\n  print \"Search returns \", r, \"\\n\";\n  assert r == 1;\n}\n}\n`\n\n## 2. Lexical and Low Level Grammar\n\nAs with most languages, Dafny syntax is defined in two levels. First the stream\nof input characters is broken up into *tokens*. Then these tokens are parsed\nusing the Dafny grammar.\n\nThe Dafny grammar is designed as an *attributed grammar*, which is a\nconventional BNF-style set of productions, but in which the productions can have\narguments. The arguments control some alternatives within the productions, such\nas whether an alternative is allowed or not in a specific context. These\narguments allow for a more compact and understandable grammar.\n\nThe precise, technical details of the grammar are presented together in [Section\n17][579]. The expository parts of this manual present the language structure\nless formally. Throughout this document there are embedded hyperlinks to\nrelevant grammar sections, marked as [grammar][580].\n\n### 2.1. Dafny Input\n\nDafny source code files are readable text encoded in UTF-8. All program text\nother than the contents of comments, character, string and verbatim string\nliterals consists of printable and white-space ASCII characters, that is, ASCII\ncharacters in the range `!` to `~`, plus space, tab, carriage return and newline\n(ASCII 9, 10, 13, 32) characters. (In some past versions of Dafny, non-ASCII,\nunicode representations of some mathematical symbols were permitted in Dafny\nsource text; these are no longer recognized.)\n\nString and character literals and comments may contain any unicode character,\neither directly or as an escape sequence.\n\n### 2.2. Tokens and whitespace\n\nThe characters used in a Dafny program fall into four groups:\n\n* White space characters: space, tab, carriage return and newline\n* alphanumerics: letters, digits, underscore (`_`), apostrophe (`'`), and\n  question mark (`?`)\n* punctuation: `(){}[],.`;`\n* operator characters (the other printable characters)\n\nExcept for string and character literals, each Dafny token consists of a\nsequence of consecutive characters from just one of these groups, excluding\nwhite-space. White-space is ignored except that it separates tokens and except\nin the bodies of character and string literals.\n\nA sequence of alphanumeric characters (with no preceding or following additional\nalphanumeric characters) is a *single* token. This is true even if the token is\nsyntactically or semantically invalid and the sequence could be separated into\nmore than one valid token. For example, `assert56` is one identifier token, not\na keyword `assert` followed by a number; `ifb!=0` begins with the token `ifb`\nand not with the keyword `if` and token `b`; `0xFFFFZZ` is an illegal token, not\na valid hex number `0xFFFF` followed by an identifier `ZZ`. White-space must be\nused to separate two such tokens in a program.\n\nSomewhat differently, operator tokens need not be separated. Only specific\nsequences of operator characters are recognized and these are somewhat\ncontext-sensitive. For example, in `seq<set<int>>`, the grammar knows that `>>`\nis two individual `>` tokens terminating the nested type parameter lists; the\nright shift operator `>>` would never be valid here. Similarly, the sequence\n`==>` is always one token; even if it were invalid in its context, separating it\ninto `==` and `>` would always still be invalid.\n\nIn summary, except for required white space between alphanumeric tokens, adding\nor removing white space between tokens can never result in changing the meaning\nof a Dafny program. For most of this document, we consider Dafny programs as\nsequences of tokens.\n\n### 2.3. Character Classes\n\nThis section defines character classes used later in the token definitions. In\nthis section\n\n* a backslash is used to start an escape sequence (so for example `'\\n'` denotes\n  the single linefeed character)\n* double quotes enclose the set of characters constituting a character class\n* enclosing single quotes are used when there is just one character in the class\n  (perhaps expressed with a `\\` escape character)\n* `+` indicates the union of two character classes\n* `-` is the set-difference between the two classes\n* `ANY` designates all [unicode characters][581].\n\n────────────────┬───────────────────────────────────────────────────────────────\nname            │description                                                    \n────────────────┼───────────────────────────────────────────────────────────────\nletter          │ASCII upper or lower case letter; no unicode characters        \n────────────────┼───────────────────────────────────────────────────────────────\ndigit           │base-ten digit (“0123456789”)                                  \n────────────────┼───────────────────────────────────────────────────────────────\nposDigit        │digits, excluding 0 (“123456789”)                              \n────────────────┼───────────────────────────────────────────────────────────────\nposDigitFrom2   │digits excluding 0 and 1 (“23456789”)                          \n────────────────┼───────────────────────────────────────────────────────────────\nhexdigit        │a normal hex digit (“0123456789abcdefABCDEF”)                  \n────────────────┼───────────────────────────────────────────────────────────────\nspecial         │`?_”                                                           \n────────────────┼───────────────────────────────────────────────────────────────\ncr              │carriage return character (ASCII 10)                           \n────────────────┼───────────────────────────────────────────────────────────────\nlf              │line feed character (ASCII 13)                                 \n────────────────┼───────────────────────────────────────────────────────────────\ntab             │tab character (ASCII 9)                                        \n────────────────┼───────────────────────────────────────────────────────────────\nspace           │space character (ASCII 32)                                     \n────────────────┼───────────────────────────────────────────────────────────────\nnondigitIdChar  │characters allowed in an identifier, except digits (letter +   \n                │special)                                                       \n────────────────┼───────────────────────────────────────────────────────────────\nidchar          │characters allowed in an identifier (nondigitIdChar + digits)  \n────────────────┼───────────────────────────────────────────────────────────────\nnonidchar       │characters not in identifiers (ANY - idchar)                   \n────────────────┼───────────────────────────────────────────────────────────────\ncharChar        │characters allowed in a character constant (ANY - ‘'’ - ‘\\’ -  \n                │cr - lf)                                                       \n────────────────┼───────────────────────────────────────────────────────────────\nstringChar      │characters allowed in a string constant (ANY - ‘”’ - ‘\\’ - cr -\n                │lf)                                                            \n────────────────┼───────────────────────────────────────────────────────────────\nverbatimStringCh│characters allowed in a verbatim string constant (ANY - ‘”’)   \nar              │                                                               \n────────────────┴───────────────────────────────────────────────────────────────\n\nThe *special* characters are the characters in addition to alphanumeric\ncharacters that are allowed to appear in a Dafny identifier. These are\n\n* `'` because mathematicians like to put primes on identifiers and some ML\n  programmers like to start names of type parameters with a `'`,\n* `_` because computer scientists expect to be able to have underscores in\n  identifiers, and\n* `?` because it is useful to have `?` at the end of names of predicates, e.g.,\n  `Cons?`.\n\nA `nonidchar` is any character except those that can be used in an identifier.\nHere the scanner generator will interpret `ANY` as any unicode character.\nHowever, `nonidchar` is used only to mark the end of the `!in` token; in this\ncontext any character other than [whitespace or printable ASCII][582] will\ntrigger a subsequent scanning or parsing error.\n\n### 2.4. Comments\n\nComments are in two forms.\n\n* They may go from `/*` to `*/` .\n* They may go from `//` to the end of the line.\n\nA comment is identified as a token during the tokenization of input text and is\nthen discarded for the purpose of interpreting the Dafny program. (It is\nretained to enable auto-formatting and provide accurate source locations for\nerror messages.) Thus comments are token separators: `a/*x*/b` becomes two\ntokens `a` and `b`.\n\nComments may be nested, but note that the nesting of multi-line comments is\nbehavior that is different from most programming languages. In Dafny,\n\n`method m() {\n  /* comment\n     /* nested comment\n     */\n     rest of outer comment\n  */\n}\n`\n\nis permitted; this feature is convenient for commenting out blocks of program\nstatements that already have multi-line comments within them. Other than looking\nfor end-of-comment delimiters, the contents of a comment are not interpreted.\nComments may contain any characters.\n\nNote that the nesting is not fool-proof. In\n\n`method m() {\n  /* var i: int;\n     // */ line comment\n     var j: int;\n  */\n}\n`\n\nand\n\n`method m() {\n  /* var i: int;\n     var s: string := \"a*/b\";\n     var j: int;\n   */\n}\n`\n\nthe `*/` inside the line comment and the string are seen as the end of the outer\ncomment, leaving trailing text that will provoke parsing errors.\n\n### 2.5. Documentation comments\n\nLike many other languages, Dafny permits *documentation comments* in a program\nfile. Such comments contain natural language descriptions of program elements\nand may be used by IDEs and documentation generation tools to present\ninformation to users.\n\nIn Dafny programs.\n\n* Documentation comments (a) either begin with `/**` or (b) begin with `//` or\n  /*` in specific locations\n* Documentation comments may be associated with any declaration, including type\n  definitions, export declarations, and datatype constructors.\n* They may be placed before the declaration, between the declaration and the\n  definition or after the definition. The priority of these comments is the\n  following:\n  \n  * If there is a comment starting with `/**` right before the definition, it’s\n    the documentation comment.\n  * Otherwise, if one or more comments appear between a declaration and its\n    definition — which is uncommon in other programming languages — they are\n    treated as documentation comments, regardless of whether they start with //,\n    /**, or /*. This is because there is no other plausible reason for a comment\n    to be placed in this position.\n  * Otherwise, if there is a single comment starting with `//` or `/**` or `/*`\n    at the end of the definition, it’s the documentation comment. In this case,\n    multi-line documentation comments must be starting with `/*`\n* The extraction of the doc-string from a documentation comment follows the\n  following rules\n  \n  * On the first line, an optional `*` right after `/*` and an optional space\n    are removed, if present\n  * On other lines, the indentation space (with possibly one star in it) is\n    removed, as if the content was supposed to align with A if the comment\n    started with `/** A` for example.\n* The documentation string is interpreted as plain text, but it is possible to\n  provide a user-written plugin that provides other interpretations. VSCode as\n  used by Dafny interprets any markdown syntax in the doc-string.\n\nHere are examples:\n\n`/* Just a comment */\nconst c0: int := 8 // docstring about c0\n// Just a comment\n\n/** docstring about c1 */\nnewtype c1 = x : int | x > 8 // Just a comment\n\n/* Just a comment */\nfunction c2(): (r: int) // Docstring about c2\n  ensures r > 0\n{ 8 } // Just a comment\n\n// just a comment\nconst c5 := 8\n`\n\nDatatype constructors may also have comments:\n\n`datatype T // Docstring for T\n= | A(x: int,\n      y: int) // Docstring for A\n  | B()       /* Docstring for B */ |\n    C()       // Docstring for C\n\n/** Docstring for T0 */\ndatatype T0 =\n  | /** Docstring for A */\n    A(x: int,\n      y: int)\n  | /** Docstring for B */\n    B()\n  | /** Docstring for C */\n    C()\n`\n\nAs can `export` declarations:\n\n`module M {\n  const A: int\n  const B: int\n  const C: int\n  const D: int\n\n  export\n    // This is the docstring of the eponymous export set intended for most clien\nts\n    provides A, B, C\n\n  /** This is the docstring */\n  export AB provides A, B\n\n  export Friends extends AB\n    // This is the docstring of the export set is for clients who need to know m\nore of the\n    // details of the module's definitions.\n    reveals A\n    provides D\n}\n`\n\n### 2.6. Tokens ([grammar][583])\n\nThe Dafny tokens are defined in this section.\n\n#### 2.6.1. Reserved Words\n\nDafny has a set of reserved words that may not be used as identifiers of\nuser-defined entities. These are listed [here][584].\n\nIn particular note that\n\n* `array`, `array2`, `array3`, etc. are reserved words, denoting array types of\n  given rank. However, `array1` and `array0` are ordinary identifiers.\n* `array?`, `array2?`, `array3?`, etc. are reserved words, denoting\n  possibly-null array types of given rank, but not `array1?` or `array0?`.\n* `bv0`, `bv1`, `bv2`, etc. are reserved words that denote the types of\n  bitvectors of given length. The sequence of digits after ‘array’ or ‘bv’ may\n  not have leading zeros: for example, `bv02` is an ordinary identifier.\n\n#### 2.6.2. Identifiers\n\nIn general, an `ident` token (an identifier) is a sequence of `idchar`\ncharacters where the first character is a `nondigitIdChar`. However tokens that\nfit this pattern are not identifiers if they look like a character literal or a\nreserved word (including array or bit-vector type tokens). Also, `ident` tokens\nthat begin with an `_` are not permitted as user identifiers.\n\n#### 2.6.3. Digits\n\nA `digits` token is a sequence of decimal digits (`digit`), possibly\ninterspersed with underscores for readability (but not beginning or ending with\nan underscore). Example: `1_234_567`.\n\nA `hexdigits` token denotes a hexadecimal constant, and is a sequence of\nhexadecimal digits (`hexdigit`) prefaced by `0x` and possibly interspersed with\nunderscores for readability (but not beginning or ending with an underscore).\nExample: `0xffff_ffff`.\n\nA `realnumber` token is a real number literal, possibly interspersed with\nunderscores for readability (but not beginning or ending with an underscore).\nReal numbers can be written as decimal fractions (like `123.456`) or using\nscientific notation (like `1.23e5` or `123e5`). Real number literals can use\ntrailing-dot shorthand (like `1.` for `1.0`). They also support leading-dot\nshorthand (like `.5` for `0.5` or `.5e2` for `50.0`). All produce real number\nvalues. Examples: `123_456.789_123`, `1.23e5`, `123e-2`, `5e10`, `1.`, `.5`,\n`.25e-3`.\n\n#### 2.6.4. Escaped Character\n\nThe `escapedChar` token is a multi-character sequence that denotes a\nnon-printable or non-ASCII character. Such tokens begin with a backslash\ncharaccter (`\\`) and denote a single- or double-quote character, backslash,\nnull, new line, carriage return, tab, or a Unicode character with given\nhexadecimal representation. Which Unicode escape form is allowed depends on the\nvalue of the `--unicode-char` option.\n\nIf `--unicode-char:false` is stipulated, `\\uXXXX` escapes can be used to specify\nany UTF-16 code unit.\n\nIf `--unicode-char:true` is stipulated, `\\U{X..X}` escapes can be used to\nspecify any Unicode scalar value. There must be at least one hex digit in\nbetween the braces, and at most six. Surrogate code points are not allowed. The\nhex digits may be interspersed with underscores for readability (but not\nbeginning or ending with an underscore), as in `\\U{1_F680}`. The braces are part\nof the required character sequence.\n\nNote that although Unicode letters are not allowed in Dafny identifiers, Dafny\ndoes support [Unicode in its character, string, and verbatim strings constants\nand in its comments][585].\n\n#### 2.6.5. Character Constant Token\n\nThe `charToken` token denotes a character constant. It is either a `charChar` or\nan `escapedChar` enclosed in single quotes.\n\n#### 2.6.6. String Constant Token\n\nA `stringToken` denotes a string constant. It consists of a sequence of\n`stringChar` and `escapedChar` characters enclosed in double quotes.\n\nA `verbatimStringToken` token also denotes a string constant. It is a sequence\nof any `verbatimStringChar` characters (which includes newline characters),\nenclosed between `@\"` and `\"`, except that two successive double quotes\nrepresent one quote character inside the string. This is the mechanism for\nescaping a double quote character, which is the only character needing escaping\nin a verbatim string. Within a verbatim string constant, a backslash character\nrepresents itself and is not the first character of an `escapedChar`.\n\n#### 2.6.7. Ellipsis\n\nThe `ellipsisToken` is the character sequence `...` and is typically used to\ndesignate something missing that will later be inserted through refinement or is\nalready present in a parent declaration.\n\n### 2.7. Low Level Grammar Productions\n\n#### 2.7.1. Identifier Variations\n\n2.7.1.1. Identifier\n\nA basic ordinary identifier is just an `ident` token.\n\nIt may be followed by a sequence of suffixes to denote compound entities. Each\nsuffix is a dot (`.`) and another token, which may be\n\n* another `ident` token\n* a `digits` token\n* the `requires` reserved word\n* the `reads` reserved word\n\nNote that\n\n* Digits can be used to name fields of classes and destructors of datatypes. For\n  example, the built-in tuple datatypes have destructors named 0, 1, 2, etc.\n  Note that as a field or destructor name, a digit sequence is treated as a\n  string, not a number: internal underscores matter, so `10` is different from\n  `1_0` and from `010`.\n* `m.requires` is used to denote the [precondition][586] for method `m`.\n* `m.reads` is used to denote the things that method `m` may [read][587].\n2.7.1.2. No-underscore-identifier\n\nA `NoUSIdent` is an identifier except that identifiers with a **leading**\nunderscore are not allowed. The names of user-defined entities are required to\nbe `NoUSIdent`s or, in some contexts, a `digits`. We introduce more mnemonic\nnames for these below (e.g. `ClassName`).\n\nA no-underscore-identifier is required for the following:\n\n* module name\n* class or trait name\n* datatype name\n* newtype name\n* synonym (and subset) type name\n* iterator name\n* type variable name\n* attribute name\n\nA variation, a no-underscore-identifier or a `digits`, is allowed for\n\n* datatype member name\n* method or function or constructor name\n* label name\n* export id\n* suffix that is a typename or constructor\n\nAll *user-declared* names do not start with underscores, but there are\ninternally generated names that a user program might *use* that begin with an\nunderscore or are just an underscore.\n\n2.7.1.3. Wild identifier\n\nA wild identifier is a no-underscore-identifier except that the singleton `_` is\nallowed. The `_` is replaced conceptually by a unique identifier distinct from\nall other identifiers in the program. A `_` is used when an identifier is\nneeded, but its content is discarded. Such identifiers are not used in\nexpressions.\n\nWild identifiers may be used in these contexts:\n\n* formal parameters of a lambda expression\n* the local formal parameter of a quantifier\n* the local formal parameter of a subset type or newtype declaration\n* a variable declaration\n* a case pattern formal parameter\n* binding guard parameter\n* for loop parameter\n* LHS of update statements\n\n#### 2.7.2. Qualified Names\n\nA qualified name starts with the name of a top-level entity and then is followed\nby zero or more `DotSuffix`s which denote a component. Examples:\n\n* `Module.MyType1`\n* `MyTuple.1`\n* `MyMethod.requires`\n* `A.B.C.D`\n\nThe identifiers and dots are separate tokens and so may optionally be separated\nby whitespace.\n\n#### 2.7.3. Identifier-Type Combinations\n\nIdentifiers are typically declared in combination with a type, as in\n\n`var i: int\n`\n\nHowever, Dafny infers types in many circumstances, and in those, the type can be\nomitted. The type is required for field declarations and formal parameters of\nmethods, functions and constructors (because there is no initializer). It may be\nomitted (if the type can be inferred) for local variable declarations, pattern\nmatching variables, quantifiers,\n\nSimilarly, there are circumstances in which the identifier name is not needed,\nbecause it is not used. This is allowed in defining algebraic datatypes.\n\nIn some other situations a wild identifier can be used, as described\n[above][588].\n\n#### 2.7.4. Quantifier Domains ([grammar][589])\n\nSeveral Dafny constructs bind one or more variables to a range of possible\nvalues. For example, the quantifier `forall x: nat | x <= 5 :: x * x <= 25` has\nthe meaning “for all integers x between 0 and 5 inclusive, the square of x is at\nmost 25”. Similarly, the set comprehension `set x: nat | x <= 5 :: f(x)` can be\nread as “the set containing the result of applying f to x, for each integer x\nfrom 0 to 5 inclusive”. The common syntax that specifies the bound variables and\nwhat values they take on is known as the *quantifier domain*; in the previous\nexamples this is `x: nat | x <= 5`, which binds the variable `x` to the values\n`0`, `1`, `2`, `3`, `4`, and `5`.\n\nHere are some more examples.\n\n* `x: byte` (where a value of type `byte` is an int-based number `x` in the\n  range `0 <= x < 256`)\n* `x: nat | x <= 5`\n* `x <- integerSet`\n* `x: nat <- integerSet`\n* `x: nat <- integerSet | x % 2 == 0`\n* `x: nat, y: nat | x < 2 && y < 2`\n* `x: nat | x < 2, y: nat | y < x`\n* `i | 0 <= i < |s|, y <- s[i] | i < y`\n\nA quantifier domain declares one or more *quantified variables*, separated by\ncommas. Each variable declaration can be nothing more than a variable name, but\nit may also include any of three optional elements:\n\n1. The optional syntax `: T` declares the type of the quantified variable. If\n   not provided, it will be inferred from context.\n2. The optional syntax `<- C` attaches a collection expression `C` as a\n   *quantified variable domain*. Here a collection is any value of a type that\n   supports the `in` operator, namely sets, multisets, maps, and sequences. The\n   domain restricts the bindings to the elements of the collection: `x <- C`\n   implies `x in C`. The example above can also be expressed as `var c := [0, 1,\n   2, 3, 4, 5]; forall x <- c :: x * x <= 25`.\n3. The optional syntax `| E` attaches a boolean expression `E` as a *quantified\n   variable range*, which restricts the bindings to values that satisfy this\n   expression. In the example above `x <= 5` is the range attached to the `x`\n   variable declaration.\n\nNote that a variable’s domain expression may reference any variable declared\nbefore it, and a variable’s range expression may reference the attached variable\n(and usually does) and any variable declared before it. For example, in the\nquantifier domain `i | 0 <= i < |s|, y <- s[i] | i < y`, the expression `s[i]`\nis always [well-formed][590] because the range attached to `i` ensures `i` is a\nvalid index in the sequence `s`.\n\nAllowing per-variable ranges is not fully backwards compatible, and so it is not\nyet allowed by default; the `--quantifier-syntax:4` option needs to be provided\nto enable this feature (See [Section 13.9.5][591]).\n\n#### 2.7.5. Numeric Literals ([grammar][592])\n\nInteger and bitvector literals may be expressed in either decimal or hexadecimal\n(`digits` or `hexdigits`).\n\nReal number literals are written as real number tokens (`realnumber`).\n\n## 3. Programs ([grammar][593])\n\nAt the top level, a Dafny program (stored as files with extension `.dfy`) is a\nset of declarations. The declarations introduce (module-level) constants,\nmethods, functions, lemmas, types (classes, traits, inductive and coinductive\ndatatypes, newtypes, type synonyms, abstract types, and iterators) and modules,\nwhere the order of introduction is irrelevant. Some types, notably classes, also\nmay contain a set of declarations, introducing fields, methods, and functions.\n\nWhen asked to compile a program, Dafny looks for the existence of a `Main()`\nmethod. If a legal `Main()` method is found, the compiler will emit an\nexecutable appropriate to the target language; otherwise it will emit a library\nor individual files. The conditions for a legal `Main()` method are described in\nthe User Guide ([Section 3.4][594]). If there is more than one `Main()`, Dafny\nwill emit an error message.\n\nAn invocation of Dafny may specify a number of source files. Each Dafny file\nfollows the grammar of the `Dafny` non-terminal.\n\nA file consists of\n\n* a sequence of optional *include* directives, followed by\n* top level declarations, followed by\n* the end of the file.\n\n### 3.1. Include Directives ([grammar][595])\n\nExamples:\n\n`include \"MyProgram.dfy\"\ninclude @\"/home/me/MyFile.dfy\"\n`\n\nInclude directives have the form `\"include\" stringToken` where the string token\nis either a normal string token or a verbatim string token. The `stringToken` is\ninterpreted as the name of a file that will be included in the Dafny source.\nThese included files also obey the `Dafny` grammar. Dafny parses and processes\nthe transitive closure of the original source files and all the included files,\nbut will not invoke the verifier on the included files unless they have been\nlisted explicitly on the command line or the `--verify-included-files` option is\nspecified.\n\nThe file name may be a path using the customary `/`, `.`, and `..` punctuation.\nThe interpretation of the name (e.g., case-sensitivity) will depend on the\nunderlying operating system. A path not beginning with `/` is looked up in the\nunderlying file system relative to the *location of the file in which the\ninclude directive is stated*. Paths beginning with a device designator (e.g.,\n`C:`) are only permitted on Windows systems. Better style advocates using\nrelative paths in include directives so that groups of files may be moved as a\nwhole to a new location.\n\nPaths of files on the command-line or named in `--library` options are relative\nthe the current working directory.\n\n### 3.2. Top Level Declarations ([grammar][596])\n\nExamples:\n\n`abstract module M { }\ntrait R { }\nclass C { }\ndatatype D = A | B\nnewtype pos = i: int | i >= 0\ntype T = i: int | 0 <= i < 100\nmethod m() {}\nfunction f(): int\nconst c: bool\n`\n\nTop-level declarations may appear either at the top level of a Dafny file, or\nwithin a (sub)module declaration. A top-level declaration is one of various\nkinds of declarations described later. Top-level declarations are implicitly\nmembers of a default (unnamed) top-level module.\n\nDeclarations within a module or at the top-level all begin with reserved\nkeywords and do not end with semicolons.\n\nThese declarations are one of these kinds:\n\n* methods and functions, encapsulating computations or actions\n* const declarations, which are names (of a given type) initialized to an\n  unchanging value; declarations of variables and mutable fields are not allowed\n  at the module level\n* type declarations of various kinds ([Section 5][597] and the following\n  sections)\n\nMethods, functions and const declarations are placed in an implicit class\ndeclaration that is in the top-level implicit module. These declarations are all\nimplicitly `static` (and may not be declared explicitly static).\n\n### 3.3. Declaration Modifiers ([grammar][598])\n\nExamples:\n\n`abstract module M {\n  class C {\n    static method m() {}\n  }\n}\nghost opaque const c : int\n`\n\nTop level declarations may be preceded by zero or more declaration modifiers.\nNot all of these are allowed in all contexts.\n\nThe `abstract` modifier may only be used for module declarations. An abstract\nmodule can leave some entities underspecified. Abstract modules are not\ncompiled.\n\nThe `ghost` modifier is used to mark entities as being used for specification\nonly, not for compilation to code.\n\nThe `opaque` modifier may be used on const declarations and functions.\n\nThe `static` modifier is used for class members that are associated with the\nclass as a whole rather than with an instance of the class. This modifier may\nnot be used with declarations that are implicitly static, as are members of the\ntop-level, unnamed implicit class.\n\nThe following table shows modifiers that are available for each of the kinds of\ndeclaration. In the table we use already-ghost (already-non-ghost) to denote\nthat the item is not allowed to have the ghost modifier because it is already\nimplicitly ghost (non-ghost).\n\n──────────────────────┬─────────────────────────────────────────\nDeclaration           │allowed modifiers                        \n──────────────────────┼─────────────────────────────────────────\nmodule                │abstract                                 \n──────────────────────┼─────────────────────────────────────────\nclass                 │-                                        \n──────────────────────┼─────────────────────────────────────────\ntrait                 │-                                        \n──────────────────────┼─────────────────────────────────────────\ndatatype or codatatype│-                                        \n──────────────────────┼─────────────────────────────────────────\nfield (const)         │ghost opaque                             \n──────────────────────┼─────────────────────────────────────────\nnewtype               │-                                        \n──────────────────────┼─────────────────────────────────────────\nsynonym types         │-                                        \n──────────────────────┼─────────────────────────────────────────\niterators             │-                                        \n──────────────────────┼─────────────────────────────────────────\nmethod                │ghost static                             \n──────────────────────┼─────────────────────────────────────────\nlemma                 │already-ghost static                     \n──────────────────────┼─────────────────────────────────────────\nleast lemma           │already-ghost static                     \n──────────────────────┼─────────────────────────────────────────\ngreatest lemma        │already-ghost static                     \n──────────────────────┼─────────────────────────────────────────\nconstructor           │ghost                                    \n──────────────────────┼─────────────────────────────────────────\nfunction              │ghost static opaque (Dafny 4)            \n──────────────────────┼─────────────────────────────────────────\nfunction method       │already-non-ghost static opaque (Dafny 3)\n──────────────────────┼─────────────────────────────────────────\nfunction (non-method) │already-ghost static opaque (Dafny 3)    \n──────────────────────┼─────────────────────────────────────────\npredicate             │ghost static opaque (Dafny 4)            \n──────────────────────┼─────────────────────────────────────────\npredicate method      │already-non-ghost static opaque (Dafny 3)\n──────────────────────┼─────────────────────────────────────────\npredicate (non-method)│already-ghost static opaque (Dafny 3)    \n──────────────────────┼─────────────────────────────────────────\nleast predicate       │already-ghost static opaque              \n──────────────────────┼─────────────────────────────────────────\ngreatest predicate    │already-ghost static opaque              \n──────────────────────┴─────────────────────────────────────────\n\n### 3.4. Executable programs\n\nDafny programs have an important emphasis on verification, but the programs may\nalso be executable.\n\nTo be executable, the program must have exactly one `Main` method and that\nmethod must be a legal main entry point.\n\n* The program is searched for a method with the attribute `{:main}`. If exactly\n  one is found, that method is used as the entry point; if more than one method\n  has the `{:main}` attribute, an error message is issued.\n* Otherwise, the program is searched for a method with the name `Main`. If more\n  than one is found an error message is issued.\n\nAny abstract modules are not searched for candidate entry points, but otherwise\nthe entry point may be in any module or type. In addition, an entry-point\ncandidate must satisfy the following conditions:\n\n* The method has no type parameters and either has no parameters or one\n  non-ghost parameter of type `seq<string>`.\n* The method has no non-ghost out-parameters.\n* The method is not a ghost method.\n* The method has no requires or modifies clauses, unless it is marked `{:main}`.\n* If the method is an instance (that is, non-static) method and the enclosing\n  type is a class, then that class must not declare any constructor. In this\n  case, the runtime system will allocate an object of the enclosing class and\n  will invoke the entry-point method on it.\n* If the method is an instance (that is, non-static) method and the enclosing\n  type is not a class, then the enclosing type must, when instantiated with\n  auto-initializing type parameters, be an auto-initializing type. In this case,\n  the runtime system will invoke the entry-point method on a value of the\n  enclosing type.\n\nNote, however, that the following are allowed:\n\n* The method is allowed to have `ensures` clauses\n* The method is allowed to have `decreases` clauses, including a `decreases *`.\n  (If `Main()` has a `decreases *`, then its execution may go on forever, but in\n  the absence of a `decreases *` on `Main()`, `dafny` will have verified that\n  the entire execution will eventually terminate.)\n\nIf no legal candidate entry point is identified, `dafny` will still produce\nexecutable output files, but they will need to be linked with some other code in\nthe target language that provides a `main` entry point.\n\nIf the `Main` method takes an argument (of type `seq<string>`), the value of\nthat input argument is the sequence of command-line arguments, with the first\nentry of the sequence (at index 0) being a system-determined name for the\nexecutable being run.\n\nThe exit code of the program, when executed, is not yet specified.\n\n## 4. Modules ([grammar][599])\n\nExamples:\n\n`module N  { }\nimport A\nexport A reveals f\n`\n\nStructuring a program by breaking it into parts is an important part of creating\nlarge programs. In Dafny, this is accomplished via *modules*. Modules provide a\nway to group together related types, classes, methods, functions, and other\nmodules, as well as to control the scope of declarations. Modules may import\neach other for code reuse, and it is possible to abstract over modules to\nseparate an implementation from an interface.\n\nModule declarations are of three types:\n\n* a module definition\n* a module import\n* a module export definition\n\nModule definitions and imports each declare a submodule of its enclosing module,\nwhich may be the implicit, undeclared, top-level module.\n\n### 4.1. Declaring New Modules ([grammar][600])\n\nExamples:\n\n`module P { const i: int }\nabstract module A.Q { method m() {} }\nmodule M { module N { } }\n`\n\nA *module definition*\n\n* has an optional modifier (only `abstract` is allowed)\n* followed by the keyword “module”\n* followed by a name (a sequence of dot-separated identifiers)\n* followed by a body enclosed in curly braces\n\nA module body consists of any declarations that are allowed at the top level:\nclasses, datatypes, types, methods, functions, etc.\n\n`module Mod {\n  class C {\n    var f: int\n    method m()\n  }\n  datatype Option = A(int) | B(int)\n  type T\n  method m()\n  function f(): int\n}\n`\n\nYou can also put a module inside another, in a nested fashion:\n\n`module Mod {\n  module Helpers {\n    class C {\n      method doIt()\n      var f: int\n    }\n  }\n}\n`\n\nThen you can refer to the members of the `Helpers` module within the `Mod`\nmodule by prefixing them with “Helpers.”. For example:\n\n`module Mod {\n  module Helpers {\n    class C {\n      constructor () { f := 0; }\n      method doIt()\n      var f: int\n    }\n  }\n  method m() {\n    var x := new Helpers.C();\n    x.doIt();\n    x.f := 4;\n  }\n}\n`\n\nMethods and functions defined at the module level are available like classes,\nwith just the module name prefixing them. They are also available in the methods\nand functions of the classes in the same module.\n\n`module Mod {\n  module Helpers {\n    function addOne(n: nat): nat {\n      n + 1\n    }\n  }\n  method m() {\n    var x := 5;\n    x := Helpers.addOne(x); // x is now 6\n  }\n}\n`\n\nNote that everything declared at the top-level (in all the files constituting\nthe program) is implicitly part of a single implicit unnamed global module.\n\n### 4.2. Declaring nested modules standalone\n\nAs described in the previous section, module declarations can be nested. It is\nalso permitted to declare a nested module *outside* of its “containing” module.\nSo instead of\n\n`module A {\n  module B {\n  }\n}\n`\n\none can write\n\n`module A {\n}\nmodule A.B {\n}\n`\n\nThe second module is completely separate; for example, it can be in a different\nfile. This feature provides flexibility in writing and maintenance; for example,\nit can reduce the size of module `A` by extracting module `A.B` into a separate\nbody of text.\n\nHowever, it can also lead to confusion, and program authors need to take care.\nIt may not be apparent to a reader of module `A` that module `A.B` exists; the\nexistence of `A.B` might cause names to be resolved differently and the\nsemantics of the program might be (silently) different if `A.B` is present or\nabsent.\n\n### 4.3. Importing Modules ([grammar][601])\n\nExamples:\n\n`import A\nimport opened B\nimport A = B\nimport A : B\nimport A.B\nimport A`E\nimport X = A.B`{E,F}\n`\n\nSometimes you want to refer to things from an existing module, such as a\nlibrary. In this case, you can *import* one module into another. This is done\nvia the `import` keyword, which has two forms with different meanings. The\nsimplest form is the concrete import, which has the form `import A = B`. This\ndeclaration creates a reference to the module `B` (which must already exist),\nand binds it to the new local name `A`. This form can also be used to create a\nreference to a nested module, as in `import A = B.C`. The other form, using a\n`:`, is described in [Section 4.6][602].\n\nAs modules in the same scope must have different names, this ability to bind a\nmodule to a new name allows disambiguating separately developed external modules\nthat have the same name. Note that the new name is only bound in the scope\ncontaining the import declaration; it does not create a global alias. For\nexample, if `Helpers` was defined outside of `Mod`, then we could import it:\n\n`module Helpers {\n  function addOne(n: nat): nat {\n    n + 1\n  }\n}\nmodule Mod {\n  import A = Helpers\n  method m() {\n    assert A.addOne(5) == 6;\n  }\n}\n`\n\nNote that inside `m()`, we have to use `A` instead of `Helpers`, as we bound it\nto a different name. The name `Helpers` is not available inside `m()` (or\nanywhere else inside `Mod`), as only names that have been bound inside `Mod` are\navailable. In order to use the members from another module, that other module\neither has to be declared there with `module` or imported with `import`. (As\ndescribed below, the resolution of the `ModuleQualifiedName` that follows the\n`=` in the `import` statement or the `refines` in a module declaration uses\nslightly different rules.)\n\nWe don’t have to give `Helpers` a new name, though, if we don’t want to. We can\nwrite `import Helpers = Helpers` to import the module under its own name; Dafny\neven provides the shorthand `import Helpers` for this behavior. You can’t bind\ntwo modules with the same name at the same time, so sometimes you have to use\nthe = version to ensure the names do not clash. When importing nested modules,\n`import B.C` means `import C = B.C`; the implicit name is always the last name\nsegment of the module designation.\n\nThe first identifier in the dot-separated sequence of identifers that constitute\nthe qualified name of the module being imported is resolved as (in order)\n\n* a submodule of the importing module,\n* or a sibling module of the importing module,\n* or a sibling module of some containing module, traversing outward. There is no\n  way to refer to a containing module, only sibling modules (and their\n  submodules).\n\nImport statements may occur at the top-level of a program (that is, in the\nimplicit top-level module of the program) as well. There they serve as a way to\ngive a new name, perhaps a shorthand name, to a module. For example,\n\n`module MyModule { } // declare MyModule\nimport MyModule  // error: cannot add a module named MyModule\n                 // because there already is one\nimport M = MyModule // OK. M and MyModule are equivalent\n`\n\n### 4.4. Opening Modules\n\nSometimes, prefixing the members of the module you imported with its name is\ntedious and ugly, even if you select a short name when importing it. In this\ncase, you can import the module as `opened`, which causes all of its members to\nbe available without adding the module name. The `opened` keyword, if present,\nmust immediately follow `import`. For example, we could write the previous\nexample as:\n\n`module Helpers {\n  function addOne(n: nat): nat {\n    n + 1\n  }\n}\nmodule Mod {\n  import opened Helpers\n  method m() {\n    assert addOne(5) == 6;\n  }\n}\n`\n\nWhen opening modules, the newly bound members have lower priority than local\ndefinitions. This means if you define a local function called `addOne`, the\nfunction from `Helpers` will no longer be available under that name. When\nmodules are opened, the original name binding is still present however, so you\ncan always use the name that was bound to get to anything that is hidden.\n\n`module Helpers {\n  function addOne(n: nat): nat {\n    n + 1\n  }\n}\nmodule Mod {\n  import opened H = Helpers\n  function addOne(n: nat): nat {\n    n - 1\n  }\n  method m() {\n    assert addOne(5) == 6; // this is now false,\n                           // as this is the function just defined\n    assert H.addOne(5) == 6; // this is still true\n  }\n}\n`\n\nIf you open two modules that both declare members with the same name, then\nneither member can be referred to without a module prefix, as it would be\nambiguous which one was meant. Just opening the two modules is not an error,\nhowever, as long as you don’t attempt to use members with common names. However,\nif the ambiguous references actually refer to the same declaration, then they\nare permitted. The `opened` keyword may be used with any kind of `import`\ndeclaration, including the module abstraction form.\n\nAn `import opened` may occur at the top-level as well. For example,\n\n`module MyModule {  } // declares MyModule\nimport opened MyModule // does not declare a new module, but does\n                       // make all names in MyModule available in\n                       // the current scope, without needing\n                       // qualification\nimport opened M = MyModule // names in MyModule are available in\n                       // the current scope without qualification\n                       // or qualified with either M (because of this\n                       // import) or MyModule (because of the original\n                       // module definition)\n`\n\nThe Dafny style guidelines suggest using opened imports sparingly. They are best\nused when the names being imported have obvious and unambiguous meanings and\nwhen using qualified names would be verbose enough to impede understanding.\n\nThere is a special case in which the behavior described above is altered. If a\nmodule `M` declares a type `M` and `M` is `import opened` without renaming\ninside another module `X`, then the rules above would have, within `X`, `M` mean\nthe module and `M.M` mean the type. This is verbose. So in this somewhat common\ncase, the type `M` is effectively made a local declaration within `X` so that it\nhas precedence over the module name. Now `M` refers to the type. If one needs to\nrefer to the module, it will have to be renamed as part of the `import opened`\nstatement.\n\nThis special-case behavior does give rise to a source of ambiguity. Consider the\nexample\n\n`module Option {\n  const a := 1\n  datatype Option = A|B { static const a := 2 }\n}\n\nmodule X {\n  import opened Option\n  method M() { print Option.a; }\n}\n`\n\n`Option.a` now means the `a` in the datatype instead of the `a` in the module.\nTo avoid confusion in such cases, it is an ambiguity error if a name that is\ndeclared in both the datatype and the module is used when there is an `import\nopen` of the module (without renaming).\n\n### 4.5. Export Sets and Access Control ([grammar][603])\n\nExamples:\n\n`export E extends F reveals f,g provides g,h\nexport E reveals *\nexport reveals f,g provides g,h\nexport E\nexport E ... reveals f\n`\n\nIn some programming languages, keywords such as `public`, `private`, and\n`protected` are used to control access to (that is, visibility of) declared\nprogram entities. In Dafny, modules and export sets provide that capability.\nModules combine declarations into logically related groups. Export sets then\npermit selectively exposing subsets of a module’s declarations; another module\ncan import the export set appropriate to its needs. A user can define as many\nexport sets as are needed to provide different kinds of access to the module’s\ndeclarations. Each export set designates a list of names, which must be names\nthat are declared in the module (or in a refinement parent).\n\nBy default (in the absence of any export set declarations) all the names\ndeclared in a module are available outside the module using the `import`\nmechanism. An *export set* enables a module to disallow the use of some\ndeclarations outside the module.\n\nAn export set has an optional name used to disambiguate in case of multiple\nexport sets; If specified, such names are used in `import` statements to\ndesignate which export set of a module is being imported. If a module `M` has\nexport sets `E1` and `E2`, we can write `import A = M`E1` to create a module\nalias `A` that contains only the names in `E1`. Or we can write `import A =\nM`{E1,E2}` to import the union of names in `E1` and `E2` as module alias `A`. As\nbefore, `import M`E1` is an abbreviation of `import M = M`E1`.\n\nIf no export set is given in an import statement, the default export set of the\nmodule is used.\n\nThere are various defaults that apply differently in different cases. The\nfollowing description is with respect to an example module `M`:\n\n*`M` has no export sets declared*. Then another module may simply `import Z = M`\nto obtain access to all of M’s declarations.\n\n*`M` has one or more named export sets (e.g., `E`, `F`)*. Then another module\ncan write `import Z = M`E` or `import Z = M`{E,F}` to obtain access to the names\nthat are listed in export set `E` or to the union of those in export sets `E`\nand `F`, respectively. If no export set has the same name as the module, then an\nexport set designator must be used: in that case you cannot write simply `import\nZ = M`.\n\n*`M` has an unnamed export set, along with other export sets (e.g., named `E`)*.\nThe unnamed export set is the default export set and implicitly has the same\nname as the module. Because there is a default export set, another module may\nwrite either `import Z = M` or `import Z = M`M` to import the names in that\ndefault export set. You can also still use the other export sets with the\nexplicit designator: `import Z = M`E`\n\n*`M` declares an export set with the same name as the module*. This is\nequivalent to declaring an export set without a name. `import M` and `import\nM`M` perform the same function in either case; the export set with or without\nthe name of the module is the default export set for the module.\n\nNote that names of module aliases (declared by import statements) are just like\nother names in a module; they can be included or omitted from export sets. Names\nbrought into a module by [*refinement*][604] are treated the same as locally\ndeclared names and can be listed in export set declarations. However, names\nbrought into a module by `import opened` (either into a module or a refinement\nparent of a module) may not be further exported. For example,\n\n`module A {\n  const a := 10\n  const z := 10\n}\nmodule B {\n  import opened Z = A // includes a, declares Z\n  const b := Z.a // OK\n}\nmodule C {\n  import opened B // includes b, Z, but not a\n  method m() {\n    //assert b == a; // error: a is not known\n    //assert b == B.a; // error: B.a is not valid\n    //assert b == A.a; // error: A is not known\n    assert b == Z.a; // OK: module Z is known and includes a\n  }\n}\n`\n\nHowever, in the above example,\n\n* if `A` has one export set `export Y reveals a` then the import in module `B`\n  is invalid because `A` has no default export set;\n* if `A` has one export set `export Y reveals a` and `B` has `import Z = A`Y`\n  then `B`’s import is OK. So is the use of `Z.a` in the assert because `B`\n  declares `Z` and `C` brings in `Z` through the `import opened` and `Z`\n  contains `a` by virtue of its declaration. (The alias `Z` is not able to have\n  export sets; all of its names are visible.)\n* if `A` has one export set `export provides z` then `A` does have a default\n  export set, so the import in `B` is OK, but neither the use of `a` in `B` nor\n  as `Z.a` in C would be valid, because `a` is not in `Z`.\n\nThe default export set is important in the resolution of qualified names, as\ndescribed in [Section 4.8][605].\n\nThere are a few unusual cases to be noted:\n\n* an export set can be completely empty, as in `export Nothing`\n* an eponymous export set can be completely empty, as in `export`, which by\n  default has the same name as the enclosing module; this is a way to make the\n  module completely private\n* an export set declaration followed by an extreme predicate declaration looks\n  like this: `export least predicate P() { true }` In this case, the `least` (or\n  `greatest`) is the identifier naming the export set. Consequently, `export\n  least predicate P[nat]() { true }` is illegal because `[nat]` cannot be part\n  of a non-extreme predicate. So, it is not possible to declare an eponymous,\n  empty export set by omitting the export id immediately prior to a declaration\n  of an extreme predicate, because the `least` or `greatest` token is parsed as\n  the export set identifier. The workaround for this situation is to either put\n  the name of the module in explicitly as the export ID (not leaving it to the\n  default) or reorder the declarations.\n* To avoid confusion, the code\n  `module M {\n  export\n  least predicate P() { true }\n  }\n  `\n  \n  provokes a warning telling the user that the `least` goes with the `export`.\n\n#### 4.5.1. Provided and revealed names\n\nNames can be exported from modules in two ways, designated by `provides` and\n`reveals` in the export set declaration.\n\nWhen a name is exported as *provided*, then inside a module that has imported\nthe name only the name is known, not the details of the name’s declaration.\n\nFor example, in the following code the constant `a` is exported as provided.\n\n`module A {\n  export provides a\n  const a := 10\n  const b := 20\n}\n\nmodule B {\n  import A\n  method m() {\n    assert A.a == 10; // a is known, but not its value\n    // assert A.b == 20; // b is not known through A`A\n  }\n}\n`\n\nSince `a` is imported into module `B` through the default export set `A`A`, it\ncan be referenced in the assert statement. The constant `b` is not exported, so\nit is not available. But the assert about `a` is not provable because the value\nof `a` is not known in module `B`.\n\nIn contrast, if `a` is exported as *revealed*, as shown in the next example, its\nvalue is known and the assertion can be proved.\n\n`module A {\n  export reveals a\n  const a := 10\n  const b := 20\n}\n\nmodule B {\n  import A\n  method m() {\n    assert A.a == 10; // a and its value are known\n    // assert A.b == 20; // b is not known through A`A\n  }\n}\n`\n\nThe following table shows which parts of a declaration are exported by an export\nset that `provides` or `reveals` the declaration.\n\n` declaration         | what is exported    | what is exported\n                     | with provides       | with reveals\n---------------------|---------------------|---------------------\n const x: X := E     | const x: X          | const x: X := E\n---------------------|---------------------|---------------------\n var x: X            | var x: X            | not allowed\n---------------------|---------------------|---------------------\n function F(x: X): Y | function F(x: X): Y | function F(x: X): Y\n   specification...  |   specification...  |   specification...\n {                   |                     | {\n   Body              |                     |   Body\n }                   |                     | }\n---------------------|---------------------|---------------------\n method M(x: X)      | method M(x: X)      | not allowed\n   returns (y: Y)    |   returns (y: Y)    |\n   specification...  |   specification...  |\n {                   |                     |\n   Body;             |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n type Opaque         | type Opaque         | type Opaque\n {                   |                     |\n   // members...     |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n type Synonym = T    | type Synonym        | type Synonym = T\n---------------------|---------------------|---------------------\n type S = x: X       | type S              | type S = x: X\n   | P witness E     |                     |   | P witness E\n---------------------|---------------------|---------------------\n newtype N = x: X    | type N              | newtype N = x: X\n   | P witness E     |                     |   | P witness E\n {                   |                     |\n   // members...     |                     |\n }                   |                     |\n`\n`---------------------|---------------------|---------------------\n datatype D =        | type D              | datatype D =\n     Ctor0(x0: X0)   |                     |    Ctor0(x0: X0)\n   | Ctor1(x1: X1)   |                     |  | Ctor1(x1: X1)\n   | ...             |                     |  | ...\n {                   |                     |\n   // members...     |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n class Cl            | type Cl             | class Cl\n   extends T0, ...   |                     |   extends T0, ...\n {                   |                     | {\n   constructor ()    |                     |   constructor ()\n     spec...         |                     |     spec...\n   {                 |                     |\n     Body;           |                     |\n   }                 |                     |\n   // members...     |                     |\n }                   |                     | }\n---------------------|---------------------|---------------------\n trait Tr            | type Tr             | trait Tr\n   extends T0, ...   |                     |   extends T0, ...\n {                   |                     |\n   // members...     |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n iterator Iter(x: X) | type Iter           | iterator Iter(x: X)\n   yields (y: Y)     |                     |   yields (y: Y)\n   specification...  |                     |   specification...\n {                   |                     |\n   Body;             |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n module SubModule    | module SubModule    | not allowed\n   ...               |   ...               |\n {                   | {                   |\n   export SubModule  |   export SubModule  |\n     ...             |     ...             |\n   export A ...      |                     |\n   // decls...       |   // decls...       |\n }                   | }                   |\n---------------------|---------------------|---------------------\n import L = MS       | import L = MS       | not allowed\n---------------------|---------------------|---------------------\n`\n\nVariations of functions (e.g., `predicate`, `twostate function`) are handled\nlike `function` above, and variations of methods (e.g., `lemma` and `twostate\nlemma`) are treated like `method` above. Since the whole signature is exported,\na function or method is exported to be of the same kind, even through\n`provides`. For example, an exported `twostate lemma` is exported as a `twostate\nlemma` (and thus is known by importers to have two implicit heap parameters),\nand an exported `least predicate P` is exported as a `least predicate P` (and\nthus importers can use both `P` and its prefix predicate `P#`).\n\nIf `C` is a `class`, `trait`, or `iterator`, then `provides C` exports the\nnon-null reference type `C` as an abstract type. This does not reveal that `C`\nis a reference type, nor does it export the nullable type `C?`.\n\nIn most cases, exporting a `class`, `trait`, `datatype`, `codatatype`, or\nabstract type does not automatically export its members. Instead, any member to\nbe exported must be listed explicitly. For example, consider the type\ndeclaration\n\n`trait Tr {\n  function F(x: int): int { 10 }\n  function G(x: int): int { 12 }\n  function H(x: int): int { 14 }\n}\n`\n\nAn export set that contains only `reveals Tr` has the effect of exporting\n\n`trait Tr {\n}\n`\n\nand an export set that contains only `provides Tr, Tr.F reveals Tr.H` has the\neffect of exporting\n\n`type Tr {\n  function F(x: int): int\n  function H(x: int): int { 14 }\n}\n`\n\nThere is no syntax (for example, `Tr.*`) to export all members of a type.\n\nSome members are exported automatically when the type is revealed. Specifically:\n\n* Revealing a `datatype` or `codatatype` automatically exports the type’s\n  discriminators and destructors.\n* Revealing an `iterator` automatically exports the iterator’s members.\n* Revealing a class automatically exports the class’s anonymous constructor, if\n  any.\n\nFor a `class`, a `constructor` member can be exported only if the class is\nrevealed. For a `class` or `trait`, a `var` member can be exported only if the\nclass or trait is revealed (but a `const` member can be exported even if the\nenclosing class or trait is only provided).\n\nWhen exporting a sub-module, only the sub-module’s eponymous export set is\nexported. There is no way for a parent module to export any other export set of\na sub-module, unless it is done via an `import` declaration of the parent\nmodule.\n\nThe effect of declaring an import as `opened` is confined to the importing\nmodule. That is, the ability of use such imported names as unqualified is not\npassed on to further imports, as the following example illustrates:\n\n`module Library {\n  const xyz := 16\n}\n\nmodule M {\n  export\n    provides Lib\n    provides xyz // error: 'xyz' is not declared locally\n\n  import opened Lib = Library\n\n  const k0 := Lib.xyz\n  const k1 := xyz\n}\n\nmodule Client {\n  import opened M\n\n  const a0 := M.Lib.xyz\n  const a1 := Lib.xyz\n  const a2 := M.xyz // error: M does not have a declaration 'xyz'\n  const a3 := xyz // error: unresolved identifier 'xyz'\n}\n`\n\nAs highlighted in this example, module `M` can use `xyz` as if it were a local\nname (see declaration `k1`), but the unqualified name `xyz` is not made\navailable to importers of `M` (see declarations `a2` and `a3`), nor is it\npossible for `M` to export the name `xyz`.\n\nA few other notes:\n\n* A `provides` list can mention `*`, which means that all local names (except\n  export set names) in the module are exported as `provides`.\n* A `reveals` list can mention `*`, which means that all local names (except\n  export set names) in the module are exported as `reveals`, if the declaration\n  is allowed to appear in a `reveals` clause, or as `provides`, if the\n  declaration is not allowed to appear in a `reveals` clause.\n* If no export sets are declared, then the implicit export set is `export\n  reveals *`.\n* A refinement module acquires all the export sets from its refinement parent.\n* Names acquired by a module from its refinement parent are also subject to\n  export lists. (These are local names just like those declared directly.)\n\n#### 4.5.2. Extends list\n\nAn export set declaration may include an *extends* list, which is a list of one\nor more export set names from the same module containing the declaration\n(including export set names obtained from a refinement parent). The effect is to\ninclude in the declaration the union of all the names in the export sets in the\nextends list, along with any other names explicitly included in the declaration.\nSo for example in\n\n`module M {\n  const a := 10\n  const b := 10\n  const c := 10\n  export A reveals a\n  export B reveals b\n  export C extends A, B\n    reveals c\n}\n`\n\nexport set `C` will contain the names `a`, `b`, and `c`.\n\n### 4.6. Module Abstraction\n\nSometimes, using a specific implementation is unnecessary; instead, all that is\nneeded is a module that implements some interface. In that case, you can use an\n*abstract* module import. In Dafny, this is written `import A : B`. This means\nbind the name `A` as before, but instead of getting the exact module `B`, you\nget any module which *adheres* to `B`. Typically, the module `B` may have\nabstract type definitions, classes with bodiless methods, or otherwise be\nunsuitable to use directly. Because of the way refinement is defined, any\nrefinement of `B` can be used safely. For example, suppose we start with these\ndeclarations:\n\n`abstract module Interface {\n  function addSome(n: nat): nat\n    ensures addSome(n) > n\n}\nabstract module Mod {\n  import A : Interface\n  method m() {\n    assert 6 <= A.addSome(5);\n  }\n}\n`\n\nWe can be more precise if we know that `addSome` actually adds exactly one. The\nfollowing module has this behavior. Further, the postcondition is stronger, so\nthis is actually a refinement of the Interface module.\n\n`module Implementation {\n  function addSome(n: nat): nat\n    ensures addSome(n) == n + 1\n  {\n    n + 1\n  }\n}\n`\n\nWe can then substitute `Implementation` for `A` in a new module, by declaring a\nrefinement of `Mod` which defines `A` to be `Implementation`.\n\n`abstract module Interface {\n  function addSome(n: nat): nat\n    ensures addSome(n) > n\n}\nabstract module Mod {\n  import A : Interface\n  method m() {\n    assert 6 <= A.addSome(5);\n  }\n}\nmodule Implementation {\n  function addSome(n: nat): nat\n    ensures addSome(n) == n + 1\n  {\n    n + 1\n  }\n}\nmodule Mod2 refines Mod {\n  import A = Implementation\n  ...\n}\n`\n\nWhen you refine an abstract import into a concrete one Dafny checks that the\nconcrete module is a refinement of the abstract one. This means that the methods\nmust have compatible signatures, all the classes and datatypes with their\nconstructors and fields in the abstract one must be present in the concrete one,\nthe specifications must be compatible, etc.\n\nA module that includes an abstract import must be declared `abstract`.\n\n### 4.7. Module Ordering and Dependencies\n\nDafny isn’t particular about the textual order in which modules are declared,\nbut they must follow some rules to be well formed. In particular, there must be\na way to order the modules in a program such that each only refers to things\ndefined **before** it in the ordering. That doesn’t mean the modules have to be\ngiven textually in that order in the source text. Dafny will figure out that\norder for you, assuming you haven’t made any circular references. For example,\nthis is pretty clearly meaningless:\n\n`import A = B\nimport B = A // error: circular\n`\n\nYou can have import statements at the toplevel and you can import modules\ndefined at the same level:\n\n`import A = B\nmethod m() {\n  A.whatever();\n}\nmodule B { method whatever() {} }\n`\n\nIn this case, everything is well defined because we can put `B` first, followed\nby the `A` import, and then finally `m()`. If there is no permitted ordering,\nthen Dafny will give an error, complaining about a cyclic dependency.\n\nNote that when rearranging modules and imports, they have to be kept in the same\ncontaining module, which disallows some pathological module structures. Also,\nthe imports and submodules are always considered to be before their containing\nmodule, even at the toplevel. This means that the following is not well formed:\n\n`method doIt() { }\nmodule M {\n  method m() {\n    doIt(); // error: M precedes doIt\n  }\n}\n`\n\nbecause the module `M` must come before any other kind of members, such as\nmethods. To define global functions like this, you can put them in a module\n(called `Globals`, say) and open it into any module that needs its\nfunctionality. Finally, if you import via a path, such as `import A = B.C`, then\nthis creates a dependency of `A` on `B`, and `B` itself depends on its own\nnested module `B.C`.\n\n### 4.8. Name Resolution\n\nWhen Dafny sees something like `A<T>.B<U>.C<V>`, how does it know what each part\nrefers to? The process Dafny uses to determine what identifier sequences like\nthis refer to is name resolution. Though the rules may seem complex, usually\nthey do what you would expect. Dafny first looks up the initial identifier.\nDepending on what the first identifier refers to, the rest of the identifier is\nlooked up in the appropriate context.\n\nIn terms of the grammar, sequences like the above are represented as a\n`NameSegment` followed by 0 or more `Suffix`es. The form shown above contains\nthree instances of `AugmentedDotSuffix_`.\n\nThe resolution is different depending on whether it is in a module context, an\nexpression context or a type context.\n\n#### 4.8.1. Modules and name spaces\n\nA module is a collection of declarations, each of which has a name. These names\nare held in two namespaces.\n\n* The names of export sets\n* The names of all other declarations, including submodules and aliased modules\n\nIn addition names can be classified as *local* or *imported*.\n\n* Local declarations of a module are the declarations that are explicit in the\n  module and the local declarations of the refinement parent. This includes, for\n  example, the `N` of `import N = ` in the refinement parent, recursively.\n* Imported names of a module are those brought in by `import opened` plus the\n  imported names in the refinement parent.\n\nWithin each namespace, the local names are unique. Thus a module may not reuse a\nname that a refinement parent has declared (unless it is a refining declaration,\nwhich replaces both declarations, as described in [Section 10][606]).\n\nLocal names take precedence over imported names. If a name is used more than\nonce among imported names (coming from different imports), then it is ambiguous\nto *use* the name without qualification.\n\n#### 4.8.2. Module Id Context Name Resolution\n\nA qualified name may be used to refer to a module in an import statement or a\nrefines clause of a module declaration. Such a qualified name is resolved as\nfollows, with respect to its syntactic location within a module `Z`:\n\n1. The leading identifier of the qualified name is resolved as a local or\n   imported module name of `Z`, if there is one with a matching name. The target\n   of a `refines` clause does not consider local names, that is, in `module Z\n   refines A.B.C`, any contents of `Z` are not considered in finding `A`.\n2. Otherwise, it is resolved as a local or imported module name of the most\n   enclosing module of `Z`, iterating outward to each successive enclosing\n   module until a match is found or the default toplevel module is reached\n   without a match. No consideration of export sets, default or otherwise, is\n   used in this step. However, if at any stage a matching name is found that is\n   not a module declaration, the resolution fails. See the examples below.\n\n3a. Once the leading identifier is resolved as say module `M`, the next\nidentifier in the quallified name is resolved as a local or imported module name\nwithin `M`. The resolution is restricted to the default export set of `M`.\n\n3b. If the resolved module name is a module alias (from an `import` statement)\nthen the target of the alias is resolved as a new qualified name with respect to\nits syntactic context (independent of any resolutions or modules so far). Since\n`Z` depends on `M`, any such alias target will already have been resolved,\nbecause modules are resolved in order of dependency.\n\n1. Step 3 is iterated for each identifier in the qualified module id, resulting\n   in a module that is the final resolution of the complete qualified id.\n\nOrdinarily a module must be *imported* in order for its constituent declarations\nto be visible inside a given module `M`. However, for the resolution of\nqualified names this is not the case.\n\nThis example shows that the resolution of the refinement parent does not use any\nlocal names:\n\n`module A {\n  const a := 10\n}\n\nmodule B refines A { // the top-level A, not the submodule A\n  module A { const a := 30 }\n  method m() { assert a == 10; } // true\n}\n`\n\nIn the example, the `A` in `refines A` refers to the global `A`, not the\nsubmodule `A`.\n\n#### 4.8.3. Expression Context Name Resolution\n\nThe leading identifier is resolved using the first following rule that succeeds.\n\n1. Local variables, parameters and bound variables. These are things like `x`,\n   `y`, and `i` in `var x;, ... returns (y: int)`, and `forall i :: ....` The\n   declaration chosen is the match from the innermost matching scope.\n2. If in a class, try to match a member of the class. If the member that is\n   found is not static an implicit `this` is inserted. This works for fields,\n   functions, and methods of the current class (if in a static context, then\n   only static methods and functions are allowed). You can refer to fields of\n   the current class either as `this.f` or `f`, assuming of course that `f` is\n   not hidden by one of the above. You can always prefix `this` if needed, which\n   cannot be hidden. (Note that a field whose name is a string of digits must\n   always have some prefix.)\n3. If there is no `Suffix`, then look for a datatype constructor, if\n   unambiguous. Any datatypes that don’t need qualification (so the datatype\n   name itself doesn’t need a prefix) and also have a uniquely named constructor\n   can be referred to just by name. So if `datatype List = Cons(List) | Nil` is\n   the only datatype that declares `Cons` and `Nil` constructors, then you can\n   write `Cons(Cons(Nil))`. If the constructor name is not unique, then you need\n   to prefix it with the name of the datatype (for example\n   `List.Cons(List.Nil)))`. This is done per constructor, not per datatype.\n4. Look for a member of the enclosing module.\n5. Module-level (static) functions and methods\n\nIn each module, names from opened modules are also potential matches, but only\nafter names declared in the module. If an ambiguous name is found or a name of\nthe wrong kind (e.g. a module instead of an expression identifier), an error is\ngenerated, rather than continuing down the list.\n\nAfter the first identifier, the rules are basically the same, except in the new\ncontext. For example, if the first identifier is a module, then the next\nidentifier looks into that module. Opened modules only apply within the module\nit is opened into. When looking up into another module, only things explicitly\ndeclared in that module are considered.\n\nTo resolve expression `E.id`:\n\nFirst resolve expression E and any type arguments.\n\n* If `E` resolved to a module `M`:\n  \n  1. If `E.id<T>` is not followed by any further suffixes, look for unambiguous\n     datatype constructor.\n  2. Member of module M: a sub-module (including submodules of imports), class,\n     datatype, etc.\n  3. Static function or method.\n* If `E` denotes a type:\n  \n  1. Look up id as a member of that type\n* If `E` denotes an expression:\n  \n  1. Let T be the type of E. Look up id in T.\n\n#### 4.8.4. Type Context Name Resolution\n\nIn a type context the priority of identifier resolution is:\n\n1. Type parameters.\n2. Member of enclosing module (type name or the name of a module).\n\nTo resolve expression `E.id`:\n\n* If `E` resolved to a module `M`:\n  \n  1. Member of module M: a sub-module (including submodules of imports), class,\n     datatype, etc.\n* If `E` denotes a type:\n  \n  1. Then the validity and meaning of `id` depends on the type and must be a\n     user-declared or pre-defined member of the type.\n\n## 5. Types\n\nA Dafny type is a (possibly-empty) set of values or heap data-structures,\ntogether with allowed operations on those values. Types are classified as\nmutable reference types or immutable value types, depending on whether their\nvalues are stored in the heap or are (mathematical) values independent of the\nheap.\n\nDafny supports the following kinds of types, all described in later sections of\nthis manual:\n\n* [builtin scalar types][607],\n* [builtin collection types][608],\n* reference types ([classes][609], [arrays][610], [iterators][611]),\n* [abstract supertypes][612] (traits)\n* [tuple types][613] (including as a special case a parenthesized type),\n* [inductive][614] and [coinductive][615] datatypes,\n* [function (arrow) types][616], and\n* [types, such as subset types, derived from other types][617].\n\n### 5.1. Kinds of types\n\n#### 5.1.1. Value Types\n\nThe value types are those whose values do not lie in the program heap. These\nare:\n\n* The basic scalar types: `bool`, `char`, `int`, `real`, `ORDINAL`, bitvector\n  types\n* The built-in collection types: `set`, `iset`, `multiset`, `seq`, `string`,\n  `map`, `imap`\n* Tuple Types\n* Inductive and coinductive types\n* Function (arrow) types\n* Subset and newtypes that are based on value types\n\nData items having value types are passed by value. Since they are not considered\nto occupy *memory*, framing expressions do not reference them.\n\nThe `nat` type is a pre-defined [subset type][618] of `int`.\n\nDafny does not include types themselves as values, nor is there a type of types.\n\n#### 5.1.2. Reference Types\n\nDafny offers a host of *reference types*. These represent *references* to\nobjects allocated dynamically in the program heap. To access the members of an\nobject, a reference to (that is, a *pointer* to or *object identity* of) the\nobject is *dereferenced*.\n\nThe reference types are class types, traits and array types. Dafny supports both\nreference types that contain the special `null` value (*nullable types*) and\nreference types that do not (*non-null types*).\n\n#### 5.1.3. Named Types ([grammar][619])\n\nA *Named Type* is used to specify a user-defined type by a (possibly module- or\nclass-qualified) name. Named types are introduced by class, trait, inductive,\ncoinductive, synonym and abstract type declarations. They are also used to refer\nto type variables. A Named Type is denoted by a dot-separated sequence of name\nsegments ([Section 9.32][620]).\n\nA name segment (for a type) is a type name optionally followed by a *generic\ninstantiation*, which supplies type parameters to a generic type, if needed.\n\nThe following sections describe each of these kinds of types in more detail.\n\n### 5.2. Basic types\n\nDafny offers these basic types: `bool` for booleans, `char` for characters,\n`int` and `nat` for integers, `real` for reals, `ORDINAL`, and bit-vector types.\n\n#### 5.2.1. Booleans ([grammar][621])\n\nThere are two boolean values and each has a corresponding literal in the\nlanguage: `false` and `true`.\n\nType `bool` supports the following operations:\n\n────────┬──────────┬──────────────────────────────────\noperator│precedence│description                       \n────────┼──────────┼──────────────────────────────────\n`<==>`  │1         │equivalence (if and only if)      \n────────┼──────────┼──────────────────────────────────\n`==>`   │2         │implication (implies)             \n────────┼──────────┼──────────────────────────────────\n`<==`   │2         │reverse implication (follows from)\n────────┼──────────┼──────────────────────────────────\n`&&`    │3         │conjunction (and)                 \n────────┼──────────┼──────────────────────────────────\n`||`    │3         │disjunction (or)                  \n────────┼──────────┼──────────────────────────────────\n`==`    │4         │equality                          \n────────┼──────────┼──────────────────────────────────\n`!=`    │4         │disequality                       \n────────┼──────────┼──────────────────────────────────\n`!`     │10        │negation (not)                    \n────────┴──────────┴──────────────────────────────────\n\nNegation is unary; the others are binary. The table shows the operators in\ngroups of increasing binding power, with equality binding stronger than\nconjunction and disjunction, and weaker than negation. Within each group,\ndifferent operators do not associate, so parentheses need to be used. For\nexample,\n\n`A && B || C    // error\n`\n\nwould be ambiguous and instead has to be written as either\n\n`(A && B) || C\n`\n\nor\n\n`A && (B || C)\n`\n\ndepending on the intended meaning.\n\n5.2.1.1. Equivalence Operator\n\nThe expressions `A <==> B` and `A == B` give the same value, but note that\n`<==>` is *associative* whereas `==` is *chaining* and they have different\nprecedence. So,\n\n`A <==> B <==> C\n`\n\nis the same as\n\n`A <==> (B <==> C)\n`\n\nand\n\n`(A <==> B) <==> C\n`\n\nwhereas\n\n`A == B == C\n`\n\nis simply a shorthand for\n\n`A == B && B == C\n`\n\nAlso,\n\n`A <==> B == C <==> D\n`\n\nis\n\n`A <==> (B == C) <==> D\n`\n5.2.1.2. Conjunction and Disjunction\n\nConjunction and disjunction are associative. These operators are *short\ncircuiting (from left to right)*, meaning that their second argument is\nevaluated only if the evaluation of the first operand does not determine the\nvalue of the expression. Logically speaking, the expression `A && B` is defined\nwhen `A` is defined and either `A` evaluates to `false` or `B` is defined. When\n`A && B` is defined, its meaning is the same as the ordinary, symmetric\nmathematical conjunction `&`. The same holds for `||` and `|`.\n\n5.2.1.3. Implication and Reverse Implication\n\nImplication is *right associative* and is short-circuiting from left to right.\nReverse implication `B <== A` is exactly the same as `A ==> B`, but gives the\nability to write the operands in the opposite order. Consequently, reverse\nimplication is *left associative* and is short-circuiting from *right to left*.\nTo illustrate the associativity rules, each of the following four lines\nexpresses the same property, for any `A`, `B`, and `C` of type `bool`:\n\n`A ==> B ==> C\nA ==> (B ==> C) // parentheses redundant, ==> is right associative\nC <== B <== A\n(C <== B) <== A // parentheses redundant, <== is left associative\n`\n\nTo illustrate the short-circuiting rules, note that the expression `a.Length` is\ndefined for an array `a` only if `a` is not `null` (see [Section 5.1.2][622]),\nwhich means the following two expressions are [well-formed][623]:\n\n`a != null ==> 0 <= a.Length\n0 <= a.Length <== a != null\n`\n\nThe contrapositives of these two expressions would be:\n\n`a.Length < 0 ==> a == null  // not well-formed\na == null <== a.Length < 0  // not well-formed\n`\n\nbut these expressions might not necessarily be [well-formed][624], since\nwell-formedness requires the left (and right, respectively) operand, `a.Length <\n0`, to be [well-formed][625] in their context.\n\nImplication `A ==> B` is equivalent to the disjunction `!A || B`, but is\nsometimes (especially in specifications) clearer to read. Since, `||` is\nshort-circuiting from left to right, note that\n\n`a == null || 0 <= a.Length\n`\n\nis [well-formed][626] by itself, whereas\n\n`0 <= a.Length || a == null  // not well-formed\n`\n\nis not if the context cannot prove that `a != null`.\n\nIn addition, booleans support *logical quantifiers* (forall and exists),\ndescribed in [Section 9.31.4][627].\n\n#### 5.2.2. Numeric Types ([grammar][628])\n\nDafny supports *numeric types* of two kinds, *integer-based*, which includes the\nbasic type `int` of all integers, and *real-based*, which includes the basic\ntype `real` of all real numbers and the floating-point type `fp64`. User-defined\nnumeric types based on `int` and `real`, either *subset types* or *newtypes*,\nare described in [Section 5.6.3][629] and [Section 5.7][630].\n\nThere is one built-in [*subset type*][631], `nat`, representing the non-negative\nsubrange of `int`.\n\nThe language includes a literal for each integer, like `0`, `13`, and `1985`.\nIntegers can also be written in hexadecimal using the prefix “`0x`”, as in\n`0x0`, `0xD`, and `0x7c1` (always with a lower case `x`, but the hexadecimal\ndigits themselves are case insensitive). Leading zeros are allowed. To form\nnegative literals, use the unary minus operator, as in `-12`, but not `-(12)`.\n\nThere are also **real literals** for some of the reals. Real literals are\nwritten as decimal numbers, optionally prefixed by a `-` character. Examples:\n`1.0`, `1609.344`, `-12.5`, and `0.5772156649`.\n\nReal literals can also be written in **scientific notation** using lowercase `e`\nto denote the exponent. For example, `1.23e5` (which equals `123000.0`),\n`1.23e-2` (which equals `0.0123`), and `5e2` (which equals `500.0`). Both\ndecimal numbers with optional exponents (like `1.23e5`) and integers with\nmandatory exponents (like `123e5`) are supported.\n\nAs a convenience, **trailing-dot shorthand** can be used with real literals,\nwhere a trailing-dot represents `.0`. For example, `1.` means `1.0` and `123.`\nmeans `123.0`.\n\nReal literals also support **leading-dot shorthand** for decimal values less\nthan 1. For example, `.5` means `0.5`, `.25` means `0.25`, and leading-dot\nshorthand can be combined with scientific notation like `.5e2` (which equals\n`50.0`) or `.123e-4` (which equals `0.0000123`).\n\nFor integers (in both decimal and hexadecimal form) and reals, any two digits in\na literal may be separated by an underscore in order to improve human\nreadability of the literals. For example:\n\n`const c1 := 1_000_000        // easier to read than 1000000\nconst c2 := 0_12_345_6789    // strange but legal formatting of 123456789\nconst c3 := 0x8000_0000      // same as 0x80000000 -- hex digits are\n                             // often placed in groups of 4\nconst c4 := 0.000_000_000_1  // same as 0.0000000001 -- 1 Angstrom\n`\n\nIn addition to equality and disequality, numeric types support the following\nrelational operations, which have the same precedence as equality:\n\n────────┬────────────\noperator│description \n────────┼────────────\n`<`     │less than   \n────────┼────────────\n`<=`    │at most     \n────────┼────────────\n`>=`    │at least    \n────────┼────────────\n`>`     │greater than\n────────┴────────────\n\nLike equality and disequality, these operators are chaining, as long as they are\nchained in the “same direction”. That is,\n\n`A <= B < C == D <= E\n`\n\nis simply a shorthand for\n\n`A <= B && B < C && C == D && D <= E\n`\n\nwhereas\n\n`A < B > C\n`\n\nis not allowed.\n\nThere are also operators on each numeric type:\n\n────────┬──────────┬────────────────────────\noperator│precedence│description             \n────────┼──────────┼────────────────────────\n`+`     │6         │addition (plus)         \n────────┼──────────┼────────────────────────\n`-`     │6         │subtraction (minus)     \n────────┼──────────┼────────────────────────\n`*`     │7         │multiplication (times)  \n────────┼──────────┼────────────────────────\n`/`     │7         │division (divided by)   \n────────┼──────────┼────────────────────────\n`%`     │7         │modulus (mod) – int only\n────────┼──────────┼────────────────────────\n`-`     │10        │negation (unary minus)  \n────────┴──────────┴────────────────────────\n\nThe binary operators are left associative, and they associate with each other in\nthe two groups. The groups are listed in order of increasing binding power, with\nequality binding less strongly than any of these operators. There is no implicit\nconversion between `int` and `real`: use `as int` or `as real` conversions to\nwrite an explicit conversion (cf. [Section 9.10][632]).\n\nModulus is supported only for integer-based numeric types. Integer division and\nmodulus are the *Euclidean division and modulus*. This means that modulus always\nreturns a non-negative value, regardless of the signs of the two operands. More\nprecisely, for any integer `a` and non-zero integer `b`,\n\n`a == a / b * b + a % b\n0 <= a % b < B\n`\n\nwhere `B` denotes the absolute value of `b`.\n\nReal-based numeric types have a member `Floor` that returns the *floor* of the\nreal value (as an int value), that is, the largest integer not exceeding the\nreal value. For example, the following properties hold, for any `r` and `r'` of\ntype `real`:\n\n`method m(r: real, r': real) {\n  assert 3.14.Floor == 3;\n  assert (-2.5).Floor == -3;\n  assert -2.5.Floor == -2; // This is -(2.5.Floor)\n  assert r.Floor as real <= r;\n  assert r <= r' ==> r.Floor <= r'.Floor;\n}\n`\n\nNote in the third line that member access (like `.Floor`) binds stronger than\nunary minus. The fourth line uses the conversion function `as real` from `int`\nto `real`, as described in [Section 9.10][633].\n\n#### 5.2.3. Floating-point Types (fp32 and fp64)\n\nDafny supports two floating-point types: `fp32` (IEEE 754 binary32,\nsingle-precision) and `fp64` (IEEE 754 binary64, double-precision). These types\nprovide hardware-compatible floating-point arithmetic with the expected\nprecision and rounding behavior. Both types are considered real-based numeric\ntypes in Dafny’s type system.\n\nThe `fp32` type has 24 bits of significand precision (approximately 7 decimal\ndigits), while `fp64` has 53 bits (approximately 16 decimal digits).\n\n5.2.3.1. Literals\n\nFloating-point literals use the same notation as real literals, but the type\nsystem distinguishes between exact and approximate representations:\n\n* **Exact literals**: Values that can be represented exactly in binary\n  floating-point, such as powers of 2 (`0.5`, `0.25`, `1.0`) and small integers.\n* **Approximate literals**: Values that cannot be represented exactly and\n  require the `~` prefix to acknowledge rounding. For example, `~0.1`, `~3.14`,\n  `~0.3`.\n`method FloatingPointLiterals() {\n  var exact: fp64 := 0.5;      // Exact: 0.5 = 2^(-1)\n  var approx: fp64 := ~0.1;    // Approximate: 0.1 cannot be exactly represented\n\n  // Scientific notation is supported\n  var large: fp64 := 1.23e10;  // 12300000000.0\n  var small: fp64 := ~1.5e-10; // Very small number\n}\n`\n\nThe `~` prefix must encompass the entire literal including the sign:\n\n* Correct: `~-0.1` (approximate negative one-tenth)\n* Incorrect: `-~0.1` (not allowed)\n5.2.3.2. Special Values\n\nBoth `fp32` and `fp64` types include IEEE 754 special values as static members:\n\n* `fp32.NaN` / `fp64.NaN` - Not a Number\n* `fp32.PositiveInfinity` / `fp64.PositiveInfinity` - Positive infinity (+∞)\n* `fp32.NegativeInfinity` / `fp64.NegativeInfinity` - Negative infinity (-∞)\n\nAdditional constants include:\n\n* `MaxValue` - Largest finite positive value\n* `MinValue` - Most negative finite value\n* `Epsilon` - Smallest positive value such that `1.0 + Epsilon != 1.0`\n* `MinNormal` - Smallest positive normal number\n* `MinSubnormal` - Smallest positive subnormal number\n* `Pi` - The mathematical constant π (pi)\n* `E` - The mathematical constant e (Euler’s number)\n5.2.3.3. Classification Predicates\n\nValues of type `fp32` and `fp64` support classification predicates to test for\nspecial values:\n\n* `.IsNaN` - true if the value is NaN\n* `.IsInfinite` - true if the value is positive or negative infinity\n* `.IsFinite` - true if the value is neither NaN nor infinite\n* `.IsNormal` - true if the value is a normal (not subnormal) number\n* `.IsSubnormal` - true if the value is a subnormal number\n* `.IsZero` - true if the value is positive or negative zero\n* `.IsPositive` - true if the value has a positive sign\n* `.IsNegative` - true if the value has a negative sign\n`method ClassificationExample() {\n  var nan := fp64.NaN;\n  var inf := fp64.PositiveInfinity;\n  var zero: fp64 := 0.0;\n  var normal: fp64 := 1.0;\n\n  assert nan.IsNaN;\n  assert inf.IsInfinite && inf.IsPositive;\n  assert zero.IsZero && zero.IsFinite;\n  assert normal.IsNormal && normal.IsFinite;\n}\n`\n5.2.3.4. Arithmetic Operations\n\nBoth `fp32` and `fp64` types support standard arithmetic operations following\nIEEE 754 semantics:\n\n* Addition (`+`), subtraction (`-`), multiplication (`*`), division (`/`)\n* Unary negation (`-`)\n* Comparisons (`<`, `<=`, `>`, `>=`)\n\n**Well-formedness checks**: All these arithmetic operations and comparisons\nrequire that operands are not NaN. Additionally, certain combinations of\ninfinity values produce invalid operations:\n\n* Addition: `∞ + (-∞)` is invalid\n* Subtraction: `∞ - ∞` is invalid\n* Multiplication: `∞ * 0` is invalid\n* Division: `0 / 0` and `∞ / ∞` are invalid\n\nThese well-formedness checks are performed by Dafny. To help it, use the\nclassification predicates (`.IsNaN`, `.IsInfinite`, `.IsZero`).\n\n`method FloatingPointArithmetic() {\n  var a: fp64 := ~0.1;\n  var b: fp64 := ~0.2;\n  var c: fp64 := ~0.3;\n\n  assert a + b != c;  // 0.1 + 0.2 != 0.3 due to rounding\n}\n\nmethod SafeArithmetic(x: fp64, y: fp64) returns (result: fp64)\n  requires !x.IsNaN && !y.IsNaN\n  requires !(x.IsInfinite && y.IsInfinite && x.IsPositive != y.IsPositive)\n{\n  result := x + y;  // OK: preconditions established\n}\n`\n5.2.3.5. Equality\n\nBoth `fp32` and `fp64` types have equality semantics that differ from IEEE 754.\nEquality is defined based on the bit representation:\n\n* In **compiled contexts** the `==` operator has **well-formedness conditions**\n  that require operands to not be NaN and, if they are zeros, to have the same\n  sign. Under these conditions, `==` behaves like IEEE 754 equality.\n* In **ghost contexts** (specifications, assertions): The well-formedness\n  conditions are relaxed, and `==` performs bitwise comparison where NaN equals\n  itself and positive/negative zero are distinct.\n* The static methods `fp32.Equal(a, b)` and `fp64.Equal(a, b)` provide IEEE 754\n  equality semantics without well-formedness restrictions (NaN is not equal to\n  anything including itself, and ±0 are equal).\n`method EqualityExample(x: fp64, y: fp64) {\n  var nan := fp64.NaN;\n  var posZero: fp64 := 0.0;\n  var negZero: fp64 := -0.0;\n\n  // In ghost context - no well-formedness restrictions\n  assert nan == nan;           // true (bitwise comparison)\n  assert posZero != negZero;   // true (different bit patterns)\n\n  // In compiled context - well-formedness restrictions verified statically\n  // var b1 := x == y;              // ERROR: verifier cannot prove x and y are \nnot NaN\n  // var b2 := posZero == negZero;  // ERROR: verifier knows they have different\n signs\n\n  // Valid use of == when preconditions can be verified\n  if !x.IsNaN {\n    // Can compare posZero with x since we know posZero is not NaN,\n    // and if x is also zero, we'd need to check signs match\n    if !x.IsZero || !x.IsNegative {\n      var equal := posZero == x;  // OK: not NaN, and no sign mismatch\n      print \"0.0 == \", x, \": \", equal, \"\\n\";\n    }\n  }\n\n  // Simpler: just use fp64.Equal when unsure about values\n  var maybeNaN := if !x.IsNaN && x.IsNegative then fp64.NaN else x;\n  // var bad := maybeNaN == x;  // ERROR: cannot prove maybeNaN is not NaN\n  var safe := fp64.Equal(maybeNaN, x);  // Always works, no preconditions\n\n  // fp64.Equal always uses IEEE 754 semantics\n  assert !fp64.Equal(nan, nan);        // NaN != NaN\n  assert fp64.Equal(posZero, negZero); // ±0 are equal\n}\n`\n5.2.3.6. Unchecked Arithmetic and Comparison Methods\n\nFor operations that may involve NaN or invalid infinity combinations, both\n`fp32` and `fp64` provide unchecked static methods:\n\n**Arithmetic methods:**\n\n* `fp32.Add(x, y)` / `fp64.Add(x, y)` - Addition without well-formedness checks\n* `fp32.Sub(x, y)` / `fp64.Sub(x, y)` - Subtraction without well-formedness\n  checks\n* `fp32.Mul(x, y)` / `fp64.Mul(x, y)` - Multiplication without well-formedness\n  checks\n* `fp32.Div(x, y)` / `fp64.Div(x, y)` - Division without well-formedness checks\n* `fp32.Neg(x)` / `fp64.Neg(x)` - Negation without well-formedness checks\n\n**Comparison methods:**\n\n* `fp32.Less(x, y)` / `fp64.Less(x, y)` - Less than without well-formedness\n  checks\n* `fp32.LessOrEqual(x, y)` / `fp64.LessOrEqual(x, y)` - Less than or equal\n  without well-formedness checks\n* `fp32.Greater(x, y)` / `fp64.Greater(x, y)` - Greater than without\n  well-formedness checks\n* `fp32.GreaterOrEqual(x, y)` / `fp64.GreaterOrEqual(x, y)` - Greater than or\n  equal without well-formedness checks\n\nThese methods follow IEEE 754 semantics exactly, including producing NaN for\ninvalid operations and returning false for all comparisons involving NaN.\n\n`method EdgeCaseTesting() {\n  var nan := fp64.NaN;\n  var inf := fp64.PositiveInfinity;\n\n  // These would fail with operators due to wellformedness checks:\n  // var bad1 := nan + 1.0;      // ERROR: fp64 arithmetic requires that operand\ns are not NaN\n  // var bad2 := inf - inf;      // ERROR: fp64 subtraction has invalid operand \ncombination\n  // var bad3 := nan < 1.0;      // ERROR: fp64 comparison requires that operand\ns are not NaN\n\n  // But work with unchecked static methods:\n  var result1 := fp64.Add(nan, 1.0);\n  var result2 := fp64.Sub(inf, inf);\n  var result3 := fp64.Less(nan, 1.0);\n\n  assert result1.IsNaN;  // NaN propagates\n  assert result2.IsNaN;  // ∞ - ∞ = NaN\n  assert !result3;       // NaN < anything = false\n}\n`\n\n**Recommendation**: Use operators (`+`, `-`, `*`, `/`, `<`, etc.) by default for\ntheir safety guarantees. Only use these unchecked static methods when you\nspecifically need to handle edge cases or rely on IEEE 754 behavior.\n\n5.2.3.7. Mathematical Functions\n\nBoth `fp32` and `fp64` types provide static methods for common mathematical\noperations. All functions require that operands are not NaN, and some have\nadditional preconditions:\n\n* `fp32.Abs(x)` / `fp64.Abs(x)` - Absolute value. **Requires**: `!x.IsNaN`.\n* `fp32.Sqrt(x)` / `fp64.Sqrt(x)` - Square root. **Requires**: `!x.IsNaN` and `x\n  ≥ 0.0` (non-negative). Returns √x for finite x ≥ 0, returns +∞ for x = +∞.\n* `fp32.Min(x, y)` / `fp64.Min(x, y)` - Minimum of two values. **Requires**:\n  `!x.IsNaN && !y.IsNaN`.\n* `fp32.Max(x, y)` / `fp64.Max(x, y)` - Maximum of two values. **Requires**:\n  `!x.IsNaN && !y.IsNaN`.\n* `fp32.Floor(x)` / `fp64.Floor(x)` - Round down to nearest integer.\n  **Requires**: `!x.IsNaN`.\n* `fp32.Ceiling(x)` / `fp64.Ceiling(x)` - Round up to nearest integer.\n  **Requires**: `!x.IsNaN`.\n* `fp32.Round(x)` / `fp64.Round(x)` - Round to nearest integer, ties to even.\n  **Requires**: `!x.IsNaN`.\n* `fp32.ToInt(x)` / `fp64.ToInt(x)` - Convert to integer. **Requires**:\n  `x.IsFinite`.\n`method MathFunctions() {\n  var x: fp64 := -3.5;\n  var y: fp64 := 2.0;\n\n  var absX := fp64.Abs(x);\n  var sqrtY := fp64.Sqrt(y);\n  var minimum := fp64.Min(x, y);\n  var floored := fp64.Floor(x);\n  var ceiled := fp64.Ceiling(x);\n  var rounded := fp64.Round(2.5);  // Rounds to 2.0 (nearest even)\n\n  assert absX == 3.5;\n  assert sqrtY == ~1.4142135623730951;  // Approximate √2\n  assert minimum == x;\n  assert floored == -4.0;\n  assert ceiled == -3.0;\n  assert rounded == 2.0;\n}\n`\n\nSpecial value behavior:\n\n`method SpecialValueBehavior() {\n  var inf := fp64.PositiveInfinity;\n  var negInf := fp64.NegativeInfinity;\n\n  // Math functions work with infinity when preconditions are met\n  var sqrtInf := fp64.Sqrt(inf);        // Returns positive infinity\n  var absNegInf := fp64.Abs(negInf);    // Returns positive infinity\n  var minInf := fp64.Min(inf, negInf);  // Returns negative infinity\n\n  assert sqrtInf == fp64.PositiveInfinity;\n  assert absNegInf == fp64.PositiveInfinity;\n  assert minInf == fp64.NegativeInfinity;\n\n  // Well-formedness checks prevent invalid operations\n  // var sqrtNeg := fp64.Sqrt(-1.0);   // ERROR: negative input not allowed\n  // var floorNaN := fp64.Floor(fp64.NaN); // ERROR: NaN not allowed\n}\n`\n5.2.3.8. Type Conversions\n\nBoth `fp32` and `fp64` types support conversions to and from other numeric types\nusing the `as` operator:\n\n* **From `real` to `fp32`/`fp64`**: Requires the real value to be exactly\n  representable in the target type.\n* **From `fp32`/`fp64` to `real`**: Requires the floating-point value to be\n  finite (not NaN or infinity).\n* **From `int` to `fp32`/`fp64`**: Requires the integer to be exactly\n  representable in the target type.\n* **From `fp32`/`fp64` to `int`**: Requires the floating-point value to be\n  finite and represent an exact integer.\n* **Between `fp32` and `fp64`**: Conversions are allowed in both directions.\n  `fp32` to `fp64` is always exact. `fp64` to `fp32` requires the value to be\n  exactly representable in fp32.\n\n**Note**: Direct conversions between `bv` and floating-point types are not\nsupported. To convert between these types, use `int` as an intermediate type\n(e.g., `bv_value as int as fp64` or `fp64_value as int as bv32`).\n\n`method ConversionExamples() {\n  // Real to fp64\n  var r1: real := 0.5;\n  // var f1: fp64 := r1 as fp64;  // OK: 0.5 is exactly representable, but times\n out\n\n  var r2: real := 0.1;\n  // var f2: fp64 := r2 as fp64;  // ERROR: 0.1 is not exactly representable\n\n  // fp64 to real\n  var f3: fp64 := 42.5;\n  var r3: real := f3 as real;  // OK: finite value\n\n  // int to fp64\n  var i1: int := 42;\n  // var f4: fp64 := i1 as fp64;  // OK: 42 is exactly representable, but times \nout\n  var i2: int := 9007199254740992;  // 2^53\n  // var f5: fp64 := i2 as fp64;  // OK: 2^53 is exactly representable, but time\ns out\n  var i3: int := 9007199254740993;  // 2^53 + 1\n  // var f6: fp64 := i3 as fp64;  // ERROR: 2^53 + 1 is not exactly representabl\ne\n\n  // fp64 to int\n  var f7: fp64 := 3.0;\n  var i4: int := f7 as int;  // OK: 3 is an integer\n\n  var f8: fp64 := ~3.14;\n  // var i5: int := f8 as int;  // ERROR: 3.14 is not an integer\n}\n`\n\n**Note**: There is a known limitation with conversions to floating-point types\nusing the `as` operator:\n\n* **Direct literal conversions work**: `42 as fp64`, `0.5 as fp32` verify\n  successfully.\n* **Variable conversions may timeout**: Converting a variable to fp32/fp64\n  (e.g., `var i := 42; i as fp64`) may cause verification timeouts due to Z3’s\n  difficulty combining quantifiers and floats.\n\nTo avoid this limitation, use direct literal conversions where possible.\n\n5.2.3.9. Inexact Conversion Methods\n\nIn addition to the exact conversions using the `as` operator, both `fp32` and\n`fp64` provide static methods for conversions that may involve rounding or\ntruncation:\n\n* `fp32.FromReal(r)` / `fp64.FromReal(r)` - Converts a real value to the target\n  type with rounding. Values outside the representable range become ±infinity.\n  No preconditions.\n* `fp32.ToInt(x)` / `fp64.ToInt(x)` - Converts a floating-point value to\n  unbounded int by truncating towards zero (like C cast). Requires x to be\n  finite (not NaN or infinity). This precondition is inspired by IEEE 754 which\n  specifies that implementations shall signal invalid operation for NaN/infinity\n  to integer conversions.\n`method InexactConversions() {\n  // FromReal allows any real value and rounds as needed\n  var r1: real := 0.1;\n  var f1 := fp64.FromReal(r1);  // OK: rounds to nearest representable value\n\n  // Verification times out here\n  // var huge: real := 1e400;\n  // var f2 := fp64.FromReal(huge);  // Becomes positive infinity\n  // assert f2 == fp64.PositiveInfinity;\n\n  // ToInt truncates towards zero (Round Toward Zero - RTZ)\n  var f3: fp64 := 3.75;  // Exactly representable\n  var i1 := fp64.ToInt(f3);  // Returns 3\n  assert i1 == 3;\n\n  var f4: fp64 := -3.75;  // Exactly representable\n  var i2 := fp64.ToInt(f4);  // Returns -3 (truncates toward zero, not -4)\n  assert i2 == -3;\n}\n\n// This method demonstrates the precondition check\nmethod ToIntWellformednessExamples() {\n  var finite: fp64 := 42.5;\n  var i := fp64.ToInt(finite);  // OK: finite value\n  assert i == 42;\n\n  // The following would fail verification:\n  // var inf := fp64.PositiveInfinity;\n  // var i_inf := fp64.ToInt(inf);  // Error: requires finite argument\n\n  // var nan := fp64.NaN;\n  // var i_nan := fp64.ToInt(nan);  // Error: requires finite argument\n}\n`\n5.2.3.10. Comparison of Numeric Types\n\n────────────────┬─────────────┬───────────┬─────────────────────\nAspect          │int          │real       │fp64                 \n────────────────┼─────────────┼───────────┼─────────────────────\nNumeric kind    │integer-based│real-based │real-based           \n────────────────┼─────────────┼───────────┼─────────────────────\nPrecision       │Unlimited    │Exact      │~15-17 decimal digits\n────────────────┼─────────────┼───────────┼─────────────────────\nSpecial values  │None         │None       │NaN, ±∞              \n────────────────┼─────────────┼───────────┼─────────────────────\nModulus operator│Yes          │No         │No                   \n────────────────┼─────────────┼───────────┼─────────────────────\nHardware mapping│BigInteger   │BigRational│IEEE 754 binary64    \n────────────────┴─────────────┴───────────┴─────────────────────\n\n#### 5.2.4. Bit-vector Types ([grammar][634])\n\nDafny includes a family of bit-vector types, each type having a specific,\nconstant length, the number of bits in its values. Each such type is distinct\nand is designated by the prefix `bv` followed (without white space) by a\npositive integer without leading zeros or zero, stating the number of bits. For\nexample, `bv1`, `bv8`, and `bv32` are legal bit-vector type names. The type\n`bv0` is also legal; it is a bit-vector type with no bits and just one value,\n`0x0`.\n\nConstant literals of bit-vector types are given by integer literals converted\nautomatically to the designated type, either by an implicit or explicit\nconversion operation or by initialization in a declaration. Dafny checks that\nthe constant literal is in the correct range. For example,\n\n`const i: bv1 := 1\nconst j: bv8 := 195\nconst k: bv2 := 5 // error - out of range\nconst m := (194 as bv8) | (7 as bv8)\n`\n\nBit-vector values can be converted to and from `int` and other bit-vector types,\nas long as the values are in range for the target type. Bit-vector values are\nalways considered unsigned.\n\nBit-vector operations include bit-wise operators and arithmetic operators (as\nwell as equality, disequality, and comparisons). The arithmetic operations\ntruncate the high-order bits from the results; that is, they perform unsigned\narithmetic modulo 2^{number of bits}, like 2’s-complement machine arithmetic.\n\n───────────────┬──────────┬─────────────────────────────────────\noperator       │precedence│description                          \n───────────────┼──────────┼─────────────────────────────────────\n`<<`           │5         │bit-limited bit-shift left           \n───────────────┼──────────┼─────────────────────────────────────\n`>>`           │5         │unsigned bit-shift right             \n───────────────┼──────────┼─────────────────────────────────────\n`+`            │6         │bit-limited addition                 \n───────────────┼──────────┼─────────────────────────────────────\n`-`            │6         │bit-limited subtraction              \n───────────────┼──────────┼─────────────────────────────────────\n`*`            │7         │bit-limited multiplication           \n───────────────┼──────────┼─────────────────────────────────────\n`&`            │8         │bit-wise and                         \n───────────────┼──────────┼─────────────────────────────────────\n`|`            │8         │bit-wise or                          \n───────────────┼──────────┼─────────────────────────────────────\n`^`            │8         │bit-wise exclusive-or                \n───────────────┼──────────┼─────────────────────────────────────\n`-`            │10        │bit-limited negation (unary minus)   \n───────────────┼──────────┼─────────────────────────────────────\n`!`            │10        │bit-wise complement                  \n───────────────┼──────────┼─────────────────────────────────────\n.RotateLeft(n) │11        │rotates bits left by n bit positions \n───────────────┼──────────┼─────────────────────────────────────\n.RotateRight(n)│11        │rotates bits right by n bit positions\n───────────────┴──────────┴─────────────────────────────────────\n\nThe groups of operators lower in the table above bind more tightly.^{[1][635]}\nAll operators bind more tightly than equality, disequality, and comparisons. All\nbinary operators are left-associative, but the bit-wise `&`, `|`, and `^` do not\nassociate together (parentheses are required to disambiguate). The `+`, `|`,\n`^`, and `&` operators are commutative.\n\nThe right-hand operand of bit-shift operations is an `int` value, must be\nnon-negative, and no more than the number of bits in the type. There is no\nsigned right shift as all bit-vector values correspond to non-negative integers.\n\nBit-vector negation returns an unsigned value in the correct range for the type.\nIt has the properties `x + (-x) == 0` and `(!x) + 1 == -x`, for a bitvector\nvalue `x` of at least one bit.\n\nThe argument of the `RotateLeft` and `RotateRight` operations is a non-negative\n`int` that is no larger than the bit-width of the value being rotated.\n`RotateLeft` moves bits to higher bit positions (e.g., `(2 as bv4).RotateLeft(1)\n== (4 as bv4)` and `(8 as bv4).RotateLeft(1) == (1 as bv4)`); `RotateRight`\nmoves bits to lower bit positions, so `b.RotateLeft(n).RotateRight(n) == b`.\n\nHere are examples of the various operations (all the assertions are true except\nwhere indicated):\n\n`const i: bv4 := 9\nconst j: bv4 := 3\n\nmethod m() {\n  assert (i & j) == (1 as bv4);\n  assert (i | j) == (11 as bv4);\n  assert (i ^ j) == (10 as bv4);\n  assert !i == (6 as bv4);\n  assert -i == (7 as bv4);\n  assert (i + i) == (2 as bv4);\n  assert (j - i) == (10 as bv4);\n  assert (i * j) == (11 as bv4);\n  assert (i as int) / (j as int) == 3;\n  assert (j << 1) == (6 as bv4);\n  assert (i << 1) == (2 as bv4);\n  assert (i >> 1) == (4 as bv4);\n  assert i == 9; // auto conversion of literal to bv4\n  assert i * 4 == j + 8 + 9; // arithmetic is modulo 16\n  assert i + j >> 1 == (i + j) >> 1; // + - bind tigher than << >>\n  assert i + j ^ 2 == i + (j^2);\n  assert i * j & 1 == i * (j&1); // & | ^ bind tighter than + - *\n}\n`\n\nThe following are incorrectly formed:\n\n`const i: bv4 := 9\nconst j: bv4 := 3\n\nmethod m() {\n  assert i & 4 | j == 0 ; // parentheses required\n}\n`\n`const k: bv4 := 9\n\nmethod p() {\n  assert k as bv5 == 9 as bv6; // error: mismatched types\n}\n`\n\nThese produce assertion errors:\n\n`const i: bv4 := 9\n\nmethod m() {\n  assert i as bv3 == 1; // error: i is out of range for bv3\n}\n`\n`const j: bv4 := 9\n\nmethod n() {\n  assert j == 25; // error: 25 is out of range for bv4\n}\n`\n\nBit-vector constants (like all constants) can be initialized using expressions,\nbut pay attention to how type inference applies to such expressions. For\nexample,\n\n`const a: bv3 := -1\n`\n\nis legal because Dafny interprets `-1` as a `bv3` expression, because `a` has\ntype `bv3`. Consequently the `-` is `bv3` negation and the `1` is a `bv3`\nliteral; the value of the expression `-1` is the `bv3` value `7`, which is then\nthe value of `a`.\n\nOn the other hand,\n\n`const b: bv3 := 6 & 11\n`\n\nis illegal because, again, the `&` is `bv3` bit-wise-and and the numbers must be\nvalid `bv3` literals. But `11` is not a valid `bv3` literal.\n\n#### 5.2.5. Ordinal type ([grammar][636])\n\nValues of type `ORDINAL` behave like `nat`s in many ways, with one important\ndifference: there are `ORDINAL` values that are larger than any `nat`. The\nsmallest of these non-nat ordinals is represented as $\\omega$ in mathematics,\nthough there is no literal expression in Dafny that represents this value.\n\nThe natural numbers are ordinals. Any ordinal has a successor ordinal\n(equivalent to adding `1`). Some ordinals are *limit* ordinals, meaning they are\nnot a successor of any other ordinal; the natural number `0` and $\\omega$ are\nlimit ordinals.\n\nThe *offset* of an ordinal is the number of successor operations it takes to\nreach it from a limit ordinal.\n\nThe Dafny type `ORDINAL` has these member functions:\n\n* `o.IsLimit` – true if `o` is a limit ordinal (including `0`)\n* `o.IsSucc` – true if `o` is a successor to something, so `o.IsSucc <==>\n  !o.IsLimit`\n* `o.IsNat` – true if `o` represents a `nat` value, so for `n` a `nat`, `(n as\n  ORDINAL).IsNat` is true and if `o.IsNat` is true then `(o as nat)` is\n  well-defined\n* `o.Offset` – is the `nat` value giving the offset of the ordinal\n\nIn addition,\n\n* non-negative numeric literals may be considered `ORDINAL` literals, so `o + 1`\n  is allowed\n* `ORDINAL`s may be compared, using `== != < <= > >=`\n* two `ORDINAL`s may be added and the result is `>=` either one of them;\n  addition is associative but not commutative\n* `*`, `/` and `%` are not defined for `ORDINAL`s\n* two `ORDINAL`s may be subtracted if the RHS satisfies `.IsNat` and the offset\n  of the LHS is not smaller than the offset of the RHS\n\nIn Dafny, `ORDINAL`s are used primarily in conjunction with [extreme functions\nand lemmas][637].\n\n#### 5.2.6. Characters ([grammar][638])\n\nDafny supports a type `char` of *characters*. Its exact meaning is controlled by\nthe command-line switch `--unicode-char:true|false`.\n\nIf `--unicode-char` is disabled, then `char` represents any [UTF-16 code\nunit][639]. This includes surrogate code points.\n\nIf `--unicode-char` is enabled, then `char` represents any [Unicode scalar\nvalue][640]. This excludes surrogate code points.\n\nCharacter literals are enclosed in single quotes, as in `'D'`. To write a single\nquote as a character literal, it is necessary to use an *escape sequence*.\nEscape sequences can also be used to write other characters. The supported\nescape sequences are the following:\n\n───────────┬────────────────────────────────────────────────────────────────────\nescape     │meaning                                                             \nsequence   │                                                                    \n───────────┼────────────────────────────────────────────────────────────────────\n`\\'`       │the character `'`                                                   \n───────────┼────────────────────────────────────────────────────────────────────\n`\\\"`       │the character `\"`                                                   \n───────────┼────────────────────────────────────────────────────────────────────\n`\\\\`       │the character `\\`                                                   \n───────────┼────────────────────────────────────────────────────────────────────\n`\\0`       │the null character, same as `\\u0000` or `\\U{0}`                     \n───────────┼────────────────────────────────────────────────────────────────────\n`\\n`       │line feed                                                           \n───────────┼────────────────────────────────────────────────────────────────────\n`\\r`       │carriage return                                                     \n───────────┼────────────────────────────────────────────────────────────────────\n`\\t`       │horizontal tab                                                      \n───────────┼────────────────────────────────────────────────────────────────────\n`\\u`*xxxx* │[UTF-16 code unit][641] whose hexadecimal code is *xxxx*, where each\n           │*x* is a hexadecimal digit                                          \n───────────┼────────────────────────────────────────────────────────────────────\n`\\U{`*x..x*│[Unicode scalar value][642] whose hexadecimal code is *x..x*, where \n`}`        │each *x* is a hexadecimal digit                                     \n───────────┴────────────────────────────────────────────────────────────────────\n\nThe escape sequence for a double quote is redundant, because `'\"'` and `'\\\"'`\ndenote the same character—both forms are provided in order to support the same\nescape sequences in string literals ([Section 5.5.3.5][643]).\n\nIn the form `\\u`*xxxx*, which is only allowed if `--unicode-char` is disabled,\nthe `u` is always lower case, but the four hexadecimal digits are case\ninsensitive.\n\nIn the form `\\U{`*x..x*`}`, which is only allowed if `--unicode-char` is\nenabled, the `U` is always upper case, but the hexadecimal digits are case\ninsensitive, and there must be at least one and at most six digits. Surrogate\ncode points are not allowed. The hex digits may be interspersed with underscores\nfor readability (but not beginning or ending with an underscore), as in\n`\\U{1_F680}`.\n\nCharacter values are ordered and can be compared using the standard relational\noperators:\n\n────────┬────────────\noperator│description \n────────┼────────────\n`<`     │less than   \n────────┼────────────\n`<=`    │at most     \n────────┼────────────\n`>=`    │at least    \n────────┼────────────\n`>`     │greater than\n────────┴────────────\n\nSequences of characters represent *strings*, as described in [Section\n5.5.3.5][644].\n\nCharacter values can be converted to and from `int` values using the `as int`\nand `as char` conversion operations. The result is what would be expected in\nother programming languages, namely, the `int` value of a `char` is the ASCII or\nUnicode numeric value.\n\nThe only other operations on characters are obtaining a character by indexing\ninto a string, and the implicit conversion to string when used as a parameter of\na `print` statement.\n\n### 5.3. Type parameters ([grammar][645])\n\nExamples:\n\n`type G1<T>\ntype G2<T(0)>\ntype G3<+T(==),-U>\n`\n\nMany of the types, functions, and methods in Dafny can be parameterized by\ntypes. These *type parameters* are declared inside angle brackets and can stand\nfor any type.\n\nDafny has some inference support that makes certain signatures less cluttered\n(described in [Section 12.2][646]).\n\n#### 5.3.1. Declaring restrictions on type parameters\n\nIt is sometimes necessary to restrict type parameters so that they can only be\ninstantiated by certain families of types, that is, by types that have certain\nproperties. These properties are known as *type characteristics*. The following\nsubsections describe the type characteristics that Dafny supports.\n\nIn some cases, type inference will infer that a type-parameter must be\nrestricted in a particular way, in which case Dafny will add the appropriate\nsuffix, such as `(==)`, automatically.\n\nIf more than one restriction is needed, they are either listed comma-separated,\ninside the parentheses or as multiple parenthesized elements: `T(==,0)` or\n`T(==)(0)`.\n\nWhen an actual type is substituted for a type parameter in a generic type\ninstantiation, the actual type must have the declared or inferred type\ncharacteristics of the type parameter. These characteristics might also be\ninferred for the actual type. For example, a numeric-based subset or newtype\nautomatically has the `==` relationship of its base type. Similarly, type\nsynonyms have the characteristics of the type they represent.\n\nAn abstract type has no known characteristics. If it is intended to be defined\nonly as types that have certain characteristics, then those characteristics must\nbe declared. For example,\n\n`class A<T(00)> {}\ntype Q\nconst a: A<Q>\n`\n\nwill give an error because it is not known whether the type `Q` is non-empty\n(`00`). Instead, one needs to write\n\n`class A<T(00)> {}\ntype Q(00)\nconst a: A?<Q> := null\n`\n5.3.1.1. Equality-supporting type parameters: `T(==)`\n\nDesignating a type parameter with the `(==)` suffix indicates that the parameter\nmay only be replaced in non-ghost contexts with types that are known to support\nrun-time equality comparisons (`==` and `!=`). All types support equality in\nghost contexts, as if, for some types, the equality function is ghost.\n\nFor example,\n\n`method Compare<T(==)>(a: T, b: T) returns (eq: bool)\n{\n  if a == b { eq := true; } else { eq := false; }\n}\n`\n\nis a method whose type parameter is restricted to equality-supporting types when\nused in a non-ghost context. Again, note that *all* types support equality in\n*ghost* contexts; the difference is only for non-ghost (that is, compiled) code.\nCoinductive datatypes, arrow types, and inductive datatypes with ghost\nparameters are examples of types that are not equality supporting.\n\n5.3.1.2. Auto-initializable types: `T(0)`\n\nAt every access of a variable `x` of a type `T`, Dafny ensures that `x` holds a\nlegal value of type `T`. If no explicit initialization is given, then an\narbitrary value is assumed by the verifier and supplied by the compiler, that\nis, the variable is *auto-initialized*, but to an arbitrary value. For example,\n\n`class Example<A(0), X> {\n  var n: nat\n  var i: int\n  var a: A\n  var x: X\n\n  constructor () {\n    new; // error: field 'x' has not been given a value`\n    assert n >= 0; // true, regardless of the value of 'n'\n    assert i >= 0; // possibly false, since an arbitrary 'int' may be negative\n    // 'a' does not require an explicit initialization, since 'A' is auto-init\n  }\n}\n`\n\nIn the example above, the class fields do not need to be explicitly initialized\nin the constructor because they are auto-initialized to an arbitrary value.\n\nLocal variables and out-parameters are however, subject to definite assignment\nrules. The following example requires `--relax-definite-assignment`, which is\nnot the default.\n\n`method m() {\n  var n: nat; // Auto-initialized to an arbitrary value of type `nat`\n  assert n >= 0; // true, regardless of the value of n\n  var i: int;\n  assert i >= 0; // possibly false, arbitrary ints may be negative\n}\n`\n\nWith the default behavior of definite assignment, `n` and `i` need to be\ninitialized to an explicit value of their type or to an arbitrary value using,\nfor example, `var n: nat := *;`.\n\nFor some types (known as *auto-init types*), the compiler can choose an initial\nvalue, but for others it does not. Variables and fields whose type the compiler\ndoes not auto-initialize are subject to *definite-assignment* rules. These\nensure that the program explicitly assigns a value to a variable before it is\nused. For more details see [Section 12.6][647] and the\n`--relax-definite-assignment` command-line option. More detail on\nauto-initializing is in [this document][648].\n\nDafny supports auto-init as a type characteristic. To restrict a type parameter\nto auto-init types, mark it with the `(0)` suffix. For example,\n\n`method AutoInitExamples<A(0), X>() returns (a: A, x: X)\n{\n  // 'a' does not require an explicit initialization, since A is auto-init\n  // error: out-parameter 'x' has not been given a value\n}\n`\n\nIn this example, an error is reported because out-parameter `x` has not been\nassigned—since nothing is known about type `X`, variables of type `X` are\nsubject to definite-assignment rules. In contrast, since type parameter `A` is\ndeclared to be restricted to auto-init types, the program does not need to\nexplicitly assign any value to the out-parameter `a`.\n\n5.3.1.3. Nonempty types: `T(00)`\n\nAuto-init types are important in compiled contexts. In ghost contexts, it may\nstill be important to know that a type is nonempty. Dafny supports a type\ncharacteristic for nonempty types, written with the suffix `(00)`. For example,\nwith `--relax-definite-assignment`, the following example happens:\n\n`method NonemptyExamples<B(00), X>() returns (b: B, ghost g: B, ghost h: X)\n{\n  // error: non-ghost out-parameter 'b' has not been given a value\n  // ghost out-parameter 'g' is fine, since its type is nonempty\n  // error: 'h' has not been given a value\n}\n`\n\nBecause of `B`’s nonempty type characteristic, ghost parameter `g` does not need\nto be explicitly assigned. However, Dafny reports an error for the non-ghost\n`b`, since `B` is not an auto-init type, and reports an error for `h`, since the\ntype `X` could be empty.\n\nNote that every auto-init type is nonempty.\n\nIn the default definite-assignment mode (that is, without\n`--relax-definite-assignment`) there will be errors for all three formal\nparameters in the example just given.\n\nFor more details see [Section 12.6][649].\n\n5.3.1.4. Non-heap based: `T(!new)`\n\nDafny makes a distinction between types whose values are on the heap, i.e.\nreferences, like classes and arrays, and those that are strictly value-based,\nlike basic types and datatypes. The practical implication is that references\ndepend on allocation state (e.g., are affected by the `old` operation) whereas\nnon-reference values are not. Thus it can be relevant to know whether the values\nof a type parameter are heap-based or not. This is indicated by the mode suffix\n`(!new)`.\n\nA type parameter characterized by `(!new)` is *recursively* independent of the\nallocation state. For example, a datatype is not a reference, but for a\nparameterized data type such as\n\n`datatype Result<T> = Failure(error: string) | Success(value: T)\n`\n\nthe instantiation `Result<int>` satisfies `(!new)`, whereas `Result<array<int>>`\ndoes not.\n\nNote that this characteristic of a type parameter is operative for both\nverification and compilation. Also, abstract types at the topmost scope are\nalways implicitly `(!new)`.\n\nHere are some examples:\n\n`datatype Result<T> = Failure(error: string) | Success(v: T)\ndatatype ResultN<T(!new)> = Failure(error: string) | Success(v: T)\n\nclass C {}\n\nmethod m() {\n  var x1: Result<int>;\n  var x2: ResultN<int>;\n  var x3: Result<C>;\n  var x4: ResultN<C>; // error\n  var x5: Result<array<int>>;\n  var x6: ResultN<array<int>>; // error\n}\n`\n\n#### 5.3.2. Type parameter variance\n\nType parameters have several different variance and cardinality properties.\nThese properties of type parameters are designated in a generic type definition.\nFor instance, in `type A<+T> = ... `, the `+` indicates that the `T` position is\nco-variant. These properties are indicated by the following notation:\n\n─────────┬──────────────┬──────────────────────\nnotation │variance      │cardinality-preserving\n─────────┼──────────────┼──────────────────────\n(nothing)│non-variant   │yes                   \n─────────┼──────────────┼──────────────────────\n`+`      │co-variant    │yes                   \n─────────┼──────────────┼──────────────────────\n`-`      │contra-variant│not necessarily       \n─────────┼──────────────┼──────────────────────\n`*`      │co-variant    │not necessarily       \n─────────┼──────────────┼──────────────────────\n`!`      │non-variant   │not necessarily       \n─────────┴──────────────┴──────────────────────\n\n* *co-variance* (`A<+T>` or `A<*T>`) means that if `U` is a subtype of `V` then\n  `A<U>` is a subtype of `A<V>`\n* *contra-variance* (`A<-T>`) means that if `U` is a subtype of `V` then `A<V>`\n  is a subtype of `A<U>`\n* *non-variance* (`A<T>` or `A<!T>`) means that if `U` is a different type than\n  `V` then there is no subtyping relationship between `A<U>` and `A<V>`\n\n*Cardinality preserving* means that the cardinality of the type being defined\nnever exceeds the cardinality of any of its type parameters. For example `type\nT<X> = X -> bool` is illegal and returns the error message `formal type\nparameter 'X' is not used according to its variance specification (it is used\nleft of an arrow) (perhaps try declaring 'X' as '-X' or '!X')` The type `X ->\nbool` has strictly more values than the type `X`. This affects certain uses of\nthe type, so Dafny requires the declaration of `T` to explicitly say so. Marking\nthe type parameter `X` with `-` or `!` announces that the cardinality of `T<X>`\nmay by larger than that of `X`. If you use `-`, you’re also declaring `T` to be\ncontravariant in its type argument, and if you use `!`, you’re declaring that\n`T` is non-variant in its type argument.\n\nTo fix it, we use the variance `!`:\n\n`type T<!X> = X -> bool\n`\n\nThis states that `T` does not preserve the cardinality of `X`, meaning there\ncould be strictly more values of type `T<E>` than values of type `E` for any\n`E`.\n\nA more detailed explanation of these topics is [here][650].\n\n### 5.4. Generic Instantiation ([grammar][651])\n\nA generic instantiation consists of a comma-separated list of 1 or more Types,\nenclosed in angle brackets (`<` `>`), providing actual types to be used in place\nof the type parameters of the declaration of the generic type. If there is no\ninstantion for a generic type, type inference will try to fill these in (cf.\n[Section 12.2][652]).\n\n### 5.5. Collection types\n\nDafny offers several built-in collection types.\n\n#### 5.5.1. Sets ([grammar][653])\n\nFor any type `T`, each value of type `set<T>` is a finite set of `T` values.\n\nSet membership is determined by equality in the type `T`, so `set<T>` can be\nused in a non-ghost context only if `T` is [equality supporting][654].\n\nFor any type `T`, each value of type `iset<T>` is a potentially infinite set of\n`T` values.\n\nA set can be formed using a [*set display* expression][655], which is a possibly\nempty, unordered, duplicate-insensitive list of expressions enclosed in curly\nbraces. To illustrate,\n\n`{}        {2, 7, 5, 3}        {4+2, 1+5, a*b}\n`\n\nare three examples of set displays. There is also a *set comprehension*\nexpression (with a binder, like in logical quantifications), described in\n[Section 9.31.5][656].\n\nIn addition to equality and disequality, set types support the following\nrelational operations:\n\n────────┬──────────┬───────────────\noperator│precedence│description    \n────────┼──────────┼───────────────\n`<`     │4         │proper subset  \n────────┼──────────┼───────────────\n`<=`    │4         │subset         \n────────┼──────────┼───────────────\n`>=`    │4         │superset       \n────────┼──────────┼───────────────\n`>`     │4         │proper superset\n────────┴──────────┴───────────────\n\nLike the arithmetic relational operators, these operators are chaining.\n\nSets support the following binary operators, listed in order of increasing\nbinding power:\n\n────────┬──────────┬────────────────\noperator│precedence│description     \n────────┼──────────┼────────────────\n`!!`    │4         │disjointness    \n────────┼──────────┼────────────────\n`+`     │6         │set union       \n────────┼──────────┼────────────────\n`-`     │6         │set difference  \n────────┼──────────┼────────────────\n`*`     │7         │set intersection\n────────┴──────────┴────────────────\n\nThe associativity rules of `+`, `-`, and `*` are like those of the arithmetic\noperators with the same names. The expression `A !! B`, whose binding power is\nthe same as equality (but which neither associates nor chains with equality),\nsays that sets `A` and `B` have no elements in common, that is, it is equivalent\nto\n\n`A * B == {}\n`\n\nHowever, the disjointness operator is chaining though in a slightly different\nway than other chaining operators: `A !! B !! C !! D` means that `A`, `B`, `C`\nand `D` are all mutually disjoint, that is\n\n`A * B == {} && (A + B) * C == {} && (A + B + C) * D == {}\n`\n\nIn addition, for any set `s` of type `set<T>` or `iset<T>` and any expression\n`e` of type `T`, sets support the following operations:\n\n──────────┬──────────┬───────────┬─────────────────────────────\nexpression│precedence│result type│description                  \n──────────┼──────────┼───────────┼─────────────────────────────\n`e in s`  │4         │`bool`     │set membership               \n──────────┼──────────┼───────────┼─────────────────────────────\n`e !in s` │4         │`bool`     │set non-membership           \n──────────┼──────────┼───────────┼─────────────────────────────\n`|s|`     │11        │`nat`      │set cardinality (not for     \n          │          │           │`iset`)                      \n──────────┴──────────┴───────────┴─────────────────────────────\n\nThe expression `e !in s` is a syntactic shorthand for `!(e in s)`.\n\n(No white space is permitted between `!` and `in`, making `!in` effectively the\none example of a mixed-character-class token in Dafny.)\n\n#### 5.5.2. Multisets ([grammar][657])\n\nA *multiset* is similar to a set, but keeps track of the multiplicity of each\nelement, not just its presence or absence. For any type `T`, each value of type\n`multiset<T>` is a map from `T` values to natural numbers denoting each\nelement’s multiplicity. Multisets in Dafny are finite, that is, they contain a\nfinite number of each of a finite set of elements. Stated differently, a\nmultiset maps only a finite number of elements to non-zero (finite)\nmultiplicities.\n\nLike sets, multiset membership is determined by equality in the type `T`, so\n`multiset<T>` can be used in a non-ghost context only if `T` is [equality\nsupporting][658].\n\nA multiset can be formed using a *multiset display* expression, which is a\npossibly empty, unordered list of expressions enclosed in curly braces after the\nkeyword `multiset`. To illustrate,\n\n`multiset{}   multiset{0, 1, 1, 2, 3, 5}   multiset{4+2, 1+5, a*b}\n`\n\nare three examples of multiset displays. There is no multiset comprehension\nexpression.\n\nIn addition to equality and disequality, multiset types support the following\nrelational operations:\n\n────────┬──────────┬────────────────────────\noperator│precedence│description             \n────────┼──────────┼────────────────────────\n`<`     │4         │proper multiset subset  \n────────┼──────────┼────────────────────────\n`<=`    │4         │multiset subset         \n────────┼──────────┼────────────────────────\n`>=`    │4         │multiset superset       \n────────┼──────────┼────────────────────────\n`>`     │4         │proper multiset superset\n────────┴──────────┴────────────────────────\n\nLike the arithmetic relational operators, these operators are chaining.\n\nMultisets support the following binary operators, listed in order of increasing\nbinding power:\n\n────────┬──────────┬─────────────────────\noperator│precedence│description          \n────────┼──────────┼─────────────────────\n`!!`    │4         │multiset disjointness\n────────┼──────────┼─────────────────────\n`+`     │6         │multiset sum         \n────────┼──────────┼─────────────────────\n`-`     │6         │multiset difference  \n────────┼──────────┼─────────────────────\n`*`     │7         │multiset intersection\n────────┴──────────┴─────────────────────\n\nThe associativity rules of `+`, `-`, and `*` are like those of the arithmetic\noperators with the same names. The `+` operator adds the multiplicity of\ncorresponding elements, the `-` operator subtracts them (but 0 is the minimum\nmultiplicity), and the `*` has multiplicity that is the minimum of the\nmultiplicity of the operands. There is no operator for multiset union, which\nwould compute the maximum of the multiplicities of the operands.\n\nThe expression `A !! B` says that multisets `A` and `B` have no elements in\ncommon, that is, it is equivalent to\n\n`A * B == multiset{}\n`\n\nLike the analogous set operator, `!!` is chaining and means mutual disjointness.\n\nIn addition, for any multiset `s` of type `multiset<T>`, expression `e` of type\n`T`, and non-negative integer-based numeric `n`, multisets support the following\noperations:\n\n──────────┬──────────┬───────────┬────────────────────────────────────────\nexpression│precedence│result type│description                             \n──────────┼──────────┼───────────┼────────────────────────────────────────\n`e in s`  │4         │`bool`     │multiset membership                     \n──────────┼──────────┼───────────┼────────────────────────────────────────\n`e !in s` │4         │`bool`     │multiset non-membership                 \n──────────┼──────────┼───────────┼────────────────────────────────────────\n`|s|`     │11        │`nat`      │multiset cardinality                    \n──────────┼──────────┼───────────┼────────────────────────────────────────\n`s[e]`    │11        │`nat`      │multiplicity of `e` in `s`              \n──────────┼──────────┼───────────┼────────────────────────────────────────\n`s[e :=   │11        │`multiset<T│multiset update (change of multiplicity)\nn]`       │          │>`         │                                        \n──────────┴──────────┴───────────┴────────────────────────────────────────\n\nThe expression `e in s` returns `true` if and only if `s[e] != 0`. The\nexpression `e !in s` is a syntactic shorthand for `!(e in s)`. The expression\n`s[e := n]` denotes a multiset like `s`, but where the multiplicity of element\n`e` is `n`. Note that the multiset update `s[e := 0]` results in a multiset like\n`s` but without any occurrences of `e` (whether or not `s` has occurrences of\n`e` in the first place). As another example, note that `s - multiset{e}` is\nequivalent to:\n\n`if e in s then s[e := s[e] - 1] else s\n`\n\n#### 5.5.3. Sequences ([grammar][659])\n\nFor any type `T`, a value of type `seq<T>` denotes a *sequence* of `T` elements,\nthat is, a mapping from a finite downward-closed set of natural numbers (called\n*indices*) to `T` values.\n\n5.5.3.1. Sequence Displays\n\nA sequence can be formed using a *sequence display* expression, which is a\npossibly empty, ordered list of expressions enclosed in square brackets. To\nillustrate,\n\n`[]        [3, 1, 4, 1, 5, 9, 3]        [4+2, 1+5, a*b]\n`\n\nare three examples of sequence displays.\n\nThere is also a sequence comprehension expression ([Section 9.28][660]):\n\n`seq(5, i => i*i)\n`\n\nis equivalent to `[0, 1, 4, 9, 16]`.\n\n5.5.3.2. Sequence Relational Operators\n\nIn addition to equality and disequality, sequence types support the following\nrelational operations:\n\n────────┬──────────┬─────────────\noperator│precedence│description  \n────────┼──────────┼─────────────\n<       │4         │proper prefix\n────────┼──────────┼─────────────\n<=      │4         │prefix       \n────────┴──────────┴─────────────\n\nLike the arithmetic relational operators, these operators are chaining. Note the\nabsence of `>` and `>=`.\n\n5.5.3.3. Sequence Concatenation\n\nSequences support the following binary operator:\n\n────────┬──────────┬─────────────\noperator│precedence│description  \n────────┼──────────┼─────────────\n`+`     │6         │concatenation\n────────┴──────────┴─────────────\n\nOperator `+` is associative, like the arithmetic operator with the same name.\n\n5.5.3.4. Other Sequence Expressions\n\nIn addition, for any sequence `s` of type `seq<T>`, expression `e` of type `T`,\ninteger-based numeric index `i` satisfying `0 <= i < |s|`, and integer-based\nnumeric bounds `lo` and `hi` satisfying `0 <= lo <= hi <= |s|`, noting that\nbounds can equal the length of the sequence, sequences support the following\noperations:\n\n───────────┬──────────┬───────────┬───────────────────────────────────\nexpression │precedence│result type│description                        \n───────────┼──────────┼───────────┼───────────────────────────────────\n`e in s`   │4         │`bool`     │sequence membership                \n───────────┼──────────┼───────────┼───────────────────────────────────\n`e !in s`  │4         │`bool`     │sequence non-membership            \n───────────┼──────────┼───────────┼───────────────────────────────────\n`|s|`      │11        │`nat`      │sequence length                    \n───────────┼──────────┼───────────┼───────────────────────────────────\n`s[i]`     │11        │`T`        │sequence selection                 \n───────────┼──────────┼───────────┼───────────────────────────────────\n`s[i := e]`│11        │`seq<T>`   │sequence update                    \n───────────┼──────────┼───────────┼───────────────────────────────────\n`s[lo..hi]`│11        │`seq<T>`   │subsequence                        \n───────────┼──────────┼───────────┼───────────────────────────────────\n`s[lo..]`  │11        │`seq<T>`   │drop                               \n───────────┼──────────┼───────────┼───────────────────────────────────\n`s[..hi]`  │11        │`seq<T>`   │take                               \n───────────┼──────────┼───────────┼───────────────────────────────────\n`s[`*slices│11        │`seq<seq<T>│slice                              \n*`]`       │          │>`         │                                   \n───────────┼──────────┼───────────┼───────────────────────────────────\n`multiset(s│11        │`multiset<T│sequence conversion to a           \n)`         │          │>`         │`multiset<T>`                      \n───────────┴──────────┴───────────┴───────────────────────────────────\n\nExpression `s[i := e]` returns a sequence like `s`, except that the element at\nindex `i` is `e`. The expression `e in s` says there exists an index `i` such\nthat `s[i] == e`. It is allowed in non-ghost contexts only if the element type\n`T` is [equality supporting][661]. The expression `e !in s` is a syntactic\nshorthand for `!(e in s)`.\n\nExpression `s[lo..hi]` yields a sequence formed by taking the first `hi`\nelements and then dropping the first `lo` elements. The resulting sequence thus\nhas length `hi - lo`. Note that `s[0..|s|]` equals `s`. If the upper bound is\nomitted, it defaults to `|s|`, so `s[lo..]` yields the sequence formed by\ndropping the first `lo` elements of `s`. If the lower bound is omitted, it\ndefaults to `0`, so `s[..hi]` yields the sequence formed by taking the first\n`hi` elements of `s`.\n\nIn the sequence slice operation, *slices* is a nonempty list of length\ndesignators separated and optionally terminated by a colon, and there is at\nleast one colon. Each length designator is a non-negative integer-based numeric;\nthe sum of the length designators is no greater than `|s|`. If there are *k*\ncolons, the operation produces *k + 1* consecutive subsequences from `s`, with\nthe length of each indicated by the corresponding length designator, and returns\nthese as a sequence of sequences. If *slices* is terminated by a colon, then the\nlength of the last slice extends until the end of `s`, that is, its length is\n`|s|` minus the sum of the given length designators. For example, the following\nequalities hold, for any sequence `s` of length at least `10`:\n\n`method m(s: seq<int>) {\n  var t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3];\n  assert |t| == 3 && t[0] == [3.14] && t[1] == [];\n  assert t[2] == [2.7, 1.41, 1985.44];\n  var u := [true, false, false, true][1:1:];\n  assert |u| == 3 && u[0][0] && !u[1][0] && u[2] == [false, true];\n  assume |s| > 10;\n  assert s[10:][0] == s[..10];\n  assert s[10:][1] == s[10..];\n}\n`\n\nThe operation `multiset(s)` yields the multiset of elements of sequence `s`. It\nis allowed in non-ghost contexts only if the element type `T` is [equality\nsupporting][662].\n\n5.5.3.5. Strings ([grammar][663])\n\nA special case of a sequence type is `seq<char>`, for which Dafny provides a\nsynonym: `string`. Strings are like other sequences, but provide additional\nsyntax for sequence display expressions, namely *string literals*. There are two\nforms of the syntax for string literals: the *standard form* and the *verbatim\nform*.\n\nString literals of the standard form are enclosed in double quotes, as in\n`\"Dafny\"`. To include a double quote in such a string literal, it is necessary\nto use an escape sequence. Escape sequences can also be used to include other\ncharacters. The supported escape sequences are the same as those for character\nliterals ([Section 5.2.6][664]). For example, the Dafny expression `\"say\n\\\"yes\\\"\"` represents the string `'say \"yes\"'`. The escape sequence for a single\nquote is redundant, because `\"\\'\"` and `\"\\'\"` denote the same string—both forms\nare provided in order to support the same escape sequences as do character\nliterals.\n\nString literals of the verbatim form are bracketed by `@\"` and `\"`, as in\n`@\"Dafny\"`. To include a double quote in such a string literal, it is necessary\nto use the escape sequence `\"\"`, that is, to write the character twice. In the\nverbatim form, there are no other escape sequences. Even characters like newline\ncan be written inside the string literal (hence spanning more than one line in\nthe program text).\n\nFor example, the following three expressions denote the same string:\n\n`\"C:\\\\tmp.txt\"\n@\"C:\\tmp.txt\"\n['C', ':', '\\\\', 't', 'm', 'p', '.', 't', 'x', 't']\n`\n\nSince strings are sequences, the relational operators `<` and `<=` are defined\non them. Note, however, that these operators still denote proper prefix and\nprefix, respectively, not some kind of alphabetic comparison as might be\ndesirable, for example, when sorting strings.\n\n#### 5.5.4. Finite and Infinite Maps ([grammar][665])\n\nFor any types `T` and `U`, a value of type `map<T,U>` denotes a *(finite) map*\nfrom `T` to `U`. In other words, it is a look-up table indexed by `T`. The\n*domain* of the map is a finite set of `T` values that have associated `U`\nvalues. Since the keys in the domain are compared using equality in the type\n`T`, type `map<T,U>` can be used in a non-ghost context only if `T` is [equality\nsupporting][666].\n\nSimilarly, for any types `T` and `U`, a value of type `imap<T,U>` denotes a\n*(possibly) infinite map*. In most regards, `imap<T,U>` is like `map<T,U>`, but\na map of type `imap<T,U>` is allowed to have an infinite domain.\n\nA map can be formed using a *map display* expression (see [Section 9.30][667]),\nwhich is a possibly empty, ordered list of *maplets*, each maplet having the\nform `t := u` where `t` is an expression of type `T` and `u` is an expression of\ntype `U`, enclosed in square brackets after the keyword `map`. To illustrate,\n\n`map[]\nmap[20 := true, 3 := false, 20 := false]\nmap[a+b := c+d]\n`\n\nare three examples of map displays. By using the keyword `imap` instead of\n`map`, the map produced will be of type `imap<T,U>` instead of `map<T,U>`. Note\nthat an infinite map (`imap`) is allowed to have a finite domain, whereas a\nfinite map (`map`) is not allowed to have an infinite domain. If the same key\noccurs more than once in a map display expression, only the last occurrence\nappears in the resulting map.^{[2][668]} There is also a *map comprehension\nexpression*, explained in [Section 9.31.8][669].\n\nFor any map `fm` of type `map<T,U>`, any map `m` of type `map<T,U>` or\n`imap<T,U>`, any expression `t` of type `T`, any expression `u` of type `U`, and\nany `d` in the domain of `m` (that is, satisfying `d in m`), maps support the\nfollowing operations:\n\n──────────┬──────────┬─────────────┬─────────────────────────\nexpression│precedence│result type  │description              \n──────────┼──────────┼─────────────┼─────────────────────────\n`t in m`  │4         │`bool`       │map domain membership    \n──────────┼──────────┼─────────────┼─────────────────────────\n`t !in m` │4         │`bool`       │map domain non-membership\n──────────┼──────────┼─────────────┼─────────────────────────\n`|fm|`    │11        │`nat`        │map cardinality          \n──────────┼──────────┼─────────────┼─────────────────────────\n`m[d]`    │11        │`U`          │map selection            \n──────────┼──────────┼─────────────┼─────────────────────────\n`m[t :=   │11        │`map<T,U>`   │map update               \nu]`       │          │             │                         \n──────────┼──────────┼─────────────┼─────────────────────────\n`m.Keys`  │11        │(i)`set<T>`  │the domain of `m`        \n──────────┼──────────┼─────────────┼─────────────────────────\n`m.Values`│11        │(i)`set<U>`  │the range of `m`         \n──────────┼──────────┼─────────────┼─────────────────────────\n`m.Items` │11        │(i)`set<(T,U)│set of pairs (t,u) in `m`\n          │          │>`           │                         \n──────────┴──────────┴─────────────┴─────────────────────────\n\n`|fm|` denotes the number of mappings in `fm`, that is, the cardinality of the\ndomain of `fm`. Note that the cardinality operator is not supported for infinite\nmaps. Expression `m[d]` returns the `U` value that `m` associates with `d`.\nExpression `m[t := u]` is a map like `m`, except that the element at key `t` is\n`u`. The expression `t in m` says `t` is in the domain of `m` and `t !in m` is a\nsyntactic shorthand for `!(t in m)`.^{[3][670]}\n\nThe expressions `m.Keys`, `m.Values`, and `m.Items` return, as sets, the domain,\nthe range, and the 2-tuples holding the key-value associations in the map. Note\nthat `m.Values` will have a different cardinality than `m.Keys` and `m.Items` if\ndifferent keys are associated with the same value. If `m` is an `imap`, then\nthese expressions return `iset` values. If `m` is a map, `m.Values` and\n`m.Items` require the type of the range `U` to support equality.\n\nHere is a small example, where a map `cache` of type `map<int,real>` is used to\ncache computed values of Joule-Thomson coefficients for some fixed gas at a\ngiven temperature:\n\n`if K in cache {  // check if temperature is in domain of cache\n  coeff := cache[K];  // read result in cache\n} else {\n  coeff := ComputeJTCoefficient(K); // do expensive computation\n  cache := cache[K := coeff];  // update the cache\n}\n`\n\nDafny also overloads the `+` and `-` binary operators for maps. The `+` operator\nmerges two maps or imaps of the same type, as if each (key,value) pair of the\nRHS is added in turn to the LHS (i)map. In this use, `+` is not commutative; if\na key exists in both (i)maps, it is the value from the RHS (i)map that is\npresent in the result.\n\nThe `-` operator implements a map difference operator. Here the LHS is a\n`map<K,V>` or `imap<K,V>` and the RHS is a `set<K>` (but not an `iset`); the\noperation removes from the LHS all the (key,value) pairs whose key is a member\nof the RHS set.\n\nTo avoid causing circular reasoning chains or providing too much information\nthat might complicate Dafny’s prover finding proofs, not all properties of maps\nare known by the prover by default. For example, the following does not prove:\n\n`method mmm<K(==),V(==)>(m: map<K,V>, k: K, v: V) {\n    var mm := m[k := v];\n    assert v in mm.Values;\n  }\n`\n\nRather, one must provide an intermediate step, which is not entirely obvious:\n\n`method mmm<K(==),V(==)>(m: map<K,V>, k: K, v: V) {\n    var mm := m[k := v];\n    assert k in mm.Keys;\n    assert v in mm.Values;\n  }\n`\n\n#### 5.5.5. Iterating over collections\n\nCollections are very commonly used in programming and one frequently needs to\niterate over the elements of a collection. Dafny does not have built-in iterator\nmethods, but the idioms by which to do so are straightforward. The subsections\nbelow give some introductory examples; more detail can be found in this [power\nuser note][671].\n\n5.5.5.1. Sequences and arrays\n\nSequences and arrays are indexable and have a length. So the idiom to iterate\nover the contents is well-known. For an array:\n\n`method m(a: array<int>) {\n  var i := 0;\n  var sum := 0;\n  while i < a.Length {\n    sum := sum + a[i];\n    i := i + 1;\n  }\n}\n`\n\nFor a sequence, the only difference is the length operator:\n\n`method m(s: seq<int>) {\n  var i := 0;\n  var sum := 0;\n  while i < |s| {\n    sum := sum + s[i];\n    i := i + 1;\n  }\n}\n`\n\nThe `forall` statement ([Section 8.21][672]) can also be used with arrays where\nparallel assignment is needed:\n\n`method m(s: array<int>) {\n  var rev := new int[s.Length];\n  forall i | 0 <= i < s.Length {\n    rev[i] := s[s.Length-i-1];\n  }\n}\n`\n\nSee [Section 5.10.2][673] on how to convert an array to a sequence.\n\n5.5.5.2. Sets\n\nThere is no intrinsic order to the elements of a set. Nevertheless, we can\nextract an arbitrary element of a nonempty set, performing an iteration as\nfollows:\n\n`method m(s: set<int>) {\n  var ss := s;\n  while ss != {}\n    decreases |ss|\n  {\n    var i: int :| i in ss;\n    ss := ss - {i};\n    print i, \"\\n\";\n  }\n}\n`\n\nBecause `iset`s may be infinite, Dafny does not permit iteration over an `iset`.\n\n5.5.5.3. Maps\n\nIterating over the contents of a `map` uses the component sets: `Keys`,\n`Values`, and `Items`. The iteration loop follows the same patterns as for sets:\n\n`method m<T(==),U(==)> (m: map<T,U>) {\n  var items := m.Items;\n  while items != {}\n    decreases |items|\n  {\n    var item :| item in items;\n    items := items - { item };\n    print item.0, \" \", item.1, \"\\n\";\n  }\n}\n`\n\nThere are no mechanisms currently defined in Dafny for iterating over `imap`s.\n\n### 5.6. Types that stand for other types ([grammar][674])\n\nIt is sometimes useful to know a type by several names or to treat a type\nabstractly. There are several mechanisms in Dafny to do this:\n\n* ([Section 5.6.1][675]) A typical *synonym type*, in which a type name is a\n  synonym for another type\n* ([Section 5.6.2][676]) An *abstract type*, in which a new type name is\n  declared as an uninterpreted type\n* ([Section 5.6.3][677]) A *subset type*, in which a new type name is given to a\n  subset of the values of a given type\n* ([Section 5.7][678]) A *newtype*, in which a subset type is declared, but with\n  restrictions on converting to and from its base type\n\n#### 5.6.1. Type synonyms ([grammar][679])\n\n`type T = int\ntype SS<T> = set<set<T>>\n`\n\nA *type synonym* declaration:\n\n`type Y<T> = G\n`\n\ndeclares `Y<T>` to be a synonym for the type `G`. If the `= G` is omitted then\nthe declaration just declares a name as an uninterpreted *abstract* type, as\ndescribed in [Section 5.6.2][680]. Such types may be given a definition\nelsewhere in the Dafny program.\n\nHere, `T` is a nonempty list of type parameters (each of which optionally has a\n[type characteristics suffix][681]), which can be used as free type variables in\n`G`. If the synonym has no type parameters, the “`<T>`” is dropped. In all\ncases, a type synonym is just a synonym. That is, there is never a difference,\nother than possibly in error messages produced, between `Y<T>` and `G`.\n\nFor example, the names of the following type synonyms may improve the\nreadability of a program:\n\n`type Replacements<T> = map<T,T>\ntype Vertex = int\n`\n\nThe new type name itself may have [type characteristics][682] declared, and may\nneed to if there is no definition. If there is a definition, the type\ncharacteristics are typically inferred from the definition. The syntax is like\nthis:\n\n`type Z(==)<T(0)>\n`\n\nAs already described in [Section 5.5.3.5][683], `string` is a built-in type\nsynonym for `seq<char>`, as if it would have been declared as follows:\n\n`type string_(==,0,!new) = seq<char>\n`\n\nIf the implicit declaration did not include the type characteristics, they would\nbe inferred in any case.\n\nNote that although a type synonym can be declared and used in place of a type\nname, that does not affect the names of datatype or class constructors. For\nexample, consider\n\n`datatype Pair<T> = Pair(first: T, second: T)\ntype IntPair = Pair<int>\n\nconst p: IntPair := Pair(1,2) // OK\nconst q: IntPair := IntPair(3,4) // Error\n`\n\nIn the declaration of `q`, `IntPair` is the name of a type, not the name of a\nfunction or datatype constructor.\n\n#### 5.6.2. Abstract types ([grammar][684])\n\nExamples:\n\n`type T\ntype Q { function toString(t: T): string }\n`\n\nAn abstract type is a special case of a type synonym that is underspecified.\nSuch a type is declared simply by:\n\n`type Y<T>\n`\n\nIts definition can be stated in a refining module. The name `Y` can be\nimmediately followed by a type characteristics suffix ([Section 5.3.1][685]).\nBecause there is no defining RHS, the type characteristics cannot be inferred\nand so must be stated. If, in some refining module, a definition of the type is\ngiven, the type characteristics must match those of the new definition.\n\nFor example, the declarations\n\n`type T\nfunction F(t: T): T\n`\n\ncan be used to model an uninterpreted function `F` on some arbitrary type `T`.\nAs another example,\n\n`type Monad<T>\n`\n\ncan be used abstractly to represent an arbitrary parameterized monad.\n\nEven as an abstract type, the type may be given members such as constants,\nmethods or functions. For example,\n\n`abstract module P {\n  type T {\n    function ToString(): string\n  }\n}\n\nmodule X refines P {\n  newtype T = i | 0 <= i < 10 {\n    function ToString(): string {  \"\" }\n  }\n}\n`\n\nThe abstract type `P.T` has a declared member `ToString`, which can be called\nwherever `P.T` may be used. In the refining module `X`, `T` is declared to be a\n`newtype`, in which `ToString` now has a body.\n\nIt would be an error to refine `P.T` as a simple type synonym or subset type in\n`X`, say `type T = int`, because type synonyms may not have members.\n\n#### 5.6.3. Subset types ([grammar][686])\n\nExamples:\n\n`type Pos = i: int | i > 0 witness 1\ntype PosReal = r | r > 0.0 witness 1.0\ntype Empty = n: nat | n < 0 witness *\ntype Big = n: nat | n > 1000 ghost witness 10000\n`\n\nA *subset type* is a restricted use of an existing type, called the *base type*\nof the subset type. A subset type is like a combined use of the base type and a\npredicate on the base type.\n\nAn assignment from a subset type to its base type is always allowed. An\nassignment in the other direction, from the base type to a subset type, is\nallowed provided the value assigned does indeed satisfy the predicate of the\nsubset type. This condition is checked by the verifier, not by the type checker.\nSimilarly, assignments from one subset type to another (both with the same base\ntype) are also permitted, as long as it can be established that the value being\nassigned satisfies the predicate defining the receiving subset type. (Note, in\ncontrast, assignments between a newtype and its base type are never allowed,\neven if the value assigned is a value of the target type. For such assignments,\nan explicit conversion must be used, see [Section 9.10][687].)\n\nThe declaration of a subset type permits an optional [`witness` clause][688], to\ndeclare that there is a value that satisfies the subset type’s predicate; that\nis, the witness clause establishes that the defined type is not empty. The\ncompiler may, but is not obligated to, use this value when auto-initializing a\nnewly declared variable of the subset type.\n\nDafny builds in three families of subset types, as described next.\n\n5.6.3.1. Type `nat`\n\nThe built-in type `nat`, which represents the non-negative integers (that is,\nthe natural numbers), is a subset type:\n\n`type nat = n: int | 0 <= n\n`\n\nA simple example that puts subset type `nat` to good use is the standard\nFibonacci function:\n\n`function Fib(n: nat): nat\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n`\n\nAn equivalent, but clumsy, formulation of this function (modulo the wording of\nany error messages produced at call sites) would be to use type `int` and to\nwrite the restricting predicate in pre- and postconditions:\n\n`function Fib(n: int): int\n  requires 0 <= n  // the function argument must be non-negative\n  ensures 0 <= Fib(n)  // the function result is non-negative\n{\n  if n < 2 then n else Fib(n - 2) + Fib(n - 1)\n}\n`\n5.6.3.2. Non-null types\n\nEvery class, trait, and iterator declaration `C` gives rise to two types.\n\nOne type has the name `C?` (that is, the name of the class, trait, or iterator\ndeclaration with a `?` character appended to the end). The values of `C?` are\nthe references to `C` objects, and also the value `null`. In other words, `C?`\nis the type of *possibly null* references (aka, *nullable* references) to `C`\nobjects.\n\nThe other type has the name `C` (that is, the same name as the class, trait, or\niterator declaration). Its values are the references to `C` objects, and does\nnot contain the value `null`. In other words, `C` is the type of *non-null*\nreferences to `C` objects.\n\nThe type `C` is a subset type of `C?`:\n\n`type C = c: C? | c != null\n`\n\n(It may be natural to think of the type `C?` as the union of type `C` and the\nvalue `null`, but, technically, Dafny defines `C` as a subset type with base\ntype `C?`.)\n\nFrom being a subset type, we get that `C` is a subtype of `C?`. Moreover, if a\nclass or trait `C` extends a trait `B`, then type `C` is a subtype of `B` and\ntype `C?` is a subtype of `B?`.\n\nEvery possibly-null reference type is a subtype of the built-in possibly-null\ntrait type `object?`, and every non-null reference type is a subtype of the\nbuilt-in non-null trait type `object`. (And, from the fact that `object` is a\nsubset type of `object?`, we also have that `object` is a subtype of `object?`.)\n\nArrays are references and array types also come in these two flavors. For\nexample, `array?` and `array2?` are possibly-null (1- and 2-dimensional) array\ntypes, and `array` and `array2` are their respective non-null types.\n\nNote that `?` is not an operator. Instead, it is simply the last character of\nthe name of these various possibly-null types.\n\n5.6.3.3. Arrow types: `->`, `-->`, and `~>`\n\nFor more information about arrow types (function types), see [Section\n5.12][689]. This section is a preview to point out the subset-type relationships\namong the kinds of function types.\n\nThe built-in type\n\n* `->` stands for total functions,\n* `-->` stands for partial functions (that is, functions with possible\n  `requires` clauses), and\n* `~>` stands for all functions.\n\nMore precisely, type constructors exist for any arity (`() -> X`, `A -> X`, `(A,\nB) -> X`, `(A, B, C) -> X`, etc.).\n\nFor a list of types `TT` and a type `U`, the values of the arrow type `(TT) ~>\nU` are functions from `TT` to `U`. This includes functions that may read the\nheap and functions that are not defined on all inputs. It is not common to need\nthis generality (and working with such general functions is difficult).\nTherefore, Dafny defines two subset types that are more common (and much easier\nto work with).\n\nThe type `(TT) --> U` denotes the subset of `(TT) ~> U` where the functions do\nnot read the (mutable parts of the) heap. Values of type `(TT) --> U` are called\n*partial functions*, and the subset type `(TT) --> U` is called the *partial\narrow type*. (As a mnemonic to help you remember that this is the partial arrow,\nyou may think of the little gap between the two hyphens in `-->` as showing a\nbroken arrow.)\n\nIntuitively, the built-in partial arrow type is defined as follows (here shown\nfor arrows with arity 1):\n\n`type A --> B = f: A ~> B | forall a :: f.reads(a) == {}\n`\n\n(except that what is shown here left of the `=` is not legal Dafny syntax and\nthat the restriction could not be verified as is). That is, the partial arrow\ntype is defined as those functions `f` whose reads frame is empty for all\ninputs. More precisely, taking variance into account, the partial arrow type is\ndefined as\n\n`type -A --> +B = f: A ~> B | forall a :: f.reads(a) == {}\n`\n\nThe type `(TT) -> U` is, in turn, a subset type of `(TT) --> U`, adding the\nrestriction that the functions must not impose any precondition. That is, values\nof type `(TT) -> U` are *total functions*, and the subset type `(TT) -> U` is\ncalled the *total arrow type*.\n\nThe built-in total arrow type is defined as follows (here shown for arrows with\narity 1):\n\n`type -A -> +B = f: A --> B | forall a :: f.requires(a)\n`\n\nThat is, the total arrow type is defined as those partial functions `f` whose\nprecondition evaluates to `true` for all inputs.\n\nAmong these types, the most commonly used are the total arrow types. They are\nalso the easiest to work with. Because they are common, they have the simplest\nsyntax (`->`).\n\nNote, informally, we tend to speak of all three of these types as arrow types,\neven though, technically, the `~>` types are the arrow types and the `-->` and\n`->` types are subset types thereof. The one place where you may need to\nremember that `-->` and `->` are subset types is in some error messages. For\nexample, if you try to assign a partial function to a variable whose type is a\ntotal arrow type and the verifier is not able to prove that the partial function\nreally is total, then you’ll get an error saying that the subset-type constraint\nmay not be satisfied.\n\nFor more information about arrow types, see [Section 5.12][690].\n\n5.6.3.4. Witness clauses\n\nThe declaration of a subset type permits an optional `witness` clause. Types in\nDafny are generally expected to be non-empty, in part because variables of any\ntype are expected to have some value when they are used. In many cases, Dafny\ncan determine that a newly declared type has some value. For example, in the\nabsence of a witness clause, a numeric type that includes 0 is known by Dafny to\nbe non-empty. However, Dafny cannot always make this determination. If it\ncannot, a `witness` clause is required. The value given in the `witness` clause\nmust be a valid value for the type and assures Dafny that the type is non-empty.\n(The variation `witness *` is described below.)\n\nFor example,\n\n`type OddInt = x: int | x % 2 == 1\n`\n\nwill give an error message, but\n\n`type OddInt = x: int | x % 2 == 1 witness 73\n`\n\ndoes not. Here is another example:\n\n`type NonEmptySeq = x: seq<int> | |x| > 0 witness [0]\n`\n\nIf the witness is only available in ghost code, you can declare the witness as a\n`ghost witness`. In this case, the Dafny verifier knows that the type is\nnon-empty, but it will not be able to auto-initialize a variable of that type in\ncompiled code.\n\nThere is even room to do the following:\n\n`type BaseType\npredicate RHS(x: BaseType)\ntype MySubset = x: BaseType | RHS(x) ghost witness MySubsetWitness()\n\nfunction {:axiom} MySubsetWitness(): BaseType\n  ensures RHS(MySubsetWitness())\n`\n\nHere the type is given a ghost witness: the result of the expression\n`MySubsetWitness()`, which is a call of a (ghost) function. Now that function\nhas a postcondition saying that the returned value is indeed a candidate value\nfor the declared type, so the verifier is satisfied regarding the non-emptiness\nof the type. However, the function has no body, so there is still no proof that\nthere is indeed such a witness. You can either supply a, perhaps complicated,\nbody to generate a viable candidate or you can be very sure, without proof, that\nthere is indeed such a value. If you are wrong, you have introduced an\nunsoundness into your program.\n\nIn addition though, types are allowed to be empty or possibly empty. This is\nindicated by the clause `witness *`, which tells the verifier not to check for a\nsatisfying witness. A declaration like this produces an empty type:\n\n`type ReallyEmpty = x: int | false witness *\n`\n\nThe type can be used in code like\n\n`method M(x: ReallyEmpty) returns (seven: int)\n  ensures seven == 7\n{\n  seven := 10;\n}\n`\n\nwhich does verify. But the method can never be called because there is no value\nthat can be supplied as the argument. Even this code\n\n`method P() returns (seven: int)\n  ensures seven == 7\n{\n  var x: ReallyEmpty;\n  seven := 10;\n}\n`\n\ndoes not complain about `x` unless `x` is actually used, in which case it must\nhave a value. The postcondition in `P` does not verify, but not because of the\nempty type.\n\n### 5.7. Newtypes ([grammar][691])\n\nExamples:\n\n`newtype I = int\nnewtype D = i: int | 0 <= i < 10\nnewtype uint8 = i | 0 <= i < 256\n`\n\nA newtype is like a type synonym or subset type except that it declares a wholly\nnew type name that is distinct from its base type. It also accepts an optional\n[`witness` clause][692].\n\nA new type can be declared with the *newtype* declaration, for example:\n\n`newtype N = x: M | Q\n`\n\nwhere `M` is a type and `Q` is a boolean expression that can use `x` as a free\nvariable. If `M` is an integer-based numeric type, then so is `N`; if `M` is\nreal-based, then so is `N`. If the type `M` can be inferred from `Q`, the “`:\nM`” can be omitted. If `Q` is just `true`, then the declaration can be given\nsimply as:\n\n`newtype N = M\n`\n\nType `M` is known as the *base type* of `N`. At present, Dafny only supports\n`int` and `real` as base types of newtypes.\n\nA newtype is a type that supports the same operations as its base type. The\nnewtype is distinct from and incompatible with other types; in particular, it is\nnot assignable to its base type without an explicit conversion. An important\ndifference between the operations on a newtype and the operations on its base\ntype is that the newtype operations are defined only if the result satisfies the\npredicate `Q`, and likewise for the literals of the newtype.\n\nFor example, suppose `lo` and `hi` are integer-based numeric bounds that satisfy\n`0 <= lo <= hi` and consider the following code fragment:\n\n`var mid := (lo + hi) / 2;\n`\n\nIf `lo` and `hi` have type `int`, then the code fragment is legal; in\nparticular, it never overflows, since `int` has no upper bound. In contrast, if\n`lo` and `hi` are variables of a newtype `int32` declared as follows:\n\n`newtype int32 = x | -0x8000_0000 <= x < 0x8000_0000\n`\n\nthen the code fragment is erroneous, since the result of the addition may fail\nto satisfy the predicate in the definition of `int32`. The code fragment can be\nrewritten as\n\n`var mid := lo + (hi - lo) / 2;\n`\n\nin which case it is legal for both `int` and `int32`.\n\nAn additional point with respect to arithmetic overflow is that for (signed)\n`int32` values `hi` and `lo` constrained only by `lo <= hi`, the difference `hi\n- lo` can also overflow the bounds of the `int32` type. So you could also write:\n\n`var mid := lo + (hi/2 - lo/2);\n`\n\nSince a newtype is incompatible with its base type and since all results of the\nnewtype’s operations are members of the newtype, a compiler for Dafny is free to\nspecialize the run-time representation of the newtype. For example, by\nscrutinizing the definition of `int32` above, a compiler may decide to store\n`int32` values using signed 32-bit integers in the target hardware.\n\nThe incompatibility of a newtype and its basetype is intentional, as newtypes\nare meant to be used as distinct types from the basetype. If numeric types are\ndesired that mix more readily with the basetype, the subset types described in\n[Section 5.6.3][693] may be more appropriate.\n\nNote that the bound variable `x` in `Q` has type `M`, not `N`. Consequently, it\nmay not be possible to state `Q` about the `N` value. For example, consider the\nfollowing type of 8-bit 2’s complement integers:\n\n`newtype int8 = x: int | -128 <= x < 128\n`\n\nand consider a variable `c` of type `int8`. The expression\n\n`-128 <= c < 128\n`\n\nis not well-defined, because the comparisons require each operand to have type\n`int8`, which means the literal `128` is checked to be of type `int8`, which it\nis not. A proper way to write this expression is to use a conversion operation,\ndescribed in [Section 5.7.1][694], on `c` to convert it to the base type:\n\n`-128 <= c as int < 128\n`\n\nIf possible, Dafny compilers will represent values of the newtype using a native\ntype for the sake of efficiency. This action can be inhibited or a specific\nnative data type selected by using the `{:nativeType}` attribute, as explained\nin [Section 11.1.2][695].\n\nFurthermore, for the compiler to be able to make an appropriate choice of\nrepresentation, the constants in the defining expression as shown above must be\nknown constants at compile-time. They need not be numeric literals; combinations\nof basic operations and symbolic constants are also allowed as described in\n[Section 9.39][696].\n\n#### 5.7.1. Conversion operations\n\nFor every type `N`, there is a conversion operation with the name `as N`,\ndescribed more fully in [Section 9.10][697]. It is a partial function defined\nwhen the given value, which can be of any type, is a member of the type\nconverted to. When the conversion is from a real-based numeric type to an\ninteger-based numeric type, the operation requires that the real-based argument\nhave no fractional part. (To round a real-based numeric value down to the\nnearest integer, use the `.Floor` member, see [Section 5.2.2][698].)\n\nTo illustrate using the example from above, if `lo` and `hi` have type `int32`,\nthen the code fragment can legally be written as follows:\n\n`var mid := (lo as int + hi as int) / 2;\n`\n\nwhere the type of `mid` is inferred to be `int`. Since the result value of the\ndivision is a member of type `int32`, one can introduce yet another conversion\noperation to make the type of `mid` be `int32`:\n\n`var mid := ((lo as int + hi as int) / 2) as int32;\n`\n\nIf the compiler does specialize the run-time representation for `int32`, then\nthese statements come at the expense of two, respectively three, run-time\nconversions.\n\nThe `as N` conversion operation is grammatically a suffix operation like\n`.`field and array indexing, but binds less tightly than unary operations: `- x\nas int` is `(- x) as int`; `a + b as int` is `a + (b as int)`.\n\nThe `as N` conversion can also be used with reference types. For example, if `C`\nis a class, `c` is an expression of type `C`, and `o` is an expression of type\n`object`, then `c as object` and `c as object?` are upcasts and `o is C` is a\ndowncast. A downcast requires the LHS expression to have the RHS type, as is\nenforced by the verifier.\n\nFor some types (in particular, reference types), there is also a corresponding\n`is` operation ([Section 9.10][699]) that tests whether a value is valid for a\ngiven type.\n\n### 5.8. Class types ([grammar][700])\n\nExamples:\n\n`trait T {}\nclass A {}\nclass B extends T {\n  const b: B?\n  var v: int\n  constructor (vv: int) { v := vv; b := null; }\n  function toString(): string { \"a B\" }\n  method m(i: int) { var x := new B(0); }\n  static method q() {}\n}\n`\n\nDeclarations within a class all begin with keywords and do not end with\nsemicolons.\n\nA *class* `C` is a reference type declared as follows:\n\n`class C<T> extends J1, ..., Jn\n{\n  _members_\n}\n`\n\nwhere the <>-enclosed list of one-or-more type parameters `T` is optional. The\ntext “`extends J1, ..., Jn`” is also optional and says that the class extends\ntraits `J1` … `Jn`. The members of a class are *fields*, *constant fields*,\n*functions*, and *methods*. These are accessed or invoked by dereferencing a\nreference to a `C` instance.\n\nA function or method is invoked on an *instance* of `C`, unless the function or\nmethod is declared `static`. A function or method that is not `static` is called\nan *instance* function or method.\n\nAn instance function or method takes an implicit *receiver* parameter, namely,\nthe instance used to access the member. In the specification and body of an\ninstance function or method, the receiver parameter can be referred to\nexplicitly by the keyword `this`. However, in such places, members of `this` can\nalso be mentioned without any qualification. To illustrate, the qualified\n`this.f` and the unqualified `f` refer to the same field of the same object in\nthe following example:\n\n`class C {\n  var f: int\n  var x: int\n  method Example() returns (b: bool)\n  {\n    var x: int;\n    b := f == this.f;\n  }\n}\n`\n\nso the method body always assigns `true` to the out-parameter `b`. However, in\nthis example, `x` and `this.x` are different because the field `x` is shadowed\nby the declaration of the local variable `x`. There is no semantic difference\nbetween qualified and unqualified accesses to the same receiver and member.\n\nA `C` instance is created using `new`. There are three forms of `new`, depending\non whether or not the class declares any *constructors* (see [Section\n6.3.2][701]):\n\n`c := new C;\nc := new C.Init(args);\nc := new C(args);\n`\n\nFor a class with no constructors, the first two forms can be used. The first\nform simply allocates a new instance of a `C` object, initializing its fields to\nvalues of their respective types (and initializing each `const` field with a RHS\nto its specified value). The second form additionally invokes an *initialization\nmethod* (here, named `Init`) on the newly allocated object and the given\narguments. It is therefore a shorthand for\n\n`c := new C;\nc.Init(args);\n`\n\nAn initialization method is an ordinary method that has no out-parameters and\nthat modifies no more than `this`.\n\nFor a class that declares one or more constructors, the second and third forms\nof `new` can be used. For such a class, the second form invokes the indicated\nconstructor (here, named `Init`), which allocates and initializes the object.\nThe third form is the same as the second, but invokes the *anonymous\nconstructor* of the class (that is, a constructor declared with the empty-string\nname).\n\nThe details of constructors and other class members are described in [Section\n6.3.2][702].\n\n### 5.9. Trait types ([grammar][703])\n\nA *trait* is an abstract superclass, similar to an “interface” or “mixin”. A\ntrait can be *extended* only by another trait or by a class (and in the latter\ncase we say that the class *implements* the trait). More specifically, algebraic\ndatatypes cannot extend traits.^{[4][704]}\n\nThe declaration of a trait is much like that of a class:\n\n`trait J\n{\n  _members_\n}\n`\n\nwhere *members* can include fields, constant fields, functions, methods and\ndeclarations of nested traits, but no constructor methods. The functions and\nmethods are allowed to be declared `static`.\n\nA reference type `C` that extends a trait `J` is assignable to a variable of\ntype `J`; a value of type `J` is assignable to a variable of a reference type\n`C` that extends `J` only if the verifier can prove that the reference does\nindeed refer to an object of allocated type `C`. The members of `J` are\navailable as members of `C`. A member in `J` is not allowed to be redeclared in\n`C`, except if the member is a non-`static` function or method without a body in\n`J`. By doing so, type `C` can supply a stronger specification and a body for\nthe member. There is further discussion on this point in [Section 5.9.2][705].\n\n`new` is not allowed to be used with traits. Therefore, there is no object whose\nallocated type is a trait. But there can of course be objects of a class `C`\nthat implement a trait `J`, and a reference to such a `C` object can be used as\na value of type `J`.\n\n#### 5.9.1. Type `object` ([grammar][706])\n\nThere is a built-in trait `object` that is implicitly extended by all classes\nand traits. It produces two types: the type `object?` that is a supertype of all\nreference types and a subset type `object` that is a supertype of all non-null\nreference types. This includes reference types like arrays and iterators that do\nnot permit explicit extending of traits. The purpose of type `object` is to\nenable a uniform treatment of *dynamic frames*. In particular, it is useful to\nkeep a ghost field (typically named `Repr` for “representation”) of type\n`set<object>`.\n\nIt serves no purpose (but does no harm) to explicitly list the trait `object` as\nan extendee in a class or trait declaration.\n\nTraits `object?` and `object` contain no members.\n\nThe dynamic allocation of objects is done using `new C`…, where `C` is the name\nof a class. The name `C` is not allowed to be a trait, except that it is allowed\nto be `object`. The construction `new object` allocates a new object (of an\nunspecified class type). The construction can be used to create unique\nreferences, where no other properties of those references are needed. (`new\nobject?` makes no sense; always use `new object` instead because the result of\n`new` is always non-null.)\n\n#### 5.9.2. Inheritance\n\nThe purpose of traits is to be able to express abstraction: a trait encapsulates\na set of behaviors; classes and traits that extend it *inherit* those behaviors,\nperhaps specializing them.\n\nA trait or class may extend multiple other traits. The traits syntactically\nlisted in a trait or class’s `extends` clause are called its *direct parents*;\nthe *transitive parents* of a trait or class are its direct parents, the\ntransitive parents of its direct parents, and the `object` trait (if it is not\nitself `object`). These are sets of traits, in that it does not matter if there\nare repetitions of a given trait in a class or trait’s direct or transitive\nparents. However, if a trait with type parameters is repeated, it must have the\nsame actual type parameters in each instance. Furthermore, a trait may not be in\nits own set of transitive parents; that is, the graph of traits connected by the\ndirected *extends* relationship may not have any cycles.\n\nA class or trait inherits (as if they are copied) all the instance members of\nits transitive parents. However, since names may not be overloaded in Dafny,\ndifferent members (that is, members with different type signatures) within the\nset of transitive parents and the class or trait itself must have different\nnames.^{[5][707]} This restriction does mean that traits from different sources\nthat coincidentally use the same name for different purposes cannot be combined\nby being part of the set of transitive parents for some new trait or class.\n\nA declaration of member `C.M` in a class or trait *overrides* any other\ndeclarations of the same name (and signature) in a transitive parent. `C.M` is\nthen called an override; a declaration that does not override anything is called\nan *original declaration*.\n\nStatic members of a trait may not be redeclared; thus, if there is a body it\nmust be declared in the trait; the compiler will require a body, though the\nverifier will not.\n\nWhere traits within an extension hierarchy do declare instance members with the\nsame name (and thus the same signature), some rules apply. Recall that, for\nmethods, every declaration includes a specification; if no specification is\ngiven explicitly, a default specification applies. Instance method declarations\nin traits, however, need not have a body, as a body can be declared in an\noverride.\n\nFor a given non-static method M,\n\n* A trait or class may not redeclare M if it has a transitive parent that\n  declares M and provides a body.\n* A trait may but need not provide a body if all its transitive parents that\n  declare M do not declare a body.\n* A trait or class may not have more than one transitive parent that declares M\n  with a body.\n* A class that has one or more transitive parents that declare M without a body\n  and no transitive parent that declares M with a body must itself redeclare M\n  with a body if it is compiled. (The verifier alone does not require a body.)\n* Currently (and under debate), the following restriction applies: if `M`\n  overrides two (or more) declarations, `P.M` and `Q.M`, then either `P.M` must\n  override `Q.M` or `Q.M` must override `P.M`.\n\nThe last restriction above is the current implementation. It effectively limits\ninheritance of a method M to a single “chain” of declarations and does not\npermit mixins.\n\nEach of any method declarations explicitly or implicitly includes a\nspecification. In simple cases, those syntactically separate specifications will\nbe copies of each other (up to renaming to take account of differing formal\nparameter names). However they need not be. The rule is that the specifications\nof M in a given class or trait must be *as strong as* M’s specifications in a\ntransitive parent. Here *as strong as* means that it must be permitted to call\nthe subtype’s M in the context of the supertype’s M. Stated differently, where P\nand C are a parent trait and a child class or trait, respectively, then, under\nthe precondition of `P.M`,\n\n* C.M’s `requires` clause must be implied by P.M’s `requires` clause\n* C.M’s `ensures` clause must imply P.M’s `ensures` clause\n* C.M’s `reads` set must be a subset of P.M’s `reads` set\n* C.M’s `modifies` set must be a subset of P.M’s `modifies` set\n* C.M’s `decreases` expression must be smaller than or equal to P.M’s\n  `decreases` expression\n\nNon-static const and field declarations are also inherited from parent traits.\nThese may not be redeclared in extending traits and classes. However, a trait\nneed not initialize a const field with a value. The class that extends a trait\nthat declares such a const field without an initializer can initialize the field\nin a constructor. If the declaring trait does give an initial value in the\ndeclaration, the extending class or trait may not either redeclare the field or\ngive it a value in a constructor.\n\nWhen names are inherited from multiple traits, they must be different. If two\ntraits declare a common name (even with the same signature), they cannot both be\nextendees of the same class or trait.\n\n#### 5.9.3. Example of traits\n\nAs an example, the following trait represents movable geometric shapes:\n\n`trait Shape extends object\n{\n  function Width(): real\n    reads this\n    decreases 1\n  method Move(dx: real, dy: real)\n    modifies this\n  method MoveH(dx: real)\n    modifies this\n  {\n    Move(dx, 0.0);\n  }\n}\n`\n\nMembers `Width` and `Move` are *abstract* (that is, body-less) and can be\nimplemented differently by different classes that extend the trait. The\nimplementation of method `MoveH` is given in the trait and thus is used by all\nclasses that extend `Shape`. Here are two classes that each extend `Shape`:\n\n`class UnitSquare extends Shape\n{\n  var x: real, y: real\n  function Width(): real\n    decreases 0\n  {  // note the empty reads clause\n    1.0\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    x, y := x + dx, y + dy;\n  }\n}\n\nclass LowerRightTriangle extends Shape\n{\n  var xNW: real, yNW: real, xSE: real, ySE: real\n  function Width(): real\n    reads this\n    decreases 0\n  {\n    xSE - xNW\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    xNW, yNW, xSE, ySE := xNW + dx, yNW + dy, xSE + dx, ySE + dy;\n  }\n}\n`\n\nNote that the classes can declare additional members, that they supply\nimplementations for the abstract members of the trait, that they repeat the\nmember signatures, and that they are responsible for providing their own member\nspecifications that both strengthen the corresponding specification in the trait\nand are satisfied by the provided body. Finally, here is some code that creates\ntwo class instances and uses them together as shapes:\n\n`method m() {\n  var myShapes: seq<Shape>;\n  var A := new UnitSquare;\n  myShapes := [A];\n  var tri := new LowerRightTriangle;\n  // myShapes contains two Shape values, of different classes\n  myShapes := myShapes + [tri];\n  // move shape 1 to the right by the width of shape 0\n  myShapes[1].MoveH(myShapes[0].Width());\n}\n`\n\n### 5.10. Array types ([grammar][708])\n\nDafny supports mutable fixed-length *array types* of any positive dimension.\nArray types are (heap-based) reference types.\n\n`arrayToken` is a kind of [reserved token][709], such as `array`, `array?`,\n`array2`, `array2?`, `array3`, and so on (but not `array1`). The type parameter\nsuffix giving the element type can be omitted if the element type can be\ninferred, though in that case it is likely that the `arrayToken` itself is also\ninferrable and can be omitted.\n\n#### 5.10.1. One-dimensional arrays\n\nA one-dimensional array of `n` `T` elements may be initialized by any expression\nthat returns a value of the desired type. Commonly, [array allocation\nexpressions][710] are used. Some examples are shown here:\n\n`type T(0)\nmethod m(n: nat) {\n  var a := new T[n];\n  var b: array<int> := new int[8];\n  var c: array := new T[9];\n}\n`\n\nThe initial values of the array elements are arbitrary values of type `T`. A\none-dimensional array value can also be assigned using an ordered list of\nexpressions enclosed in square brackets, as follows:\n\n`a := new T[] [t1, t2, t3, t4];\n`\n\nThe initialization can also use an expression that returns a function of type\n`nat -> T`:\n\n`a := new int[5](i => i*i);\n`\n\nIn fact, the initializer can simply be a function name for the right type of\nfunction:\n\n`a := new int[5](Square);\n`\n\nThe length of an array is retrieved using the immutable `Length` member. For\nexample, the array allocated with `a := new T[n];` satisfies:\n\n`a.Length == n\n`\n\nOnce an array is allocated, its length cannot be changed.\n\nFor any integer-based numeric `i` in the range `0 <= i < a.Length`, the *array\nselection* expression `a[i]` retrieves element `i` (that is, the element\npreceded by `i` elements in the array). The element stored at `i` can be changed\nto a value `t` using the array update statement:\n\n`a[i] := t;\n`\n\nCaveat: The type of the array created by `new T[n]` is `array<T>`. A mistake\nthat is simple to make and that can lead to befuddlement is to write `array<T>`\ninstead of `T` after `new`. For example, consider the following:\n\n`type T(0)\nmethod m(n: nat) {\n  var a := new array<T>;\n  var b := new array<T>[n];\n  var c := new array<T>(n);  // resolution error\n  var d := new array(n);  // resolution error\n}\n`\n\nThe first statement allocates an array of type `array<T>`, but of unknown\nlength. The second allocates an array of type `array<array<T>>` of length `n`,\nthat is, an array that holds `n` values of type `array<T>`. The third statement\nallocates an array of type `array<T>` and then attempts to invoke an anonymous\nconstructor on this array, passing argument `n`. Since `array` has no\nconstructors, let alone an anonymous constructor, this statement gives rise to\nan error. If the type-parameter list is omitted for a type that expects type\nparameters, Dafny will attempt to fill these in, so as long as the `array` type\nparameter can be inferred, it is okay to leave off the “`<T>`” in the fourth\nstatement above. However, as with the third statement, `array` has no anonymous\nconstructor, so an error message is generated.\n\n#### 5.10.2. Converting arrays to sequences\n\nOne-dimensional arrays support operations that convert a stretch of consecutive\nelements into a sequence. For any array `a` of type `array<T>`, integer-based\nnumeric bounds `lo` and `hi` satisfying `0 <= lo <= hi <= a.Length`, noting that\nbounds can equal the array’s length, the following operations each yields a\n`seq<T>`:\n\n──────────┬───────────────────────────────\nexpression│description                    \n──────────┼───────────────────────────────\n`a[lo..hi]│subarray conversion to sequence\n`         │                               \n──────────┼───────────────────────────────\n`a[lo..]` │drop                           \n──────────┼───────────────────────────────\n`a[..hi]` │take                           \n──────────┼───────────────────────────────\n`a[..]`   │array conversion to sequence   \n──────────┴───────────────────────────────\n\nThe expression `a[lo..hi]` takes the first `hi` elements of the array, then\ndrops the first `lo` elements thereof and returns what remains as a sequence,\nwith length `hi - lo`. The other operations are special instances of the first.\nIf `lo` is omitted, it defaults to `0` and if `hi` is omitted, it defaults to\n`a.Length`. In the last operation, both `lo` and `hi` have been omitted, thus\n`a[..]` returns the sequence consisting of all the array elements of `a`.\n\nThe subarray operations are especially useful in specifications. For example,\nthe loop invariant of a binary search algorithm that uses variables `lo` and\n`hi` to delimit the subarray where the search `key` may still be found can be\nexpressed as follows:\n\n`key !in a[..lo] && key !in a[hi..]\n`\n\nAnother use is to say that a certain range of array elements have not been\nchanged since the beginning of a method:\n\n`a[lo..hi] == old(a[lo..hi])\n`\n\nor since the beginning of a loop:\n\n`ghost var prevElements := a[..];\nwhile // ...\n  invariant a[lo..hi] == prevElements[lo..hi]\n{\n  // ...\n}\n`\n\nNote that the type of `prevElements` in this example is `seq<T>`, if `a` has\ntype `array<T>`.\n\nA final example of the subarray operation lies in expressing that an array’s\nelements are a permutation of the array’s elements at the beginning of a method,\nas would be done in most sorting algorithms. Here, the subarray operation is\ncombined with the sequence-to-multiset conversion:\n\n`multiset(a[..]) == multiset(old(a[..]))\n`\n\n#### 5.10.3. Multi-dimensional arrays\n\nAn array of 2 or more dimensions is mostly like a one-dimensional array, except\nthat `new` takes more length arguments (one for each dimension), and the array\nselection expression and the array update statement take more indices. For\nexample:\n\n`matrix := new T[m, n];\nmatrix[i, j], matrix[x, y] := matrix[x, y], matrix[i, j];\n`\n\ncreate a 2-dimensional array whose dimensions have lengths `m` and `n`,\nrespectively, and then swaps the elements at `i,j` and `x,y`. The type of\n`matrix` is `array2<T>`, and similarly for higher-dimensional arrays\n(`array3<T>`, `array4<T>`, etc.). Note, however, that there is no type\n`array0<T>`, and what could have been `array1<T>` is actually named just\n`array<T>`. (Accordingly, `array0` and `array1` are just normal identifiers, not\ntype names.)\n\nThe `new` operation above requires `m` and `n` to be non-negative integer-based\nnumerics. These lengths can be retrieved using the immutable fields `Length0`\nand `Length1`. For example, the following holds for the array created above:\n\n`matrix.Length0 == m && matrix.Length1 == n\n`\n\nHigher-dimensional arrays are similar (`Length0`, `Length1`, `Length2`, …). The\narray selection expression and array update statement require that the indices\nare in bounds. For example, the swap statement above is [well-formed][711] only\nif:\n\n`0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 &&\n0 <= x < matrix.Length0 && 0 <= y < matrix.Length1\n`\n\nIn contrast to one-dimensional arrays, there is no operation to convert\nstretches of elements from a multi-dimensional array to a sequence.\n\nThere is however syntax to create a multi-dimensional array value using a\nfunction: see [Section 9.16][712].\n\n### 5.11. Iterator types ([grammar][713])\n\nSee [Section 7.5][714] for a description of iterator specifications.\n\nAn *iterator* provides a programming abstraction for writing code that\niteratively returns elements. These CLU-style iterators are *co-routines* in the\nsense that they keep track of their own program counter and control can be\ntransferred into and out of the iterator body.\n\nAn iterator is declared as follows:\n\n`iterator Iter<T>(_in-params_) yields (_yield-params_)\n  _specification_\n{\n  _body_\n}\n`\n\nwhere `T` is a list of type parameters (as usual, if there are no type\nparameters, “`<T>`” is omitted). This declaration gives rise to a reference type\nwith the same name, `Iter<T>`. In the signature, in-parameters and\nyield-parameters are the iterator’s analog of a method’s in-parameters and\nout-parameters. The difference is that the out-parameters of a method are\nreturned to a caller just once, whereas the yield-parameters of an iterator are\nreturned each time the iterator body performs a `yield`. The body consists of\nstatements, like in a method body, but with the availability also of `yield`\nstatements.\n\nFrom the perspective of an iterator client, the `iterator` declaration can be\nunderstood as generating a class `Iter<T>` with various members, a simplified\nversion of which is described next.\n\nThe `Iter<T>` class contains an anonymous constructor whose parameters are the\niterator’s in-parameters:\n\n`predicate Valid()\nconstructor (_in-params_)\n  modifies this\n  ensures Valid()\n`\n\nAn iterator is created using `new` and this anonymous constructor. For example,\nan iterator willing to return ten consecutive integers from `start` can be\ndeclared as follows:\n\n`iterator Gen(start: int) yields (x: int)\n  yield ensures |xs| <= 10 && x == start + |xs| - 1\n{\n  var i := 0;\n  while i < 10 invariant |xs| == i {\n    x := start + i;\n    yield;\n    i := i + 1;\n  }\n}\n`\n\nAn instance of this iterator is created using\n\n`iter := new Gen(30);\n`\n\nIt is used like this:\n\n`method Main() {\n  var i := new Gen(30);\n  while true\n    invariant i.Valid() && fresh(i._new)\n    decreases 10 - |i.xs|\n  {\n    var m := i.MoveNext();\n    if (!m) {break; }\n    print i.x;\n  }\n}\n`\n\nThe predicate `Valid()` says when the iterator is in a state where one can\nattempt to compute more elements. It is a postcondition of the constructor and\noccurs in the specification of the `MoveNext` member:\n\n`method MoveNext() returns (more: bool)\n  requires Valid()\n  modifies this\n  ensures more ==> Valid()\n`\n\nNote that the iterator remains valid as long as `MoveNext` returns `true`. Once\n`MoveNext` returns `false`, the `MoveNext` method can no longer be called. Note,\nthe client is under no obligation to keep calling `MoveNext` until it returns\n`false`, and the body of the iterator is allowed to keep returning elements\nforever.\n\nThe in-parameters of the iterator are stored in immutable fields of the iterator\nclass. To illustrate in terms of the example above, the iterator class `Gen`\ncontains the following field:\n\n`const start: int\n`\n\nThe yield-parameters also result in members of the iterator class:\n\n`var x: int\n`\n\nThese fields are set by the `MoveNext` method. If `MoveNext` returns `true`, the\nlatest yield values are available in these fields and the client can read them\nfrom there.\n\nTo aid in writing specifications, the iterator class also contains ghost members\nthat keep the history of values returned by `MoveNext`. The names of these ghost\nfields follow the names of the yield-parameters with an “`s`” appended to the\nname (to suggest plural). Name checking rules make sure these names do not give\nrise to ambiguities. The iterator class for `Gen` above thus contains:\n\n`ghost var xs: seq<int>\n`\n\nThese history fields are changed automatically by `MoveNext`, but are not\nassignable by user code.\n\nFinally, the iterator class contains some special fields for use in\nspecifications. In particular, the iterator specification is recorded in the\nfollowing immutable fields:\n\n`ghost var _reads: set<object>\nghost var _modifies: set<object>\nghost var _decreases0: T0\nghost var _decreases1: T1\n// ...\n`\n\nwhere there is a `_decreases(`*i*`): T(`*i*`)` field for each component of the\niterator’s `decreases` clause.^{[6][715]} In addition, there is a field:\n\n`ghost var _new: set<object>;\n`\n\nto which any objects allocated on behalf of the iterator body are added. The\niterator body is allowed to remove elements from the `_new` set, but cannot by\nassignment to `_new` add any elements.\n\nNote, in the precondition of the iterator, which is to hold upon construction of\nthe iterator, the in-parameters are indeed in-parameters, not fields of `this`.\n\n`reads` clauses on iterators have a different meaning than they do on functions\nand methods. Iterators may read any memory they like, but because arbitrary code\nmay be executed whenever they `yield` control, they need to declare what memory\nlocations must not be modified by other code in order to maintain correctness.\nThe contents of an iterator’s `reads` clauses become part of the `reads` clause\nof the implicitly created `Valid()` predicate. This means if client code\nmodifies any of this state, it will not be able to establish the precondition\nfor the iterator’s `MoveNext()` method, and hence the iterator body will never\nresume if this state is modified.\n\nIt is regrettably tricky to use iterators. The language really ought to have a\n`foreach` statement to make this easier. Here is an example showing a definition\nand use of an iterator.\n\n`iterator Iter<T(0)>(s: set<T>) yields (x: T)\n  yield ensures x in s && x !in xs[..|xs|-1]\n  ensures s == set z | z in xs\n{\n  var r := s;\n  while (r != {})\n    invariant r !! set z | z in xs\n    invariant s == r + set z | z in xs\n  {\n    var y :| y in r;\n    assert y !in xs;\n    r, x := r - {y}, y;\n    assert y !in xs;\n    yield;\n    assert y == xs[|xs|-1]; // a lemma to help prove loop invariant\n  }\n}\n\nmethod UseIterToCopy<T(0)>(s: set<T>) returns (t: set<T>)\n  ensures s == t\n{\n  t := {};\n  var m := new Iter(s);\n  while (true)\n    invariant m.Valid() && fresh(m._new)\n    invariant t == set z | z in m.xs\n    decreases s - t\n  {\n    var more := m.MoveNext();\n    if (!more) { break; }\n    t := t + {m.x};\n  }\n}\n`\n\nThe design of iterators is [under discussion and may change][716].\n\n### 5.12. Arrow types ([grammar][717])\n\nExamples:\n\n`(int) -> int\n(bool,int) ~> bool\n() --> object?\n`\n\nFunctions are first-class values in Dafny. The types of function values are\ncalled *arrow types* (aka, *function types*). Arrow types have the form `(TT) ~>\nU` where `TT` is a (possibly empty) comma-delimited list of types and `U` is a\ntype. `TT` is called the function’s *domain type(s)* and `U` is its *range\ntype*. For example, the type of a function\n\n`function F(x: int, arr: array<bool>): real\n  requires x < 1000\n  reads arr\n`\n\nis `(int, array<bool>) ~> real`.\n\nAs seen in the example above, the functions that are values of a type `(TT) ~>\nU` can have a precondition (as indicated by the `requires` clause) and can read\nvalues in the heap (as indicated by the `reads` clause). As described in\n[Section 5.6.3.3][718],\n\n* the subset type `(TT) --> U` denotes partial (but heap-independent) functions\n* and the subset type `(TT) -> U` denotes total functions.\n\nA function declared without a `reads` clause is known by the type checker to be\na partial function. For example, the type of\n\n`function F(x: int, b: bool): real\n  requires x < 1000\n`\n\nis `(int, bool) --> real`. Similarly, a function declared with neither a `reads`\nclause nor a `requires` clause is known by the type checker to be a total\nfunction. For example, the type of\n\n`function F(x: int, b: bool): real\n`\n\nis `(int, bool) -> real`. In addition to functions declared by name, Dafny also\nsupports anonymous functions by means of *lambda expressions* (see [Section\n9.13][719]).\n\nTo simplify the appearance of the basic case where a function’s domain consists\nof a list of exactly one non-function, non-tuple type, the parentheses around\nthe domain type can be dropped in this case. For example, you may write just `T\n-> U` for a total arrow type. This innocent simplification requires additional\nexplanation in the case where that one type is a tuple type, since tuple types\nare also written with enclosing parentheses. If the function takes a single\nargument that is a tuple, an additional set of parentheses is needed. For\nexample, the function\n\n`function G(pair: (int, bool)): real\n`\n\nhas type `((int, bool)) -> real`. Note the necessary double parentheses.\nSimilarly, a function that takes no arguments is different from one that takes a\n0-tuple as an argument. For instance, the functions\n\n`function NoArgs(): real\nfunction Z(unit: ()): real\n`\n\nhave types `() -> real` and `(()) -> real`, respectively.\n\nThe function arrows are right associative. For example, `A -> B -> C` means `A\n-> (B -> C)`, whereas the other association requires explicit parentheses: `(A\n-> B) -> C`. As another example, `A -> B --> C ~> D` means `A -> (B --> (C ~>\nD))`.\n\nNote that the receiver parameter of a named function is not part of the type.\nRather, it is used when looking up the function and can then be thought of as\nbeing captured into the function definition. For example, suppose function `F`\nabove is declared in a class `C` and that `c` references an object of type `C`;\nthen, the following is type correct:\n\n`var f: (int, bool) -> real := c.F;\n`\n\nwhereas it would have been incorrect to have written something like:\n\n`var f': (C, int, bool) -> real := F;  // not correct\n`\n\nThe arrow types themselves do not divide a function’s parameters into ghost\nversus non-ghost. Instead, a function used as a first-class value is considered\nto be ghost if either the function or any of its arguments is ghost. The\nfollowing example program illustrates:\n\n`function F(x: int, ghost y: int): int\n{\n  x\n}\n\nmethod Example() {\n  ghost var f: (int, int) -> int;\n  var g: (int, int) -> int;\n  var h: (int) -> int;\n  var x: int;\n  f := F;\n  x := F(20, 30);\n  g := F; // error: tries to assign ghost to non-ghost\n  h := F; // error: wrong arity (and also tries to assign ghost to non-ghost)\n}\n`\n\nIn addition to its type signature, each function value has three properties,\ndescribed next.\n\nEvery function implicitly takes the heap as an argument. No function ever\ndepends on the *entire* heap, however. A property of the function is its\ndeclared upper bound on the set of heap locations it depends on for a given\ninput. This lets the verifier figure out that certain heap modifications have no\neffect on the value returned by a certain function. For a function `f: T ~> U`\nand a value `t` of type `T`, the dependency set is denoted `f.reads(t)` and has\ntype `set<object>`.\n\nThe second property of functions stems from the fact that every function is\npotentially *partial*. In other words, a property of a function is its\n*precondition*. For a function `f: T ~> U`, the precondition of `f` for a\nparameter value `t` of type `T` is denoted `f.requires(t)` and has type `bool`.\n\nThe third property of a function is more obvious—the function’s body. For a\nfunction `f: T ~> U`, the value that the function yields for an input `t` of\ntype `T` is denoted `f(t)` and has type `U`.\n\nNote that `f.reads` and `f.requires` are themselves functions. Without loss of\ngenerality, suppose `f` is defined as:\n\n`function f<T,U>(x: T): U\n  reads R(x)\n  requires P(x)\n{\n  body(x)\n}\n`\n\nwhere `P`, `R`, and `body` are declared as:\n\n`predicate P<T>(x: T)\nfunction R<T>(x: T): set<object>\nfunction body<T,U>(x: T): U\n`\n\nThen, `f.reads` is a function of type `T ~> set<object?>` whose `reads` and\n`requires` properties are given by the definition:\n\n`function f.reads<T>(x: T): set<object>\n  reads R(x)\n  requires P(x)\n{\n  R(x)\n}\n`\n\n`f.requires` is a function of type `T ~> bool` whose `reads` and `requires`\nproperties are given by the definition:\n\n`predicate f_requires<T>(x: T)\n  requires true\n  reads if P(x) then R(x) else *\n{\n  P(x)\n}\n`\n\nwhere `*` is a notation to indicate that any memory location can be read, but is\nnot valid Dafny syntax.\n\nIn these examples, if `f` instead had type `T --> U` or `T -> U`, then the type\nof `f.reads` is `T -> set<object?>` and the type of `f.requires` is `T -> bool`.\n\nDafny also supports anonymous functions by means of *lambda expressions*. See\n[Section 9.13][720].\n\n### 5.13. Tuple types\n\n`TupleType = \"(\" [ [ \"ghost\" ] Type { \",\" [ \"ghost\" ] Type } ] \")\"\n`\n\nDafny builds in record types that correspond to tuples and gives these a\nconvenient special syntax, namely parentheses. For example, for what might have\nbeen declared as\n\n`datatype Pair<T,U> = Pair(0: T, 1: U)\n`\n\nDafny provides the type `(T, U)` and the constructor `(t, u)`, as if the\ndatatype’s name were “” (i.e., an empty string) and its type arguments are given\nin round parentheses, and as if the constructor name were the empty string. Note\nthat the destructor names are `0` and `1`, which are legal identifier names for\nmembers. For an example showing the use of a tuple destructor, here is a\nproperty that holds of 2-tuples (that is, *pairs*):\n\n`method m(){\n  assert (5, true).1 == true;\n}\n`\n\nDafny declares *n*-tuples where *n* is 0 or 2 or more. There are no 1-tuples,\nsince parentheses around a single type or a single value have no semantic\nmeaning. The 0-tuple type, `()`, is often known as the *unit type* and its\nsingle value, also written `()`, is known as *unit*.\n\nThe `ghost` modifier can be used to mark tuple components as being used for\nspecification only:\n\n`const pair: (int, ghost int) := (1, ghost 2)\n`\n\n### 5.14. Algebraic Datatypes ([grammar][721])\n\nDafny offers two kinds of algebraic datatypes, those defined inductively (with\n`datatype`) and those defined coinductively (with `codatatype`). The salient\nproperty of every datatype is that each value of the type uniquely identifies\none of the datatype’s constructors and each constructor is injective in its\nparameters.\n\n#### 5.14.1. Inductive datatypes\n\nThe values of inductive datatypes can be seen as finite trees where the leaves\nare values of basic types, numeric types, reference types, coinductive\ndatatypes, or arrow types. Indeed, values of inductive datatypes can be compared\nusing Dafny’s well-founded `<` ordering.\n\nAn inductive datatype is declared as follows:\n\n`datatype D<T> = _Ctors_\n`\n\nwhere *Ctors* is a nonempty `|`-separated list of *(datatype) constructors* for\nthe datatype. Each constructor has the form:\n\n`C(_params_)\n`\n\nwhere *params* is a comma-delimited list of types, optionally preceded by a name\nfor the parameter and a colon, and optionally preceded by the keyword `ghost`.\nIf a constructor has no parameters, the parentheses after the constructor name\nmay be omitted. If no constructor takes a parameter, the type is usually called\nan *enumeration*; for example:\n\n`datatype Friends = Agnes | Agatha | Jermaine | Jack\n`\n\nFor every constructor `C`, Dafny defines a *discriminator* `C?`, which is a\nmember that returns `true` if and only if the datatype value has been\nconstructed using `C`. For every named parameter `p` of a constructor `C`, Dafny\ndefines a *destructor* `p`, which is a member that returns the `p` parameter\nfrom the `C` call used to construct the datatype value; its use requires that\n`C?` holds. For example, for the standard `List` type\n\n`datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n`\n\nthe following holds:\n\n`method m() {\n  assert Cons(5, Nil).Cons? && Cons(5, Nil).head == 5;\n}\n`\n\nNote that the expression\n\n`Cons(5, Nil).tail.head\n`\n\nis not [well-formed][722] by itself, since `Cons(5, Nil).tail` does not\nnecessarily satisfy `Cons?`.\n\nA constructor can have the same name as the enclosing datatype; this is\nespecially useful for single-constructor datatypes, which are often called\n*record types*. For example, a record type for black-and-white pixels might be\nrepresented as follows:\n\n`datatype Pixel = Pixel(x: int, y: int, on: bool)\n`\n\nTo call a constructor, it is usually necessary only to mention the name of the\nconstructor, but if this is ambiguous, it is always possible to qualify the name\nof constructor by the name of the datatype. For example, `Cons(5, Nil)` above\ncan be written\n\n`List.Cons(5, List.Nil)\n`\n\nAs an alternative to calling a datatype constructor explicitly, a datatype value\ncan be constructed as a change in one parameter from a given datatype value\nusing the *datatype update* expression. For any `d` whose type is a datatype\nthat includes a constructor `C` that has a parameter (destructor) named `f` of\ntype `T`, and any expression `t` of type `T`,\n\n`d.(f := t)\n`\n\nconstructs a value like `d` but whose `f` parameter is `t`. The operation\nrequires that `d` satisfies `C?`. For example, the following equality holds:\n\n`method m(){\n  assert Cons(4, Nil).(tail := Cons(3, Nil)) == Cons(4, Cons(3, Nil));\n}\n`\n\nThe datatype update expression also accepts multiple field names, provided these\nare distinct. For example, a node of some inductive datatype for trees may be\nupdated as follows:\n\n`node.(left := L, right := R)\n`\n\nThe operator `<` is defined for two operands of the same datataype. It means *is\nproperly contained in*. For example, in the code\n\n`datatype X = T(t: X) | I(i: int)\nmethod comp() {\n  var x := T(I(0));\n  var y := I(0);\n  var z := I(1);\n  assert x.t < x;\n  assert y < x;\n  assert !(x < x);\n  assert z < x; // FAILS\n}\n`\n\n`x` is a datatype value that holds a `T` variant, which holds a `I` variant,\nwhich holds an integer `0`. The value `x.t` is a portion of the datatype\nstructure denoted by `x`, so `x.t < x` is true. Datatype values are immutable\nmathematical values, so the value of `y` is identical to the value of `x.t`, so\n`y < x` is true also, even though `y` is constructed from the ground up, rather\nthan as a portion of `x`. However, `z` is different than either `y` or `x.t` and\nconsequently `z < x` is not provable. Furthermore, `<` does not include `==`, so\n`x < x` is false.\n\nNote that only `<` is defined; not `<=` or `>` or `>=`.\n\nAlso, `<` is underspecified. With the above code, one can prove neither `z < x`\nnor `!(z < x)` and neither `z < y` nor `!(z < y)`. In each pair, though, one or\nthe other is true, so `(z < x) || !(z < x)` is provable.\n\n#### 5.14.2. Coinductive datatypes\n\nWhereas Dafny insists that there is a way to construct every inductive datatype\nvalue from the ground up, Dafny also supports *coinductive datatypes*, whose\nconstructors are evaluated lazily, and hence the language allows infinite\nstructures. A coinductive datatype is declared using the keyword `codatatype`;\nother than that, it is declared and used like an inductive datatype.\n\nFor example,\n\n`codatatype IList<T> = Nil | Cons(head: T, tail: IList<T>)\ncodatatype Stream<T> = More(head: T, tail: Stream<T>)\ncodatatype Tree<T> = Node(left: Tree<T>, value: T, right: Tree<T>)\n`\n\ndeclare possibly infinite lists (that is, lists that can be either finite or\ninfinite), infinite streams (that is, lists that are always infinite), and\ninfinite binary trees (that is, trees where every branch goes on forever),\nrespectively.\n\nThe paper [Co-induction Simply][723], by Leino and\nMoskal[@LEINO:Dafny:Coinduction], explains Dafny’s implementation and\nverification of coinductive types. We capture the key features from that paper\nin the following section but the reader is referred to that paper for more\ncomplete details and to supply bibliographic references that are omitted here.\n\n#### 5.14.3. Coinduction\n\nMathematical induction is a cornerstone of programming and program verification.\nIt arises in data definitions (e.g., some algebraic data structures can be\ndescribed using induction), it underlies program semantics (e.g., it explains\nhow to reason about finite iteration and recursion), and it is used in proofs\n(e.g., supporting lemmas about data structures use inductive proofs). Whereas\ninduction deals with finite things (data, behavior, etc.), its dual,\ncoinduction, deals with possibly infinite things. Coinduction, too, is important\nin programming and program verification: it arises in data definitions (e.g.,\nlazy data structures), semantics (e.g., concurrency), and proofs (e.g., showing\nrefinement in a coinductive big-step semantics). It is thus desirable to have\ngood support for both induction and coinduction in a system for constructing and\nreasoning about programs.\n\nCo-datatypes and co-recursive functions make it possible to use lazily evaluated\ndata structures (like in Haskell or Agda). *Greatest predicates*, defined by\ngreatest fix-points, let programs state properties of such data structures (as\ncan also be done in, for example, Coq). For the purpose of writing coinductive\nproofs in the language, we introduce greatest and least lemmas. A greatest lemma\ninvokes the coinduction hypothesis much like an inductive proof invokes the\ninduction hypothesis. Underneath the hood, our coinductive proofs are actually\napproached via induction: greatest and least lemmas provide a syntactic veneer\naround this approach.\n\nThe following example gives a taste of how the coinductive features in Dafny\ncome together to give straightforward definitions of infinite matters.\n\n`// infinite streams\ncodatatype IStream<T> = ICons(head: T, tail: IStream<T>)\n\n// pointwise product of streams\nfunction Mult(a: IStream<int>, b: IStream<int>): IStream<int>\n{ ICons(a.head * b.head, Mult(a.tail, b.tail)) }\n\n// lexicographic order on streams\ngreatest predicate Below(a: IStream<int>, b: IStream<int>)\n{ a.head <= b.head &&\n  ((a.head == b.head) ==> Below(a.tail, b.tail))\n}\n\n// a stream is Below its Square\ngreatest lemma Theorem_BelowSquare(a: IStream<int>)\n  ensures Below(a, Mult(a, a))\n{ assert a.head <= Mult(a, a).head;\n  if a.head == Mult(a, a).head {\n    Theorem_BelowSquare(a.tail);\n  }\n}\n\n// an incorrect property and a bogus proof attempt\ngreatest lemma NotATheorem_SquareBelow(a: IStream<int>)\n  ensures Below(Mult(a, a), a) // ERROR\n{\n  NotATheorem_SquareBelow(a);\n}\n`\n\nThe example defines a type `IStream` of infinite streams, with constructor\n`ICons` and destructors `head` and `tail`. Function `Mult` performs pointwise\nmultiplication on infinite streams of integers, defined using a co-recursive\ncall (which is evaluated lazily). Greatest predicate `Below` is defined as a\ngreatest fix-point, which intuitively means that the co-predicate will take on\nthe value true if the recursion goes on forever without determining a different\nvalue. The greatest lemma states the theorem `Below(a, Mult(a, a))`. Its body\ngives the proof, where the recursive invocation of the co-lemma corresponds to\nan invocation of the coinduction hypothesis.\n\nThe proof of the theorem stated by the first co-lemma lends itself to the\nfollowing intuitive reading: To prove that `a` is below `Mult(a, a)`, check that\ntheir heads are ordered and, if the heads are equal, also prove that the tails\nare ordered. The second co-lemma states a property that does not always hold;\nthe verifier is not fooled by the bogus proof attempt and instead reports the\nproperty as unproved.\n\nWe argue that these definitions in Dafny are simple enough to level the playing\nfield between induction (which is familiar) and coinduction (which, despite\nbeing the dual of induction, is often perceived as eerily mysterious). Moreover,\nthe automation provided by our SMT-based verifier reduces the tedium in writing\ncoinductive proofs. For example, it verifies `Theorem_BelowSquare` from the\nprogram text given above—no additional lemmas or tactics are needed. In fact, as\na consequence of the automatic-induction heuristic in Dafny, the verifier will\nautomatically verify `Theorem_BelowSquare` even given an empty body.\n\nJust like there are restrictions on when an *inductive hypothesis* can be\ninvoked, there are restrictions on how a *coinductive* hypothesis can be *used*.\nThese are, of course, taken into consideration by Dafny’s verifier. For example,\nas illustrated by the second greatest lemma above, invoking the coinductive\nhypothesis in an attempt to obtain the entire proof goal is futile. (We explain\nhow this works in [the section about greatest lemmas][724]) Our initial\nexperience with coinduction in Dafny shows it to provide an intuitive,\nlow-overhead user experience that compares favorably to even the best of today’s\ninteractive proof assistants for coinduction. In addition, the coinductive\nfeatures and verification support in Dafny have other potential benefits. The\nfeatures are a stepping stone for verifying functional lazy programs with Dafny.\nCoinductive features have also shown to be useful in defining language\nsemantics, as needed to verify the correctness of a compiler, so this opens the\npossibility that such verifications can benefit from SMT automation.\n\n5.14.3.1. Well-Founded Function/Method Definitions\n\nThe Dafny programming language supports functions and methods. A *function* in\nDafny is a mathematical function (i.e., it is well-defined, deterministic, and\npure), whereas a *method* is a body of statements that can mutate the state of\nthe program. A function is defined by its given body, which is an expression. To\nensure that function definitions are mathematically consistent, Dafny insists\nthat recursive calls be well-founded, enforced as follows: Dafny computes the\ncall graph of functions. The strongly connected components within it are\n*clusters* of mutually recursive definitions; the clusters are arranged in a\nDAG. This stratifies the functions so that a call from one cluster in the DAG to\na lower cluster is allowed arbitrarily. For an intra-cluster call, Dafny\nprescribes a proof obligation that is taken through the program verifier’s\nreasoning engine. Semantically, each function activation is labeled by a\n*rank*—a lexicographic tuple determined by evaluating the function’s `decreases`\nclause upon invocation of the function. The proof obligation for an\nintra-cluster call is thus that the rank of the callee is strictly less (in a\nlanguage-defined well-founded relation) than the rank of the caller. Because\nthese well-founded checks correspond to proving termination of executable code,\nwe will often refer to them as “termination checks”. The same process applies to\nmethods.\n\nLemmas in Dafny are commonly introduced by declaring a method, stating the\nproperty of the lemma in the *postcondition* (keyword `ensures`) of the method,\nperhaps restricting the domain of the lemma by also giving a *precondition*\n(keyword `requires`), and using the lemma by invoking the method. Lemmas are\nstated, used, and proved as methods, but since they have no use at run time,\nsuch lemma methods are typically declared as *ghost*, meaning that they are not\ncompiled into code. The keyword `lemma` introduces such a method. Control flow\nstatements correspond to proof techniques—case splits are introduced with if\nstatements, recursion and loops are used for induction, and method calls for\nstructuring the proof. Additionally, the statement:\n\n`forall x | P(x) { Lemma(x); }\n`\n\nis used to invoke `Lemma(x)` on all `x` for which `P(x)` holds. If `Lemma(x)`\nensures `Q(x)`, then the forall statement establishes\n\n`forall x :: P(x) ==> Q(x).\n`\n5.14.3.2. Defining Coinductive Datatypes\n\nEach value of an inductive datatype is finite, in the sense that it can be\nconstructed by a finite number of calls to datatype constructors. In contrast,\nvalues of a coinductive datatype, or co-datatype for short, can be infinite. For\nexample, a co-datatype can be used to represent infinite trees.\n\nSyntactically, the declaration of a co-datatype in Dafny looks like that of a\ndatatype, giving prominence to the constructors (following Coq). The following\nexample defines a co-datatype Stream of possibly infinite lists.\n\n`codatatype Stream<T> = SNil | SCons(head: T, tail: Stream)\nfunction Up(n: int): Stream<int> { SCons(n, Up(n+1)) }\nfunction FivesUp(n: int): Stream<int>\n  decreases 4 - (n - 1) % 5\n{\n  if (n % 5 == 0) then\n    SCons(n, FivesUp(n+1))\n  else\n    FivesUp(n+1)\n}\n`\n\n`Stream` is a coinductive datatype whose values are possibly infinite lists.\nFunction `Up` returns a stream consisting of all integers upwards of `n` and\n`FivesUp` returns a stream consisting of all multiples of 5 upwards of `n` . The\nself-call in `Up` and the first self-call in `FivesUp` sit in productive\npositions and are therefore classified as co-recursive calls, exempt from\ntermination checks. The second self-call in `FivesUp` is not in a productive\nposition and is therefore subject to termination checking; in particular, each\nrecursive call must decrease the rank defined by the `decreases` clause.\n\nAnalogous to the common finite list datatype, `Stream` declares two\nconstructors, `SNil` and `SCons`. Values can be destructed using match\nexpressions and statements. In addition, like for inductive datatypes, each\nconstructor `C` automatically gives rise to a discriminator `C?` and each\nparameter of a constructor can be named in order to introduce a corresponding\ndestructor. For example, if `xs` is the stream `SCons(x, ys)`, then `xs.SCons?`\nand `xs.head == x` hold. In contrast to datatype declarations, there is no\ngrounding check for co-datatypes—since a codatatype admits infinite values, the\ntype is nevertheless inhabited.\n\n5.14.3.3. Creating Values of Co-datatypes\n\nTo define values of co-datatypes, one could imagine a “co-function” language\nfeature: the body of a “co-function” could include possibly never-ending\nself-calls that are interpreted by a greatest fix-point semantics (akin to a\n**CoFixpoint** in Coq). Dafny uses a different design: it offers only functions\n(not “co-functions”), but it classifies each intra-cluster call as either\n*recursive* or *co-recursive*. Recursive calls are subject to termination\nchecks. Co-recursive calls may be never-ending, which is what is needed to\ndefine infinite values of a co-datatype. For example, function `Up(n)` in the\npreceding example is defined as the stream of numbers from `n` upward: it\nreturns a stream that starts with `n` and continues as the co-recursive call\n`Up(n + 1)`.\n\nTo ensure that co-recursive calls give rise to mathematically consistent\ndefinitions, they must occur only in productive positions. This says that it\nmust be possible to determine each successive piece of a co-datatype value after\na finite amount of work. This condition is satisfied if every co-recursive call\nis syntactically guarded by a constructor of a co-datatype, which is the\ncriterion Dafny uses to classify intra-cluster calls as being either\nco-recursive or recursive. Calls that are classified as co-recursive are exempt\nfrom termination checks.\n\nA consequence of the productivity checks and termination checks is that, even in\nthe absence of talking about least or greatest fix-points of self-calling\nfunctions, all functions in Dafny are deterministic. Since there cannot be\nmultiple fix-points, the language allows one function to be involved in both\nrecursive and co-recursive calls, as we illustrate by the function `FivesUp`.\n\n5.14.3.4. Co-Equality\n\nEquality between two values of a co-datatype is a built-in co-predicate. It has\nthe usual equality syntax `s == t`, and the corresponding prefix equality is\nwritten `s ==#[k] t`. And similarly for `s != t` and `s !=#[k] t`.\n\n5.14.3.5. Greatest predicates\n\nDetermining properties of co-datatype values may require an infinite number of\nobservations. To that end, Dafny provides *greatest predicates* which are\nfunction declarations that use the `greatest predicate` keyword phrase.\nSelf-calls to a greatest predicate need not terminate. Instead, the value\ndefined is the greatest fix-point of the given recurrence equations. Continuing\nthe preceding example, the following code defines a greatest predicate that\nholds for exactly those streams whose payload consists solely of positive\nintegers. The greatest predicate definition implicitly also gives rise to a\ncorresponding prefix predicate, `Pos#`. The syntax for calling a prefix\npredicate sets apart the argument that specifies the prefix length, as shown in\nthe last line; for this figure, we took the liberty of making up a coordinating\nsyntax for the signature of the automatically generated prefix predicate (which\nis not part of Dafny syntax).\n\n`greatest predicate Pos[nat](s: Stream<int>)\n{\n  match s\n  case SNil => true\n  case SCons(x, rest) => x > 0 && Pos(rest)\n}\n`\n\nThe following code is automatically generated by the Dafny compiler:\n\n`predicate Pos#[_k: nat](s: Stream<int>)\n  decreases _k\n{ if _k == 0 then true else\n  match s\n  case SNil => true\n  case SCons(x, rest) => x > 0 && Pos#[_k-1](rest)\n}\n`\n\nSome restrictions apply. To guarantee that the greatest fix-point always exists,\nthe (implicit functor defining the) greatest predicate must be monotonic. This\nis enforced by a syntactic restriction on the form of the body of greatest\npredicates: after conversion to negation normal form (i.e., pushing negations\ndown to the atoms), intra-cluster calls of greatest predicates must appear only\nin *positive* positions—that is, they must appear as atoms and must not be\nnegated. Additionally, to guarantee soundness later on, we require that they\nappear in *continous* positions—that is, in negation normal form, when they\nappear under existential quantification, the quantification needs to be limited\nto a finite range^{[7][725]}. Since the evaluation of a greatest predicate might\nnot terminate, greatest predicates are always ghost. There is also a restriction\non the call graph that a cluster containing a greatest predicate must contain\nonly greatest predicates, no other kinds of functions.\n\nextreme predicates and lemmas, one in which `_k` has type `nat` and one in which\nit has type `ORDINAL` (the default). The continuous restriction applies only\nwhen `_k` is `nat`. Also, higher-order function support in Dafny is rather\nmodest and typical reasoning patterns do not involve them, so this restriction\nis not as limiting as it would have been in, e.g., Coq.\n\nA **greatest predicate** declaration of `P` defines not just a greatest\npredicate, but also a corresponding *prefix predicate* `P#`. A prefix predicate\nis a finite unrolling of a co-predicate. The prefix predicate is constructed\nfrom the co-predicate by\n\n* adding a parameter `_k` of type `nat` to denote the prefix length,\n* adding the clause `decreases _k;` to the prefix predicate (the greatest\n  predicate itself is not allowed to have a decreases clause),\n* replacing in the body of the greatest predicate every intra-cluster call\n  `Q(args)` to a greatest predicate by a call `Q#[_k - 1](args)` to the\n  corresponding prefix predicate, and then\n* prepending the body with `if _k == 0 then true else`.\n\nFor example, for greatest predicate `Pos`, the definition of the prefix\npredicate `Pos#` is as suggested above. Syntactically, the prefix-length\nargument passed to a prefix predicate to indicate how many times to unroll the\ndefinition is written in square brackets, as in `Pos#[k](s)`. In the Dafny\ngrammar this is called a `HashCall`. The definition of `Pos#` is available only\nat clusters strictly higher than that of `Pos`; that is, `Pos` and `Pos#` must\nnot be in the same cluster. In other words, the definition of `Pos` cannot\ndepend on `Pos#`.\n\n5.14.3.6. Coinductive Proofs\n\nFrom what we have said so far, a program can make use of properties of\nco-datatypes. For example, a method that declares `Pos(s)` as a precondition can\nrely on the stream `s` containing only positive integers. In this section, we\nconsider how such properties are established in the first place.\n\n5.14.3.6.1. Properties of Prefix Predicates\n\nAmong other possible strategies for establishing coinductive properties we take\nthe time-honored approach of reducing coinduction to induction. More precisely,\nDafny passes to the SMT solver an assumption `D(P)` for every greatest predicate\n`P`, where:\n\n`D(P) = forall x • P(x) <==> forall k • P#[k](x)\n`\n\nIn other words, a greatest predicate is true iff its corresponding prefix\npredicate is true for all finite unrollings.\n\nIn Sec. 4 of the paper [Co-induction Simply] a soundness theorem of such\nassumptions is given, provided the greatest predicates meet the continous\nrestrictions. An example proof of `Pos(Up(n))` for every `n > 0` is shown here:\n\n`lemma UpPosLemma(n: int)\n  requires n > 0\n  ensures Pos(Up(n))\n{\n  forall k | 0 <= k { UpPosLemmaK(k, n); }\n}\n\nlemma UpPosLemmaK(k: nat, n: int)\n  requires n > 0\n  ensures Pos#[k](Up(n))\n  decreases k\n{\n  if k != 0 {\n    // this establishes Pos#[k-1](Up(n).tail)\n    UpPosLemmaK(k-1, n+1);\n  }\n}\n`\n\nThe lemma `UpPosLemma` proves `Pos(Up(n))` for every `n > 0`. We first show\n`Pos#[k](Up(n ))`, for `n > 0` and an arbitrary `k`, and then use the forall\nstatement to show `forall k • Pos#[k](Up(n))`. Finally, the axiom `D(Pos)` is\nused (automatically) to establish the greatest predicate.\n\n5.14.3.6.2. Greatest lemmas\n\nAs we just showed, with help of the `D` axiom we can now prove a greatest\npredicate by inductively proving that the corresponding prefix predicate holds\nfor all prefix lengths `k`. In this section, we introduce *greatest lemma*\ndeclarations, which bring about two benefits. The first benefit is that greatest\nlemmas are syntactic sugar and reduce the tedium of having to write explicit\nquantifications over `k`. The second benefit is that, in simple cases, the\nbodies of greatest lemmas can be understood as coinductive proofs directly. As\nan example consider the following greatest lemma.\n\n`greatest lemma UpPosLemma(n: int)\n  requires n > 0\n  ensures Pos(Up(n))\n{\n  UpPosLemma(n+1);\n}\n`\n\nThis greatest lemma can be understood as follows: `UpPosLemma` invokes itself\nco-recursively to obtain the proof for `Pos(Up(n).tail)` (since `Up(n).tail`\nequals `Up(n+1)`). The proof glue needed to then conclude `Pos(Up(n))` is\nprovided automatically, thanks to the power of the SMT-based verifier.\n\n5.14.3.6.3. Prefix Lemmas\n\nTo understand why the above `UpPosLemma` greatest lemma code is a sound proof,\nlet us now describe the details of the desugaring of greatest lemmas. In analogy\nto how a **greatest predicate** declaration defines both a greatest predicate\nand a prefix predicate, a **greatest lemma** declaration defines both a greatest\nlemma and *prefix lemma*. In the call graph, the cluster containing a greatest\nlemma must contain only greatest lemmas and prefix lemmas, no other methods or\nfunction. By decree, a greatest lemma and its corresponding prefix lemma are\nalways placed in the same cluster. Both greatest lemmas and prefix lemmas are\nalways ghost code.\n\nThe prefix lemma is constructed from the greatest lemma by\n\n* adding a parameter `_k` of type `nat` to denote the prefix length,\n* replacing in the greatest lemma’s postcondition the positive continuous\n  occurrences of greatest predicates by corresponding prefix predicates, passing\n  in `_k` as the prefix-length argument,\n* prepending `_k` to the (typically implicit) **decreases** clause of the\n  greatest lemma,\n* replacing in the body of the greatest lemma every intra-cluster call `M(args)`\n  to a greatest lemma by a call `M#[_k - 1](args)` to the corresponding prefix\n  lemma, and then\n* making the body’s execution conditional on `_k != 0`.\n\nNote that this rewriting removes all co-recursive calls of greatest lemmas,\nreplacing them with recursive calls to prefix lemmas. These recursive calls are,\nas usual, checked to be terminating. We allow the pre-declared identifier `_k`\nto appear in the original body of the greatest lemma.^{[8][726]}\n\nWe can now think of the body of the greatest lemma as being replaced by a\n**forall** call, for every *k* , to the prefix lemma. By construction, this new\nbody will establish the greatest lemma’s declared postcondition (on account of\nthe `D` axiom, and remembering that only the positive continuous occurrences of\ngreatest predicates in the greatest lemma’s postcondition are rewritten), so\nthere is no reason for the program verifier to check it.\n\nThe actual desugaring of our greatest lemma `UpPosLemma` is in fact the previous\ncode for the `UpPosLemma` lemma except that `UpPosLemmaK` is named `UpPosLemma#`\nand modulo a minor syntactic difference in how the `k` argument is passed.\n\nIn the recursive call of the prefix lemma, there is a proof obligation that the\nprefixlength argument `_k - 1` is a natural number. Conveniently, this follows\nfrom the fact that the body has been wrapped in an `if _k != 0` statement. This\nalso means that the postcondition must hold trivially when `_k == 0`, or else a\npostcondition violation will be reported. This is an appropriate design for our\ndesugaring, because greatest lemmas are expected to be used to establish\ngreatest predicates, whose corresponding prefix predicates hold trivially when\n`_k = 0`. (To prove other predicates, use an ordinary lemma, not a greatest\nlemma.)\n\nIt is interesting to compare the intuitive understanding of the coinductive\nproof in using a greatest lemma with the inductive proof in using a lemma.\nWhereas the inductive proof is performing proofs for deeper and deeper\nequalities, the greatest lemma can be understood as producing the infinite proof\non demand.\n\n5.14.3.7. Abstemious and voracious functions\n\nSome functions on codatatypes are *abstemious*, meaning that they do not need to\nunfold a datatype instance very far (perhaps just one destructor call) to prove\na relevant property. Knowing this is the case can aid the proofs of properties\nabout the function. The attribute `{:abstemious}` can be applied to a function\ndefinition to indicate this.\n\n*TODO: Say more about the effect of this attribute and when it should be applied\n(and likely, correct the paragraph above).*\n\n## 6. Member declarations\n\nMembers are the various kinds of methods, the various kinds of functions,\nmutable fields, and constant fields. These are usually associated with classes,\nbut they also may be declared (with limitations) in traits, newtypes and\ndatatypes (but not in subset types or type synonyms).\n\n### 6.1. Field Declarations ([grammar][727])\n\nExamples:\n\n`class C {\n  var c: int  // no initialization\n  ghost var 123: bv10  // name may be a sequence of digits\n  var d: nat, e: real  // type is required\n}\n`\n\nA field declaration is not permitted in a value type nor as a member of a module\n(despite there being an implicit unnamed class).\n\nThe field name is either an identifier (that is not allowed to start with a\nleading underscore) or some digits. Digits are used if you want to number your\nfields, e.g. “0”, “1”, etc. The digits do not denote numbers but sequences of\ndigits, so 0, 00, 0_0 are all different.\n\nA field x of some type T is declared as:\n\n`var x: T\n`\n\nA field declaration declares one or more fields of the enclosing class. Each\nfield is a named part of the state of an object of that class. A field\ndeclaration is similar to but distinct from a variable declaration statement.\nUnlike for local variables and bound variables, the type is required and will\nnot be inferred.\n\nUnlike method and function declarations, a field declaration is not permitted as\na member of a module, even though there is an implicit class. Fields can be\ndeclared in either an explicit class or a trait. A class that inherits from\nmultiple traits will have all the fields declared in any of its parent traits.\n\nFields that are declared as `ghost` can only be used in specifications, not in\ncode that will be compiled into executable code.\n\nFields may not be declared static.\n\n### 6.2. Constant Field Declarations ([grammar][728])\n\nExamples:\n\n`const c: int\nghost const d := 5\nclass A {\n  const e: bool\n  static const f: int\n}\n`\n\nA `const` declaration declares a name bound to a value, which value is fixed\nafter initialization.\n\nThe declaration must either have a type or an initializing expression (or both).\nIf the type is omitted, it is inferred from the initializing expression.\n\n* A const declaration may include the `ghost`, `static`, and `opaque` modifiers,\n  but no others.\n* A const declaration may appear within a module or within any declaration that\n  may contain members (class, trait, datatype, newtype).\n* If it is in a module, it is implicitly `static`, and may not also be declared\n  `static`.\n* If the declaration has an initializing expression that is a ghost expression,\n  then the ghost-ness of the declaration is inferred; the `ghost` modifier may\n  be omitted.\n* If the declaration includes the `opaque` modifier, then uses of the declared\n  variable know its name and type but not its value. The value can be made known\n  for reasoning purposes by using the [reveal statement][729].\n* The initialization expression may refer to other constant fields that are in\n  scope and declared either before or after this declaration, but circular\n  references are not allowed.\n\n### 6.3. Method Declarations ([grammar][730])\n\nExamples:\n\n`method m(i: int) requires i > 0 {}\nmethod p() returns (r: int) { r := 0; }\nmethod q() returns (r: int, s: int, t: nat) ensures r < s < t { r := 0; s := 1; \nt := 2; }\nghost method g() {}\nclass A {\n  method f() {}\n  constructor Init() {}\n  static method g<T>(t: T) {}\n}\nlemma L(p: bool) ensures p || !p {}\ntwostate lemma TL(p: bool) ensures p || !p {}\nleast lemma LL[nat](p: bool) ensures p || !p {}\ngreatest lemma GL(p: bool) ensures p || !p {}\nabstract module M { method m(i: int) }\nmodule N refines M { method m ... {} }\n`\n\nMethod declarations include a variety of related types of methods:\n\n* method\n* constructor\n* lemma\n* twostate lemma\n* least lemma\n* greatest lemma\n\nA method signature specifies the method generic parameters, input parameters and\nreturn parameters. The formal parameters are not allowed to have `ghost`\nspecified if `ghost` was already specified for the method. Within the body of a\nmethod, formal (input) parameters are immutable, that is, they may not be\nassigned to, though their array elements or fields may be assigned, if otherwise\npermitted. The out-parameters are mutable and must be assigned in the body of\nthe method.\n\nAn `ellipsis` is used when a method or function is being redeclared in a module\nthat refines another module. (cf. [Section 10][731]) In that case the signature\nis copied from the module that is being refined. This works because Dafny does\nnot support method or function overloading, so the name of the class method\nuniquely identifies it without the signature.\n\nSee [Section 7.2][732] for a description of the method specification.\n\nHere is an example of a method declaration.\n\n`method {:att1}{:att2} M<T1, T2>(a: A, b: B, c: C)\n                                        returns (x: X, y: Y, z: Z)\n  requires Pre\n  modifies Frame\n  ensures Post\n  decreases Rank\n{\n  Body\n}\n`\n\nwhere `:att1` and `:att2` are attributes of the method, `T1` and `T2` are type\nparameters of the method (if generic), `a, b, c` are the method’s in-parameters,\n`x, y, z` are the method’s out-parameters, `Pre` is a boolean expression\ndenoting the method’s precondition, `Frame` denotes a set of objects whose\nfields may be updated by the method, `Post` is a boolean expression denoting the\nmethod’s postcondition, `Rank` is the method’s variant function, and `Body` is a\nlist of statements that implements the method. `Frame` can be a list of\nexpressions, each of which is a set of objects or a single object, the latter\nstanding for the singleton set consisting of that one object. The method’s frame\nis the union of these sets, plus the set of objects allocated by the method\nbody. For example, if `c` and `d` are parameters of a class type `C`, then\n\n`modifies {c, d}\nmodifies {c} + {d}\nmodifies c, {d}\nmodifies c, d\n`\n\nall mean the same thing.\n\nIf the method is an *extreme lemma* ( a `least` or `greatest` lemma), then the\nmethod signature may also state the type of the *k* parameter as either `nat` or\n`ORDINAL`. These are described in [Section 12.5.3][733] and subsequent sections.\n\n#### 6.3.1. Ordinary methods\n\nA method can be declared as ghost by preceding the declaration with the keyword\n`ghost` and as static by preceding the declaration with the keyword `static`.\nThe default is non-static (i.e., instance) for methods declared in a type and\nnon-ghost. An instance method has an implicit receiver parameter, `this`. A\nstatic method M in a class C can be invoked by `C.M(…)`.\n\nAn ordinary method is declared with the `method` keyword; [the section about\nconstructors][734] explains methods that instead use the `constructor` keyword;\n[the section about lemmas][735] discusses methods that are declared with the\n`lemma` keyword. Methods declared with the `least lemma` or `greatest lemma`\nkeyword phrases are discussed later in the context of extreme predicates (see\n[the section about greatest lemmas][736]).\n\nA method without a body is *abstract*. A method is allowed to be abstract under\nthe following circumstances:\n\n* It contains an `{:axiom}` attribute\n* It contains an `{:extern}` attribute (in this case, to be runnable, the method\n  must have a body in non-Dafny compiled code in the target language.)\n* It is a declaration in an abstract module. Note that when there is no body,\n  Dafny assumes that the *ensures* clauses are true without proof.\n\n#### 6.3.2. Constructors\n\nTo write structured object-oriented programs, one often relies on objects being\nconstructed only in certain ways. For this purpose, Dafny provides *constructor\n(method)s*. A constructor is declared with the keyword `constructor` instead of\n`method`; constructors are permitted only in classes. A constructor is allowed\nto be declared as `ghost`, in which case it can only be used in ghost contexts.\n\nA constructor can only be called at the time an object is allocated (see\nobject-creation examples below). Moreover, when a class contains a constructor,\nevery call to `new` for a class must be accompanied by a call to one of its\nconstructors. A class may declare no constructors or one or more constructors.\n\nIn general, a constructor is responsible for initializating the instance fields\nof its class. However, any field that is given an initializer in its declaration\nmay not be reassigned in the body of the constructor.\n\n6.3.2.1. Classes with no explicit constructors\n\nFor a class that declares no constructors, an instance of the class is created\nwith\n\n`c := new C;\n`\n\nThis allocates an object and initializes its fields to values of their\nrespective types (and initializes each `const` field with a RHS to its specified\nvalue). The RHS of a `const` field may depend on other `const` or `var` fields,\nbut circular dependencies are not allowed.\n\nThis simple form of `new` is allowed only if the class declares no constructors,\nwhich is not possible to determine in every scope. It is easy to determine\nwhether or not a class declares any constructors if the class is declared in the\nsame module that performs the `new`. If the class is declared in a different\nmodule and that module exports a constructor, then it is also clear that the\nclass has a constructor (and thus this simple form of `new` cannot be used).\n(Note that an export set that `reveals` a class `C` also exports the anonymous\nconstructor of `C`, if any.) But if the module that declares `C` does not export\nany constructors for `C`, then callers outside the module do not know whether or\nnot `C` has a constructor. Therefore, this simple form of `new` is allowed only\nfor classes that are declared in the same module as the use of `new`.\n\nThe simple `new C` is allowed in ghost contexts. Also, unlike the forms of `new`\nthat call a constructor or initialization method, it can be used in a\nsimultaneous assignment; for example\n\n`c, d, e := new C, new C, 15;\n`\n\nis legal.\n\nAs a shorthand for writing\n\n`c := new C;\nc.Init(args);\n`\n\nwhere `Init` is an initialization method (see the top of [the section about\nclass types][737]), one can write\n\n`c := new C.Init(args);\n`\n\nbut it is more typical in such a case to declare a constructor for the class.\n\n(The syntactic support for initialization methods is provided for historical\nreasons. It may be deprecated in some future version of Dafny. In most cases, a\nconstructor is to be preferred.)\n\n6.3.2.2. Classes with one or more constructors\n\nLike other class members, constructors have names. And like other members, their\nnames must be distinct, even if their signatures are different. Being able to\nname constructors promotes names like `InitFromList` or `InitFromSet` (or just\n`FromList` and `FromSet`). Unlike other members, one constructor is allowed to\nbe *anonymous*; in other words, an *anonymous constructor* is a constructor\nwhose name is essentially the empty string. For example:\n\n`class Item {\n  constructor I(xy: int) // ...\n  constructor (x: int, y: int)\n  // ...\n}\n`\n\nThe named constructor is invoked as\n\n`  i := new Item.I(42);\n`\n\nThe anonymous constructor is invoked as\n\n`  m := new Item(45, 29);\n`\n\ndropping the “`.`”.\n\n6.3.2.3. Two-phase constructors\n\nThe body of a constructor contains two sections, an initialization phase and a\npost-initialization phase, separated by a `new;` statement. If there is no\n`new;` statement, the entire body is the initialization phase. The\ninitialization phase is intended to initialize field variables that were not\ngiven values in their declaration; it may not reassign to fields that do have\ninitializers in their declarations. In this phase, uses of the object reference\n`this` are restricted; a program may use `this`\n\n* as the receiver on the LHS,\n* as the entire RHS of an assignment to a field of `this`,\n* and as a member of a set on the RHS that is being assigned to a field of\n  `this`.\n\nA `const` field with a RHS is not allowed to be assigned anywhere else. A\n`const` field without a RHS may be assigned only in constructors, and more\nprecisely only in the initialization phase of constructors. During this phase, a\n`const` field may be assigned more than once; whatever value the `const` field\nhas at the end of the initialization phase is the value it will have forever\nthereafter.\n\nFor a constructor declared as `ghost`, the initialization phase is allowed to\nassign both ghost and non-ghost fields. For such an object, values of non-ghost\nfields at the end of the initialization phase are in effect no longer\nchangeable.\n\nThere are no restrictions on expressions or statements in the\npost-initialization phase.\n\n#### 6.3.3. Lemmas\n\nSometimes there are steps of logic required to prove a program correct, but they\nare too complex for Dafny to discover and use on its own. When this happens, we\ncan often give Dafny assistance by providing a lemma. This is done by declaring\na method with the `lemma` keyword. Lemmas are implicitly ghost methods and the\n`ghost` keyword cannot be applied to them.\n\nSyntactically, lemmas can be placed where ghost methods can be placed, but they\nserve a significantly different function. First of all, a lemma is forbidden to\nhave `modifies` clause: it may not change anything about even the ghost state;\nghost methods may have `modifies` clauses and may change ghost (but not\nnon-ghost) state. Furthermore, a lemma is not allowed to allocate any new\nobjects. And a lemma may be used in the program text in places where ghost\nmethods may not, such as within expressions (cf. [Section 21.1][738]).\n\nLemmas may, but typically do not, have out-parameters.\n\nIn summary, a lemma states a logical fact, summarizing an inference that the\nverifier cannot do on its own. Explicitly “calling” a lemma in the program text\ntells the verifier to use that fact at that location with the actual arguments\nsubstituted for the formal parameters. The lemma is proved separately for all\ncases of its formal parameters that satisfy the preconditions of the lemma.\n\nFor an example, see the `FibProperty` lemma in [Section 12.5.2][739].\n\nSee [the Dafny Lemmas tutorial][740] for more examples and hints for using\nlemmas.\n\n#### 6.3.4. Two-state lemmas and functions\n\nThe heap is an implicit parameter to every function, though a function is only\nallowed to read those parts of the mutable heap that it admits to in its `reads`\nclause. Sometimes, it is useful for a function to take two heap parameters, for\nexample, so the function can return the difference between the value of a field\nin the two heaps. Such a *two-state function* is declared by `twostate function`\n(or `twostate predicate`, which is the same as a `twostate function` that\nreturns a `bool`). A two-state function is always ghost. It is appropriate to\nthink of these two implicit heap parameters as representing a “current” heap and\nan “old” heap.\n\nFor example, the predicate\n\n`class Cell { var data: int  constructor(i: int) { data := i; } }\ntwostate predicate Increasing(c: Cell)\n  reads c\n{\n  old(c.data) <= c.data\n}\n`\n\nreturns `true` if the value of `c.data` has not been reduced from the old state\nto the current. Dereferences in the current heap are written as usual (e.g.,\n`c.data`) and must, as usual, be accounted for in the function’s `reads` clause.\nDereferences in the old heap are enclosed by `old` (e.g., `old(c.data)`), just\nlike when one dereferences a method’s initial heap. The function is allowed to\nread anything in the old heap; the `reads` clause only declares dependencies on\nlocations in the current heap. Consequently, the frame axiom for a two-state\nfunction is sensitive to any change in the old-heap parameter; in other words,\nthe frame axiom says nothing about two invocations of the two-state function\nwith different old-heap parameters.\n\nAt a call site, the two-state function’s current-heap parameter is always passed\nin as the caller’s current heap. The two-state function’s old-heap parameter is\nby default passed in as the caller’s old heap (that is, the initial heap if the\ncaller is a method and the old heap if the caller is a two-state function).\nWhile there is never a choice in which heap gets passed as the current heap, the\ncaller can use any preceding heap as the argument to the two-state function’s\nold-heap parameter. This is done by labeling a state in the caller and passing\nin the label, just like this is done with the built-in `old` function.\n\nFor example, the following assertions all hold:\n\n`method Caller(c: Cell)\n  modifies c\n{\n  c.data := c.data + 10;\n  label L:\n  assert Increasing(c);\n  c.data := c.data - 2;\n  assert Increasing(c);\n  assert !Increasing@L(c);\n}\n`\n\nThe first call to `Increasing` uses `Caller`’s initial state as the old-heap\nparameter, and so does the second call. The third call instead uses as the\nold-heap parameter the heap at label `L`, which is why the third call returns\n`false`. As shown in the example, an explicitly given old-heap parameter is\ngiven after an `@`-sign (which follows the name of the function and any\nexplicitly given type parameters) and before the open parenthesis (after which\nthe ordinary parameters are given).\n\nA two-state function is allowed to be called only from a two-state context,\nwhich means a method, a two-state lemma (see below), or another two-state\nfunction. Just like a label used with an `old` expression, any label used in a\ncall to a two-state function must denote a program point that *dominates* the\ncall. This means that any control leading to the call must necessarily have\npassed through the labeled program point.\n\nAny parameter (including the receiver parameter, if any) passed to a two-state\nfunction must have been allocated already in the old state. For example, the\nsecond call to `Diff` in method `M` is illegal, since `d` was not allocated on\nentry to `M`:\n\n`twostate function Diff(c: Cell, d: Cell): int\n  reads d\n{\n  d.data - old(c.data)\n}\n\nmethod M(c: Cell) {\n  var d := new Cell(10);\n  label L:\n  ghost var x := Diff@L(c, d);\n  ghost var y := Diff(c, d); // error: d is not allocated in old state\n}\n`\n\nA two-state function may declare that it only assumes a parameter to be\nallocated in the current heap. This is done by preceding the parameter with the\n`new` modifier, as illustrated in the following example, where the first call to\n`DiffAgain` is legal:\n\n`twostate function DiffAgain(c: Cell, new d: Cell): int\n  reads d\n{\n  d.data - old(c.data)\n}\n\nmethod P(c: Cell) {\n  var d := new Cell(10);\n  ghost var x := DiffAgain(c, d);\n  ghost var y := DiffAgain(d, c); // error: d is not allocated in old state\n}\n`\n\nA *two-state lemma* works in an analogous way. It is a lemma with both a\ncurrent-heap parameter and an old-heap parameter, it can use `old` expressions\nin its specification (including in the precondition) and body, its parameters\nmay use the `new` modifier, and the old-heap parameter is by default passed in\nas the caller’s old heap, which can be changed by using an `@`-parameter.\n\nHere is an example of something useful that can be done with a two-state lemma:\n\n`function SeqSum(s: seq<Cell>): int\n  reads s\n{\n  if s == [] then 0 else s[0].data + SeqSum(s[1..])\n}\n\ntwostate lemma IncSumDiff(s: seq<Cell>)\n  requires forall c :: c in s ==> Increasing(c)\n  ensures old(SeqSum(s)) <= SeqSum(s)\n{\n  if s == [] {\n  } else {\n    calc {\n      old(SeqSum(s));\n    ==  // def. SeqSum\n      old(s[0].data + SeqSum(s[1..]));\n    ==  // distribute old\n      old(s[0].data) + old(SeqSum(s[1..]));\n    <=  { assert Increasing(s[0]); }\n      s[0].data + old(SeqSum(s[1..]));\n    <=  { IncSumDiff(s[1..]); }\n      s[0].data + SeqSum(s[1..]);\n    ==  // def. SeqSum\n      SeqSum(s);\n    }\n  }\n}\n`\n\nA two-state function can be used as a first-class function value, where the\nreceiver (if any), type parameters (if any), and old-heap parameter are\ndetermined at the time the first-class value is mentioned. While the receiver\nand type parameters can be explicitly instantiated in such a use (for example,\n`p.F<int>` for a two-state instance function `F` that takes one type parameter),\nthere is currently no syntactic support for giving the old-heap parameter\nexplicitly. A caller can work around this restriction by using (fancy-word\nalert!) eta-expansion, meaning wrapping a lambda expression around the call, as\nin `x => p.F<int>@L(x)`. The following example illustrates using such an\neta-expansion:\n\n`class P {\n  twostate function F<X>(x: X): X\n}\n\nmethod EtaExample(p: P) returns (ghost f: int -> int) {\n  label L:\n  f := x => p.F<int>@L(x);\n}\n`\n\n### 6.4. Function Declarations ([grammar][741])\n\n#### 6.4.1. Functions\n\nExamples:\n\n`function f(i: int): real { i as real }\nfunction g(): (int, int) { (2,3) }\nfunction h(i: int, k: int): int requires i >= 0 { if i == 0 then 0 else 1 }\n`\n\nFunctions may be declared as ghost. If so, all the formal parameters and return\nvalues are ghost; if it is not a ghost function, then individual parameters may\nbe declared ghost as desired.\n\nSee [Section 7.3][742] for a description of the function specification. A Dafny\nfunction is a pure mathematical function. It is allowed to read memory that was\nspecified in its `reads` expression but is not allowed to have any side effects.\n\nHere is an example function declaration:\n\n`function {:att1}{:att2} F<T1, T2>(a: A, b: B, c: C): T\n  requires Pre\n  reads Frame\n  ensures Post\n  decreases Rank\n{\n  Body\n}\n`\n\nwhere `:att1` and `:att2` are attributes of the function, if any, `T1` and `T2`\nare type parameters of the function (if generic), `a, b, c` are the function’s\nparameters, `T` is the type of the function’s result, `Pre` is a boolean\nexpression denoting the function’s precondition, `Frame` denotes a set of\nobjects whose fields the function body may depend on, `Post` is a boolean\nexpression denoting the function’s postcondition, `Rank` is the function’s\nvariant function, and `Body` is an expression that defines the function’s return\nvalue. The precondition allows a function to be partial, that is, the\nprecondition says when the function is defined (and Dafny will verify that every\nuse of the function meets the precondition).\n\nThe postcondition is usually not needed, since the body of the function gives\nthe full definition. However, the postcondition can be a convenient place to\ndeclare properties of the function that may require an inductive proof to\nestablish, such as when the function is recursive. For example:\n\n`function Factorial(n: int): int\n  requires 0 <= n\n  ensures 1 <= Factorial(n)\n{\n  if n == 0 then 1 else Factorial(n-1) * n\n}\n`\n\nsays that the result of Factorial is always positive, which Dafny verifies\ninductively from the function body.\n\nWithin a postcondition, the result of the function is designated by a call of\nthe function, such as `Factorial(n)` in the example above. Alternatively, a name\nfor the function result can be given in the signature, as in the following\nrewrite of the example above.\n\n`function Factorial(n: int): (f: int)\n  requires 0 <= n\n  ensures 1 <= f\n{\n  if n == 0 then 1 else Factorial(n-1) * n\n}\n`\n\nPre v4.0, a function is `ghost` by default, and cannot be called from non-ghost\ncode. To make it non-ghost, replace the keyword `function` with the two keywords\n“`function method`”. From v4.0 on, a function is non-ghost by default. To make\nit ghost, replace the keyword `function` with the two keywords “`ghost\nfunction`”. (See the [–function-syntax option][743] for a description of the\nmigration path for this change in behavior.}\n\nLike methods, functions can be either *instance* (which they are by default when\ndeclared within a type) or *static* (when the function declaration contains the\nkeyword `static` or is declared in a module). An instance function, but not a\nstatic function, has an implicit receiver parameter, `this`. A static function\n`F` in a class `C` can be invoked by `C.F(…)`. This provides a convenient way to\ndeclare a number of helper functions in a separate class.\n\nAs for methods, a `...` is used when declaring a function in a module refinement\n(cf. [Section 10][744]). For example, if module `M0` declares function `F`, a\nmodule `M1` can be declared to refine `M0` and `M1` can then refine `F`. The\nrefinement function, `M1.F` can have a `...` which means to copy the signature\nfrom `M0.F`. A refinement function can furnish a body for a function (if `M0.F`\ndoes not provide one). It can also add `ensures` clauses.\n\nIf a function definition does not have a body, the program that contains it may\nstill be verified. The function itself has nothing to verify. However, any calls\nof a body-less function are treated as unverified assumptions by the caller,\nasserting the preconditions and assuming the postconditions. Because body-less\nfunctions are unverified assumptions, Dafny will not compile them and will\ncomplain if called by [`dafny translate`, `dafny build` or even `dafny\nrun`][745]\n\n#### 6.4.2. Predicates\n\nA function that returns a `bool` result is called a *predicate*. As an\nalternative syntax, a predicate can be declared by replacing the `function`\nkeyword with the `predicate` keyword and possibly omitting a declaration of the\nreturn type (if it is not named).\n\n#### 6.4.3. Function-by-method\n\nA function with a `by method` clause declares a *function-by-method*. A\nfunction-by-method gives a way to implement a (deterministic, side-effect free)\nfunction by a method (whose body may be nondeterministic and may allocate\nobjects that it modifies). This can be useful if the best implementation uses\nnondeterminism (for example, because it uses `:|` in a nondeterministic way) in\na way that does not affect the result, or if the implementation temporarily\nmakes use of some mutable data structures, or if the implementation is done with\na loop. For example, here is the standard definition of the Fibonacci function\nbut with an efficient implementation that uses a loop:\n\n`function Fib(n: nat): nat {\n  if n < 2 then n else Fib(n - 2) + Fib(n - 1)\n} by method {\n  var x, y := 0, 1;\n  for i := 0 to n\n    invariant x == Fib(i) && y == Fib(i + 1)\n  {\n    x, y := y, x + y;\n  }\n  return x;\n}\n`\n\nThe `by method` clause is allowed only for non-ghost `function` or `predicate`\ndeclarations (without `twostate`, `least`, and `greatest`, but possibly with\n`static`); it inherits the in-parameters, attributes, and `requires` and\n`decreases` clauses of the function. The method also gets one out-parameter,\ncorresponding to the function’s result value (and the name of it, if present).\nFinally, the method gets an empty `modifies` clause and a postcondition `ensures\nr == F(args)`, where `r` is the name of the out-parameter and `F(args)` is the\nfunction with its arguments. In other words, the method body must compute and\nreturn exactly what the function says, and must do so without modifying any\npreviously existing heap state.\n\nThe function body of a function-by-method is allowed to be ghost, but the method\nbody must be compilable. In non-ghost contexts, the compiler turns a call of the\nfunction-by-method into a call that leads to the method body.\n\nNote, the method body of a function-by-method may contain `print` statements.\nThis means that the run-time evaluation of an expression may have print effects.\nIf `--track-print-effects` is enabled, this use of print in a function context\nwill be disallowed.\n\n#### 6.4.4. Function Hiding\n\nA function is said to be *revealed* at a location if the body of the function is\nvisible for verification at that point, otherwise it is considered *hidden*.\n\nFunctions are revealed by default, but can be hidden using the `hide` statement,\nwhich takes either a specific function or a wildcard, to hide all functions.\nHiding a function can speed up verification of a proof if the body of that\nfunction is not needed for the proof. See the [hide statement][746] for more\ninformation.\n\nAlthough mostly made obsolete by the hide statement, a function can also be\nhidden using the `opaque` keyword, or using the option\n`default-function-opacity`. Here are the rules regarding those:\n\nInside the module where the function is declared:\n\n* If `--default-function-opacity` is set to `transparent` (default), then:\n  \n  * if there is no `opaque` modifier, the function is transparent.\n  * if there is an `opaque` modifier, then the function is opaque. If the\n    function is mentioned in a `reveal` statement, then its body is available\n    starting at that `reveal` statement.\n* If `--default-function-opacity` is set to `opaque`, then:\n  \n  * if there is no [`{:transparent}` attribute][747], the function is opaque. If\n    the function is mentioned in a `reveal` statement, then the body of the\n    function is available starting at that `reveal` statement.\n  * if there is a [`{:transparent}` attribute][748], then the function is\n    transparent.\n* If `--default-function-opacity` is set to `autoRevealDependencies`, then:\n  \n  * if there is no [`{:transparent}` attribute][749], the function is opaque.\n    However, the body of the function is available inside any callable that\n    depends on this function via an implicitly inserted `reveal` statement,\n    unless the callable has the [`{autoRevealDependencies k}` attribute][750]\n    for some natural number `k` which is too low.\n  * if there is a [`{:transparent}` attribute][751], then the function is\n    transparent.\n\nOutside the module where the function is declared, the function is visible only\nif it was listed in the export set by which the contents of its module was\nimported. In that case, if the function was exported with `reveals`, the rules\nare the same within the importing module as when the function is used inside its\ndeclaring module. If the function is exported only with `provides` it is always\nhidden and is not permitted to be used in a reveal statement.\n\nMore information about the Boogie implementation of opaquenes is [here][752].\n\n#### 6.4.5. Extreme (Least or Greatest) Predicates and Lemmas\n\nSee [Section 12.5.3][753] for descriptions of extreme predicates and lemmas.\n\n#### 6.4.6. `older` parameters in predicates\n\nA parameter of any predicate (more precisely, of any boolean-returning,\nnon-extreme function) can be marked as `older`. This specifies that the truth of\nthe predicate implies that the allocatedness of the parameter follows from the\nallocatedness of the non-`older` parameters.\n\nTo understand what this means and why this attribute is useful, consider the\nfollowing example, which specifies reachability between nodes in a directed\ngraph. A `Node` is declared to have any number of children:\n\n`class Node {\n  var children: seq<Node>\n}\n`\n\nThere are several ways one could specify reachability between nodes. One way\n(which is used in `Test/dafny1/SchorrWaite.dfy` in the Dafny test suite) is to\ndefine a type `Path`, representing lists of `Node`s, and to define a predicate\nthat checks if a given list of `Node`s is indeed a path between two given nodes:\n\n`datatype Path = Empty | Extend(Path, Node)\n\npredicate ReachableVia(source: Node, p: Path, sink: Node, S: set<Node>)\n  reads S\n  decreases p\n{\n  match p\n  case Empty =>\n    source == sink\n  case Extend(prefix, n) =>\n    n in S && sink in n.children && ReachableVia(source, prefix, n, S)\n}\n`\n\nIn a nutshell, the definition of `ReachableVia` says\n\n* An empty path lets `source` reach `sink` just when `source` and `sink` are the\n  same node.\n* A path `Extend(prefix, n)` lets `source` reach `sink` just when the path\n  `prefix` lets `source` reach `n` and `sink` is one of the children nodes of\n  `n`.\n\nTo be admissible by Dafny, the recursive predicate must be shown to terminate.\nTermination is assured by the specification `decreases p`, since every such\ndatatype value has a finite structure and every recursive call passes in a path\nthat is structurally included in the previous. Predicate `ReachableVia` must\nalso declare (an upper bound on) which heap objects it depends on. For this\npurpose, the predicate takes an additional parameter `S`, which is used to limit\nthe set of intermediate nodes in the path. More precisely, predicate\n`ReachableVia(source, p, sink, S)` returns `true` if and only if `p` is a list\nof nodes in `S` and `source` can reach `sink` via `p`.\n\nUsing predicate `ReachableVia`, we can now define reachability in `S`:\n\n`predicate Reachable(source: Node, sink: Node, S: set<Node>)\n  reads S\n{\n  exists p :: ReachableVia(source, p, sink, S)\n}\n`\n\nThis looks like a good definition of reachability, but Dafny won’t admit it. The\nreason is twofold:\n\n* Quantifiers and comprehensions are allowed to range only over allocated state.\n  Ater all, Dafny is a type-safe language where every object reference is\n  *valid* (that is, a pointer to allocated storage of the right type)—it should\n  not be possible, not even through a bound variable in a quantifier or\n  comprehension, for a program to obtain an object reference that isn’t valid.\n* This property is ensured by disallowing *open-ended* quantifiers. More\n  precisely, the object references that a quantifier may range over must be\n  shown to be confined to object references that were allocated before some of\n  the non-`older` parameters passed to the predicate. Quantifiers that are not\n  open-ended are called *close-ended*. Note that close-ended refers only to the\n  object references that the quantification or comprehension ranges over—it does\n  not say anything about values of other types, like integers.\n\nOften, it is easy to show that a quantifier is close-ended. In fact, if the type\nof a bound variable does not contain any object references, then the quantifier\nis trivially close-ended. For example,\n\n`forall x: int :: x <= Square(x)\n`\n\nis trivially close-ended.\n\nAnother innocent-looking quantifier occurs in the following example:\n\n`predicate IsCommutative<X>(r: (X, X) -> bool)\n{\n  forall x, y :: r(x, y) == r(y, x) // error: open-ended quantifier\n}\n`\n\nSince nothing is known about type `X`, this quantifier might be open-ended. For\nexample, if `X` were passed in as a class type, then the quantifier would be\nopen-ended. One way to fix this predicate is to restrict it to non-heap based\ntypes, which is indicated with the `(!new)` type characteristic (see [Section\n5.3.1.4][754]):\n\n`ghost predicate IsCommutative<X(!new)>(r: (X, X) -> bool) // X is restricted to\n non-heap types\n{\n  forall x, y :: r(x, y) == r(y, x) // allowed\n}\n`\n\nAnother way to make `IsCommutative` close-ended is to constrain the values of\nthe bound variables `x` and `y`. This can be done by adding a parameter to the\npredicate and limiting the quantified values to ones in the given set:\n\n`predicate IsCommutativeInS<X>(r: (X, X) -> bool, S: set<X>)\n{\n  forall x, y :: x in S && y in S ==> r(x, y) == r(y, x) // close-ended\n}\n`\n\nThrough a simple syntactic analysis, Dafny detects the antecedents `x in S` and\n`y in S`, and since `S` is a parameter and thus can only be passed in as\nsomething that the caller has already allocated, the quantifier in\n`IsCommutativeInS` is determined to be close-ended.\n\nNote, the `x in S` trick does not work for the motivating example, `Reachable`.\nIf you try to write\n\n`predicate Reachable(source: Node, sink: Node, S: set<Node>)\n  reads S\n{\n  exists p :: p in S && ReachableVia(source, p, sink, S) // type error: p\n}\n`\n\nyou will get a type error, because `p in S` does not make sense if `p` has type\n`Path`. We need some other way to justify that the quantification in `Reachable`\nis close-ended.\n\nDafny offers a way to extend the `x in S` trick to more situations. This is\nwhere the `older` modifier comes in. Before we apply `older` in the `Reachable`\nexample, let’s first look at what `older` does in a less cluttered example.\n\nSuppose we rewrite `IsCommutativeInS` using a programmer-defined predicate `In`:\n\n`predicate In<X>(x: X, S: set<X>) {\n  x in S\n}\n\npredicate IsCommutativeInS<X>(r: (X, X) -> bool, S: set<X>)\n{\n  forall x, y :: In(x, S) && In(y, S) ==> r(x, y) == r(y, x) // error: open-ende\nd?\n}\n`\n\nThe simple syntactic analysis that looks for `x in S` finds nothing here,\nbecause the `in` operator is relegated to the body of predicate `In`. To inform\nthe analysis that `In` is a predicate that, in effect, is like `in`, you can\nmark parameter `x` with `older`:\n\n`predicate In<X>(older x: X, S: set<X>) {\n  x in S\n}\n`\n\nThis causes the simple syntactic analysis to accept the quantifier in\n`IsCommutativeInS`. Adding `older` also imposes a semantic check on the body of\npredicate `In`, enforced by the verifier. The semantic check is that all the\nobject references in the value `x` are older (or equally old as) the object\nreferences that are part of the other parameters, *in the event that the\npredicate returns true*. That is, `older` is designed to help the caller only if\nthe predicate returns `true`, and the semantic check amounts to nothing if the\npredicate returns `false`.\n\nFinally, let’s get back to the motivating example. To allow the quantifier in\n`Reachable`, mark parameter `p` of `ReachableVia` with `older`:\n\n`class Node {\n  var children: seq<Node>\n}\n\ndatatype Path = Empty | Extend(Path, Node)\n\nghost predicate Reachable(source: Node, sink: Node, S: set<Node>)\n  reads S\n{\n  exists p :: ReachableVia(source, p, sink, S) // allowed because of 'older p' o\nn ReachableVia\n}\n\nghost predicate ReachableVia(source: Node, older p: Path, sink: Node, S: set<Nod\ne>)\n  reads S\n  decreases p\n{\n  match p\n  case Empty =>\n    source == sink\n  case Extend(prefix, n) =>\n    n in S && sink in n.children && ReachableVia(source, prefix, n, S)\n}\n`\n\nThis example is more involved than the simpler `In` example above. Because of\nthe `older` modifier on the parameter, the quantifier in `Reachable` is allowed.\nFor intuition, you can think of the effect of `older p` as adding an antecedent\n`p in {source} + {sink} + S` (but, as we have seen, this is not type correct).\nThe semantic check imposed on the body of `ReachableVia` makes sure that, if the\npredicate returns `true`, then every object reference in `p` is as old as some\nobject reference in another parameter to the predicate.\n\n### 6.5. Nameonly Formal Parameters and Default-Value Expressions\n\nA formal parameter of a method, constructor in a class, iterator, function, or\ndatatype constructor can be declared with an expression denoting a *default\nvalue*. This makes the parameter *optional*, as opposed to *required*.\n\nFor example,\n\n`function f(x: int, y: int := 10): int\n`\n\nmay be called as either\n\n`const i := f(1, 2)\nconst j := f(1)\n`\n\nwhere `f(1)` is equivalent to `f(1, 10)` in this case.\n\nThe above function may also be called as\n\n`var k := f(y := 10, x := 2);\n`\n\nusing names; actual arguments with names may be given in any order, though they\nmust be after actual arguments without names.\n\nFormal parameters may also be declared `nameonly`, in which case a call site\nmust always explicitly name the formal when providing its actual argument.\n\nFor example, a function `ff` declared as\n\n`function ff(x: int, nameonly y: int): int\n`\n\nmust be called either by listing the value for x and then y with a name, as in\n`ff(0, y := 4)` or by giving both actuals by name (in any order). A `nameonly`\nformal may also have a default value and thus be optional.\n\nAny formals after a `nameonly` formal must either be `nameonly` themselves or\nhave default values.\n\nThe formals of datatype constructors are not required to have names. A nameless\nformal may not have a default value, nor may it follow a formal that has a\ndefault value.\n\nThe default-value expression for a parameter is allowed to mention the other\nparameters, including `this` (for instance methods and instance functions), but\nnot the implicit `_k` parameter in least and greatest predicates and lemmas. The\ndefault value of a parameter may mention both preceding and subsequent\nparameters, but there may not be any dependent cycle between the parameters and\ntheir default-value expressions.\n\nThe [well-formedness][755] of default-value expressions is checked independent\nof the precondition of the enclosing declaration. For a function, the parameter\ndefault-value expressions may only read what the function’s `reads` clause\nallows. For a datatype constructor, parameter default-value expressions may not\nread anything. A default-value expression may not be involved in any recursive\nor mutually recursive calls with the enclosing declaration.\n\n## 7. Specifications\n\nSpecifications describe logical properties of Dafny methods, functions, lambdas,\niterators and loops. They specify preconditions, postconditions, invariants,\nwhat memory locations may be read or modified, and termination information by\nmeans of *specification clauses*. For each kind of specification, zero or more\nspecification clauses (of the type accepted for that type of specification) may\nbe given, in any order.\n\nWe document specifications at these levels:\n\n* At the lowest level are the various kinds of specification clauses, e.g., a\n  `RequiresClause`.\n* Next are the specifications for entities that need them, e.g., a `MethodSpec`,\n  which typically consist of a sequence of specification clauses.\n* At the top level are the entity declarations that include the specifications,\n  e.g., `MethodDecl`.\n\nThis section documents the first two of these in a bottom-up manner. We first\ndocument the clauses and then the specifications that use them.\n\nSpecification clauses typically appear in a sequence. They all begin with a\nkeyword and do not end with semicolons.\n\n### 7.1. Specification Clauses\n\nWithin expressions in specification clauses, you can use [specification\nexpressions][756] along with any [other expressions][757] you need.\n\n#### 7.1.1. Requires Clause ([grammar][758])\n\nExamples:\n\n`method m(i: int)\n  requires true\n  requires i > 0\n  requires L: 0 < i < 10\n`\n\nThe `requires` clauses specify preconditions for methods, functions, lambda\nexpressions and iterators. Dafny checks that the preconditions are met at all\ncall sites. The callee may then assume the preconditions hold on entry.\n\nIf no `requires` clause is specified, then a default implicit clause `requires\ntrue` is used.\n\nIf more than one `requires` clause is given, then the precondition is the\nconjunction of all of the expressions from all of the `requires` clauses, with a\ncollected list of all the given Attributes. The order of conjunctions (and hence\nthe order of `requires` clauses with respect to each other) can be important:\nearlier conjuncts can set conditions that establish that later conjuncts are\nwell-defined.\n\nThe attributes recognized for requires clauses are discussed in [Section\n11.4][759].\n\nA requires clause can have [custom error and success messages][760].\n\n#### 7.1.2. Ensures Clause ([grammar][761])\n\nExamples:\n\n`method {:axiom} m(i: int) returns (r: int)\n  ensures r > 0\n`\n\nAn `ensures` clause specifies the post condition for a method, function or\niterator.\n\nIf no `ensures` clause is specified, then a default implicit clause `ensures\ntrue` is used.\n\nIf more than one `ensures` clause is given, then the postcondition is the\nconjunction of all of the expressions from all of the `ensures` clauses, with a\ncollected list of all the given Attributes. The order of conjunctions (and hence\nthe order of `ensures` clauses with respect to each other) can be important:\nearlier conjuncts can set conditions that establish that later conjuncts are\nwell-defined.\n\nThe attributes recognized for ensures clauses are discussed in [Section\n11.4][762].\n\nAn ensures clause can have [custom error and success messages][763].\n\n#### 7.1.3. Decreases Clause ([grammar][764])\n\nExamples:\n\n`method m(i: int, j: int) returns (r: int)\n  decreases i, j\nmethod n(i: int) returns (r: int)\n  decreases *\n`\n\nDecreases clauses are used to prove termination in the presence of recursion. If\nmore than one `decreases` clause is given it is as if a single `decreases`\nclause had been given with the collected list of arguments and a collected list\nof Attributes. That is,\n\n`decreases A, B\ndecreases C, D\n`\n\nis equivalent to\n\n`decreases A, B, C, D\n`\n\nNote that changing the order of multiple `decreases` clauses will change the\norder of the expressions within the equivalent single `decreases` clause, and\nwill therefore have different semantics.\n\nLoops and compiled methods (but not functions and not ghost methods, including\nlemmas) can be specified to be possibly non-terminating. This is done by\ndeclaring the method or loop with `decreases *`, which causes the proof of\ntermination to be skipped. If a `*` is present in a `decreases` clause, no other\nexpressions are allowed in the `decreases` clause. A method that contains a\npossibly non-terminating loop or a call to a possibly non-terminating method\nmust itself be declared as possibly non-terminating.\n\nTermination metrics in Dafny, which are declared by `decreases` clauses, are\nlexicographic tuples of expressions. At each recursive (or mutually recursive)\ncall to a function or method, Dafny checks that the effective `decreases` clause\nof the callee is strictly smaller than the effective `decreases` clause of the\ncaller.\n\nWhat does “strictly smaller” mean? Dafny provides a built-in well-founded order\nfor every type and, in some cases, between types. For example, the Boolean\n`false` is strictly smaller than `true`, the integer `78` is strictly smaller\nthan `102`, the set `{2,5}` is strictly smaller than (because it is a proper\nsubset of) the set `{2,3,5}`, and for `s` of type `seq<Color>` where `Color` is\nsome inductive datatype, the color `s[0]` is strictly less than `s` (provided\n`s` is nonempty).\n\nWhat does “effective decreases clause” mean? Dafny always appends a “top”\nelement to the lexicographic tuple given by the user. This top element cannot be\nsyntactically denoted in a Dafny program and it never occurs as a run-time value\neither. Rather, it is a fictitious value, which here we will denote $\\top$, such\nthat each value that can ever occur in a Dafny program is strictly less than\n$\\top$. Dafny sometimes also prepends expressions to the lexicographic tuple\ngiven by the user. The effective decreases clause is any such prefix, followed\nby the user-provided decreases clause, followed by $\\top$. We said\n“user-provided decreases clause”, but if the user completely omits a `decreases`\nclause, then Dafny will usually make a guess at one, in which case the effective\ndecreases clause is any prefix followed by the guess followed by $\\top$.\n\nHere is a simple but interesting example: the Fibonacci function.\n\n`function Fib(n: nat) : nat\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n`\n\nIn this example, Dafny supplies a `decreases n` clause.\n\nLet’s take a look at the kind of example where a mysterious-looking decreases\nclause like “Rank, 0” is useful.\n\nConsider two mutually recursive methods, `A` and `B`:\n\n`method A(x: nat)\n{\n  B(x);\n}\n\nmethod B(x: nat)\n{\n  if x != 0 { A(x-1); }\n}\n`\n\nTo prove termination of `A` and `B`, Dafny needs to have effective decreases\nclauses for A and B such that:\n\n* the measure for the callee `B(x)` is strictly smaller than the measure for the\n  caller `A(x)`, and\n* the measure for the callee `A(x-1)` is strictly smaller than the measure for\n  the caller `B(x)`.\n\nSatisfying the second of these conditions is easy, but what about the first?\nNote, for example, that declaring both `A` and `B` with “decreases x” does not\nwork, because that won’t prove a strict decrease for the call from `A(x)` to\n`B(x)`.\n\nHere’s one possibility:\n\n`method A(x: nat)\n  decreases x, 1\n{\n  B(x);\n}\n\nmethod B(x: nat)\n  decreases x, 0\n{\n  if x != 0 { A(x-1); }\n}\n`\n\nFor the call from `A(x)` to `B(x)`, the lexicographic tuple `\"x, 0\"` is strictly\nsmaller than `\"x, 1\"`, and for the call from `B(x)` to `A(x-1)`, the\nlexicographic tuple `\"x-1, 1\"` is strictly smaller than `\"x, 0\"`.\n\nTwo things to note: First, the choice of “0” and “1” as the second components of\nthese lexicographic tuples is rather arbitrary. It could just as well have been\n“false” and “true”, respectively, or the sets `{2,5}` and `{2,3,5}`. Second, the\nkeyword `decreases` often gives rise to an intuitive English reading of the\ndeclaration. For example, you might say that the recursive calls in the\ndefinition of the familiar Fibonacci function `Fib(n)` “decreases n”. But when\nthe lexicographic tuple contains constants, the English reading of the\ndeclaration becomes mysterious and may give rise to questions like “how can you\ndecrease the constant 0?”. The keyword is just that—a keyword. It says “here\ncomes a list of expressions that make up the lexicographic tuple we want to use\nfor the termination measure”. What is important is that one effective decreases\nclause is compared against another one, and it certainly makes sense to compare\nsomething to a constant (and to compare one constant to another).\n\nWe can simplify things a little bit by remembering that Dafny appends $\\top$ to\nthe user-supplied decreases clause. For the A-and-B example, this lets us drop\nthe constant from the `decreases` clause of A:\n\n`method A(x: nat)\n   decreases x\n{\n  B(x);\n}\n\nmethod B(x: nat)\n  decreases x, 0\n{\n  if x != 0 { A(x-1); }\n}\n`\n\nThe effective decreases clause of `A` is $(x, \\top)$ and the effective decreases\nclause of `B` is $(x, 0, \\top)$. These tuples still satisfy the two conditions\n$(x, 0, \\top) < (x, \\top)$ and $(x-1, \\top) < (x, 0, \\top)$. And as before, the\nconstant “0” is arbitrary; anything less than $\\top$ (which is any Dafny\nexpression) would work.\n\nLet’s take a look at one more example that better illustrates the utility of\n$\\top$. Consider again two mutually recursive methods, call them `Outer` and\n`Inner`, representing the recursive counterparts of what iteratively might be\ntwo nested loops:\n\n`method Outer(x: nat)\n{\n  // set y to an arbitrary non-negative integer\n  var y :| 0 <= y;\n  Inner(x, y);\n}\n\nmethod Inner(x: nat, y: nat)\n{\n  if y != 0 {\n    Inner(x, y-1);\n  } else if x != 0 {\n    Outer(x-1);\n  }\n}\n`\n\nThe body of `Outer` uses an assign-such-that statement to represent some\ncomputation that takes place before `Inner` is called. It sets “y” to some\narbitrary non-negative value. In a more concrete example, `Inner` would do some\nwork for each “y” and then continue as `Outer` on the next smaller “x”.\n\nUsing a `decreases` clause $(x, y)$ for `Inner` seems natural, but if we don’t\nhave any bound on the size of the $y$ computed by `Outer`, there is no\nexpression we can write in the `decreases` clause of `Outer` that is sure to\nlead to a strictly smaller value for $y$ when `Inner` is called. $\\top$ to the\nrescue. If we arrange for the effective decreases clause of `Outer` to be $(x,\n\\top)$ and the effective decreases clause for `Inner` to be $(x, y, \\top)$, then\nwe can show the strict decreases as required. Since $\\top$ is implicitly\nappended, the two decreases clauses declared in the program text can be:\n\n`method Outer(x: nat)\n  decreases x\n{\n  // set y to an arbitrary non-negative integer\n  var y :| 0 <= y;\n  Inner(x, y);\n}\n\nmethod Inner(x: nat, y: nat)\n  decreases x,y\n{\n  if y != 0 {\n    Inner(x, y-1);\n  } else if x != 0 {\n    Outer(x-1);\n  }\n}\n`\n\nMoreover, remember that if a function or method has no user-declared `decreases`\nclause, Dafny will make a guess. The guess is (usually) the list of arguments of\nthe function/method, in the order given. This is exactly the decreases clauses\nneeded here. Thus, Dafny successfully verifies the program without any explicit\n`decreases` clauses:\n\n`method Outer(x: nat)\n{\n  var y :| 0 <= y;\n  Inner(x, y);\n}\n\nmethod Inner(x: nat, y: nat)\n{\n  if y != 0 {\n    Inner(x, y-1);\n  } else if x != 0 {\n    Outer(x-1);\n  }\n}\n`\n\nThe ingredients are simple, but the end result may seem like magic. For many\nusers, however, there may be no magic at all – the end result may be so natural\nthat the user never even has to be bothered to think about that there was a need\nto prove termination in the first place.\n\nDafny also prepends two expressions to the user-specified (or guessed) tuple of\nexpressions in the decreases clause. The first expression is the ordering of the\nmodule containing the decreases clause in the dependence-ordering of modules.\nThat is, a module that neither imports or defines (as submodules) any other\nmodules has the lowest value in the order and every other module has a value\nthat is higher than that of any module it defines or imports. As a module cannot\ncall a method in a module that it does not depend on, this is an effective first\ncomponent to the overall decreases tuple.\n\nThe second prepended expression represents the position of the method in the\ncall graph within a module. Dafny analyzes the call-graph of the module,\ngrouping all methods into mutually-recursive groups. Any method that calls\nnothing else is at the lowest level (say level 0). Absent recursion, every\nmethod has a level value strictly greater than any method it calls. Methods that\nare mutually recursive are at the same level and they are above the level of\nanything else they call. With this level value prepended to the decreases\nclause, the decreases tuple automatically decreases on any calls in a\nnon-recursive context.\n\nThough Dafny fixes a well-founded order that it uses when checking termination,\nDafny does not normally surface this ordering directly in expressions. However,\nit is possible to write such ordering constraints using [`decreases to`\nexpressions][765].\n\n#### 7.1.4. Framing ([grammar][766])\n\nExamples:\n\n`*\no\no`a\n`a\n{ o, p, q }\n{}\n`\n\nFrame expressions are used to denote the set of memory locations that a Dafny\nprogram element may read or write. They are used in `reads` and `modifies`\nclauses. A frame expression is a set expression. The form `{}` is the empty set.\nThe type of the frame expression is `set<object>`.\n\nNote that framing only applies to the heap, or memory accessed through\nreferences. Local variables are not stored on the heap, so they cannot be\nmentioned (well, they are not in scope in the declaration) in frame annotations.\nNote also that types like sets, sequences, and multisets are value types, and\nare treated like integers or local variables. Arrays and objects are reference\ntypes, and they are stored on the heap (though as always there is a subtle\ndistinction between the reference itself and the value it points to.)\n\nThe `FrameField` construct is used to specify a field of a class object. The\nidentifier following the back-quote is the name of the field being referenced.\nIf the `FrameField` is preceded by an expression the expression must be a\nreference to an object having that field. If the `FrameField` is not preceded by\nan expression then the frame expression is referring to that field of the\ncurrent object (`this`). This form is only used within a method of a class or\ntrait.\n\nA `FrameField` can be useful in the following case: When a method modifies only\none field, rather than writing\n\n`class A {\n  var i: int\n  var x0: int\n  var x1: int\n  var x2: int\n  var x3: int\n  var x4: int\n  method M()\n    modifies this\n    ensures unchanged(`x0) && unchanged(`x1) && unchanged(`x2) && unchanged(`x3)\n && unchanged(`x4)\n  { i := i + 1; }\n}\n`\n\none can write the more concise:\n\n`class A {\n  var i: int\n  var x0: int\n  var x1: int\n  var x2: int\n  var x3: int\n  var x4: int\n  method M()\n    modifies `i\n  { i := i + 1; }\n}\n`\n\nThere’s (unfortunately) no form of it for array elements – but to account for\nunchanged elements, you can always write `forall i | 0 <= i < |a| ::\nunchanged(a[i])`.\n\nA `FrameField` is not taken into consideration for lambda expressions.\n\n#### 7.1.5. Reads Clause ([grammar][767])\n\nExamples:\n\n`const o: object\nconst o, oo: object\nfunction f()\n  reads *\nfunction g()\n  reads o, oo\nfunction h()\n  reads { o }\nmethod f()\n  reads *\nmethod g()\n  reads o, oo\nmethod h()\n  reads { o }\n`\n\nFunctions are not allowed to have side effects; they may also be restricted in\nwhat they can read. The *reading frame* of a function (or predicate) consists of\nall the heap memory locations that the function is allowed to read. The reason\nwe might limit what a function can read is so that when we write to memory, we\ncan be sure that functions that did not read that part of memory have the same\nvalue they did before. For example, we might have two arrays, one of which we\nknow is sorted. If we did not put a reads annotation on the sorted predicate,\nthen when we modify the unsorted array, we cannot determine whether the other\narray stopped being sorted. While we might be able to give invariants to\npreserve it in this case, it gets even more complex when manipulating data\nstructures. In this case, framing is essential to making the verification\nprocess feasible.\n\nBy default, methods are not required to list the memory location they read.\nHowever, there are use cases for restricting what methods can read as well. In\nparticular, if you want to verify that imperative code is safe to execute\nconcurrently when compiled, you can specify that a method does not read or write\nany shared state, and therefore cannot encounter race conditions or runtime\ncrashes related to unsafe communication between concurrent executions. See [the\n`{:concurrent}` attribute][768] for more details.\n\nIt is not just the body of a function or method that is subject to `reads`\nchecks, but also its precondition and the `reads` clause itself.\n\nA `reads` clause can list a wildcard `*`, which allows the enclosing function or\nmethod to read anything. This is the implicit default for methods with no\n`reads` clauses, allowing methods to read whatever they like. The default for\nfunctions, however, is to not allow reading any memory. Allowing functions to\nread arbitrary memory is more problematic: in many cases, and in particular in\nall cases where the function is defined recursively, this makes it next to\nimpossible to make any use of the function. Nevertheless, as an experimental\nfeature, the language allows it (and it is sound). If a `reads` clause uses `*`,\nthen the `reads` clause is not allowed to mention anything else (since anything\nelse would be irrelevant, anyhow).\n\nA `reads` clause specifies the set of memory locations that a function, lambda,\nor method may read. The readable memory locations are all the fields of all of\nthe references given in the set specified in the frame expression and the single\nfields given in [`FrameField`][769] elements of the frame expression. For\nexample, in\n\n`class C {\n  var x: int\n  var y: int\n\n  predicate f(c: C) \n    reads this, c`x\n  {\n    this.x == c.x\n  }\n}\n`\n\nthe `reads` clause allows reading `this.x`, `this,y`, and `c.x` (which may be\nthe same memory location as `this.x`). }\n\nIf more than one `reads` clause is given in a specification the effective read\nset is the union of the sets specified. If there are no `reads` clauses the\neffective read set is empty. If `*` is given in a `reads` clause it means any\nmemory may be read.\n\nIf a `reads` clause refers to a sequence or multiset, that collection (call it\n`c`) is converted to a set by adding an implicit set comprehension of the form\n`set o: object | o in c` before computing the union of object sets from other\n`reads` clauses.\n\nAn expression in a `reads` clause is also allowed to be a function call whose\nvalue is a collection of references. Such an expression is converted to a set by\ntaking the union of the function’s image over all inputs. For example, if `F` is\na function from `int` to `set<object>`, then `reads F` has the meaning\n\n`set x: int, o: object | o in F(x) :: o\n`\n\nFor each function value `f`, Dafny defines the function `f.reads`, which takes\nthe same arguments as `f` and returns that set of objects that `f` reads\n(according to its reads clause) with those arguments. `f.reads` has type `T ~>\nset<object>`, where `T` is the input type(s) of `f`.\n\nThis is particularly useful when wanting to specify the reads set of another\nfunction. For example, function `Sum` adds up the values of `f(i)` where `i`\nranges from `lo` to `hi`:\n\n`function Sum(f: int ~> real, lo: int, hi: int): real\n  requires lo <= hi\n  requires forall i :: f.requires(i)\n  reads f.reads\n  decreases hi - lo\n{\n  if lo == hi then 0.0 else\n    f(lo) + Sum(f, lo + 1, hi)\n}\n`\n\nIts `reads` specification says that `Sum(f, lo, hi)` may read anything that `f`\nmay read on any input. (The specification `reads f.reads` gives an\noverapproximation of what `Sum` will actually read. More precise would be to\nspecify that `Sum` reads only what `f` reads on the values from `lo` to `hi`,\nbut the larger set denoted by `reads f.reads` is easier to write down and is\noften good enough.)\n\nWithout such `reads` function, one could also write the more precise and more\nverbose:\n\n`function Sum(f: int ~> real, lo: int, hi: int): real\n  requires lo <= hi\n  requires forall i :: lo <= i < hi ==> f.requires(i)\n  reads set i, o | lo <= i < hi && o in f.reads(i) :: o\n  decreases hi - lo\n{\n  if lo == hi then 0.0 else\n    f(lo) + Sum(f, lo + 1, hi)\n}\n`\n\nNote, only `reads` clauses, not `modifies` clauses, are allowed to include\nfunctions as just described.\n\nIterator specifications also allow `reads` clauses, with the same syntax and\ninterpretation of arguments as above, but the meaning is quite different! See\n[Section 5.11][770] for more details.\n\n#### 7.1.6. Modifies Clause ([grammar][771])\n\nExamples:\n\n`class A { var f: int }\nconst o: object?\nconst p: A?\nmethod M()\n  modifies { o, p }\nmethod N()\n  modifies { }\nmethod Q()\n  modifies o, p`f\n`\n\nBy default, methods are allowed to read whatever memory they like, but they are\nrequired to list which parts of memory they modify, with a `modifies`\nannotation. These are almost identical to their `reads` cousins, except they say\nwhat can be changed, rather than what the definition depends on. In combination\nwith reads, modification restrictions allow Dafny to prove properties of code\nthat would otherwise be very difficult or impossible. Reads and modifies are one\nof the tools that allow Dafny to work on one method at a time, because they\nrestrict what would otherwise be arbitrary modifications of memory to something\nthat Dafny can reason about.\n\nJust as for a `reads` clause, the memory locations allowed to be modified in a\nmethod are all the fields of any object reference in the frame expression set\nand any specific field denoted by a [`FrameField`][772] in the `modifies`\nclause. For example, in\n\n`class C {\n  var next: C?\n  var value: int\n\n  method M() \n    modifies next\n  { \n    ... \n  }\n}\n`\n\nmethod `M` is permitted to modify `this.next.next` and `this.next.value` but not\n`this.next`. To be allowed to modify `this.next`, the modifies clause must\ninclude `this`, or some expression that evaluates to `this`, or `this`next`.\n\nIf an object is newly allocated within the body of a method or within the scope\nof a `modifies` statement or a loop’s `modifies` clause, then the fields of that\nobject may always be modified.\n\nA `modifies` clause specifies the set of memory locations that a method,\niterator or loop body may modify. If more than one `modifies` clause is given in\na specification, the effective modifies set is the union of the sets specified.\nIf no `modifies` clause is given the effective modifies set is empty. There is\nno wildcard (`*`) allowed in a modifies clause. A loop can also have a\n`modifies` clause. If none is given, the loop may modify anything the enclosing\ncontext is allowed to modify.\n\nNote that *modifies* here is used in the sense of *writes*. That is, a field\nthat may not be modified may not be written to, even with the same value it\nalready has or even if the value is restored later. The terminology and\nsemantics varies among specification languages. Some define frame conditions in\nthis sense (a) of *writes* and others in the sense (b) that allows writing a\nfield with the same value or changing the value so long as the original value is\nrestored by the end of the scope. For example, JML defines `assignable` and\n`modifies` as synonyms in the sense (a), though KeY interprets JML’s\n`assigns/modifies` in sense (b). ACSL and ACSL++ use the `assigns` keyword, but\nwith *modify* (b) semantics. Ada/SPARK’s dataflow contracts encode *write* (a)\nsemantics.\n\n#### 7.1.7. Invariant Clause ([grammar][773])\n\nExamples:\n\n`method m()\n{\n  var i := 10;\n  while 0 < i\n    invariant 0 <= i < 10\n}\n`\n\nAn `invariant` clause is used to specify an invariant for a loop. If more than\none `invariant` clause is given for a loop, the effective invariant is the\nconjunction of the conditions specified, in the order given in the source text.\n\nThe invariant must hold on entry to the loop. And assuming it is valid on entry\nto a particular iteration of the loop, Dafny must be able to prove that it then\nholds at the end of that iteration of the loop.\n\nAn invariant can have [custom error and success messages][774].\n\n### 7.2. Method Specification ([grammar][775])\n\nExamples:\n\n`class C {\n  var next: C?\n  var value: int\n\n  method M(i: int) returns (r: int)\n    requires i >= 0\n    modifies next\n    decreases i\n    ensures r >= 0\n  { \n    ... \n  }\n}\n`\n\nA method specification consists of zero or more `reads`, `modifies`, `requires`,\n`ensures` or `decreases` clauses, in any order. A method does not need `reads`\nclauses in most cases, because methods are allowed to read any memory by\ndefault, but `reads` clauses are supported for use cases such as verifying safe\nconcurrent execution. See [the `{:concurrent}` attribute][776] for more details.\n\n### 7.3. Function Specification ([grammar][777])\n\nExamples:\n\n`class C {\n  var next: C?\n  var value: int\n\n  function M(i: int): (r: int)\n    requires i >= 0\n    reads this\n    decreases i\n    ensures r >= 0\n  { \n    0 \n  }\n}\n`\n\nA function specification is zero or more `reads`, `requires`, `ensures` or\n`decreases` clauses, in any order. A function specification does not have\n`modifies` clauses because functions are not allowed to modify any memory.\n\n### 7.4. Lambda Specification ([grammar][778])\n\nA lambda specification provides a specification for a lambda function\nexpression; it consists of zero or more `reads` or `requires` clauses. Any\n`requires` clauses may not have labels or attributes. Lambda specifications do\nnot have `ensures` clauses because the body is never opaque. Lambda\nspecifications do not have `decreases` clauses because lambda expressions do not\nhave names and thus cannot be recursive. A lambda specification does not have\n`modifies` clauses because lambdas are not allowed to modify any memory.\n\n### 7.5. Iterator Specification ([grammar][779])\n\nAn iterator specification may contains `reads`, `modifies`, `decreases`,\n`requires`, `yield requires, `ensures` and `yield ensures` clauses.\n\nAn iterator specification applies both to the iterator’s constructor method and\nto its `MoveNext` method.\n\n* The `reads` and `modifies` clauses apply to both of them (but `reads` clauses\n  have a [different meaning on iterators][780] than on functions or methods).\n* The `requires` and `ensures` clauses apply to the constructor.\n* The `yield requires` and `yield ensures` clauses apply to the `MoveNext`\n  method.\n\nExamples of iterators, including iterator specifications, are given in [Section\n5.11][781]. Briefly\n\n* a requires clause gives a precondition for creating an iterator\n* an ensures clause gives a postcondition when the iterator exits (after all\n  iterations are complete)\n* a decreases clause is used to show that the iterator will eventually terminate\n* a yield requires clause is a precondition for calling `MoveNext`\n* a yield ensures clause is a postcondition for calling `MoveNext`\n* a reads clause gives a set of memory locations that will be unchanged after a\n  `yield` statement\n* a modifies clause gives a set of memory locations the iterator may write to\n\n### 7.6. Loop Specification ([grammar][782])\n\nA loop specification provides the information Dafny needs to prove properties of\na loop. It contains `invariant`, `decreases`, and `modifies` clauses.\n\nThe `invariant` clause is effectively a precondition and it along with the\nnegation of the loop test condition provides the postcondition. The `decreases`\nclause is used to prove termination.\n\n### 7.7. Auto-generated boilerplate specifications\n\nAutoContracts is an experimental feature that inserts much of the dynamic-frames\nboilerplate into a class. The user simply\n\n* marks the class with `{:autocontracts}` and\n* declares a function (or predicate) called Valid().\n\nAutoContracts then\n\n* Declares, unless there already exist members with these names:\n  `ghost var Repr: set(object)\n  predicate Valid()\n  `\n* For function/predicate `Valid()`, inserts\n  `reads this, Repr\n  ensures Valid() ==> this in Repr\n  `\n* Into body of `Valid()`, inserts (at the beginning of the body)\n  `this in Repr && null !in Repr\n  `\n  \n  and also inserts, for every array-valued field `A` declared in the class:\n  \n  `(A != null ==> A in Repr) &&\n  `\n  \n  and for every field `F` of a class type `T` where `T` has a field called\n  `Repr`, also inserts\n  \n  `(F != null ==> F in Repr && F.Repr SUBSET Repr && this !in Repr && F.Valid())\n  `\n  \n  except, if `A` or `F` is declared with `{:autocontracts false}`, then the\n  implication will not be added.\n* For every constructor, inserts\n  `ensures Valid() && fresh(Repr)\n  `\n* At the end of the body of the constructor, adds\n  ` Repr := {this};\n   if (A != null) { Repr := Repr + {A}; }\n   if (F != null) { Repr := Repr + {F} + F.Repr; }\n  `\n\nIn all the following cases, no `modifies` clause or `reads` clause is added if\nthe user has given one.\n\n* For every non-static non-ghost method that is not a “simple query method”,\n  inserts\n  ` requires Valid()\n   modifies Repr\n   ensures Valid() && fresh(Repr - old(Repr))\n  `\n* At the end of the body of the method, inserts\n  ` if (A != null && !(A in Repr)) { Repr := Repr + {A}; }\n   if (F != null && !(F in Repr && F.Repr SUBSET Repr)) { Repr := Repr + {F} + F\n  .Repr; }\n  `\n* For every non-static non-twostate method that is either ghost or is a “simple\n  query method”, add:\n  ` requires Valid()\n  `\n* For every non-static twostate method, inserts\n  ` requires old(Valid())\n  `\n* For every non-“Valid” non-static function, inserts\n  ` requires Valid()\n   reads Repr\n  `\n\n### 7.8. Well-formedness of specifications\n\nDafny ensures that the [`requires` clauses][783] and [`ensures` clauses][784],\nwhich are expressions, are [well-formed][785] independent of the body they\nbelong to. Examples of conditions this rules out are null pointer dereferencing,\nout-of-bounds array access, and division by zero. Hence, when declaring the\nfollowing method:\n\n`method Test(a: array<int>) returns (j: int)\n  requires a.Length >= 1\n  ensures a.Length % 2 == 0 ==> j >= 10 / a.Length\n{\n  j := 20;\n  var divisor := a.Length;\n  if divisor % 2 == 0 {\n    j := j / divisor;\n  }\n}\n`\n\nDafny will split the verification in two [assertion batches][786] that will\nroughly look like the following lemmas:\n\n`lemma Test_WellFormed(a: array?<int>)\n{\n  assume a != null;       // From the definition of a\n  assert a != null;       // for the `requires a.Length >= 1`\n  assume a.Length >= 1;   // After well-formedness, we assume the requires\n  assert a != null;       // Again for the `a.Length % 2`\n  if a.Length % 2 == 0 {\n    assert a != null;     // Again for the final `a.Length`\n    assert a.Length != 0; // Because of the 10 / a.Length\n  }\n}\n\nmethod Test_Correctness(a: array?<int>)\n{ // Here we assume the well-formedness of the condition\n  assume a != null;       // for the `requires a.Length >= 1`\n  assume a != null;       // Again for the `a.Length % 2`\n  if a.Length % 2 == 0 {\n    assume a != null;     // Again for the final `a.Length`\n    assume a.Length != 0; // Because of the 10 / a.Length\n  }\n\n  // Now the body is translated\n  var j := 20;\n  assert a != null;          // For `var divisor := a.Length;`\n  var divisor := a.Length;\n  if * {\n    assume divisor % 2 == 0;\n    assert divisor != 0;\n    j := j / divisor;\n  }\n  assume divisor % 2 == 0 ==> divisor != 0;\n  assert a.Length % 2 == 0 ==> j >= 10 / a.Length;\n}\n`\n\nFor this reason the IDE typically reports at least two [assertion batches][787]\nwhen hovering a method.\n\n## 8. Statements ([grammar][788])\n\nMany of Dafny’s statements are similar to those in traditional programming\nlanguages, but a number of them are significantly different. Dafny’s various\nkinds of statements are described in subsequent sections.\n\nStatements have zero or more labels and end with either a semicolon (`;`) or a\nclosing curly brace (‘}’).\n\n### 8.1. Labeled Statement ([grammar][789])\n\nExamples:\n\n`class A { var f: int }\nmethod m(a: A) {\n  label x:\n  while true {\n     if (*) { break x; }\n  }\n  a.f := 0;\n  label y:\n  a.f := 1;\n  assert old@y(a.f) == 1;\n}\n`\n\nA labeled statement is just\n\n* the keyword `label`\n* followed by an identifier, which is the label,\n* followed by a colon\n* and a statement.\n\nThe label may be referenced in a `break` or `continue` statement within the\nlabeled statement (see [Section 8.14][790]). That is, the break or continue that\nmentions the label must be *enclosed* in the labeled statement.\n\nThe label may also be used in an `old` expression ([Section 9.22][791]). In this\ncase, the label must have been encountered during the control flow en route to\nthe `old` expression. We say in this case that the (program point of the) label\n*dominates* the (program point of the) use of the label. Similarly, labels are\nused to indicate previous states in calls of [two-state predicates][792], [fresh\nexpressions][793], [unchanged expressions][794], and [allocated\nexpressions][795].\n\nA statement can be given several labels. It makes no difference which of these\nlabels is used to reference the statement—they are synonyms of each other. The\nlabels must be distinct from each other, and are not allowed to be the same as\nany previous enclosing or [dominating label][796].\n\n### 8.2. Block Statement ([grammar][797])\n\nExamples:\n\n`{\n  print 0;\n  var x := 0;\n}\n`\n\nA block statement is a sequence of zero or more statements enclosed by curly\nbraces. Local variables declared in the block end their scope at the end of the\nblock.\n\n### 8.3. Return Statement ([grammar][798])\n\nExamples:\n\n`method m(i: int) returns (r: int) {\n  return i+1;\n}\nmethod n(i: int) returns (r: int, q: int) {\n  return i+1, i + 2;\n}\nmethod p() returns (i: int) {\n  i := 1;\n  return;\n}\nmethod q() {\n  return;\n}\n`\n\nA return statement can only be used in a method. It is used to terminate the\nexecution of the method.\n\nTo return a value from a method, the value is assigned to one of the named\nout-parameters sometime before a return statement. In fact, the out-parameters\nact very much like local variables, and can be assigned to more than once.\nReturn statements are used when one wants to return before reaching the end of\nthe body block of the method.\n\nReturn statements can be just the `return` keyword (where the current values of\nthe out-parameters are used), or they can take a list of expressions to return.\nIf a list is given, the number of expressions given must be the same as the\nnumber of named out-parameters. These expressions are evaluated, then they are\nassigned to the out-parameters, and then the method terminates.\n\n### 8.4. Yield Statement ([grammar][799])\n\nA yield statement may only be used in an iterator. See [iterator types][800] for\nmore details about iterators.\n\nThe body of an iterator is a *co-routine*. It is used to yield control to its\ncaller, signaling that a new set of values for the iterator’s yield\n(out-)parameters (if any) are available. Values are assigned to the yield\nparameters at or before a yield statement. In fact, the yield parameters act\nvery much like local variables, and can be assigned to more than once. Yield\nstatements are used when one wants to return new yield parameter values to the\ncaller. Yield statements can be just the `yield` keyword (where the current\nvalues of the yield parameters are used), or they can take a list of expressions\nto yield. If a list is given, the number of expressions given must be the same\nas the number of named iterator out-parameters. These expressions are then\nevaluated, then they are assigned to the yield parameters, and then the iterator\nyields.\n\n### 8.5. Update and Call Statements ([grammar][801])\n\nExamples:\n\n`class C { var f: int }\nclass D {\n  var i: int\n  constructor(i: int) {\n    this.i := i;\n  }\n}\nmethod q(i: int, j: int) {}\nmethod r() returns (s: int, t: int) { return 2,3; }\nmethod m() {\n  var ss: int, tt: int, c: C?, a: array<int>, d: D?;\n  q(0,1);\n  ss, c.f := r();\n  c := new C;\n  d := new D(2);\n  a := new int[10];\n  ss, tt := 212, 33;\n  ss :| ss > 7;\n  ss := *;\n}\n`\n\nThis statement corresponds to familiar assignment or method call statements,\nwith variations. If more than one left-hand side is used, these must denote\ndifferent l-values, unless the corresponding right-hand sides also denote the\nsame value.\n\nThe update statement serves several logical purposes.\n\n#### 8.5.1. Method call with no out-parameters\n\n1) Examples of method calls take this form\n\n`m();\nm(1,2,3) {:attr} ;\ne.f().g.m(45);\n`\n\nAs there are no left-hand-side locations to receive values, this form is allowed\nonly for methods that have no out-parameters.\n\n#### 8.5.2. Method call with out-parameters\n\nThis form uses `:=` to denote the assignment of the out-parameters of the method\nto the corresponding number of LHS values.\n\n`a, b.e().f := m() {:attr};\n`\n\nIn this case, the right-hand-side must be a method call and the number of\nleft-hand sides must match the number of out-parameters of the method that is\ncalled. Note that the result of a method call is not allowed to be used as an\nargument of another method call, as if it were an expression.\n\n#### 8.5.3. Parallel assignment\n\nA parallel-assignment has one-or-more right-hand-side expressions, which may be\nfunction calls but may not be method calls.\n\n`    x, y := y, x;\n`\n\nThe above example swaps the values of `x` and `y`. If more than one left-hand\nside is used, these must denote different l-values, unless the corresponding\nright-hand sides also denote the same value. There must be an equal number of\nleft-hand sides and right-hand sides. The most common case has only one RHS and\none LHS.\n\n#### 8.5.4. Havoc assignment\n\nThe form with a right-hand-side that is `*` is a *havoc* assignment. It assigns\nan arbitrary but type-correct value to the corresponding left-hand-side. It can\nbe mixed with other assignments of computed values.\n\n`a := *;\na, b, c := 4, *, 5;\n`\n\n#### 8.5.5. Such-that assignment\n\nThis form has one or more left-hand-sides, a `:|` symbol and then a boolean\nexpression on the right. The effect is to assign values to the left-hand-sides\nthat satisfy the RHS condition.\n\n`x, y :| 0 < x+y < 10;\n`\n\nThis is read as assign values to `x` and `y` such that `0 < x+y < 10` is true.\nThe given boolean expression need not constrain the LHS values uniquely: the\nchoice of satisfying values is non-deterministic. This can be used to make a\nchoice as in the following example where we choose an element in a set.\n\n`method Sum(X: set<int>) returns (s: int)\n{\n  s := 0; var Y := X;\n  while Y != {}\n    decreases Y\n  {\n    var y: int;\n    y :| y in Y;\n    s, Y := s + y, Y - {y};\n  }\n}\n`\n\nDafny will report an error if it cannot prove that values exist that satisfy the\ncondition.\n\nIn this variation, with an `assume` keyword\n\n`    y :| assume y in Y;\n`\n\nDafny assumes without proof that an appropriate value exists.\n\nNote that the syntax\n\n`    Lhs \":\"\n`\n\nis interpreted as a label in which the user forgot the `label` keyword.\n\n#### 8.5.6. Method call with a `by` proof\n\nThe purpose of this form of a method call is to seperate the called method’s\nprecondition and its proof from the rest of the correctness proof of the calling\nmethod.\n\n`opaque predicate P() { true }\n\nlemma ProveP() ensures P() {\n  reveal P();\n}\n\nmethod M(i: int) returns (r: int)\n  requires P()\n  ensures r == i\n{ r := i; }\n\nmethod C() {\n  var v := M(1/3) by { // We prove 3 != 0 outside of the by proof\n    ProveP();          // Prove precondtion  \n  }\n  assert v == 0;       // Use postcondition\n  assert P();          // Fails\n}\n`\n\nBy placing the call to lemma `ProveP` inside of the by block, we can not use `P`\nafter the method call. The well-formedness checks of the arguments to the method\ncall are not subject to the separation.\n\n### 8.6. Update with Failure Statement (`:-`) ([grammar][802])\n\nSee the subsections below for examples.\n\nA `:-`^{[9][803]} statement is an alternate form of the `:=` statement that\nallows for abrupt return if a failure is detected. This is a language feature\nsomewhat analogous to exceptions in other languages.\n\nAn update-with-failure statement uses *failure-compatible* types. A\nfailure-compatible type is a type that has the following (non-static) members\n(each with no in-parameters and one out-parameter):\n\n* a non-ghost function `IsFailure()` that returns a `bool`\n* an optional non-ghost function `PropagateFailure()` that returns a value\n  assignable to the first out-parameter of the caller\n* an optional function `Extract()` (PropagateFailure and Extract were permitted\n  to be methods (but deprecated) prior to Dafny 4. They will be required to be\n  functions in Dafny 4.)\n\nA failure-compatible type with an `Extract` member is called *value-carrying*.\n\nTo use this form of update,\n\n* if the RHS of the update-with-failure statement is a method call, the first\n  out-parameter of the callee must be failure-compatible\n* if instead, the RHS of the update-with-failure statement is one or more\n  expressions, the first of these expressions must be a value with a\n  failure-compatible type\n* the caller must have a first out-parameter whose type matches the output of\n  `PropagateFailure` applied to the first output of the callee, unless an\n  `expect`, `assume`, or `assert` keyword is used after `:-` (cf. [Section\n  8.6.7][804]).\n* if the failure-compatible type of the RHS does not have an `Extract` member,\n  then the LHS of the `:-` statement has one less expression than the RHS (or\n  than the number of out-parameters from the method call), the value of the\n  first out-parameter or expression being dropped (see the discussion and\n  examples in [Section 8.6.2][805])\n* if the failure-compatible type of the RHS does have an `Extract` member, then\n  the LHS of the `:-` statement has the same number of expressions as the RHS\n  (or as the number of out-parameters from the method call) and the type of the\n  first LHS expression must be assignable from the return type of the `Extract`\n  member\n* the `IsFailure` and `PropagateFailure` methods may not be ghost\n* the LHS expression assigned the output of the `Extract` member is ghost\n  precisely if `Extract` is ghost\n\nThe following subsections show various uses and alternatives.\n\n#### 8.6.1. Failure compatible types\n\nA simple failure-compatible type is the following:\n\n`datatype Status =\n| Success\n| Failure(error: string)\n{\n  predicate IsFailure() { this.Failure?  }\n  function PropagateFailure(): Status\n    requires IsFailure()\n  {\n    Failure(this.error)\n  }\n}\n`\n\nA commonly used alternative that carries some value information is something\nlike this generic type:\n\n`datatype Outcome<T> =\n| Success(value: T)\n| Failure(error: string)\n{\n  predicate IsFailure() {\n    this.Failure?\n  }\n  function PropagateFailure<U>(): Outcome<U>\n    requires IsFailure()\n  {\n    Failure(this.error) // this is Outcome<U>.Failure(...)\n  }\n  function Extract(): T\n    requires !IsFailure()\n  {\n    this.value\n  }\n}\n`\n\n#### 8.6.2. Simple status return with no other outputs\n\nThe simplest use of this failure-return style of programming is to have a method\ncall that just returns a non-value-carrying `Status` value:\n\n`method Callee(i: int) returns (r: Status)\n{\n  if i < 0 { return Failure(\"negative\"); }\n  return Success;\n}\n\nmethod Caller(i: int) returns (rr: Status)\n{\n  :- Callee(i);\n  ...\n}\n`\n\nNote that there is no LHS to the `:-` statement. If `Callee` returns `Failure`,\nthen the caller immediately returns, not executing any statements following the\ncall of `Callee`. The value returned by `Caller` (the value of `rr` in the code\nabove) is the result of `PropagateFailure` applied to the value returned by\n`Callee`, which is often just the same value. If `Callee` does not return\n`Failure` (that is, returns a value for which `IsFailure()` is `false`) then\nthat return value is forgotten and execution proceeds normally with the\nstatements following the call of `Callee` in the body of `Caller`.\n\nThe desugaring of the `:- Callee(i);` statement is\n\n`var tmp;\ntmp := Callee(i);\nif tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\n`\n\nIn this and subsequent examples of desugaring, the `tmp` variable is a new,\nunique variable, unused elsewhere in the calling member.\n\n#### 8.6.3. Status return with additional outputs\n\nThe example in the previous subsection affects the program only through side\neffects or the status return itself. It may well be convenient to have\nadditional out-parameters, as is allowed for `:=` updates; these out-parameters\nbehave just as for `:=`. Here is an example:\n\n`method Callee(i: int) returns (r: Status, v: int, w: int)\n{\n  if i < 0 { return Failure(\"negative\"), 0, 0; }\n  return Success, i+i, i*i;\n}\n\nmethod Caller(i: int) returns (rr: Status, k: int)\n{\n  var j: int;\n  j, k :- Callee(i);\n  k := k + k;\n  ...\n}\n`\n\nHere `Callee` has two outputs in addition to the `Status` output. The LHS of the\n`:-` statement accordingly has two l-values to receive those outputs. The\nrecipients of those outputs may be any sort of l-values; here they are a local\nvariable and an out-parameter of the caller. Those outputs are assigned in the\n`:-` call regardless of the `Status` value:\n\n* If `Callee` returns a failure value as its first output, then the other\n  outputs are assigned, the *caller’s* first out-parameter (here `rr`) is\n  assigned the value of `PropagateFailure`, and the caller returns.\n* If `Callee` returns a non-failure value as its first output, then the other\n  outputs are assigned and the caller continues execution as normal.\n\nThe desugaring of the `j, k :- Callee(i);` statement is\n\n`var tmp;\ntmp, j, k := Callee(i);\nif tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\n`\n\n#### 8.6.4. Failure-returns with additional data\n\nThe failure-compatible return value can carry additional data as shown in the\n`Outcome<T>` example above. In this case there is a (first) LHS l-value to\nreceive this additional data. The type of that first LHS value is one that is\nassignable from the result of the `Extract` function, not the actual first\nout-parameter.\n\n`method Callee(i: int) returns (r: Outcome<nat>, v: int)\n{\n  if i < 0 { return Failure(\"negative\"), i+i; }\n  return Success(i), i+i;\n}\n\nmethod Caller(i: int) returns (rr: Outcome<int>, k: int)\n{\n  var j: int;\n  j, k :- Callee(i);\n  k := k + k;\n  ...\n}\n`\n\nSuppose `Caller` is called with an argument of `10`. Then `Callee` is called\nwith argument `10` and returns `r` and `v` of `Outcome<nat>.Success(10)` and\n`20`. Here `r.IsFailure()` is `false`, so control proceeds normally. The `j` is\nassigned the result of `r.Extract()`, which will be `10`, and `k` is assigned\n`20`. Control flow proceeds to the next line, where `k` now gets the value `40`.\n\nSuppose instead that `Caller` is called with an argument of `-1`. Then `Callee`\nis called with the value `-1` and returns `r` and `v` with values\n`Outcome<nat>.Failure(\"negative\")` and `-2`. `k` is assigned the value of `v`\n(-2). But `r.IsFailure()` is `true`, so control proceeds directly to return from\n`Caller`. The first out-parameter of `Caller` (`rr`) gets the value of\n`r.PropagateFailure()`, which is `Outcome<int>.Failure(\"negative\")`; `k` already\nhas the value `-2`. The rest of the body of `Caller` is skipped. In this\nexample, the first out-parameter of `Caller` has a failure-compatible type so\nthe exceptional return will propagate up the call stack. It will keep\npropagating up the call stack as long as there are callers with this first\nspecial output type and calls that use `:-` and the return value keeps having\n`IsFailure()` true.\n\nThe desugaring of the `j, k :- Callee(i);` statement in this example is\n\n`var tmp;\ntmp, k := Callee(i);\nif tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\nj := tmp.Extract();\n`\n\n#### 8.6.5. RHS with expression list\n\nInstead of a failure-returning method call on the RHS of the statement, the RHS\ncan instead be a list of expressions. As for a `:=` statement, in this form, the\nexpressions on the left and right sides of `:-` must correspond, just omitting a\nLHS l-value for the first RHS expression if its type is not value-carrying. The\nsemantics is very similar to that in the previous subsection.\n\n* The first RHS expression must have a failure-compatible type.\n* All the assignments of RHS expressions to LHS values except for the first RHS\n  value are made.\n* If the first RHS value (say `r`) responds `true` to `r.IsFailure()`, then\n  `r.PropagateFailure()` is assigned to the first out-parameter of the *caller*\n  and the execution of the caller’s body is ended.\n* If the first RHS value (say `r`) responds `false` to `r.IsFailure()`, then\n  \n  * if the type of `r` is value-carrying, then `r.Extract()` is assigned to the\n    first LHS value of the `:-` statement; if `r` is not value-carrying, then\n    the corresponding LHS l-value is omitted\n  * execution of the caller’s body continues with the statement following the\n    `:-` statement.\n\nA RHS with a method call cannot be mixed with a RHS containing multiple\nexpressions.\n\nFor example, the desugaring of\n\n`method m(r: Status) returns (rr: Status) {\n  var k;\n  k :- r, 7;\n  ...\n}\n`\n\nis\n\n`var k;\nvar tmp;\ntmp, k := r, 7;\nif tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\n`\n\n#### 8.6.6. Failure with initialized declaration.\n\nThe `:-` syntax can also be used in initialization, as in\n\n`var s, t :- M();\n`\n\nThis is equivalent to\n\n`var s, t;\ns, t :- M();\n`\n\nwith the semantics as described above.\n\n#### 8.6.7. Keyword alternative\n\nIn any of the above described uses of `:-`, the `:-` token may be followed\nimmediately by the keyword `expect`, `assert` or `assume`.\n\n* `assert` means that the RHS evaluation is expected to be successful, but that\n  the verifier should prove that this is so; that is, the verifier should prove\n  `assert !r.IsFailure()` (where `r` is the status return from the callee) (cf.\n  [Section 8.17][806])\n* `assume` means that the RHS evaluation should be assumed to be successful, as\n  if the statement `assume !r.IsFailure()` followed the evaluation of the RHS\n  (cf. [Section 8.18][807])\n* `expect` means that the RHS evaluation should be assumed to be successful\n  (like using `assume` above), but that the compiler should include a run-time\n  check for success. This is equivalent to including `expect !r.IsFailure()`\n  after the RHS evaluation; that is, if the status return is a failure, the\n  program halts. (cf. [Section 8.19][808])\n\nIn each of these cases, there is no abrupt return from the caller. Thus there is\nno evaluation of `PropagateFailure`. Consequently the first out-parameter of the\ncaller need not match the return type of `PropagateFailure`; indeed, the\nfailure-compatible type returned by the callee need not have a\n`PropagateFailure` member.\n\nThe equivalent desugaring replaces\n\n`if tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\n`\n\nwith\n\n`expect !tmp.IsFailure(), tmp;\n`\n\nor\n\n`assert !tmp.IsFailure();\n`\n\nor\n\n`assume !tmp.IsFailure();\n`\n\nThere is a grammatical nuance that the user should be aware of. The keywords\n`assert`, `assume`, and `expect` can start an expression. For example, `assert\nP; E` can be an expression. However, in `e :- assert P; E;` the `assert` is\nparsed as the keyword associated with `:-`. To have the `assert` considered part\nof the expression use parentheses: `e :- (assert P; E);`.\n\n#### 8.6.8. Key points\n\nThere are several points to note.\n\n* The first out-parameter of the callee is special. It has a special type and\n  that type indicates that the value is inspected to see if an abrupt return\n  from the caller is warranted. This type is often a datatype, as shown in the\n  examples above, but it may be any type with the appropriate members.\n* The restriction on the type of caller’s first out-parameter is just that it\n  must be possible (perhaps through generic instantiation and type inference, as\n  in these examples) for `PropagateFailure` applied to the failure-compatible\n  output from the callee to produce a value of the caller’s first out-parameter\n  type. If the caller’s first out-parameter type is failure-compatible (which it\n  need not be), then failures can be propagated up the call chain. If the\n  keyword form (e.g. `assume`) of the statement is used, then no\n  `PropagateFailure` member is needed, because no failure can occur, and there\n  is no restriction on the caller’s first out-parameter.\n* In the statement `j, k :- Callee(i);`, when the callee’s return value has an\n  `Extract` member, the type of `j` is not the type of the first out-parameter\n  of `Callee`. Rather it is a type assignable from the output type of `Extract`\n  applied to the first out-value of `Callee`.\n* A method like `Callee` with a special first out-parameter type can still be\n  used in the normal way: `r, k := Callee(i)`. Now `r` gets the first output\n  value from `Callee`, of type `Status` or `Outcome<nat>` in the examples above.\n  No special semantics or exceptional control paths apply. Subsequent code can\n  do its own testing of the value of `r` and whatever other computations or\n  control flow are desired.\n* The caller and callee can have any (positive) number of output arguments, as\n  long as the callee’s first out-parameter has a failure-compatible type and the\n  caller’s first out-parameter type matches `PropagateFailure`.\n* If there is more than one LHS, the LHSs must denote different l-values, unless\n  the RHS is a list of expressions and the corresponding RHS values are equal.\n* The LHS l-values are evaluated before the RHS method call, in case the method\n  call has side-effects or return values that modify the l-values prior to\n  assignments being made.\n\nIt is important to note the connection between the failure-compatible types used\nin the caller and callee, if they both use them. They do not have to be the same\ntype, but they must be closely related, as it must be possible for the callee’s\n`PropagateFailure` to return a value of the caller’s failure-compatible type. In\npractice this means that one such failure-compatible type should be used for an\nentire program. If a Dafny program uses a library shared by multiple programs,\nthe library should supply such a type and it should be used by all the client\nprograms (and, effectively, all Dafny libraries). It is also the case that it is\ninconvenient to mix types such as `Outcome` and `Status` above within the same\nprogram. If there is a mix of failure-compatible types, then the program will\nneed to use `:=` statements and code for explicit handling of failure values.\n\n#### 8.6.9. Failure returns and exceptions\n\nThe `:-` mechanism is like the exceptions used in other programming languages,\nwith some similarities and differences.\n\n* There is essentially just one kind of ‘exception’ in Dafny, the variations of\n  the failure-compatible data type.\n* Exceptions are passed up the call stack whether or not intervening methods are\n  aware of the possibility of an exception, that is, whether or not the\n  intervening methods have declared that they throw exceptions. Not so in Dafny:\n  a failure is passed up the call stack only if each caller has a\n  failure-compatible first out-parameter, is itself called in a `:-` statement,\n  and returns a value that responds true to `IsFailure()`.\n* All methods that contain failure-return callees must explicitly handle those\n  failures using either `:-` statements or using `:=` statements with a LHS to\n  receive the failure value.\n\n### 8.7. Variable Declaration Statement ([grammar][809])\n\nExamples:\n\n`method m() {\n  var x, y: int; // x's type is inferred, not necessarily 'int'\n  var b: bool, k: int;\n  x := 1; // settles x's type\n}\n`\n\nA variable declaration statement is used to declare one or more local variables\nin a method or function. The type of each local variable must be given unless\nits type can be inferred, either from a given initial value, or from other uses\nof the variable. If initial values are given, the number of values must match\nthe number of variables declared.\n\nThe scope of the declared variable extends to the end of the block in which it\nis declared. However, be aware that if a simple variable declaration is followed\nby an expression (rather than a subsequent statement) then the `var` begins a\n[Let Expression][810] and the scope of the introduced variables is only to the\nend of the expression. In this case, though, the `var` is in an expression\ncontext, not a statement context.\n\nNote that the type of each variable must be given individually. The following\ncode\n\n`var x, y : int;\nvar x, y := 5, 6;\nvar x, y :- m();\nvar x, y :| 0 < x + y < 10;\nvar (x, y) := makePair();\nvar Cons(x, y) = ConsMaker();\n`\n\ndoes not declare both `x` and `y` to be of type `int`. Rather it will give an\nerror explaining that the type of `x` is underspecified if it cannot be inferred\nfrom uses of x.\n\nThe variables can be initialized with syntax similar to update statements (cf.\n[Section 8.5][811]).\n\nIf the RHS is a call, then any variable receiving the value of a formal ghost\nout-parameter will automatically be declared as ghost, even if the `ghost`\nkeyword is not part of the variable declaration statement.\n\nThe left-hand side can also contain a tuple of patterns that will be matched\nagainst the right-hand-side. For example:\n\n`function returnsTuple() : (int, int)\n{\n    (5, 10)\n}\n\nfunction usesTuple() : int\n{\n    var (x, y) := returnsTuple();\n    x + y\n}\n`\n\nThe initialization with failure operator `:-` returns from the enclosing method\nif the initializer evaluates to a failure value of a failure-compatible type\n(see [Section 8.6][812]).\n\n### 8.8. Guards ([grammar][813])\n\nExamples (in `if` statements):\n\n`method m(i: int) {\n  if (*) { print i; }\n  if i > 0 { print i; }\n}\n`\n\nGuards are used in `if` and `while` statements as boolean expressions. Guards\ntake two forms.\n\nThe first and most common form is just a boolean expression.\n\nThe second form is either `*` or `(*)`. These have the same meaning. An\nunspecified boolean value is returned. The value returned may be different each\ntime it is executed.\n\n### 8.9. Binding Guards ([grammar][814])\n\nExamples (in `if` statements):\n\n`method m(i: int) {\n  ghost var k: int;\n  if i, j :| 0 < i+j < 10 {\n    k := 0;\n  } else {\n    k := 1;\n  }\n}\n`\n\nAn `if` statement can also take a *binding guard*. Such a guard checks if there\nexist values for the given variables that satisfy the given expression. If so,\nit binds some satisfying values to the variables and proceeds into the “then”\nbranch; otherwise it proceeds with the “else” branch, where the bound variables\nare not in scope.\n\nIn other words, the statement\n\n`if x :| P { S } else { T }\n`\n\nhas the same meaning as\n\n`if exists x :: P { var x :| P; S } else { T }\n`\n\nThe identifiers bound by the binding guard are ghost variables and cannot be\nassigned to non-ghost variables. They are only used in specification contexts.\n\nHere is another example:\n\n`predicate P(n: int)\n{\n  n % 2 == 0\n}\n\nmethod M1() returns (ghost y: int)\n    requires exists x :: P(x)\n    ensures P(y)\n{\n  if x : int :| P(x) {\n      y := x;\n  }\n}\n`\n\n### 8.10. If Statement ([grammar][815])\n\nExamples:\n\n`method m(i: int) {\n  var x: int;\n  if i > 0 {\n    x := i;\n  } else {\n    x := -i;\n  }\n  if * {\n    x := i;\n  } else {\n    x := -i;\n  }\n  if i: nat, j: nat :| i+j<10 {\n    assert i < 10;\n  }\n  if i == 0 {\n    x := 0;\n  } else if i > 0 {\n    x := 1;\n  } else {\n    x := -1;\n  }\n  if \n    case i == 0 => x := 0;\n    case i > 0 => x := 1;\n    case i < 0 => x := -1;\n}\n`\n\nThe simplest form of an `if` statement uses a guard that is a boolean\nexpression. For example,\n\n`  if x < 0 {\n    x := -x;\n  }\n`\n\nUnlike `match` statements, `if` statements do not have to be exhaustive:\nomitting the `else` block is the same as including an empty `else` block. To\nensure that an `if` statement is exhaustive, use the `if-case` statement\ndocumented below.\n\nIf the guard is an asterisk then a non-deterministic choice is made:\n\n`  if * {\n    print \"True\";\n  } else {\n    print \"False\";\n  }\n`\n\nThe then alternative of the if-statement must be a block statement; the else\nalternative may be either a block statement or another if statement. The\ncondition of the if statement need not (but may) be enclosed in parentheses.\n\nAn if statement with a binding guard is non-deterministic; it will not be\ncompiled if `--enforce-determinism` is enabled (even if it can be proved that\nthere is a unique value). An if statement with `*` for a guard is\nnon-deterministic and ghost.\n\nThe `if-case` statement using the `AlternativeBlock` form is similar to the `if\n... fi` construct used in the book “A Discipline of Programming” by Edsger W.\nDijkstra. It is used for a multi-branch `if`.\n\nFor example:\n\n`method m(x: int, y: int) returns (max: int) \n{\n  if {\n    case x <= y => max := y;\n    case y <= x => max := x;\n  }\n}\n`\n\nIn this form, the expressions following the `case` keyword are called *guards*.\nThe statement is evaluated by evaluating the guards in an undetermined order\nuntil one is found that is `true` and the statements to the right of `=>` for\nthat guard are executed. The statement requires at least one of the guards to\nevaluate to `true` (that is, `if-case` statements must be exhaustive: the guards\nmust cover all cases).\n\nIn the if-with-cases, a sequence of statements may follow the `=>`; it may but\nneed not be a block statement (a brace-enclosed sequence of statements).\n\nThe form that used `...` (a refinement feature) as the guard is deprecated.\n\n### 8.11. Match Statement ([grammar][816])\n\nExamples:\n\n`\nmatch list {\n  case Nil => {}\n  case Cons(head,tail) => print head;\n}\nmatch x\ncase 1 =>\n  print x;\ncase 2 =>\n  var y := x*x;\n  print y;\ncase _ =>\n  print \"Other\";\n  // Any statement after is captured in this case.\n`\n\nThe `match` statement is used to do case analysis on a value of an expression.\nThe expression may be a value of a basic type (e.g. `int`), a newtype, or an\ninductive or coinductive datatype (which includes the built-in tuple types). The\nexpression after the `match` keyword is called the *selector*. The selector is\nevaluated and then matched against each clause in order until a matching clause\nis found.\n\nThe process of matching the selector expression against the case patterns is the\nsame as for match expressions and is described in [Section 9.31.2][817].\n\nThe selector need not be enclosed in parentheses; the sequence of cases may but\nneed not be enclosed in braces. The cases need not be disjoint. The cases must\nbe exhaustive, but you can use a wild variable (`_`) or a simple identifier to\nindicate “match anything”. Please refer to the [section about case\npatterns][818] to learn more about shadowing, constants, etc.\n\nThe code below shows an example of a match statement.\n\n`datatype Tree = Empty | Node(left: Tree, data: int, right: Tree)\n\n// Return the sum of the data in a tree.\nmethod Sum(x: Tree) returns (r: int)\n{\n  match x {\n    case Empty => r := 0;\n    case Node(t1, d, t2) =>\n      var v1 := Sum(t1);\n      var v2 := Sum(t2);\n      r := v1 + d + v2;\n  }\n}\n`\n\nNote that the `Sum` method is recursive yet has no `decreases` annotation. In\nthis case it is not needed because Dafny is able to deduce that `t1` and `t2`\nare *smaller* (structurally) than `x`. If `Tree` had been coinductive this would\nnot have been possible since `x` might have been infinite.\n\n### 8.12. While Statement ([grammar][819])\n\nExamples:\n\n`method m() {\n  var i := 10;\n  while 0 < i\n    invariant 0 <= i <= 10\n    decreases i\n  {\n    i := i-1;\n  }\n  while * {}\n  i := *;\n  while \n     decreases if i < 0 then -i else i\n  {\n     case i < 0 => i := i + 1;\n     case i > 0 => i := i - 1;\n  }\n}\n`\n\nLoops\n\n* may be a conventional loop with a condition and a block statement for a body\n* need not have parentheses around the condition\n* may have a `*` for the condition (the loop is then non-deterministic)\n* binding guards are not allowed\n* may have a case-based structure\n* may have no body — a bodyless loop is not compilable, but can be reaosnaed\n  about\n\nImportantly, loops need *loop specifications* in order for Dafny to prove that\nthey obey expected behavior. In some cases Dafny can infer the loop\nspecifications by analyzing the code, so the loop specifications need not always\nbe explicit. These specifications are described in [Section 7.6][820] and\n[Section 8.15][821].\n\nThe general loop statement in Dafny is the familiar `while` statement. It has\ntwo general forms.\n\nThe first form is similar to a while loop in a C-like language. For example:\n\n`method m(){\n  var i := 0;\n  while i < 5 {\n    i := i + 1;\n  }\n}\n`\n\nIn this form, the condition following the `while` is one of these:\n\n* A boolean expression. If true it means execute one more iteration of the loop.\n  If false then terminate the loop.\n* An asterisk (`*`), meaning non-deterministically yield either `true` or\n  `false` as the value of the condition\n\nThe *body* of the loop is usually a block statement, but it can also be missing\naltogether. A loop with a missing body may still pass verification, but any\nattempt to compile the containing program will result in an error message. When\nverifying a loop with a missing body, the verifier will skip attempts to prove\nloop invariants and decreases assertions that would normally be asserted at the\nend of the loop body. There is more discussion about bodyless loops in [Section\n8.15.4][822].\n\nThe second form uses a case-based block. It is similar to the `do ... od`\nconstruct used in the book “A Discipline of Programming” by Edsger W. Dijkstra.\nFor example:\n\n`method m(n: int){\n  var r := n;\n  while\n    decreases if 0 <= r then r else -r\n  {\n    case r < 0 =>\n      r := r + 1;\n    case 0 < r =>\n      r := r - 1;\n  }\n}\n`\n\nFor this form, the guards are evaluated in some undetermined order until one is\nfound that is true, in which case the corresponding statements are executed and\nthe while statement is repeated. If none of the guards evaluates to true, then\nthe loop execution is terminated.\n\nThe form that used `...` (a refinement feature) as the guard is deprecated.\n\n### 8.13. For Loops ([grammar][823])\n\nExamples:\n\n`method m() decreases * {\n  for i := 0 to 10 {}\n  for _ := 0 to 10 {}\n  for i := 0 to * invariant i >= 0 decreases * {}\n  for i: int := 10 downto 0 {}\n  for i: int := 10 downto 0 \n}\n`\n\nThe `for` statement provides a convenient way to write some common loops.\n\nThe statement introduces a local variable with optional type, which is called\nthe *loop index*. The loop index is in scope in the specification and the body,\nbut not after the `for` loop. Assignments to the loop index are not allowed. The\ntype of the loop index can typically be inferred; if so, it need not be given\nexplicitly. If the identifier is not used, it can be written as `_`, as\nillustrated in this repeat-20-times loop:\n\n`for _ := 0 to 20 {\n  Body\n}\n`\n\nThere are four basic variations of the `for` loop:\n\n`for i: T := lo to hi\n  LoopSpec\n{ Body }\n\nfor i: T := hi downto lo\n  LoopSpec\n{ Body }\n\nfor i: T := lo to *\n  LoopSpec\n{ Body }\n\nfor i: T := hi downto *\n  LoopSpec\n{ Body }\n`\n\nSemantically, they are defined as the following respective `while` loops:\n\n`{\n  var _lo, _hi := lo, hi;\n  assert _lo <= _hi && forall _i: int :: _lo <= _i <= _hi ==> _i is T;\n  var i := _lo;\n  while i != _hi\n    invariant _lo <= i <= _hi\n    LoopSpec\n    decreases _hi - i\n  {\n    Body\n    i := i + 1;\n  }\n}\n\n{\n  var _lo, _hi := lo, hi;\n  assert _lo <= _hi && forall _i: int :: _lo <= _i <= _hi ==> _i is T;\n  var i := _hi;\n  while i != lo\n    invariant _lo <= i <= _hi\n    LoopSpec\n    decreases i - _lo\n  {\n    i := i - 1;\n    Body\n  }\n}\n\n{\n  var _lo := lo;\n  assert forall _i: int :: _lo <= _i ==> _i is T;\n  var i := _lo;\n  while true\n    invariant _lo <= i\n    LoopSpec\n  {\n    Body\n    i := i + 1;\n  }\n}\n\n{\n  var _hi := hi;\n  assert forall _i: int :: _i <= _hi ==> _i is T;\n  var i := _hi;\n  while true\n    invariant i <= _hi\n    LoopSpec\n  {\n    i := i - 1;\n    Body\n  }\n}\n`\n\nThe expressions `lo` and `hi` are evaluated just once, before the loop\niterations start.\n\nAlso, in all variations the values of `i` in the body are the values from `lo`\nto, *but not including*, `hi`. This makes it convenient to write common loops,\nincluding these:\n\n`for i := 0 to a.Length {\n  Process(a[i]);\n}\nfor i := a.Length downto 0 {\n  Process(a[i]);\n}\n`\n\nNevertheless, `hi` must be a legal value for the type of the index variable,\nsince that is how the index variable is used in the invariant.\n\nIf the end-expression is not `*`, then no explicit `decreases` is allowed, since\nsuch a loop is already known to terminate. If the end-expression is `*`, then\nthe absence of an explicit `decreases` clause makes it default to `decreases *`.\nSo, if the end-expression is `*` and no explicit `decreases` clause is given,\nthe loop is allowed only in methods that are declared with `decreases *`.\n\nThe directions `to` or `downto` are contextual keywords. That is, these two\nwords are part of the syntax of the `for` loop, but they are not reserved\nkeywords elsewhere.\n\nJust like for while loops, the body of a for-loop may be omitted during\nverification. This suppresses attempts to check assertions (like invariants)\nthat would occur at the end of the loop. Eventually, however a body must be\nprovided; the compiler will not compile a method containing a body-less\nfor-loop. There is more discussion about bodyless loops in [Section\n8.15.4][824].\n\n### 8.14. Break and Continue Statements ([grammar][825])\n\nExamples:\n\n`class A { var f: int }\nmethod m(a: A) {\n  label x:\n  while true {\n    if (*) { break; }\n  }\n  label y: {\n    var z := 1;\n    if * { break y; }\n    z := 2;\n  }\n\n}\n`\n\nBreak and continue statements provide a means to transfer control in a way\ndifferent than the usual nested control structures. There are two forms of each\nof these statements: with and without a label.\n\nIf a label is used, the break or continue statement must be enclosed in a\nstatement with that label. The enclosing statement is called the *target* of the\nbreak or continue.\n\nA `break` statement transfers control to the point immediately following the\ntarget statement. For example, such a break statement can be used to exit a\nsequence of statements in a block statement before reaching the end of the\nblock.\n\nFor example,\n\n`label L: {\n  var n := ReadNext();\n  if n < 0 {\n    break L;\n  }\n  DoSomething(n);\n}\n`\n\nis equivalent to\n\n`{\n  var n := ReadNext();\n  if 0 <= n {\n    DoSomething(n);\n  }\n}\n`\n\nIf no label is specified and the statement lists `n` occurrences of `break`,\nthen the statement must be enclosed in at least `n` levels of loop statements.\nControl continues after exiting `n` enclosing loops. For example,\n\n`method m() {\n  for i := 0 to 10 {\n    for j := 0 to 10 {\n      label X: {\n        for k := 0 to 10 {\n          if j + k == 15 {\n            break break;\n          }\n        }\n      }\n    }\n    // control continues here after the \"break break\", exiting two loops\n  }\n}\n`\n\nNote that a non-labeled `break` pays attention only to loops, not to labeled\nstatements. For example, the labeled block `X` in the previous example does not\nplay a role in determining the target statement of the `break break;`.\n\nFor a `continue` statement, the target statement must be a loop statement. The\ncontinue statement transfers control to the point immediately before the closing\ncurly-brace of the loop body.\n\nFor example,\n\n`method m() {\n  for i := 0 to 100 {\n    if i == 17 {\n      continue;\n    }\n    DoSomething(i);\n  }\n}\nmethod DoSomething(i:int){}\n`\n\nis equivalent to\n\n`method m() {\n  for i := 0 to 100 {\n    if i != 17 {\n      DoSomething(i);\n    }\n  }\n}\nmethod DoSomething(i:int){}\n`\n\nThe same effect can also be obtained by wrapping the loop body in a labeled\nblock statement and then using `break` with a label, but that usually makes for\na more cluttered program:\n\n`method m() {\n  for i := 0 to 100 {\n    label LoopBody: {\n      if i == 17 {\n        break LoopBody;\n      }\n      DoSomething(i);\n    }\n  }\n}\nmethod DoSomething(i:int){}\n`\n\nStated differently, `continue` has the effect of ending the current loop\niteration, after which control continues with any remaining iterations. This is\nmost natural for `for` loops. For a `while` loop, be careful to make progress\ntoward termination before a `continue` statement. For example, the following\nprogram snippet shows an easy mistake to make (the verifier will complain that\nthe loop may not terminate):\n\n`method m() {\n  var i := 0;\n  while i < 100 {\n    if i == 17 {\n      continue; // error: this would cause an infinite loop\n    }\n    DoSomething(i);\n    i := i + 1;\n  }\n}\nmethod DoSomething(i:int){}\n`\n\nThe `continue` statement can give a label, provided the label is a label of a\nloop. For example,\n\n`method m() {\n  label Outer:\n  for i := 0 to 100 {\n    for j := 0 to 100 {\n      if i + j == 19 {\n        continue Outer;\n      }\n      WorkIt(i, j);\n    }\n    PostProcess(i);\n    // the \"continue Outer\" statement above transfers control to here\n  }\n}\nmethod WorkIt(i:int, j:int){}\nmethod PostProcess(i:int){}\n`\n\nIf a non-labeled continue statement lists `n` occurrences of `break` before the\n`continue` keyword, then the statement must be enclosed in at least `n + 1`\nlevels of loop statements. The effect is to `break` out of the `n` most closely\nenclosing loops and then `continue` the iterations of the next loop. That is,\n`n` occurrences of `break` followed by one more `break;` will break out of `n`\nlevels of loops and then do a `break`, whereas `n` occurrences of `break`\nfollowed by `continue;` will break out of `n` levels of loops and then do a\n`continue`.\n\nFor example, the `WorkIt` example above can equivalently be written without\nlabels as\n\n`method m() {\n  for i := 0 to 100 {\n    for j := 0 to 100 {\n      if i + j == 19 {\n        break continue;\n      }\n      WorkIt(i, j);\n    }\n    PostProcess(i);\n    // the \"break continue\" statement above transfers control to here\n  }\n}\nmethod WorkIt(i:int, j:int){}\nmethod PostProcess(i:int){}\n`\n\nNote that a loop invariant is checked on entry to a loop and at the closing\ncurly-brace of the loop body. It is not checked at break statements. For\ncontinue statements, the loop invariant is checked as usual at the closing\ncurly-brace that the continue statement jumps to. This checking ensures that the\nloop invariant holds at the very top of every iteration. Commonly, the only exit\nout of a loop happens when the loop guard evaluates to `false`. Since no state\nis changed between the top of an iteration (where the loop invariant is known to\nhold) and the evaluation of the loop guard, one can also rely on the loop\ninvariant to hold immediately following the loop. But the loop invariant may not\nhold immediately following a loop if a loop iteration changes the program state\nand then exits the loop with a break statement.\n\nFor example, the following program verifies:\n\n`method m() {\n  var i := 0;\n  while i < 10\n    invariant 0 <= i <= 10\n  {\n    if P(i) {\n      i := i + 200;\n      break;\n    }\n    i := i + 1;\n  }\n  assert i == 10 || 200 <= i < 210;\n}\npredicate P(i:int)\n`\n\nTo explain the example, the loop invariant `0 <= i <= 10` is known to hold at\nthe very top of each iteration, that is, just before the loop guard `i < 10` is\nevaluated. If the loop guard evaluates to `false`, then the negated guard\ncondition (`10 <= i`) and the invariant hold, so `i == 10` will hold immediately\nafter the loop. If the loop guard evaluates to `true` (that is, `i < 10` holds),\nthen the loop body is entered. If the test `P(i)` then evaluates to `true`, the\nloop adds `200` to `i` and breaks out of the loop, so on such a path, `200 <= i\n< 210` is known to hold immediately after the loop. This is summarized in the\nassert statement in the example. So, remember, a loop invariant holds at the\nvery top of every iteration, not necessarily immediately after the loop.\n\n### 8.15. Loop Specifications\n\nFor some simple loops, such as those mentioned previously, Dafny can figure out\nwhat the loop is doing without more help. However, in general the user must\nprovide more information in order to help Dafny prove the effect of the loop.\nThis information is provided by a *loop specification*. A loop specification\nprovides information about invariants, termination, and what the loop modifies.\nFor additional tutorial information see [@KoenigLeino:MOD2011] or the [online\nDafny tutorial][826].\n\n#### 8.15.1. Loop invariants\n\nLoops present a problem for specification-based reasoning. There is no way to\nknow in advance how many times the code will go around the loop and a tool\ncannot reason about every one of a possibly unbounded sequence of unrollings. In\norder to consider all paths through a program, specification-based program\nverification tools require loop invariants, which are another kind of\nannotation.\n\nA loop invariant is an expression that holds just prior to the loop test, that\nis, upon entering a loop and after every execution of the loop body. It captures\nsomething that is invariant, i.e. does not change, about every step of the loop.\nNow, obviously we are going to want to change variables, etc. each time around\nthe loop, or we wouldn’t need the loop. Like pre- and postconditions, an\ninvariant is a property that is preserved for each execution of the loop,\nexpressed using the same boolean expressions we have seen. For example,\n\n`var i := 0;\nwhile i < n\n  invariant 0 <= i\n{\n  i := i + 1;\n}\n`\n\nWhen you specify an invariant, Dafny proves two things: the invariant holds upon\nentering the loop, and it is preserved by the loop. By preserved, we mean that\nassuming that the invariant holds at the beginning of the loop (just prior to\nthe loop test), we must show that executing the loop body once makes the\ninvariant hold again. Dafny can only know upon analyzing the loop body what the\ninvariants say, in addition to the loop guard (the loop condition). Just as\nDafny will not discover properties of a method on its own, it will not know that\nany but the most basic properties of a loop are preserved unless it is told via\nan invariant.\n\n#### 8.15.2. Loop termination\n\nDafny proves that code terminates, i.e. does not loop forever, by using\n`decreases` annotations. For many things, Dafny is able to guess the right\nannotations, but sometimes it needs to be made explicit. There are two places\nDafny proves termination: loops and recursion. Both of these situations require\neither an explicit annotation or a correct guess by Dafny.\n\nA `decreases` annotation, as its name suggests, gives Dafny an expression that\ndecreases with every loop iteration or recursive call. There are two conditions\nthat Dafny needs to verify when using a `decreases` expression:\n\n* that the expression actually gets smaller, and\n* that it is bounded.\n\nThat is, the expression must strictly decrease in a well-founded ordering (cf.\n[Section 12.7][827]).\n\nMany times, an integral value (natural or plain integer) is the quantity that\ndecreases, but other values can be used as well. In the case of integers, the\nbound is assumed to be zero. For each loop iteration the `decreases` expression\nat the end of the loop body must be strictly smaller than its value at the\nbeginning of the loop body (after the loop test). For integers, the well-founded\nrelation between `x` and `X` is `x < X && 0 <= X`. Thus if the `decreases` value\n(`X`) is negative at the loop test, it must exit the loop, since there is no\npermitted value for `x` to have at the end of the loop body.\n\nFor example, the following is a proper use of `decreases` on a loop:\n\n`method m(n: nat){\n  var i := n;\n  while 0 < i\n    invariant 0 <= i\n    decreases i\n  {\n    i := i - 1;\n  }\n}\n`\n\nHere Dafny has all the ingredients it needs to prove termination. The variable\n`i` becomes smaller each loop iteration, and is bounded below by zero. When `i`\nbecomes 0, the lower bound of the well-founded order, control flow exits the\nloop.\n\nThis is fine, except the loop is backwards compared to most loops, which tend to\ncount up instead of down. In this case, what decreases is not the counter\nitself, but rather the distance between the counter and the upper bound. A\nsimple trick for dealing with this situation is given below:\n\n`method m(m: nat, n: int) \n  requires m <= n \n{\n  var i := m;\n  while i < n\n    invariant 0 <= i <= n\n    decreases n - i\n  {\n    i := i + 1;\n  }\n}\n`\n\nThis is actually Dafny’s guess for this situation, as it sees `i < n` and\nassumes that `n - i` is the quantity that decreases. The upper bound of the loop\ninvariant implies that `0 <= n – i`, and gives Dafny a lower bound on the\nquantity. This also works when the bound `n` is not constant, such as in the\nbinary search algorithm, where two quantities approach each other, and neither\nis fixed.\n\nIf the `decreases` clause of a loop specifies `*`, then no termination check\nwill be performed. Use of this feature is sound only with respect to partial\ncorrectness.\n\n#### 8.15.3. Loop framing\n\nThe specification of a loop also includes *framing*, which says what the loop\nmodifies. The loop frame includes both local variables and locations in the\nheap.\n\nFor local variables, the Dafny verifier performs a syntactic scan of the loop\nbody to find every local variable or out-parameter that occurs as a left-hand\nside of an assignment. These variables are called *syntactic assignment targets\nof the loop*, or *syntactic loop targets* for short. Any local variable or\nout-parameter that is not a syntactic assignment target is known by the verifier\nto remain unchanged by the loop.\n\nThe heap may or may not be a syntactic loop target. It is when the loop body\nsyntactically contains a statement that can modify a heap location. This\nincludes calls to compiled methods, even if such a method has an empty\n`modifies` clause, since a compiled method is always allowed to allocate new\nobjects and change their values in the heap.\n\nIf the heap is not a syntactic loop target, then the verifier knows the heap\nremains unchanged by the loop. If the heap *is* a syntactic loop target, then\nthe loop’s effective `modifies` clause determines what is allowed to be modified\nby iterations of the loop body.\n\nA loop can use `modifies` clauses to declare the effective `modifies` clause of\nthe loop. If a loop does not explicitly declare any `modifies` clause, then the\neffective `modifies` clause of the loop is the effective `modifies` clause of\nthe most tightly enclosing loop or, if there is no enclosing loop, the\n`modifies` clause of the enclosing method.\n\nIn most cases, there is no need to give an explicit `modifies` clause for a\nloop. The one case where it is sometimes needed is if a loop modifies less than\nis allowed by the enclosing method. Here are two simple methods that illustrate\nthis case:\n\n`class Cell {\n  var data: int\n}\n\nmethod M0(c: Cell, d: Cell)\n  requires c != d\n  modifies c, d\n  ensures c.data == d.data == 100\n{\n  c.data, d.data := 100, 0;\n  var i := 0;\n  while i < 100\n    invariant d.data == i\n    // Needs \"invariant c.data == 100\" or \"modifies d\" to verify\n  {\n    d.data := d.data + 1;\n    i := i + 1;\n  }\n}\n\nmethod M1(c: Cell)\n  modifies c\n  ensures c.data == 100\n{\n  c.data := 100;\n  var i := 0;\n  while i < 100\n    // Needs \"invariant c.data == 100\" or \"modifies {}\" to verify\n  {\n    var tmp := new Cell;\n    tmp.data := i;\n    i := i + 1;\n  }\n}\n`\n\nIn `M0`, the effective `modifies` clause of the loop is `modifies c, d`.\nTherefore, the method’s postcondition `c.data == 100` is not provable. To remedy\nthe situation, the loop needs to be declared either with `invariant c.data ==\n100` or with `modifies d`.\n\nSimilarly, the effective `modifies` clause of the loop in `M1` is `modifies c`.\nTherefore, the method’s postcondition `c.data == 100` is not provable. To remedy\nthe situation, the loop needs to be declared either with `invariant c.data ==\n100` or with `modifies {}`.\n\nWhen a loop has an explicit `modifies` clause, there is, at the top of every\niteration, a proof obligation that\n\n* the expressions given in the `modifies` clause are [well-formed][828], and\n* everything indicated in the loop `modifies` clause is allowed to be modified\n  by the (effective `modifies` clause of the) enclosing loop or method.\n\n#### 8.15.4. Body-less methods, functions, loops, and aggregate statements\n\nMethods (including lemmas), functions, loops, and `forall` statements are\nordinarily declared with a body, that is, a curly-braces pair that contains (for\nmethods, loops, and `forall`) a list of zero-or-more statements or (for a\nfunction) an expression. In each case, Dafny syntactically allows these\nconstructs to be given without a body (no braces at all). This is to allow\nprogrammers to temporarily postpone the development of the implementation of the\nmethod, function, loop, or aggregate statement.\n\nIf a method has no body, there is no difference for callers of the method.\nCallers still reason about the call in terms of the method’s specification. But\nwithout a body, the verifier has no method implementation to check against the\nspecification, so the verifier is silently happy. The compiler, on the other\nhand, will complain if it encounters a body-less method, because the compiler is\nsupposed to generate code for the method, but it isn’t clever enough to do that\nby itself without a given method body. If the method implementation is provided\nby code written outside of Dafny, the method can be marked with an `{:extern}`\nannotation, in which case the compiler will no longer complain about the absence\nof a method body; the verifier will not object either, even though there is now\nno proof that the Dafny specifications are satisfied by the external\nimplementation.\n\nA lemma is a special kind of (ghost) method. Callers are therefore unaffected by\nthe absence of a body, and the verifier is silently happy with not having a\nproof to check against the lemma specification. Despite a lemma being ghost, it\nis still the compiler that checks for, and complains about, body-less lemmas. A\nbody-less lemma is an unproven lemma, which is often known as an *axiom*. If you\nintend to use a lemma as an axiom, omit its body and add the attribute\n`{:axiom}`, which causes the compiler to suppress its complaint about the lack\nof a body.\n\nSimilarly, calls to a body-less function use only the specification of the\nfunction. The verifier is silently happy, but the compiler complains (whether or\nnot the function is ghost). As for methods and lemmas, the `{:extern}` and\n`{:axiom}` attributes can be used to suppress the compiler’s complaint.\n\nBy supplying a body for a method or function, the verifier will in effect show\nthe feasibility of the specification of the method or function. By supplying an\n`{:extern}` or `{:axiom}` attribute, you are taking that responsibility into\nyour own hands. Common mistakes include forgetting to provide an appropriate\n`modifies` or `reads` clause in the specification, or forgetting that the\nresults of functions in Dafny (unlike in most other languages) must be\ndeterministic.\n\nJust like methods and functions have two sides, callers and implementations,\nloops also have two sides. One side (analogous to callers) is the context that\nuses the loop. That context treats the loop in the same way, using its\nspecifications, regardless of whether or not the loop has a body. The other side\nis the loop body, that is, the implementation of each loop iteration. The\nverifier checks that the loop body maintains the loop invariant and that the\niterations will eventually terminate, but if there is no loop body, the verifier\nis silently happy. This allows you to temporarily postpone the authoring of the\nloop body until after you’ve made sure that the loop specification is what you\nneed in the context of the loop.\n\nThere is one thing that works differently for body-less loops than for loops\nwith bodies. It is the computation of syntactic loop targets, which become part\nof the loop frame (see [Section 8.15.3][829]). For a body-less loop, the local\nvariables computed as part of the loop frame are the mutable variables that\noccur free in the loop specification. The heap is considered a part of the loop\nframe if it is used for mutable fields in the loop specification or if the loop\nhas an explicit `modifies` clause. The IDE will display the computed loop frame\nin hover text.\n\nFor example, consider\n\n`class Cell {\n  var data: int\n  const K: int\n}\n\nmethod BodylessLoop(n: nat, c: Cell)\n  requires c.K == 8\n  modifies c\n{\n  c.data := 5;\n  var a, b := n, n;\n  for i := 0 to n\n    invariant c.K < 10\n    invariant a <= n\n    invariant c.data < 10\n  assert a == n;\n  assert b == n;\n  assert c.data == 5;\n}\n`\n\nThe loop specification mentions local variable `a`, and thus `a` is considered\npart of the loop frame. Since what the loop invariant says about `a` is not\nstrong enough to prove the assertion `a == n` that follows the loop, the\nverifier complains about that assertion.\n\nLocal variable `b` is not mentioned in the loop specification, and thus `b` is\nnot included in the loop frame. Since in-parameter `n` is immutable, it is not\nincluded in the loop frame, either, despite being mentioned in the loop\nspecification. For these reasons, the assertion `b == n` is provable after the\nloop.\n\nBecause the loop specification mentions the mutable field `data`, the heap\nbecomes part of the loop frame. Since the loop invariant is not strong enough to\nprove the assertion `c.data == 5` that follows the loop, the verifier complains\nabout that assertion. On the other hand, had `c.data < 10` not been mentioned in\nthe loop specification, the assertion would be verified, since field `K` is then\nthe only field mentioned in the loop specification and `K` is immutable.\n\nFinally, the aggregate statement (`forall`) can also be given without a body.\nSuch a statement claims that the given `ensures` clause holds true for all\nvalues of the bound variables that satisfy the given range constraint. If the\nstatement has no body, the program is in effect omitting the proof, much like a\nbody-less lemma is omitting the proof of the claim made by the lemma\nspecification. As with the other body-less constructs above, the verifier is\nsilently happy with a body-less `forall` statement, but the compiler will\ncomplain.\n\n### 8.16. Print Statement ([grammar][830])\n\nExamples:\n\n`print 0, x, list, array;\n`\n\nThe `print` statement is used to print the values of a comma-separated list of\nexpressions to the console (standard-out). The generated code uses\ntarget-language-specific idioms to perform this printing. The expressions may of\ncourse include strings that are used for captions. There is no implicit new line\nadded, so to add a new line you must include `\"\\n\"` as part of one of the\nexpressions. Dafny automatically creates implementations of methods that convert\nvalues to strings for all Dafny data types. For example,\n\n`datatype Tree = Empty | Node(left: Tree, data: int, right: Tree)\nmethod Main()\n{\n  var x : Tree := Node(Node(Empty, 1, Empty), 2, Empty);\n  print \"x=\", x, \"\\n\";\n}\n`\n\nproduces this output:\n\n`x=Tree.Node(Tree.Node(Tree.Empty, 1, Tree.Empty), 2, Tree.Empty)\n`\n\nNote that Dafny does not have method overriding and there is no mechanism to\noverride the built-in value->string conversion. Nor is there a way to explicitly\ninvoke this conversion. One can always write an explicit function to convert a\ndata value to a string and then call it explicitly in a `print` statement or\nelsewhere.\n\nBy default, Dafny does not keep track of print effects, but this can be changed\nusing the `--track-print-effects` command line flag. `print` statements are\nallowed only in non-ghost contexts and not in expressions, with one exception.\nThe exception is that a function-by-method may contain `print` statements, whose\neffect may be observed as part of the run-time evaluation of such functions\n(unless `--track-print-effects` is enabled).\n\nThe verifier checks that each expression is well-defined, but otherwise ignores\nthe `print` statement.\n\n\n**Note:** `print` writes to standard output. To improve compatibility with\nnative code and external libraries, the process of encoding Dafny strings passed\nto `print` into standard-output byte strings is left to the runtime of the\nlanguage that the Dafny code is compiled to (some language runtimes use UTF-8 in\nall cases; others obey the current locale or console encoding).\n\nIn most cases, the standard-output encoding can be set before running the\ncompiled program using language-specific flags or environment variables (e.g.\n`-Dfile.encoding=` for Java). This is in fact how `dafny run` operates: it uses\nlanguage-specific flags and variables to enforce UTF-8 output regardless of the\ntarget language (but note that the C++ and Go backends currently have limited\nsupport for UTF-16 surrogates).\n\n### 8.17. Assert statement ([grammar][831])\n\nExamples:\n\n`assert i > 0;\nassert IsPositive: i > 0;\nassert i > 0 by {\n ...\n}\n`\n\n`Assert` statements are used to express logical propositions that are expected\nto be true. Dafny will attempt to prove that the assertion is true and give an\nerror if the assertion cannot be proven. Once the assertion is proved, its truth\nmay aid in proving subsequent deductions. Thus if Dafny is having a difficult\ntime verifying a method, the user may help by inserting assertions that Dafny\ncan prove, and whose truth may aid in the larger verification effort, much as\nlemmas might be used in mathematical proofs.\n\n`Assert` statements are ignored by the compiler.\n\nIn the `by` form of the `assert` statement, there is an additional block of\nstatements that provide the Dafny verifier with additional proof steps. Those\nstatements are often a sequence of [lemmas][832], [`calc`][833] statements,\n[`reveal`][834] statements or other `assert` statements, combined with ghost\ncontrol flow, ghost variable declarations and ghost update statements of\nvariables declared in the `by` block. The intent is that those statements be\nevaluated in support of proving the `assert` statement. For that purpose, they\ncould be simply inserted before the `assert` statement. But by using the `by`\nblock, the statements in the block are discarded after the assertion is proved.\nAs a result, the statements in the block do not clutter or confuse the solver in\nperforming subsequent proofs of assertions later in the program. Furthermore, by\nisolating the statements in the `by` block, their purpose – to assist in proving\nthe given assertion – is manifest in the structure of the code.\n\nExamples of this form of assert are given in the section of the [`reveal`][835]\nstatement and in [*Different Styles of Proof*][836]\n\nAn assert statement may have a label, whose use is explained in [Section\n8.20.1][837].\n\nThe attributes recognized for assert statements are discussed in [Section\n11.4][838].\n\nUsing `...` as the argument of the statement is deprecated.\n\nAn assert statement can have [custom error and success messages][839].\n\n### 8.18. Assume Statement ([grammar][840])\n\nExamples:\n\n`assume i > 0;\nassume {:axiom} i > 0 ==> -i < 0;\n`\n\nThe `assume` statement lets the user specify a logical proposition that Dafny\nmay assume to be true without proof. If in fact the proposition is not true this\nmay lead to invalid conclusions.\n\nAn `assume` statement would ordinarily be used as part of a larger verification\neffort where verification of some other part of the program required the\nproposition. By using the `assume` statement the other verification can proceed.\nThen when that is completed the user would come back and replace the `assume`\nwith `assert`.\n\nTo help the user not forget about that last step, a warning is emitted for any\nassume statement. Adding the `{:axiom}` attribute to the assume will suppress\nthe warning, indicating the user takes responsibility for being absolutely sure\nthat the proposition is indeed true.\n\nUsing `...` as the argument of the statement is deprecated.\n\n### 8.19. Expect Statement ([grammar][841])\n\nExamples:\n\n`expect i > 0;\nexpect i > 0, \"i is positive\";\n`\n\nThe `expect` statement states a boolean expression that is (a) assumed to be\ntrue by the verifier and (b) checked to be true at run-time. That is, the\ncompiler inserts into the run-time executable a check that the given expression\nis true; if the expression is false, then the execution of the program halts\nimmediately. If a second argument is given, it may be a value of any type. That\nvalue is converted to a string (just like the `print` statement) and the string\nis included in the message emitted by the program when it halts; otherwise a\ndefault message is emitted.\n\nBecause the expect expression and optional second argument are compiled, they\ncannot be ghost expressions.\n\nThe `expect` statement behaves like `assume` for the verifier, but also inserts\na run-time check that the assumption is indeed correct (for the test cases used\nat run-time).\n\nHere are a few use-cases for the `expect` statement.\n\nA) To check the specifications of external methods.\n\nConsider an external method `Random` that takes a `nat` as input and returns a\n`nat` value that is less than the input. Such a method could be specified as\n\n`method {:extern} Random(n: nat) returns (r: nat)\n  ensures r < n\n`\n\nBut because there is no body for `Random` (only the external non-dafny\nimplementation), it cannot be verified that `Random` actually satisfies this\nspecification.\n\nTo mitigate this situation somewhat, we can define a wrapper function,\n`Random'`, that calls `Random` but in which we can put some run-time checks:\n\n`method {:extern} Random(n: nat) returns (r: nat)\n\nmethod Random'(n: nat) returns (r: nat)\n  ensures r < n\n{\n  r := Random(n);\n  expect r < n;\n}\n`\n\nHere we can verify that `Random'` satisfies its own specification, relying on\nthe unverified specification of `Random`. But we are also checking at run-time\nthat any input-output pairs for `Random` encountered during execution do satisfy\nthe specification, as they are checked by the `expect` statement.\n\nNote, in this example, two problems still remain. One problem is that the\nout-parameter of the extern `Random` has type `nat`, but there is no check that\nthe value returned really is non-negative. It would be better to declare the\nout-parameter of `Random` to be `int` and to include `0 <= r` in the condition\nchecked by the `expect` statement in `Random'`. The other problem is that\n`Random` surely will need `n` to be strictly positive. This can be fixed by\nadding `requires n != 0` to `Random'` and `Random`.\n\nB) Run-time testing\n\nVerification and run-time testing are complementary and both have their role in\nassuring that software does what is intended. Dafny can produce executables and\nthese can be instrumented with unit tests. Annotating a method with the\n`{:test}` attribute indicates to the compiler that it should produce target code\nthat is correspondingly annotated to mark the method as a unit test (e.g., an\nXUnit test) in the target language. Alternatively, the `dafny test` command will\nproduce a main method that invokes all methods with the `{:test}` attribute, and\nhence does not depend on any testing framework in the target language. Within\nsuch methods one might use `expect` statements (as well as `print` statements)\nto insert checks that the target program is behaving as expected.\n\nC) Debugging\n\nWhile developing a new program, one work style uses proof attempts and runtime\ntests in combination. If an assert statement does not prove, one might run the\nprogram with a corresponding expect statement to see if there are some\nconditions when the assert is not actually true. So one might have paired\nassert/expect statements:\n\n`assert _P_;\nexpect _P_;\n`\n\nOnce the program is debugged, both statements can be removed. Note that it is\nimportant that the `assert` come before the `expect`, because by the verifier,\nthe `expect` is interpreted as an `assume`, which would automatically make a\nsubsequent `assert` succeed.\n\nD) Compiler tests\n\nThe same approach might be taken to assure that compiled code is behaving at\nrun-time consistently with the statically verified code, one can again use\npaired assert/expect statements with the same expression:\n\n`assert _P_;\nexpect _P_;\n`\n\nThe verifier will check that *P* is always true at the given point in a program\n(at the `assert` statement).\n\nAt run-time, the compiler will insert checks that the same predicate, in the\n`expect` statement, is true. Any difference identifies a compiler bug. Again the\n`expect` must be after the `assert`: if the `expect` is first, then the verifier\nwill interpret the `expect` like an `assume`, in which case the `assert` will be\nproved trivially and potential unsoundness will be hidden.\n\nUsing `...` as the argument of the statement is deprecated.\n\n### 8.20. Reveal Statement ([grammar][842])\n\nExamples:\n\n`reveal f(), L;\n`\n\nThe `reveal` statement makes available to the solver information that is\notherwise not visible, as described in the following subsections.\n\n#### 8.20.1. Revealing assertions\n\nIf an assert statement has an expression label, then a proof of that assertion\nis attempted, but the assertion itself is not used subsequently. For example,\nconsider\n\n`method m(i: int) {\n  assert x: i == 0; // Fails\n  assert i == 0; // Fails also because the label 'x:' hides the first assertion\n}\n`\n\nThe first assertion fails. Without the label `x:`, the second would succeed\nbecause after a failing assertion, the assertion is assumed in the context of\nthe rest of the program. But with the label, the first assertion is hidden from\nthe rest of the program. That assertion can be *revealed* by adding a `reveal`\nstatement:\n\n`method m(i: int) {\n  assert x: i == 0; // Fails\n  reveal x;\n  assert i == 0; // Now succeeds\n}\n`\n\nor\n\n`method m(i: int) {\n  assert x: i == 0; // Fails\n  assert i == 0 by { reveal x; } // Now succeeds\n}\n`\n\nAt the point of the `reveal` statement, the labeled assertion is made visible\nand can be used in proving the second assertion. In this example there is no\npoint to labeling an assertion and then immediately revealing it. More useful\nare the cases where the reveal is in an assert-by block or much later in the\nmethod body.\n\n#### 8.20.2. Revealing preconditions\n\nIn the same way as assertions, preconditions can be labeled. Within the body of\na method, a precondition is an assumption; if the precondition is labeled then\nthat assumption is not visible in the body of the method. A `reveal` statement\nnaming the label of the precondition then makes the assumption visible.\n\nHere is a toy example:\n\n`method m(x: int, y: int) returns (z: int)\n  requires L: 0 < y\n  ensures z == x+y\n  ensures x < z\n{\n  z := x + y;\n}\n`\n\nThe above method will not verify. In particular, the second postcondition cannot\nbe proved. However, if we add a `reveal L;` statement in the body of the method,\nthen the precondition is visible and both postconditions can be proved.\n\nOne could also use this style:\n\n`method m(x: int, y: int) returns (z: int)\n  requires L: 0 < y\n  ensures z == x+y\n  ensures x < z\n{\n  z := x + y;\n  assert x < z by { reveal L; }\n}\n`\n\nThe reason to possibly hide a precondition is the same as the reason to hide\nassertions: sometimes less information is better for the solver as it helps the\nsolver focus attention on relevant information.\n\nSection 7 of [http://leino.science/papers/krml276.html][843] provides an\nextended illustration of this technique to make all the dependencies of an\n`assert` explicit.\n\n#### 8.20.3. Hiding and revealing function bodies\n\nBy default, function bodies are revealed and available for constructing proofs\nof assertions that use those functions. However, if a function body is not\nnecessary for a proof, the runtime of the proof can be improved by hiding that\nbody. To do this, use the hide statement. Here’s an example:\n\n`// We are using the options --isolate-assertions and --type-system-refresh\nmethod Outer(x: int)\n  requires ComplicatedBody(x) \n{\n  hide ComplicatedBody; // This hides the body of ComplicatedBody for the remain\nder of the method.\n  \n  // The body of ComplicatedBody is not needed to prove the requires of Inner\n  var y := Inner(x);\n  \n  // We reveal ComplicatedBody inside the following expression, to prove that we\n are not dividing by zero\n  var z := (reveal ComplicatedBody; 10 / x);\n}\n\nmethod Inner(x: int) returns (r: int)\n  requires ComplicatedBody(x)\n\npredicate ComplicatedBody(x: int) {\n  x != 0 && true // pretend true is complicated \n}\n`\n\nHere is a larger example that shows the rules for hide and reveal statements\nwhen used on functions:\n\n`// We are using the options --isolate-assertions and --type-system-refresh\npredicate P() { true }\npredicate Q(x: bool) requires x\n\nmethod Foo() {\n  var q1 := Q(hide P; P()); // error, precondition not satisfied\n  var q2 := Q(hide P; reveal P; P()); // no error\n  \n  hide *;\n  \n  var q3 := Q(P()); // error, precondition not satisfied\n  var q4 := Q(reveal P; P()); // no error\n  \n  if (*) {\n    reveal P;\n    assert P();\n  } else {\n    assert P(); // error\n  }\n  reveal P;\n  if (*) {\n    assert P();\n  } else {\n    hide *;\n    assert P(); // error\n  }\n  \n  hide *;\n  if (*) {\n    reveal P;\n  } else {\n    reveal P;\n  }\n  assert P(); // error, since the previous two reveal statements are out of scop\ne\n}\n`\n\n#### 8.20.4. Revealing constants\n\nA `const` declaration can be `opaque`. If so the value of the constant is not\nknown in reasoning about its uses, just its type and the fact that the value\ndoes not change. The constant’s identifier can be listed in a reveal statement.\nIn that case, like other revealed items, the value of the constant will be known\nto the reasoning engine until the end of the block containing the reveal\nstatement.\n\nA label or locally declared name in a method body will shadow an opaque constant\nwith the same name outside the method body, making it unable to be revealed\nwithout using a qualified name.\n\n### 8.21. Forall Statement ([grammar][844])\n\nExamples:\n\n`forall i | 0 <= i < a.Length {\n  a[i] := 0;\n}\nforall i | 0 <= i < 100 {\n  P(i); // P a lemma\n}\nforall i | 0 <= i < 100\n  ensures i < 1000 {\n} \n`\n\nThe `forall` statement executes the body simultaneously for all quantified\nvalues in the specified quantifier domain. You can find more details about\n[quantifier domains here][845].\n\nThere are several variant uses of the `forall` statement and there are a number\nof restrictions. A `forall` statement can be classified as one of the following:\n\n* *Assign* - the `forall` statement is used for simultaneous assignment. The\n  target must be an array element or an object field.\n* *Call* - The body consists of a single call to a ghost method without side\n  effects\n* *Proof* - The `forall` has `ensure` expressions which are effectively\n  quantified or proved by the body (if present).\n\nAn *assign* `forall` statement performs simultaneous assignment. The left-hand\nsides must denote different l-values, unless the corresponding right-hand sides\nalso coincide.\n\nThe following is an excerpt of an example given by Leino in [*Developing\nVerified Programs with Dafny*][846]. When the buffer holding the queue needs to\nbe resized, the `forall` statement is used to simultaneously copy the old\ncontents into the new buffer.\n\n`class SimpleQueue<Data(0)>\n{\n  ghost var Contents: seq<Data>\n  var a: array<Data>  // Buffer holding contents of queue.\n  var m: int          // Index head of queue.\n  var n: int          // Index just past end of queue\n   \n  method Enqueue(d: Data)\n    requires a.Length > 0\n    requires 0 <= m <= n <= a.Length\n    modifies this, this.a\n    ensures Contents == old(Contents) + [d]\n  {\n    if n == a.Length {\n      var b := a;\n      if m == 0 { b := new Data[2 * a.Length]; }\n      forall i | 0 <= i < n - m {\n        b[i] := a[m + i];\n      }\n      a, m, n := b, 0, n - m;\n    }\n    a[n], n, Contents := d, n + 1, Contents + [d];\n  }\n}\n`\n\nHere is an example of a *call* `forall` statement and the callee. This is\ncontained in the `CloudMake-ConsistentBuilds.dfy` test in the Dafny repository.\n\n`method m() {\n  forall cmd', deps', e' |\n       Hash(Loc(cmd', deps', e')) == Hash(Loc(cmd, deps, e)) {\n    HashProperty(cmd', deps', e', cmd, deps, e);\n  }\n}\n\nlemma HashProperty(cmd: Expression, deps: Expression, ext: string,\n    cmd': Expression, deps': Expression, ext': string)\n  requires Hash(Loc(cmd, deps, ext)) == Hash(Loc(cmd', deps', ext'))\n  ensures cmd == cmd' && deps == deps' && ext == ext'\n`\n\nThe following example of a *proof* `forall` statement comes from the same file:\n\n`forall p | p in DomSt(stCombinedC.st) && p in DomSt(stExecC.st)\n  ensures GetSt(p, stCombinedC.st) == GetSt(p, stExecC.st)\n{\n  assert DomSt(stCombinedC.st) <= DomSt(stExecC.st);\n  assert stCombinedC.st == Restrict(DomSt(stCombinedC.st),\n                                               stExecC.st);\n}\n`\n\nMore generally, the statement\n\n`forall x | P(x) { Lemma(x); }\n`\n\nis used to invoke `Lemma(x)` on all `x` for which `P(x)` holds. If `Lemma(x)`\nensures `Q(x)`, then the forall statement establishes\n\n`forall x :: P(x) ==> Q(x).\n`\n\nThe `forall` statement is also used extensively in the de-sugared forms of\nco-predicates and co-lemmas. See [datatypes][847].\n\n### 8.22. Modify Statement ([grammar][848])\n\nThe effect of the `modify` statement is to say that some undetermined\nmodifications have been made to any or all of the memory locations specified by\nthe given [frame expressions][849]. In the following example, a value is\nassigned to field `x` followed by a `modify` statement that may modify any field\nin the object. After that we can no longer prove that the field `x` still has\nthe value we assigned to it. The now unknown values still are values of their\ntype (e.g. of the subset type or newtype).\n\n`class MyClass {\n  var x: int\n  method N()\n    modifies this\n  {\n    x := 18;\n    modify this;\n    assert x == 18;  // error: cannot conclude this here\n  }\n}\n`\n\nUsing `...` as the argument of the statement is deprecated.\n\nThe form of the `modify` statement which includes a block statement is also\ndeprecated.\n\nThe [havoc assignment][850] also sets a variable or field to some arbitrary (but\ntype-consistent) value. The difference is that the havoc assignment acts on one\nLHS variable or memory location; the modify statement acts on all the fields of\nan object.\n\n### 8.23. Calc Statement ([grammar][851])\n\nSee also: [Verified Calculations][852].\n\nThe `calc` statement supports *calculational proofs* using a language feature\ncalled *program-oriented calculations* (poC). This feature was introduced and\nexplained in the [*Verified Calculations*] paper by Leino and\nPolikarpova[@LEINO:Dafny:Calc]. Please see that paper for a more complete\nexplanation of the `calc` statement. We here mention only the highlights.\n\nCalculational proofs are proofs by stepwise formula manipulation as is taught in\nelementary algebra. The typical example is to prove an equality by starting with\na left-hand-side and through a series of transformations morph it into the\ndesired right-hand-side.\n\nNon-syntactic rules further restrict hints to only ghost and side-effect free\nstatements, as well as imposing a constraint that only chain-compatible\noperators can be used together in a calculation. The notion of\nchain-compatibility is quite intuitive for the operators supported by poC; for\nexample, it is clear that “<” and “>” cannot be used within the same\ncalculation, as there would be no relation to conclude between the first and the\nlast line. See the [paper][Verified Calculations] for a more formal treatment of\nchain-compatibility.\n\nNote that we allow a single occurrence of the intransitive operator “!=” to\nappear in a chain of equalities (that is, “!=” is chain-compatible with equality\nbut not with any other operator, including itself). Calculations with fewer than\ntwo lines are allowed, but have no effect. If a step operator is omitted, it\ndefaults to the calculation-wide operator, defined after the `calc` keyword. If\nthat operator is omitted, it defaults to equality.\n\nHere is an example using `calc` statements to prove an elementary algebraic\nidentity. As it turns out, Dafny is able to prove this without the `calc`\nstatements, but the example illustrates the syntax.\n\n`lemma docalc(x : int, y: int)\n  ensures (x + y) * (x + y) == x * x + 2 * x * y + y * y\n{\n  calc {\n    (x + y) * (x + y);\n    ==\n    // distributive law: (a + b) * c == a * c + b * c\n    x * (x + y) + y * (x + y);\n    ==\n    // distributive law: a * (b + c) == a * b + a * c\n    x * x + x * y + y * x + y * y;\n    ==\n    calc {\n            y * x;\n      ==\n            x * y;\n    }\n    x * x + x * y + x * y + y * y;\n    ==\n    calc {\n      x * y + x * y;\n      ==\n      // a = 1 * a\n      1 * x * y + 1 * x * y;\n      ==\n      // Distributive law\n      (1 + 1) * x * y;\n      ==\n      2 * x * y;\n    }\n    x * x + 2 * x * y + y * y;\n  }\n}\n`\n\nHere we started with `(x + y) * (x + y)` as the left-hand-side expressions and\ngradually transformed it using distributive, commutative and other laws into the\ndesired right-hand-side.\n\nThe justification for the steps are given as comments or as nested `calc`\nstatements that prove equality of some sub-parts of the expression.\n\nThe `==` operators show the relation between the previous expression and the\nnext. Because of the transitivity of equality we can then conclude that the\noriginal left-hand-side is equal to the final expression.\n\nWe can avoid having to supply the relational operator between every pair of\nexpressions by giving a default operator between the `calc` keyword and the\nopening brace as shown in this abbreviated version of the above calc statement:\n\n`lemma docalc(x : int, y: int)\n  ensures (x + y) * (x + y) == x * x + 2 * x * y + y * y\n{\n  calc == {\n    (x + y) * (x + y);\n    x * (x + y) + y * (x + y);\n    x * x + x * y + y * x + y * y;\n    x * x + x * y + x * y + y * y;\n    x * x + 2 * x * y + y * y;\n  }\n}\n`\n\nAnd since equality is the default operator, we could have omitted it after the\n`calc` keyword. The purpose of the block statements or the `calc` statements\nbetween the expressions is to provide hints to aid Dafny in proving that step.\nAs shown in the example, comments can also be used to aid the human reader in\ncases where Dafny can prove the step automatically.\n\n### 8.24. Opaque Block ([grammar][853])\n\nAs a Dafny sequence of statements grows in length, it can become harder to\nverify later statements in the block. With each statement, new information can\nbecome available, and with each modification of the heap, it becomes more\nexpensive to access information from an older heap version. To reduce the\nverification complexity of long lists of statements, Dafny users can extract\npart of this block into a separate method or lemma. However, doing so introduces\nsome boilerplate, which is where opaque blocks come in. They achieve a similar\neffect on verification performance as extracting code, but without the\nboilerplate.\n\nAn opaque block is similar to a block statement: it contains a sequence of zero\nor more statements, enclosed by curly braces. However, an opaque block is\npreceded by the keyword ‘opaque’, and may define ensures and modifies clauses\nbefore the curly braces. Anything that happens inside the block is invisible to\nthe statements that come after it, unless it is specified by the ensures clause.\nHere is an example:\n\n`method OpaqueBlockUser() returns (x: int)\n  ensures x > 4 \n{\n  x := 1;\n  var y := 1;\n  opaque\n    ensures x > 3 \n  {\n    x := x + y;\n    x := x + 2;\n  }\n  assert x == 4; // error\n  x := x + 1;\n}\n`\n\nBy default, the modifies clause of an opaque block is the same as that of the\nenclosing context. Opaque blocks may be nested.\n\n## 9. Expressions\n\nDafny expressions come in three flavors.\n\n* The bulk of expressions have no side-effects and can be used within methods,\n  functions, and specifications, and in either compiled or ghost code.\n* Some expressions, called [right-hand-side expressions][854], do have\n  side-effects and may only be used in specific syntactic locations, such as the\n  right-hand-side of update (assignment) statements; object allocation and\n  method calls are two typical examples of [right-hand-side expressions][855].\n  Note that method calls are syntactically indistinguishable from function\n  calls; both are Expressions ([PrimaryExpressions][856] with an [ArgumentList\n  suffix][857]). However, method calls are semantically permitted only in\n  right-hand-side expression locations.\n* Some expressions are allowed only in specifications and other ghost code, as\n  listed [here][858].\n\nThe grammar of Dafny expressions follows a hierarchy that reflects the\nprecedence of Dafny operators. The following table shows the Dafny operators and\ntheir precedence in order of increasing binding power.\n\n───────────────────┬──────────┬───────────────────────────────────────\noperator           │precedence│description                            \n───────────────────┼──────────┼───────────────────────────────────────\n`;`                │0         │That is [LemmaCall; Expression][859]   \n───────────────────┼──────────┼───────────────────────────────────────\n`<==>`             │1         │[equivalence (if and only if)][860]    \n───────────────────┼──────────┼───────────────────────────────────────\n`==>`              │2         │[implication (implies)][861]           \n───────────────────┼──────────┼───────────────────────────────────────\n`<==`              │2         │[reverse implication (follows          \n                   │          │from)][862]                            \n───────────────────┼──────────┼───────────────────────────────────────\n`&&`, `&`          │3         │[conjunction (and)][863]               \n───────────────────┼──────────┼───────────────────────────────────────\n`||`, `|`          │3         │[disjunction (or)][864]                \n───────────────────┼──────────┼───────────────────────────────────────\n`==`               │4         │equality                               \n───────────────────┼──────────┼───────────────────────────────────────\n`==#[k]`           │4         │[prefix equality (coinductive)][865]   \n───────────────────┼──────────┼───────────────────────────────────────\n`!=`               │4         │disequality                            \n───────────────────┼──────────┼───────────────────────────────────────\n`!=#[k]`           │4         │[prefix disequality (coinductive)][866]\n───────────────────┼──────────┼───────────────────────────────────────\n`<`                │4         │less than                              \n───────────────────┼──────────┼───────────────────────────────────────\n`<=`               │4         │at most                                \n───────────────────┼──────────┼───────────────────────────────────────\n`>=`               │4         │at least                               \n───────────────────┼──────────┼───────────────────────────────────────\n`>`                │4         │greater than                           \n───────────────────┼──────────┼───────────────────────────────────────\n`in`               │4         │collection membership                  \n───────────────────┼──────────┼───────────────────────────────────────\n`!in`              │4         │collection non-membership              \n───────────────────┼──────────┼───────────────────────────────────────\n`!!`               │4         │disjointness                           \n───────────────────┼──────────┼───────────────────────────────────────\n`<<`               │5         │[left-shift][867]                      \n───────────────────┼──────────┼───────────────────────────────────────\n`>>`               │5         │[right-shift][868]                     \n───────────────────┼──────────┼───────────────────────────────────────\n`+`                │6         │addition (plus)                        \n───────────────────┼──────────┼───────────────────────────────────────\n`-`                │6         │subtraction (minus)                    \n───────────────────┼──────────┼───────────────────────────────────────\n`*`                │7         │multiplication (times)                 \n───────────────────┼──────────┼───────────────────────────────────────\n`/`                │7         │division (divided by)                  \n───────────────────┼──────────┼───────────────────────────────────────\n`%`                │7         │modulus (mod)                          \n───────────────────┼──────────┼───────────────────────────────────────\n`|`                │8         │[bit-wise or][869]                     \n───────────────────┼──────────┼───────────────────────────────────────\n`&`                │8         │[bit-wise and][870]                    \n───────────────────┼──────────┼───────────────────────────────────────\n`^`                │8         │[bit-wise exclusive-or (not            \n                   │          │equal)][871]                           \n───────────────────┼──────────┼───────────────────────────────────────\n`as` operation     │9         │[type conversion][872]                 \n───────────────────┼──────────┼───────────────────────────────────────\n`is` operation     │9         │[type test][873]                       \n───────────────────┼──────────┼───────────────────────────────────────\n`-`                │10        │arithmetic negation (unary minus)      \n───────────────────┼──────────┼───────────────────────────────────────\n`!`                │10        │logical negation, bit-wise complement  \n───────────────────┼──────────┼───────────────────────────────────────\nPrimary Expressions│11        │                                       \n───────────────────┴──────────┴───────────────────────────────────────\n\n### 9.1. Lemma-call expressions ([grammar][874])\n\nExamples:\n\n`var a := L(a,b); a*b\n`\n\nThis expression has the form `S; E`. The type of the expression is the type of\n`E`. `S` must be a lemma call (though the grammar appears more lenient). The\nlemma introduces a fact necessary to establish properties of `E`.\n\nSometimes an expression will fail unless some relevant fact is known. In the\nfollowing example the `F_Fails` function fails to verify because the `Fact(n)`\ndivisor may be zero. But preceding the expression by a lemma that ensures that\nthe denominator is not zero allows function `F_Succeeds` to succeed.\n\n`function Fact(n: nat): nat\n{\n  if n == 0 then 1 else n * Fact(n-1)\n}\n\nlemma L(n: nat)\n  ensures 1 <= Fact(n)\n{\n}\n\nfunction F_Fails(n: nat): int\n{\n  50 / Fact(n)  // error: possible division by zero\n}\n\nfunction F_Succeeds(n: nat): int\n{\n  L(n); // note, this is a lemma call in an expression\n  50 / Fact(n)\n}\n`\n\nOne restriction is that a lemma call in this form is permitted only in\nsituations in which the expression itself is not terminated by a semicolon.\n\nA second restriction is that `E` is not always permitted to contain lambda\nexpressions, such as in the expressions that are the body of a lambda expression\nitself, function, method and iterator specifications, and if and while\nstatements with guarded alternatives.\n\nA third restriction is that `E` is not always permitted to contain a bit-wise or\n(`|`) operator, because it would be ambiguous with the vertical bar used in\ncomprehension expressions.\n\nNote that the effect of the lemma call only extends to the succeeding expression\n`E` (which may be another `;` expression).\n\n### 9.2. Equivalence Expressions ([grammar][875])\n\nExamples:\n\n`A\nA <==> B\nA <==> C ==> D <==> B \n`\n\nAn Equivalence Expression that contains one or more `<==>`s is a boolean\nexpression and all the operands must also be boolean expressions. In that case\neach `<==>` operator tests for logical equality which is the same as ordinary\nequality (but with a different precedence).\n\nSee [Section 5.2.1.1][876] for an explanation of the `<==>` operator as compared\nwith the `==` operator.\n\nThe `<==>` operator is commutative and associative: `A <==> B <==> C` and `(A\n<==> B) <==> C` and `A <==> (B <==> C)` and `C <==> B <==> A` are all equivalent\nand are all true iff an even number of operands are false.\n\n### 9.3. Implies or Explies Expressions ([grammar][877])\n\nExamples:\n\n`A ==> B\nA ==> B ==> C ==> D\nB <== A\n`\n\nSee [Section 5.2.1.3][878] for an explanation of the `==>` and `<==` operators.\n\n### 9.4. Logical Expressions ([grammar][879])\n\nExamples:\n\n`A && B\nA || B\n&& A && B && C\n`\n\nNote that the Dafny grammar allows a conjunction or disjunction to be *prefixed*\nwith `&&` or `||` respectively. This form simply allows a parallel structure to\nbe written:\n\n`method m(x: object?, y:object?, z: object?) {\n  var b: bool :=\n    && x != null\n    && y != null\n    && z != null\n    ;\n}\n`\n\nThis is purely a syntactic convenience allowing easy edits such as reordering\nlines or commenting out lines without having to check that the infix operators\nare always where they should be.\n\nNote also that `&&` and `||` cannot be mixed without using parentheses: `A && B\n|| C` is not permitted. Write `(A && B) || C` or `A && (B || C)` instead.\n\nSee [Section 5.2.1.2][880] for an explanation of the `&&` and `||` operators.\n\n### 9.5. Relational Expressions ([grammar][881])\n\nExamples:\n\n`x == y\nx != y\nx < y\nx >= y\nx in y\nx ! in y\nx !! y\nx ==#[k] y\n`\n\nThe relation expressions compare two or more terms. As explained in [the section\nabout basic types][882], `==`, `!=`, `<`, `>`, `<=`, and `>=` are *chaining*.\n\nThe `in` and `!in` operators apply to collection types as explained in [Section\n5.5][883] and represent membership or non-membership respectively.\n\nThe `!!` represents disjointness for sets and multisets as explained in [Section\n5.5.1][884] and [Section 5.5.2][885].\n\n`x ==#[k] y` is the prefix equality operator that compares coinductive values\nfor equality to a nesting level of k, as explained in [the section about\nco-equality][886].\n\n### 9.6. Bit Shifts ([grammar][887])\n\nExamples:\n\n`k << 5\nj >> i\n`\n\nThese operators are the left and right shift operators for bit-vector values.\nThey take a bit-vector value and an `int`, shifting the bits by the given\namount; the result has the same bit-vector type as the LHS. For the expression\nto be well-defined, the RHS value must be in the range 0 to the number of bits\nin the bit-vector type, inclusive.\n\nThe operations are left-associative: `a << i >> j` is `(a << i) >> j`.\n\n### 9.7. Terms ([grammar][888])\n\nExamples:\n\n`x + y - z\n`\n\n`Terms` combine `Factors` by adding or subtracting. Addition has these meanings\nfor different types:\n\n* arithmetic addition for numeric types ([Section 5.2.2][889]])\n* union for sets and multisets ([Section 5.5.1][890] and [Section 5.5.2][891])\n* concatenation for sequences ([Section 5.5.3][892])\n* map merging for maps ([Section 5.5.4][893])\n\nSubtraction is\n\n* arithmetic subtraction for numeric types\n* set or multiset subtraction for sets and multisets\n* domain subtraction for maps.\n\nAll addition operations are associative. Arithmetic addition and union are\ncommutative. Subtraction is neither; it groups to the left as expected: `x - y\n-z` is `(x - y) -z`.\n\n### 9.8. Factors ([grammar][894])\n\nExamples:\n\n`x * y\nx / y\nx % y\n`\n\nA `Factor` combines expressions using multiplication, division, or modulus. For\nnumeric types these are explained in [Section 5.2.2][895]. As explained there,\n`/` and `%` on `int` values represent *Euclidean* integer division and modulus\nand not the typical C-like programming language operations.\n\nOnly `*` has a non-numeric application. It represents set or multiset\nintersection as explained in [Section 5.5.1][896] and [Section 5.5.2][897].\n\n`*` is commutative and associative; `/` and `%` are neither but do group to the\nleft.\n\n### 9.9. Bit-vector Operations ([grammar][898])\n\nExamples:\n\n`x | y\nx & y\nx ^ y\n`\n\nThese operations take two bit-vector values of the same type, returning a value\nof the same type. The operations perform bit-wise *or* (`|`), *and* (`&`), and\n*exclusive-or* (`^`). To perform bit-wise equality, use `^` and `!` (unary\ncomplement) together. (`==` is boolean equality of the whole bit-vector.)\n\nThese operations are associative and commutative but do not associate with each\nother. Use parentheses: `a & b | c` is illegal; use `(a & b) | c` or `a & (b |\nc)` instead.\n\nBit-vector operations are not allowed in some contexts. The `|` symbol is used\nboth for bit-wise or and as the delimiter in a [cardinality][899] expression: an\nambiguity arises if the expression E in `| E |` contains a `|`. This situation\nis easily remedied: just enclose E in parentheses, as in `|(E)|`. The only\ntype-correct way this can happen is if the expression is a comprehension, as in\n`| set x: int :: x | 0x101 |`.\n\n### 9.10. As (Conversion) and Is (type test) Expressions ([grammar][900])\n\nExamples:\n\n`e as MyClass\ni as bv8\ne is MyClass\n`\n\nThe `as` expression converts the given LHS to the type stated on the RHS, with\nthe result being of the given type. The following combinations of conversions\nare permitted:\n\n* Any type to itself\n* Any int-based or real-based numeric type or bit-vector type to another\n  int-based or real-based numeric type or bit-vector type\n* Any base type to a subset or newtype with that base\n* Any subset or newtype to its base type or a subset or newtype of the same base\n* Any type to a subset or newtype that has the type as its base\n* Any trait to a class or trait that extends (perhaps recursively) that trait\n* Any class or trait to a trait extended by that class or trait\n\nSome of the conversions above are already implicitly allowed, without the `as`\noperation, such as from a subset type to its base. In any case, it must be able\nto be proved that the value of the given expression is a legal value of the\ngiven type. For example, `5 as MyType` is permitted (by the verifier) only if\n`5` is a legitimate value of`MyType` (which must be a numeric type).\n\nThe `as` operation is like a grammatical suffix or postfix operation. However,\nnote that the unary operations bind more tightly than does `as`. That is `- 5 as\nnat` is `(- 5) as nat` (which fails), whereas `a * b as nat` is `a * (b as\nnat)`. On the other hand, `- a[4]` is `- (a[4])`.\n\nThe `is` expression is grammatically similar to the `as` expression, with the\nsame binding power. The `is` expression is a type test that returns a `bool`\nvalue indicating whether the LHS expression is a legal value of the RHS type.\nThe expression can be used to check whether a trait value is of a particular\nclass type. That is, the expression in effect checks the allocated type of a\ntrait.\n\nThe RHS type of an `is` expression can always be a supertype of the type of the\nLHS expression, in which case the result is trivally true. Other than that, the\nRHS must be based on a reference type and the LHS expression must be assignable\nto the RHS type. Furthermore, in order to be compilable, the RHS type must not\nbe a subset type other than a non-null reference type, and the type parameters\nof the RHS must be uniquely determined from the type parameters of the LHS type.\nThe last restriction is designed to make it possible to perform type tests\nwithout inspecting type parameters at run time. For example, consider the\nfollowing types:\n\n`trait A { }\ntrait B<X> { }\nclass C<Y> extends B<Y> { }\nclass D<Y(==)> extends B<set<Y>> { }\nclass E extends B<int> { }\nclass F<Z> extends A { }\n`\n\nA LHS expression of type `B<set<int>>` can be used in a type test where the RHS\nis `B<set<int>>`, `C<set<int>>`, or `D<int>`, and a LHS expression of type\n`B<int>` can be used in a type test where the RHS is `B<int>`, `C<int>`, or `E`.\nThose are always allowed in compiled (and ghost) contexts. For an expression `a`\nof type `A`, the expression `a is F<int>` is a ghost expression; it can be used\nin ghost contexts, but not in compiled contexts.\n\nFor an expression `e` and type `t`, `e is t` is the condition determining\nwhether `e as t` is well-defined (but, as noted above, is not always a legal\nexpression).\n\n*The repertoire of types allowed in `is` tests may be expanded in the future.*\n\n### 9.11. Unary Expressions ([grammar][901])\n\nExamples:\n\n`-x\n- - x\n! x\n`\n\nA unary expression applies\n\n* logical complement (`!` – [Section 5.2.1][902]),\n* bit-wise complement (`!` – [Section 5.2.4][903]),\n* numeric negation (`-` – [Section 5.2.2][904]), or\n* bit-vector negation (`-` – [Section 5.2.4][905])\n\nto its operand.\n\n### 9.12. Primary Expressions ([grammar][906])\n\nExamples:\n\n`true\n34\nM(i,j)\nb.c.d\n[1,2,3]\n{2,3,4}\nmap[1 => 2, 3 => 4]\n(i:int,j:int)=>i+j\nif b then 4 else 5\n`\n\nAfter descending through all the binary and unary operators we arrive at the\nprimary expressions, which are explained in subsequent sections. A number of\nthese can be followed by 0 or more suffixes to select a component of the value.\n\n### 9.13. Lambda expressions ([grammar][907])\n\nExamples:\n\n`x => -x\n_ => true\n(x,y) => x*y\n(x:int, b:bool) => if b then x else -x\nx requires x > 0 => x-1\n`\n\nSee [Section 7.4][908] for a description of specifications for lambda\nexpressions.\n\nIn addition to named functions, Dafny supports expressions that define\nfunctions. These are called *lambda (expression)s* (some languages know them as\n*anonymous functions*). A lambda expression has the form:\n\n`( _params_ ) _specification_ => _body_\n`\n\nwhere *params* is a comma-delimited list of parameter declarations, each of\nwhich has the form `x` or `x: T`. The type `T` of a parameter can be omitted\nwhen it can be inferred. If the identifier `x` is not needed, it can be replaced\nby `_`. If *params* consists of a single parameter `x` (or `_`) without an\nexplicit type, then the parentheses can be dropped; for example, the function\nthat returns the successor of a given integer can be written as the following\nlambda expression:\n\n`x => x + 1\n`\n\nThe *specification* is a list of clauses `requires E` or `reads W`, where `E` is\na boolean expression and `W` is a frame expression.\n\n*body* is an expression that defines the function’s return value. The body must\nbe [well-formed][909] for all possible values of the parameters that satisfy the\nprecondition (just like the bodies of named functions and methods). In some\ncases, this means it is necessary to write explicit `requires` and `reads`\nclauses. For example, the lambda expression\n\n`x requires x != 0 => 100 / x\n`\n\nwould not be [well-formed][910] if the `requires` clause were omitted, because\nof the possibility of division-by-zero.\n\nIn settings where functions cannot be partial and there are no restrictions on\nreading the heap, the *eta expansion* of a function `F: T -> U` (that is, the\nwrapping of `F` inside a lambda expression in such a way that the lambda\nexpression is equivalent to `F`) would be written `x => F(x)`. In Dafny, eta\nexpansion must also account for the precondition and reads set of the function,\nso the eta expansion of `F` looks like:\n\n`x requires F.requires(x) reads F.reads(x) => F(x)\n`\n\n### 9.14. Left-Hand-Side Expressions ([grammar][911])\n\nExamples:\n\n`x\na[k]\nLibraryModule.F().x\nold(o.f).x\n`\n\nA left-hand-side expression is only used on the left hand side of an [Update\nstatement][912] or an [Update with Failure Statement][913].\n\nAn LHS can be\n\n* a simple identifier: `k`\n* an expression with a dot suffix: `this.x`, `f(k).y`\n* an expression with an array selection: `a[k]`, `f(a8)[6]`\n\n### 9.15. Right-Hand-Side Expressions ([grammar][914])\n\nExamples:\n\n`new int[6]\nnew MyClass\nnew MyClass(x,y,z)\nx+y+z\n*\n`\n\nA Right-Hand-Side expression is an expression-like construct that may have\nside-effects. Consequently such expressions can only be used within certain\nstatements within methods, and not as general expressions or within functions or\nspecifications.\n\nAn RHS is either an array allocation, an object allocation, a havoc\nright-hand-side, a method call, or a simple expression, optionally followed by\none or more attributes.\n\nRight-hand-side expressions (that are not just regular expressions) appear in\nthe following constructs:\n\n* [return statements][915],\n* [yield statements][916],\n* [update statements][917],\n* [update-with-failure statements][918], or\n* [variable declaration statements][919].\n\nThese are the only contexts in which arrays or objects may be allocated or in\nwhich havoc may be stipulated.\n\n### 9.16. Array Allocation ([grammar][920])\n\nExamples:\n\n`new int[5,6]\nnew int[5][2,3,5,7,11]\nnew int[][2,3,5,7,11]\nnew int[5](i => i*i)\nnew int[2,3]((i,j) => i*j)\n`\n\nThis right-hand-side expression allocates a new single or multi-dimensional\narray (cf. [Section 5.10][921]). The initialization portion is optional. One\nform is an explicit list of values, in which case the dimension is optional:\n\n`var a := new int[5];\nvar b := new int[5][2,3,5,7,11];\nvar c := new int[][2,3,5,7,11];\nvar d := new int[3][4,5,6,7]; // error\n`\n\nThe comprehension form requires a dimension and uses a function of type `nat ->\nT` where `T` is the array element type:\n\n`var a := new int[5](i => i*i);\n`\n\nTo allocate a multi-dimensional array, simply give the sizes of each dimension.\nFor example,\n\n`var m := new real[640, 480];\n`\n\nallocates a 640-by-480 two-dimensional array of `real`s. The initialization\nportion cannot give a display of elements like in the one-dimensional case, but\nit can use an initialization function. A function used to initialize a\nn-dimensional array requires a function from n `nat`s to a `T`, where `T` is the\nelement type of the array. Here is an example:\n\n`var diag := new int[30, 30]((i, j) => if i == j then 1 else 0);\n`\n\nArray allocation is permitted in ghost contexts. If any expression used to\nspecify a dimension or initialization value is ghost, then the `new` allocation\ncan only be used in ghost contexts. Because the elements of an array are\nnon-ghost, an array allocated in a ghost context in effect cannot be changed\nafter initialization.\n\n### 9.17. Object Allocation ([grammar][922])\n\nExamples:\n\n`new MyClass\nnew MyClass.Init\nnew MyClass.Init(1,2,3)\n`\n\nThis right-hand-side expression allocates a new object of a class type as\nexplained in section [Class Types][923].\n\n### 9.18. Havoc Right-Hand-Side ([grammar][924])\n\nExamples:\n\n`*\n`\n\nA havoc right-hand-side is just a `*` character. It produces an arbitrary value\nof its associated type. The “assign-such-that” operator (`:|`) can be used to\nobtain a more constrained arbitrary value. See [Section 8.5][925].\n\n### 9.19. Constant Or Atomic Expressions ([grammar][926])\n\nExamples:\n\n`this\nnull\n5\n5.5\ntrue\n'a'\n\"dafny\"\n( e )\n| s |\nold(x)\nallocated(x)\nunchanged(x)\nfresh(e)\nassigned(x)\n`\n\nThese expressions are never l-values. They include\n\n* [literal expressions][927]\n* [parenthesized expressions][928]\n* [`this` expressions][929]\n* [fresh expressions][930]\n* [allocated expressions][931]\n* [unchanged expressions][932]\n* [old expressions][933]\n* [cardinality expressions][934]\n* [assigned expressions][935]\n\n### 9.20. Literal Expressions ([grammar][936]}\n\nExamples:\n\n`5\n5.5\ntrue\n'a'\n\"dafny\"\n`\n\nA literal expression is a null object reference or a boolean, integer, real,\ncharacter or string literal.\n\n### 9.21. `this` Expression ([grammar][937])\n\nExamples:\n\n`this\n`\n\nThe `this` token denotes the current object in the context of a constructor,\ninstance method, or instance function.\n\n### 9.22. Old and Old@ Expressions ([grammar][938])\n\nExamples:\n\n`old(c)\nold@L(c)\n`\n\nAn *old expression* is used in postconditions or in the body of a method or in\nthe body or specification of any two-state function or two-state lemma; an *old*\nexpression with a label is used only in the body of a method at a point where\nthe label dominates its use in the expression.\n\n`old(e)` evaluates the argument using the value of the heap on entry to the\nmethod; `old@ident(e)` evaluates the argument using the value of the heap at the\ngiven statement label.\n\nNote that **old** and **old@** only affect heap dereferences, like `o.f` and\n`a[i]`. In particular, neither form has any effect on the value returned for\nlocal variables or out-parameters (as they are not on the heap).^{[10][939]} If\nthe value of an entire expression at a particular point in the method body is\nneeded later on in the method body, the clearest means is to declare a ghost\nvariable, initializing it to the expression in question. If the argument of\n`old` is a local variable or out-parameter. Dafny issues a warning.\n\nThe argument of an `old` expression may not contain nested `old`,\n[`fresh`][940], or [`unchanged`][941] expressions, nor [two-state\nfunctions][942] or [two-state lemmas][943].\n\nHere are some explanatory examples. All `assert` statements verify to be true.\n\n`class A {\n\n  var value: int\n\n  method m(i: int)\n    requires i == 6\n    requires value == 42\n    modifies this\n  {\n    var j: int := 17;\n    value := 43;\n    label L:\n    j := 18;\n    value := 44;\n    label M:\n    assert old(i) == 6; // i is local, but can't be changed anyway\n    assert old(j) == 18; // j is local and not affected by old\n    assert old@L(j) == 18; // j is local and not affected by old\n    assert old(value) == 42;\n    assert old@L(value) == 43;\n    assert old@M(value) == 44 && this.value == 44;\n    // value is this.value; 'this' is the same\n    // same reference in current and pre state but the\n    // values stored in the heap as its fields are different;\n    // '.value' evaluates to 42 in the pre-state, 43 at L,\n    // and 44 in the current state\n  }\n}\n`\n`class A {\n  var value: int\n  constructor ()\n     ensures value == 10\n  {\n     value := 10;\n  }\n}\n\nclass B {\n   var a: A\n   constructor () { a := new A(); }\n\n   method m()\n     requires a.value == 11\n     modifies this, this.a\n   {\n     label L:\n     a.value := 12;\n     label M:\n     a := new A(); // Line X\n     label N:\n     a.value := 20;\n     label P:\n\n     assert old(a.value) == 11;\n     assert old(a).value == 12; // this.a is from pre-state,\n                                // but .value in current state\n     assert old@L(a.value) == 11;\n     assert old@L(a).value == 12; // same as above\n     assert old@M(a.value) == 12; // .value in M state is 12\n     assert old@M(a).value == 12;\n     assert old@N(a.value) == 10; // this.a in N is the heap\n                                  // reference at Line X\n     assert old@N(a).value == 20; // .value in current state is 20\n     assert old@P(a.value) == 20;\n     assert old@P(a).value == 20;\n  }\n}\n`\n`class A {\n  var value: int\n  constructor ()\n     ensures value == 10\n  {\n     value := 10;\n  }\n}\n\nclass B {\n   var a: A\n   constructor () { a := new A(); }\n\n   method m()\n     requires a.value == 11\n     modifies this, this.a\n   {\n     label L:\n     a.value := 12;\n     label M:\n     a := new A(); // Line X\n     label N:\n     a.value := 20;\n     label P:\n\n     assert old(a.value) == 11;\n     assert old(a).value == 12; // this.a is from pre-state,\n                                // but .value in current state\n     assert old@L(a.value) == 11;\n     assert old@L(a).value == 12; // same as above\n     assert old@M(a.value) == 12; // .value in M state is 12\n     assert old@M(a).value == 12;\n     assert old@N(a.value) == 10; // this.a in N is the heap\n                                  // reference at Line X\n     assert old@N(a).value == 20; // .value in current state is 20\n     assert old@P(a.value) == 20;\n     assert old@P(a).value == 20;\n  }\n}\n`\n\nThe next example demonstrates the interaction between `old` and array elements.\n\n`class A {\n  var z1: array<nat>\n  var z2: array<nat>\n\n  method mm()\n    requires z1.Length > 10 && z1[0] == 7\n    requires z2.Length > 10 && z2[0] == 17\n    modifies z2\n  {\n    var a: array<nat> := z1;\n    assert a[0] == 7;\n    a := z2;\n    assert a[0] == 17;\n    assert old(a[0]) == 17; // a is local with value z2\n    z2[0] := 27;\n    assert old(a[0]) == 17; // a is local, with current value of\n                            // z2; in pre-state z2[0] == 17\n    assert old(a)[0] == 27; // a is local, so old(a) has no effect\n  }\n}\n`\n\n### 9.23. Fresh Expressions ([grammar][944])\n\nExamples:\n\n`fresh(e)\nfresh@L(e)\n`\n\n`fresh(e)` returns a boolean value that is true if the objects denoted by\nexpression `e` were all freshly allocated since the time of entry to the\nenclosing method, or since [`label L:`][945] in the variant `fresh@L(e)`. The\nargument is an object or set of objects. For example, consider this valid\nprogram:\n\n`class C { constructor() {} }\nmethod f(c1: C) returns (r: C)\n  ensures fresh(r)\n{\n  assert !fresh(c1);\n  var c2 := new C();\n  label AfterC2:\n  var c3 := new C();\n  assert fresh(c2) && fresh(c3);\n  assert fresh({c2, c3});\n  assert !fresh@AfterC2(c2) && fresh@AfterC2(c3);\n  r := c2;\n}\n`\n\nThe `L` in the variant `fresh@L(e)` must denote a [label][946] that, in the\nenclosing method’s control flow, [dominates the expression][947]. In this case,\n`fresh@L(e)` returns `true` if the objects denoted by `e` were all freshly\nallocated since control flow reached label `L`.\n\nThe argument of `fresh` must be either an [`object`][948] reference or a set or\nsequence of object references. In this case, `fresh(e)` (respectively\n`fresh@L(e)` with a label) is a synonym of [`old(!allocated(e))`][949]\n(respectively [`old@L(!allocated(e))`][950])\n\n### 9.24. Allocated Expressions ([grammar][951])\n\nExamples:\n\n`allocated(c)\nallocated({c1,c2})\n`\n\nFor any expression `e`, the expression `allocated(e)` evaluates to `true` in a\nstate if the value of `e` is available in that state, meaning that it could in\nprinciple have been the value of a variable in that state.\n\nFor example, consider this valid program:\n\n`class C { constructor() {} }\ndatatype D = Nil | Cons(C, D)\nmethod f() {\n  var d1, d2 := Nil, Nil;\n  var c1 := new C();\n  label L1:\n  var c2 := new C();\n  label L2:\n  assert old(allocated(d1) && allocated(d2));\n  d1 := Cons(c1, Nil);\n  assert old(!allocated(d1) && allocated(d2));\n  d2 := Cons(c2, Nil);\n  assert old(!allocated(d1) && !allocated(d2));\n  assert allocated(d1) && allocated(d2);\n  assert old@L1(allocated(d1) && !allocated(d2));\n  assert old@L2(allocated(d1) && allocated(d2));\n  d1 := Nil;\n  assert old(allocated(d1) && !allocated(d2));\n}\n`\n\nThis can be useful when, for example, `allocated(e)` is evaluated in an\n[`old`][952] state. Like in the example, where `d1` is a local variable holding\na datatype value `Cons(c1, Nil)` where `c1` is an object that was allocated in\nthe enclosing method, then [`old(allocated(d))`][953] is `false`.\n\nIf the expression `e` is of a reference type, then `!old(allocated(e))` is the\nsame as [`fresh(e)`][954].\n\n### 9.25. Unchanged Expressions ([grammar][955])\n\nExamples:\n\n`unchanged(c)\nunchanged([c1,c2])\nunchanged@L(c)\n`\n\nThe `unchanged` expression returns `true` if and only if every reference denoted\nby its arguments has the same value for all its fields in the old and current\nstate. For example, if `c` is an object with two fields, `x` and `y`, then\n`unchanged(c)` is equivalent to\n\n`c.x == old(c.x) && c.y == old(c.y)\n`\n\nEach argument to `unchanged` can be a reference, a set of references, or a\nsequence of references, each optionally followed by a back-tick and field name.\nThis form with a frame field expresses that just the field `f`, not necessarily\nall fields, has the same value in the old and current state. If there is such a\nframe field, all the references must have the same type, which must have a field\nof that name.\n\nThe optional `@`-label says to use the state at that label as the old-state\ninstead of using the `old` state (the pre-state of the method). That is, using\nthe example `c` from above, the expression `unchanged@Lbl(c)` is equivalent to\n\n`c.x == old@Lbl(c.x) && c.y == old@Lbl(c.y)\n`\n\nEach reference denoted by the arguments of `unchanged` must be non-null and must\nbe allocated in the old-state of the expression.\n\n### 9.26. Cardinality Expressions ([grammar][956])\n\nExamples:\n\n`|s|\n|s[1..i]|\n`\n\nFor a finite-collection expression `c`, `|c|` is the cardinality of `c`. For a\nfinite set or sequence, the cardinality is the number of elements. For a\nmultiset, the cardinality is the sum of the multiplicities of the elements. For\na finite map, the cardinality is the cardinality of the domain of the map.\nCardinality is not defined for infinite sets or infinite maps. For more\ninformation, see [Section 5.5][957].\n\n### 9.27. Parenthesized Expressions ([grammar][958])\n\nA parenthesized expression is a list of zero or more expressions enclosed in\nparentheses.\n\nIf there is exactly one expression enclosed then the value is just the value of\nthat expression.\n\nIf there are zero or more than one, the result is a `tuple` value. See [Section\n5.13][959].\n\n### 9.28. Sequence Display Expression ([grammar][960])\n\nExamples:\n\n`[1, 2, 3]\n[1]\n[]\nseq(k, n => n+1)\n`\n\nA sequence display expression provides a way to construct a sequence with given\nvalues. For example\n\n`[1, 2, 3]\n`\n\nis a sequence with three elements in it.\n\n`seq(k, n => n+1)\n`\n\nis a sequence of k elements whose values are obtained by evaluating the second\nargument (a function, in this case a lambda expression) on the indices 0 up to\nk.\n\nSee [this section][961] for more information on sequences.\n\n### 9.29. Set Display Expression ([grammar][962])\n\nExamples:\n\n`{}\n{1,2,3}\niset{1,2,3,4}\nmultiset{1,2,2,3,3,3}\nmultiset(s)\n`\n\nA set display expression provides a way of constructing a set with given\nelements. If the keyword `iset` is present, then a potentially infinite set\n(with the finite set of given elements) is constructed.\n\nFor example\n\n`{1, 2, 3}\n`\n\nis a set with three elements in it. See [Section 5.5.1][963] for more\ninformation on sets.\n\nA multiset display expression provides a way of constructing a multiset with\ngiven elements and multiplicities. For example\n\n`multiset{1, 1, 2, 3}\n`\n\nis a multiset with three elements in it. The number 1 has a multiplicity of 2,\nand the numbers 2 and 3 each have a multiplicity of 1.\n\nA multiset cast expression converts a set or a sequence into a multiset as shown\nhere:\n\n`var s : set<int> := {1, 2, 3};\nvar ms : multiset<int> := multiset(s);\nms := ms + multiset{1};\nvar sq : seq<int> := [1, 1, 2, 3];\nvar ms2 : multiset<int> := multiset(sq);\nassert ms == ms2;\n`\n\nNote that `multiset{1, 1}` is a multiset holding the value `1` with multiplicity\n2, but in `multiset({1,1})` the multiplicity is 1, because the expression\n`{1,1}` is the set `{1}`, which is then converted to a multiset.\n\nSee [Section 5.5.2][964] for more information on multisets.\n\n### 9.30. Map Display Expression ([grammar][965])\n\nExamples:\n\n`map[]\nmap[1 := \"a\", 2 := \"b\"]\nimap[1 := \"a\", 2 := \"b\"]\n`\n\nA map display expression builds a finite or potentially infinite map from\nexplicit mappings. For example:\n\n`const m := map[1 := \"a\", 2 := \"b\"]\nghost const im := imap[1 := \"a\", 2 := \"b\"]\n`\n\nSee [Section 5.5.4][966] for more details on maps and imaps.\n\n### 9.31. Endless Expression ([grammar][967])\n\n*Endless expression* gets it name from the fact that all its alternate\nproductions have no terminating symbol to end them, but rather they all end with\nan arbitrary expression at the end. The various endless expression alternatives\nare described in the following subsections.\n\n#### 9.31.1. If Expression ([grammar][968])\n\nExamples:\n\n`if c then e1 else e2\nif x: int :| P(x) then x else 0\n`\n\nAn *if expression* is a conditional (ternary) expression. It first evaluates the\ncondition expression that follows the `if`. If the condition evaluates to `true`\nthen the expression following the `then` is evaluated and its value is the\nresult of the expression. If the condition evaluates to `false` then the\nexpression following the `else` is evaluated and that value is the result of the\nexpression. It is important that only the selected expression is evaluated as\nthe following example shows.\n\n`var k := 10 / x; // error, may divide by 0.\nvar m := if x != 0 then 10 / x else 1; // ok, guarded\n`\n\nThe `if` expression also permits a binding form. In this case the condition of\nthe `if` is an existential asking “does there exist a value satisfying the given\npredicate?”. If not, the else branch is evaluated. But if so, then an\n(arbitrary) value that does satisfy the given predicate is bound to the given\nvariable and that variable is in scope in the then-branch of the expression.\n\nFor example, in the code\n\n`predicate P(x: int) {\n  x == 5 || x == -5\n}\nmethod main() {\n  assert P(5);\n  var y := if x: int :| P(x) then x else 0;\n  assert y == 5 || y == -5;\n}\n`\n\n`x` is given some value that satisfies `P(x)`, namely either `5` or `-5`. That\nvalue of `x` is the value of the expression in the `then` branch above; if there\nis no value satisfying `P(x)`, then `0` is returned. Note that if `x` is\ndeclared to be a `nat` in this example, then only the value `5` would be\npermissible.\n\nThis binding form of the `if` expression acts in the same way as the binding\nform of the [`if` statement][969].\n\nIn the example given, the binder for `x` has no constraining range, so the\nexpression is `ghost`; if a range is given, such as `var y := if x: int :| 0 <=\nx < 10 && P(x) then x else 0;`, then the `if` and `y` are no longer ghost, and\n`y` could be used, for example, in a `print` statement.\n\n#### 9.31.2. Case and Extended Patterns ([grammar][970])\n\nPatterns are used for (possibly nested) pattern matching on inductive,\ncoinductive or base type values. They are used in [match statements][971],\n[match expressions][972], [let expressions][973], and [variable\ndeclarations][974]. The match expressions and statements allow literals,\nsymbolic constants, and disjunctive (“or”) patterns.\n\nWhen matching an inductive or coinductive value in a match statement or\nexpression, the pattern must correspond to one of the following:\n\n* (0) a case disjunction (“or-pattern”)\n* (1) bound variable (a simple identifier),\n* (2) a constructor of the type of the value,\n* (3) a literal of the correct type, or\n* (4) a symbolic constant.\n\nIf the extended pattern is\n\n* a sequence of `|`-separated sub-patterns, then the pattern matches values\n  matched by any of the sub-patterns.\n* a parentheses-enclosed possibly-empty list of patterns, then the pattern\n  matches a tuple.\n* an identifier followed by a parentheses-enclosed possibly-empty list of\n  patterns, then the pattern matches a constructor.\n* a literal, then the pattern matches exactly that literal.\n* a simple identifier, then the pattern matches\n  \n  * a parameter-less constructor if there is one defined with the correct type\n    and the given name, else\n  * the value of a symbolic constant, if a name lookup finds a declaration for a\n    constant with the given name (if the name is declared but with a\n    non-matching type, a type resolution error will occur),\n  * otherwise, the identifier is a new bound variable\n\nDisjunctive patterns may not bind variables, and may not be nested inside other\npatterns.\n\nAny patterns inside the parentheses of a constructor (or tuple) pattern are then\nmatched against the arguments that were given to the constructor when the value\nwas constructed. The number of patterns must match the number of parameters to\nthe constructor (or the arity of the tuple).\n\nWhen matching a value of base type, the pattern should either be a literal\nexpression of the same type as the value, or a single identifier matching all\nvalues of this type.\n\nPatterns may be nested. The bound variable identifiers contained in all the\npatterns must be distinct. They are bound to the corresponding values in the\nvalue being matched. (Thus, for example, one cannot repeat a bound variable to\nattempt to match a constructor that has two identical arguments.)\n\n#### 9.31.3. Match Expression ([grammar][975])\n\nA *match expression* is used to conditionally evaluate and select an expression\ndepending on the value of an algebraic type, i.e. an inductive type, a\ncoinductive type, or a base type.\n\nAll of the variables in the patterns must be distinct. If types for the\nidentifiers are not given then types are inferred from the types of the\nconstructor’s parameters. If types are given then they must agree with the types\nof the corresponding parameters.\n\nThe expression following the `match` keyword is called the *selector*. A match\nexpression is evaluated by first evaluating the selector. The patterns of each\nmatch alternative are then compared, in order, with the resulting value until a\nmatching pattern is found, as described in the [section on case bindings][976].\nIf the constructor had parameters, then the actual values used to construct the\nselector value are bound to the identifiers in the identifier list. The\nexpression to the right of the `=>` in the matched alternative is then evaluated\nin the environment enriched by this binding. The result of that evaluation is\nthe result of the match expression.\n\nNote that the braces enclosing the sequence of match alternatives may be\nomitted. Those braces are required if lemma or lambda expressions are used in\nthe body of any match alternative; they may also be needed for disambiguation if\nthere are nested match expressions.\n\n#### 9.31.4. Quantifier Expression ([grammar][977])\n\nExamples:\n\n`forall x: int :: x > 0\nforall x: nat | x < 10 :: x*x < 100\nexists x: int :: x * x == 25\n`\n\nA *quantifier expression* is a boolean expression that specifies that a given\nexpression (the one following the `::`) is true for all (for **forall**) or some\n(for **exists**) combination of values of the quantified variables, namely those\nin the given quantifier domain. See [Section 2.7.4][978] for more details on\nquantifier domains.\n\nHere are some examples:\n\n`assert forall x : nat | x <= 5 :: x * x <= 25;\n(forall n :: 2 <= n ==> (exists d :: n < d < 2*n))\nassert forall x: nat | 0 <= x < |s|, y <- s[x] :: y < x;\n`\n\nThe quantifier identifiers are *bound* within the scope of the expressions in\nthe quantifier expression.\n\nIf types are not given for the quantified identifiers, then Dafny attempts to\ninfer their types from the context of the expressions. It this is not possible,\nthe program is in error.\n\n#### 9.31.5. Set Comprehension Expressions ([grammar][979])\n\nExamples:\n\n`const c1 := set x: nat | x < 100\nconst c2 := set x: nat | x < 100 :: x * x\nconst c3 := set x: nat, y: nat | x < y < 100 :: x * y\nghost const c4 := iset x: nat | x > 100\nghost const c5: iset<int> := iset s\nconst c6 := set x <- c3 :: x + 1\n`\n\nA set comprehension expression is an expression that yields a set (possibly\ninfinite only if `iset` is used) that satisfies specified conditions. There are\ntwo basic forms.\n\nIf there is only one quantified variable, the optional `\"::\" Expression` need\nnot be supplied, in which case it is as if it had been supplied and the\nexpression consists solely of the quantified variable. That is,\n\n`set x : T | P(x)\n`\n\nis equivalent to\n\n`set x : T | P(x) :: x\n`\n\nFor the full form\n\n`var S := set x1: T1 <- C1 | P1(x1),\n             x2: T2 <- C2 | P2(x1, x2),\n             ... \n             :: Q(x1, x2, ...)\n`\n\nthe elements of `S` will be all values resulting from evaluation of `Q(x1, x2,\n...)` for all combinations of quantified variables `x1, x2, ...` (from their\nrespective `C1, C2, ...` domains) such that all predicates `P1(x1), P2(x1, x2),\n...` hold.\n\nFor example,\n\n`var S := set x:nat, y:nat | x < y < 3 :: (x, y)\n`\n\nyields `S == {(0, 1), (0, 2), (1, 2) }`\n\nThe types on the quantified variables are optional and if not given Dafny will\nattempt to infer them from the contexts in which they are used in the various\nexpressions. The `<- C` domain expressions are also optional and default to\n`iset x: T` (i.e. all values of the variable’s type), as are the `| P`\nexpressions which default to `true`. See also [Section 2.7.4][980] for more\ndetails on quantifier domains.\n\nIf a finite set was specified (“set” keyword used), Dafny must be able to prove\nthat the result is finite otherwise the set comprehension expression will not be\naccepted.\n\nSet comprehensions involving reference types such as\n\n`set o: object\n`\n\nare allowed in ghost expressions within methods, but not in ghost\nfunctions^{[11][981]}. In particular, in ghost contexts, the check that the\nresult is finite should allow any set comprehension where the bound variable is\nof a reference type. In non-ghost contexts, it is not allowed, because–even\nthough the resulting set would be finite–it is not pleasant or practical to\ncompute at run time.\n\nThe universe in which set comprehensions are evaluated is the set of all\n*allocated* objects, of the appropriate type and satisfying the given predicate.\nFor example, given\n\n`class I {\n  var i: int\n}\n\nmethod test() {\n  ghost var m := set x: I :: 0 <= x.i <= 10;\n}\n`\n\nthe set `m` contains only those instances of `I` that have been allocated at the\npoint in program execution that `test` is evaluated. This could be no instances,\none per value of `x.i` in the stated range, multiple instances of `I` for each\nvalue of `x.i`, or any other combination.\n\n#### 9.31.6. Statements in an Expression ([grammar][982])\n\nExamples:\n\n`assert x != 0; 10/x\nassert x != 0; assert y > 0; y/x\nassume x != 0; 10/x\nexpect x != 0; 10/x\nreveal M.f; M.f(x)\ncalc { x * 0; == 0; } x/1;\n`\n\nA `StmtInExpr` is a kind of statement that is allowed to precede an expression\nin order to ensure that the expression can be evaluated without error. For\nexample:\n\n`assume x != 0; 10/x\n`\n\n`Assert`, `assume`, `expect`, `reveal` and `calc` statements can be used in this\nway.\n\n#### 9.31.7. Let and Let or Fail Expression ([grammar][983])\n\nExamples:\n\n`var x := f(y); x*x\nvar x :- f(y); x*x\nvar x :| P(x); x*x\nvar (x, y) := T(); x + y   // T returns a tuple\nvar R(x,y) := T(); x + y   // T returns a datatype value R\n`\n\nA `let` expression allows binding of intermediate values to identifiers for use\nin an expression. The start of the `let` expression is signaled by the `var`\nkeyword. They look much like a local variable declaration except the scope of\nthe variable only extends to the enclosed expression.\n\nFor example:\n\n`var sum := x + y; sum * sum\n`\n\nIn the simple case, the pattern is just an identifier with optional type (which\nif missing is inferred from the rhs).\n\nThe more complex case allows destructuring of constructor expressions. For\nexample:\n\n`datatype Stuff = SCons(x: int, y: int) | Other\nfunction GhostF(z: Stuff): int\n  requires z.SCons?\n{\n  var SCons(u, v) := z; var sum := u + v; sum * sum\n}\n`\n\nThe Let expression has a failure variant that simply uses `:-` instead of `:=`.\nThis Let-or-Fail expression also permits propagating failure results. However,\nin statements ([Section 8.6][984]), failure results in immediate return from the\nmethod; expressions do not have side effects or immediate return mechanisms.\nRather, if the expression to the right of `:-` results in a failure value `V`,\nthe overall expression returns `V.PropagateFailure()`; if there is no failure,\nthe expression following the semicolon is returned. Note that these two possible\nreturn values must have the same type (or be implicitly convertible to the same\ntype). Typically that means that `tmp.PropagateFailure()` is a failure value and\n`E` is a value-carrying success value, both of the same failure-compatible type,\nas described in [Section 8.6][985].\n\nThe expression `:- V; E` is desugared into the *expression*\n\n`var tmp := V;\nif tmp.IsFailure()\nthen tmp.PropagateFailure()\nelse E\n`\n\nThe expression `var v :- V; E` is desugared into the *expression*\n\n`var tmp := V;\nif tmp.IsFailure()\nthen tmp.PropagateFailure()\nelse var v := tmp.Extract(); E\n`\n\nIf the RHS is a list of expressions then the desugaring is similar. `var v, v1\n:- V, V1; E` becomes\n\n`var tmp := V;\nif tmp.IsFailure()\nthen tmp.PropagateFailure()\nelse var v, v1 := tmp.Extract(), V1; E\n`\n\nSo, if tmp is a failure value, then a corresponding failure value is propagated\nalong; otherwise, the expression is evaluated as normal.\n\n#### 9.31.8. Map Comprehension Expression ([grammar][986])\n\nExamples:\n\n`map x : int | 0 <= x <= 10 :: x * x;\nmap x : int | 0 <= x <= 10 :: -x := x * x;\nimap x : int | 10 < x :: x * x;\n`\n\nA *map comprehension expression* defines a finite or infinite map value by\ndefining a domain and for each value in the domain, giving the mapped value\nusing the expression following the “::”. See [Section 2.7.4][987] for more\ndetails on quantifier domains.\n\nFor example:\n\n`function square(x : int) : int { x * x }\nmethod test()\n{\n  var m := map x : int | 0 <= x <= 10 :: x * x;\n  ghost var im := imap x : int :: x * x;\n  ghost var im2 := imap x : int :: square(x);\n}\n`\n\nDafny finite maps must be finite, so the domain must be constrained to be\nfinite. But imaps may be infinite as the examples show. The last example shows\ncreation of an infinite map that gives the same results as a function.\n\nIf the expression includes the `:=` token, that token separates domain values\nfrom range values. For example, in the following code\n\n`method test()\n{\n  var m := map x : int | 1 <= x <= 10 :: 2*x := 3*x;\n}\n`\n\n`m` maps `2` to `3`, `4` to `6`, and so on.\n\n### 9.32. Name Segment ([grammar][988])\n\nExamples:\n\n`I\nI<int,C>\nI#[k]\nI#<int>[k]\n`\n\nA *name segment* names a Dafny entity by giving its declared name optionally\nfollowed by information to make the name more complete. For the simple case, it\nis just an identifier. Note that a name segment may be followed by\n[suffixes][989], including the common ‘.’ and further name segments.\n\nIf the identifier is for a generic entity, it is followed by a\n`GenericInstantiation` which provides actual types for the type parameters.\n\nTo reference a prefix predicate (see [Section 5.14.3.5][990]) or prefix lemma\n(see [Section 5.14.3.6.3][991]), the identifier must be the name of the greatest\npredicate or greatest lemma and it must be followed by a [*hash call*][992].\n\n### 9.33. Hash call ([grammar][993])\n\nA *hash call* is used to call the prefix for a greatest predicate or greatest\nlemma. In the non-generic case, just insert `\"#[k]\"` before the call argument\nlist where k is the number of recursion levels.\n\nIn the case where the `greatest lemma` is generic, the generic type argument is\ngiven before. Here is an example:\n\n`codatatype Stream<T> = Nil | Cons(head: int, stuff: T,\n                                  tail: Stream<T>)\n\nfunction append(M: Stream, N: Stream): Stream\n{\n  match M\n  case Nil => N\n  case Cons(t, s, M') => Cons(t, s, append(M', N))\n}\n\nfunction zeros<T>(s : T): Stream<T>\n{\n  Cons(0, s, zeros(s))\n}\n\nfunction ones<T>(s: T): Stream<T>\n{\n  Cons(1, s, ones(s))\n}\n\ngreatest predicate atmost(a: Stream, b: Stream)\n{\n  match a\n  case Nil => true\n  case Cons(h,s,t) => b.Cons? && h <= b.head && atmost(t, b.tail)\n}\n\ngreatest lemma {:induction false} Theorem0<T>(s: T)\n  ensures atmost(zeros(s), ones(s))\n{\n  // the following shows two equivalent ways to state the\n  // coinductive hypothesis\n  if (*) {\n    Theorem0#<T>[_k-1](s);\n  } else {\n    Theorem0(s);\n  }\n}\n`\n\nwhere the `HashCall` is `\"Theorem0#<T>[_k-1](s);\"`. See [Section 5.14.3.5][994]\nand [Section 5.14.3.6.3][995].\n\n### 9.34. Suffix ([grammar][996])\n\nA *suffix* describes ways of deriving a new value from the entity to which the\nsuffix is appended. The several kinds of suffixes are described below.\n\n#### 9.34.1. Augmented Dot Suffix ([grammar][997])\n\nExamples: (expression with suffix)\n\n`a.b\n(a).b<int>\na.b#[k]\na.b#<int>[k]\n`\n\nAn augmented dot suffix consists of a simple [dot suffix][998] optionally\nfollowed by either\n\n* a `GenericInstantiation` (for the case where the item selected by the\n  `DotSuffix` is generic), or\n* a `HashCall` for the case where we want to call a prefix predicate or prefix\n  lemma. The result is the result of calling the prefix predicate or prefix\n  lemma.\n\n#### 9.34.2. Datatype Update Suffix ([grammar][999])\n\nExamples: (expression with suffix)\n\n`a.(f := e1, g:= e2)\na.(0 := e1)\n(e).(f := e1, g:= e2)\n`\n\nA *datatype update suffix* is used to produce a new datatype value that is the\nsame as an old datatype value except that the value corresponding to a given\ndestructor has the specified value. In a *member binding update*, the given\nidentifier (or digit sequence) is the name of a destructor (i.e. the formal\nparameter name) for one of the constructors of the datatype. The expression to\nthe right of the `:=` is the new value for that formal.\n\nAll of the destructors in a datatype update suffix must be for the same\nconstructor, and if they do not cover all of the destructors for that\nconstructor then the datatype value being updated must have a value derived from\nthat same constructor.\n\nHere is an example:\n\n`module NewSyntax {\n  datatype MyDataType = MyConstructor(myint:int, mybool:bool)\n                    | MyOtherConstructor(otherbool:bool)\n                    | MyNumericConstructor(42:int)\n\n  method test(datum:MyDataType, x:int)\n    returns (abc:MyDataType, def:MyDataType,\n             ghi:MyDataType, jkl:MyDataType)\n    requires datum.MyConstructor?\n    ensures abc == datum.(myint := x + 2)\n    ensures def == datum.(otherbool := !datum.mybool)  // error\n    ensures ghi == datum.(myint := 2).(mybool := false)\n    // Resolution error: no non_destructor in MyDataType\n    //ensures jkl == datum.(non_destructor := 5) // error\n    ensures jkl == datum.(42 := 7)\n  {\n    abc := MyConstructor(x + 2, datum.mybool);\n    abc := datum.(myint := x + 2);\n    def := MyOtherConstructor(!datum.mybool);\n    ghi := MyConstructor(2, false);\n    jkl := datum.(42 := 7); // error\n\n    assert abc.(myint := abc.myint - 2) == datum.(myint := x);\n  }\n}\n`\n\n#### 9.34.3. Subsequence Suffix ([grammar][1000])\n\nExamples: (with leading expression)\n\n`a[lo .. hi ]\n(e)[ lo .. ]\ne[ .. hi ]\ne[ .. ]\n`\n\nA subsequence suffix applied to a sequence produces a new sequence whose\nelements are taken from a contiguous part of the original sequence. For example,\nexpression `s[lo..hi]` for sequence `s`, and integer-based numeric bounds `lo`\nand `hi` satisfying `0 <= lo <= hi <= |s|`. See [the section about other\nsequence expressions][1001] for details.\n\nA subsequence suffix applied to an array produces a *sequence* consisting of the\nvalues of the designated elements. A concise way of converting a whole array to\na sequence is to write `a[..]`.\n\n#### 9.34.4. Subsequence Slices Suffix ([grammar][1002])\n\nExamples: (with leading expression)\n\n`a[ 0 : 2 : 3 ]\na[ e1 : e2 : e3 ]\na[ 0 : 2 : ]\n`\n\nApplying a *subsequence slices suffix* to a sequence produces a sequence of\nsubsequences of the original sequence. See [the section about other sequence\nexpressions][1003] for details.\n\n#### 9.34.5. Sequence Update Suffix ([grammar][1004])\n\nExamples:\n\n`s[1 := 2, 3 := 4]\n`\n\nFor a sequence `s` and expressions `i` and `v`, the expression `s[i := v]` is\nthe same as the sequence `s` except that at index `i` it has value `v`.\n\nIf the type of `s` is `seq<T>`, then `v` must have type `T`. The index `i` can\nhave any integer- or bit-vector-based type (this is one situation in which Dafny\nimplements implicit conversion, as if an `as int` were appended to the index\nexpression). The expression `s[i := v]` has the same type as `s`.\n\n#### 9.34.6. Selection Suffix ([grammar][1005])\n\nExamples:\n\n`a[9]\na[i.j.k]\n`\n\nIf a selection suffix has only one expression in it, it is a zero-based index\nthat may be used to select a single element of a sequence or from a\nsingle-dimensional array.\n\nIf a selection suffix has more than one expression in it, then it is a list of\nindices to index into a multi-dimensional array. The rank of the array must be\nthe same as the number of indices.\n\nIf the selection suffix is used with an array or a sequence, then each index\nexpression can have any integer- or bit-vector-based type (this is one situation\nin which Dafny implements implicit conversion, as if an `as int` were appended\nto the index expression).\n\n#### 9.34.7. Argument List Suffix ([grammar][1006])\n\nExamples:\n\n`()\n(a)\n(a, b)\n`\n\nAn argument list suffix is a parenthesized list of expressions that are the\narguments to pass to a method or function that is being called. Applying such a\nsuffix causes the method or function to be called and the result is the result\nof the call.\n\nNote that method calls may only appear in [right-hand-side][1007] locations,\nwhereas function calls may appear in expressions and specifications; this\ndistinction can be made only during name and type resolution, not by the parser.\n\n### 9.35. Expression Lists ([grammar][1008])\n\nExamples:\n\n`                // empty list\na\na, b\n`\n\nAn expression list is a comma-separated sequence of expressions, used, for\nexample, as actual araguments in a method or function call or in parallel\nassignment.\n\n### 9.36. Parameter Bindings ([grammar][1009])\n\nExamples:\n\n`a\na, b\na, optimize := b\n`\n\nMethod calls, object-allocation calls (`new`), function calls, and datatype\nconstructors can be called with both positional arguments and named arguments.\n\nFormal parameters have three ways to indicate how they are to be passed in:\n\n* nameonly: the only way to give a specific argument value is to name the\n  parameter\n* positional only: these are nameless parameters (which are allowed only for\n  datatype constructor parameters)\n* either positional or by name: this is the most common parameter\n\nA parameter is either required or optional:\n\n* required: a caller has to supply an argument\n* optional: the parameter has a default value that is used if a caller omits\n  passing a specific argument\n\nThe syntax for giving a positional-only (i.e., nameless) parameter does not\nallow a default-value expression, so a positional-only parameter is always\nrequired.\n\nAt a call site, positional arguments are not allowed to follow named arguments.\nTherefore, if `x` is a nameonly parameter, then there is no way to supply the\nparameters after `x` by position. Thus, any parameter that follows `x` must\neither be passed by name or have a default value. That is, if a later (in the\nformal parameter declaration) parameter does not have a default value, it is\neffectively nameonly.\n\nPositional arguments must be given before any named arguments. Positional\narguments are passed to the formals in the corresponding position. Named\narguments are passed to the formal of the given name. Named arguments can be\ngiven out of order from how the corresponding formal parameters are declared. A\nformal declared with the modifier `nameonly` is not allowed to be passed\npositionally. The list of bindings for a call must provide exactly one value for\nevery required parameter and at most one value for each optional parameter, and\nmust never name non-existent formals. Any optional parameter that is not given a\nvalue takes on the default value declared in the callee for that optional\nparameter.\n\n### 9.37. Assigned Expressions\n\nExamples:\n\n`assigned(x)\n`\n\nFor any variable, constant, out-parameter, or object field `x`, the expression\n`assigned(x)` evaluates to `true` in a state if `x` is definitely assigned in\nthat state.\n\nSee [Section 12.6][1010] for more details on definite assignment.\n\n### 9.38. Termination Ordering Expressions\n\nWhen proving that a loop or recursive callable terminates, Dafny automatically\ngenerates a proof obligation that the sequence of expressions listed in a\n`decreases` clause gets smaller (in the [lexicographic termination\nordering][1011]) with each iteration or recursive call. Normally, this proof\nobligation is purely internal. However, it can be written as a Dafny expression\nusing the `decreases to` operator.\n\nThe Boolean expression `(a, ..., b decreases to a', ..., b')` encodes this\nordering. (The parentheses can be omitted if there is exactly 1 left-hand side\nand exactly 1 right-hand side.) For example, the following assertions are valid:\n\n`method M(x: int, y: int) {\n  assert 1 decreases to 0;\n  assert (true, false decreases to false, true);\n  assert (x, y decreases to x - 1, y);\n}\n`\n\nConversely, the following assertion is invalid:\n\n`method M(x: int, y: int) {\n  assert x decreases to x + 1;\n}\n`\n\nThe `decreases to` operator is strict, that is, it means “strictly greater\nthan”. The `nonincreases to` operator is the non-strict (“greater than or\nequal”) version of it.\n\n### 9.39. Compile-Time Constants\n\nIn certain situations in Dafny it is helpful to know what the value of a\nconstant is during program analysis, before verification or execution takes\nplace. For example, a compiler can choose an optimized representation of a\n`newtype` that is a subset of `int` if it knows the range of possible values of\nthe subset type: if the range is within 0 to less than 256, then an unsigned\n8-bit representation can be used.\n\nTo continue this example, suppose a new type is defined as\n\n`const MAX := 47\nnewtype mytype = x | 0 <= x < MAX*4\n`\n\nIn this case, we would prefer that Dafny recognize that `MAX*4` is known to be\nconstant with a value of `188`. The kinds of expressions for which such an\noptimization is possible are called *compile-time constants*. Note that the\nrepresentation of `mytype` makes no difference semantically, but can affect how\ncompiled code is represented at run time. In addition, though, using a symbolic\nconstant (which may well be used elsewhere as well) improves the\nself-documentation of the code.\n\nIn Dafny, the following expressions are compile-time constants^{[12][1012]},\nrecursively (that is, the arguments of any operation must themselves be\ncompile-time constants):\n\n* int, bit-vector, real, boolean, char and string literals\n* int operations: `+ - * / %` and unary `-` and comparisons `< <= > >= == !=`\n* real operations: `+ - *` and unary `-` and comparisons `< <= > >= == !=`\n* bool operations: `&& || ==> <== <==> == !=` and unary `!`\n* bit-vector operations: `+ - * / % << >> & | ^` and unary `! -` and comparisons\n  `< <= > >= == !=`\n* char operations: `< <= > >= == !=`\n* string operations: length: `|...|`, concatenation: `+`, comparisons `< <= ==\n  !=`, indexing `[]`\n* conversions between: `int` `real` `char` bit-vector\n* newtype operations: newtype arguments, but not newtype results\n* symbolic values that are declared `const` and have an explicit initialization\n  value that is a compile-time constant\n* conditional (if-then-else) expressions\n* parenthesized expressions\n\n### 9.40. List of specification expressions\n\nThe following is a list of expressions that can only appear in specification\ncontexts or in ghost blocks.\n\n* [Fresh expressions][1013]\n* [Allocated expressions][1014]\n* [Unchanged expressions][1015]\n* [Old expressions][1016]\n* [Assigned expressions][1017]\n* [Assert and calc expressions][1018]\n* [Hash Calls][1019]\n* [Termination ordering expression][1020]\n\n## 10. Refinement\n\nRefinement is the process of replacing something somewhat abstract with\nsomething somewhat more concrete. For example, in one module one might declare a\ntype name, with no definition, such as `type T`, and then in a refining module,\nprovide a definition. One could prove general properties about the contents of\nan (abstract) module, and use that abstract module, and then later provide a\nmore concrete implementation without having to redo all of the proofs.\n\nDafny supports *module refinement*, where one module is created from another,\nand in that process the new module may be made more concrete than the previous.\nMore precisely, refinement takes the following form in Dafny. One module\ndeclares some program entities. A second module *refines* the first by declaring\nhow to augment or replace (some of) those program entities. The first module is\ncalled the *refinement parent*; the second is the *refining* module; the result\nof combining the two (the original declarations and the augmentation directives)\nis the *assembled* module or *refinement result*.\n\nSyntactically, the refinement parent is a normal module declaration. The\nrefining module declares which module is its refinement parent with the\n`refines` clause:\n\n`module P { // refinement parent\n}\nmodule M refines P { // refining module\n}\n`\n\nThe refinement result is created as follows.\n\n0) The refinement result is a module within the same enclosing module as the\nrefining module, has the same name, and in fact replaces the refining module in\ntheir shared scope.\n\n1) All the declarations (including import and export declarations) of the parent\nare copied into the refinement result. These declarations are *not* re-resolved.\nThat is, the assignment of declarations and types to syntactic names is not\nchanged. The refinement result may exist in a different enclosing module and\nwith a different set of imports than the refinement parent, so that if names\nwere reresolved, the result might be different (and possibly not semantically\nvalid). This is why Dafny does not re-resolve the names in their new context.\n\n2) All the declarations of the refining module that have different names than\nthe declarations in the refinement parent are also copied into the refinement\nresult. However, because the refining module is just a set of augmentation\ndirectives and may refer to names copied from the refinement parent, resolution\nof names and types of the declarations copied in this step is performed in the\ncontext of the full refinement result.\n\n3) Where declarations in the parent and refinement module have the same name,\nthe second refines the first and the combination, a refined declaration, is the\nresult placed in the refinement result module, to the exclusion of the\ndeclarations with the same name from the parent and refinement modules.\n\nThe way the refinement result declarations are assembled depends on the kind of\ndeclaration; the rules are described in subsections below.\n\nSo that it is clear that refinement is taking place, refining declarations have\nsome syntactic indicator that they are refining some parent declaration.\nTypically this is the presence of a `...` token.\n\n### 10.1. Export set declarations\n\nA refining export set declaration begins with [the syntax][1021]\n\n`\"export\" Ident ellipsis\n`\n\nbut otherwise contains the same `provides`, `reveals` and `extends` sections,\nwith the ellipsis indicating that it is a refining declaration.\n\nThe result declaration has the same name as the two input declarations and the\nunions of names from each of the `provides`, `reveals`, and `extends` sections,\nrespectively.\n\nAn unnamed export set declaration from the parent is copied into the result\nmodule with the name of the parent module. The result module has a default\nexport set according to the general rules for export sets, after all of the\nresult module’s export set declarations have been assembled.\n\n### 10.2. Import declarations\n\nAliasing import declarations are not refined. The result module contains the\nunion of the import declarations from the two input modules. There must be no\nnames in common among them.\n\nAbstract import declarations (declared with `:` instead of `=`, [Section\n4.6][1022]) are refined. The refinement parent contains the abstract import and\nthe refining module contains a regular aliasing import for the same name. Dafny\nchecks that the refining import *adheres* to the abstract import.\n\n### 10.3. Sub-module declarations\n\nWith respect to refinement, a nested module behaves just like a top-level\nmodule. It may be declared abstract and it may be declared to `refine` some\nrefinement parent. If the nested module is not refining anything and not being\nrefined, then it is copied into the refinement result like any other\ndeclaration.\n\nHere is some example code:\n\n`abstract module P {\n  module A { const i := 5 }\n  abstract module B { type T }\n}\n\nmodule X refines P {\n  module B' refines P.B { type T = int }\n  module C { const k := 6}\n}\n\nmodule M {\n  import X\n  method m() {\n    var z: X.B'.T := X.A.i + X.C.k;\n  }\n}\n`\n\nThe refinement result of `P` and `X` contains nested modules `A`, `B'`, and `C`.\nIt is this refinement result that is imported into `M`. Hence the names\n`X.B'.T`, `X.A.i` and `X.C.k` are all valid.\n\n### 10.4. Const declarations\n\nConst declarations can be refined as in the following example.\n\n`module A {\n  const ToDefine: int\n  const ToDefineWithoutType: int\n  const ToGhost: int := 1\n}\n\nmodule B refines A {\n  const ToDefine: int := 2\n  const ToDefineWithoutType ... := 3\n  ghost const ToGhost: int\n  const NewConst: int\n}\n`\n\nFormally, a child `const` declaration may refine a `const` declaration from a\nparent module if\n\n* the parent has no initialization,\n* the child has the same type as the parent, and\n* one or both of the following holds:\n  \n  * the child has an initializing expression\n  * the child is declared `ghost` and the parent is not `ghost`.\n\nA refining module can also introduce new `const` declarations that do not exist\nin the refinement parent.\n\n### 10.5. Method declarations\n\nMethod declarations can be refined as in the following example.\n\n`abstract module A {\n  method ToImplement(x: int) returns (r: int)\n    ensures r > x\n\n  method ToStrengthen(x: int) returns (r: int)\n\n  method ToDeterminize(x: int) returns (r: int)\n    ensures r >= x\n  {\n    var y :| y >= x;\n    return y;\n  }\n\n}\n\nmodule B refines A {\n  method ToImplement(x: int) returns (r: int)\n  {\n    return x + 2;\n  }\n\n  method ToStrengthen ...\n    ensures r == x*2\n  {\n    return x*2;\n  }\n\n  method ToDeterminize(x: int) returns (r: int)\n  {\n    return x;\n  }\n}\n`\n\nFormally, a child `method` definition may refine a parent `method` declaration\nor definition by performing one or more of the following operations:\n\n* provide a body missing in the parent (as in `ToImplement`),\n* strengthen the postcondition of the parent method by adding one or more\n  `ensures` clauses (as in `ToStrengthen`),\n* provide a more deterministic version of a non-deterministic parent body (as in\n  `ToDeterminize`), or\n\nThe type signature of a child method must be the same as that of the parent\nmethod it refines. This can be ensured by providing an explicit type signature\nequivalent to that of the parent (with renaming of parameters allowed) or by\nusing an ellipsis (`...`) to indicate copying of the parent type signature. The\nbody of a child method must satisfy any ensures clauses from its parent in\naddition to any it adds.\n\nA refined method is allowed only if it does not invalidate any parent lemmas\nthat mention it.\n\nA refining module can also introduce new `method` declarations or definitions\nthat do not exist in the refinement parent.\n\n### 10.6. Lemma declarations\n\nAs lemmas are (ghost) methods, the description of method refinement from the\nprevious section also applies to lemma refinement.\n\nA valid refinement is one that does not invalidate any proofs. A lemma from a\nrefinement parent must still be valid for the refinement result of any method or\nlemma it mentions.\n\n### 10.7. Function and predicate declarations\n\nFunction (and equivalently predicate) declarations can be refined as in the\nfollowing example.\n\n`abstract module A {\n  function F(x: int): (r: int)\n    ensures r > x\n\n  function G(x: int): (r: int)\n    ensures r > x\n  { x + 1 }\n}\n\nmodule B refines A {\n  function F ...\n  { x + 1 }\n\n  function G ...\n    ensures r == x + 1\n}\n`\n\nFormally, a child `function` (or `predicate`) definition can refine a parent\n`function` (or `predicate`) declaration or definition to\n\n* provide a body missing in the parent,\n* strengthen the postcondition of the parent function by adding one or more\n  `ensures` clauses.\n\nThe relation between the type signature of the parent and child function is the\nsame as for methods and lemmas, as described in the previous section.\n\nA refining module can also introduce new `function` declarations or definitions\nthat do not exist in the refinement parent.\n\n### 10.8. Class, trait and iterator declarations\n\nClass, trait, and iterator declarations are refined as follows:\n\n* If a class (or trait or iterator, respectively) `C` in a refining parent\n  contains a member that is not matched by a same-named member in the class `C`\n  in the refining module, or vice-versa, then that class is copied as is to the\n  refinement result.\n* When there are members with the same name in the class in the refinement\n  parent and in the refining module, then the combination occurs according to\n  the rules for that category of member.\n\nHere is an example code snippet:\n\n`abstract module P {\n  class C {\n    function F(): int\n      ensures F() > 0\n  }\n}\n\nmodule X refines P {\n  class C ... {\n    function F...\n      ensures F() > 0\n    { 1 }\n  }\n}\n`\n\n### 10.9. Type declarations\n\nTypes can be refined in two ways:\n\n* Turning an abstract type into a concrete type;\n* Adding members to a datatype or a newtype.\n\nFor example, consider the following abstract module:\n\n`abstract module Parent {\n  type T\n  type B = bool\n  type S = s: string | |s| > 0 witness \"!\"\n  newtype Pos = n: nat | n > 0 witness 1\n  datatype Bool = True | False\n}\n`\n\nIn this module, type `T` is opaque and hence can be refined with any type,\nincluding class types. Types `B`, `S`, `Pos`, and `Bool` are concrete and cannot\nbe refined further, except (for `Pos` and `Bool`) by giving them additional\nmembers or attributes (or refining their existing members, if any). Hence, the\nfollowing are valid refinements:\n\n`module ChildWithTrait refines Parent {\n  trait T {}\n}\n\nmodule ChildWithClass refines Parent {\n  class T {}\n}\n\nmodule ChildWithSynonymType refines Parent {\n  type T = bool\n}\n\nmodule ChildWithSubsetType refines Parent {\n  type T = s: seq<int> | s != [] witness [0]\n}\n\nmodule ChildWithDataType refines Parent {\n  datatype T = True | False\n}\n\nabstract module ChildWithExtraMembers refines Parent {\n  newtype Pos ... {\n    method Print() { print this; }\n  }\n\n  datatype Bool ... {\n    function AsDafnyBool() : bool { this.True? }\n  }\n}\n`\n\n(The last example is marked `abstract` because it leaves `T` opaque.)\n\nNote that datatype constructors, codatatype destructors, and newtype definitions\ncannot be refined: it is not possible to add or remove `datatype` constructors,\nnor to change destructors of a `codatatype`, nor to change the base type,\nconstraint, or witness of a `newtype`.\n\nWhen a type takes arguments, its refinement must use the same type arguments\nwith the same type constraints and the same variance.\n\nWhen a type has type constraints, these type constraints must be preserved by\nrefinement. This means that a type declaration `type T(!new)` cannot be refined\nby a `class T`, for example. Similarly, a `type T(00)` cannot be refined by a\nsubset type with a `witness *` clause.\n\nThe refinement of an abstract type with body-less members can include both a\ndefinition for the type along with a body for the member, as in this example:\n\n`abstract module P {\n  type T3 {\n    function ToString(): string\n  }\n}\n\nmodule X refines P {\n  newtype T3 = i | 0 <= i < 10 {\n    function ToString... { \"\" }\n  }\n}\n`\n\nNote that type refinements are not required to include the `...` indicator that\nthey are refining a parent type.\n\n### 10.10. Statements\n\nThe refinement syntax (`...`) in statements is deprecated.\n\n## 11. Attributes\n\nDafny allows many of its entities to be annotated with *Attributes*. Attributes\nare declared between `{:` and `}` like this:\n\n`{:attributeName \"argument\", \"second\" + \"argument\", 57}\n`\n\n(White-space may follow but not precede the `:` in `{:`.)\n\nIn general an attribute may have any name the user chooses. It may be followed\nby a comma-separated list of expressions. These expressions will be resolved and\ntype-checked in the context where the attribute appears.\n\nAny Dafny entity may have a list of attributes. Dafny does not check that the\nattributes listed for an entity are appropriate for it (which means that\nmisspellings may go silently unnoticed).\n\nThe grammar shows where the attribute annotations may appear:\n\n`Attribute = \"{:\" AttributeName [ Expressions ] \"}\"\n`\n\nDafny has special processing for some attributes^{[13][1023]}. Of those, some\napply only to the entity bearing the attribute, while others (inherited\nattributes) apply to the entity and its descendants (such as nested modules,\ntypes, or declarations). The attribute declaration closest to the entity\noverrides those further away.\n\nFor attributes with a single boolean expression argument, the attribute with no\nargument is interpreted as if it were true.\n\n### 11.1. Attributes on top-level declarations\n\n#### 11.1.1. `{:autocontracts}`\n\nDynamic frames\n[@Kassios:FM2006;@SmansEtAl:VeriCool;@SmansEtAl:ImplicitDynamicFrames;\n@LEINO:Dafny:DynamicFrames] are frame expressions that can vary dynamically\nduring program execution. AutoContracts is an experimental feature that will\nfill much of the dynamic-frames boilerplate into a class.\n\nFrom the user’s perspective, what needs to be done is simply:\n\n* mark the class with `{:autocontracts}`\n* declare a function (or predicate) called `Valid()`\n\nAutoContracts will then:\n\n* Declare:\n  `ghost var Repr: set<object>\n  `\n* For function/predicate `Valid()`, insert:\n  ` reads this, Repr\n  `\n* Into body of `Valid()`, insert (at the beginning of the body):\n  ` this in Repr && null !in Repr\n  `\n* and also insert, for every array-valued field `A` declared in the class:\n  ` && (A != null ==> A in Repr)\n  `\n* and for every field `F` of a class type `T` where `T` has a field called\n  `Repr`, also insert:\n  ` (F != null ==> F in Repr && F.Repr <= Repr && this !in F.Repr)\n  `\n  \n  Except, if A or F is declared with `{:autocontracts false}`, then the\n  implication will not be added.\n* For every constructor, add:\n  ` modifies this\n   ensures Valid() && fresh(Repr - {this})\n  `\n* At the end of the body of the constructor, add:\n  ` Repr := {this};\n   if (A != null) { Repr := Repr + {A}; }\n   if (F != null) { Repr := Repr + {F} + F.Repr; }\n  `\n* For every method, add:\n  ` requires Valid()\n   modifies Repr\n   ensures Valid() && fresh(Repr - old(Repr))\n  `\n* At the end of the body of the method, add:\n  ` if (A != null) { Repr := Repr + {A}; }\n   if (F != null) { Repr := Repr + {F} + F.Repr; }\n  `\n\n#### 11.1.2. `{:nativeType}`\n\nThe `{:nativeType}` attribute is only recognized by a `newtype` declaration\nwhere the base type is an integral type or a real type. For example:\n\n`newtype {:nativeType \"byte\"} ubyte = x : int | 0 <= x < 256\nnewtype {:nativeType \"byte\"} bad_ubyte = x : int | 0 <= x < 257 // Fails\n`\n\nIt can take one of the following forms:\n\n* `{:nativeType}` - With no parameters it has no effect and the declaration will\n  have its default behavior, which is to choose a native type that can hold any\n  value satisfying the constraints, if possible, and otherwise to use\n  BigInteger.\n* `{:nativeType true}` - Also gives default behavior, but gives an error if the\n  base type is not integral.\n* `{:nativeType false}` - Inhibits using a native type. BigInteger is used.\n* `{:nativeType \"typename\"}` - This form has an native integral type name as a\n  string literal. Acceptable values are:\n  \n  * `\"byte\"` 8 bits, unsigned\n  * `\"sbyte\"` 8 bits, signed\n  * `\"ushort\"` 16 bits, unsigned\n  * `\"short\"` 16 bits, signed\n  * `\"uint\"` 32 bits, unsigned\n  * `\"int\"` 32 bits, signed\n  * `\"number\"` 53 bits, signed\n  * `\"ulong\"` 64 bits, unsigned\n  * `\"long\"` 64 bits, signed\n  \n  If the target compiler does not support a named native type X, then an error\n  is generated. Also, if, after scrutinizing the constraint predicate, the\n  compiler cannot confirm that the type’s values will fit in X, an error is\n  generated. The names given above do not have to match the names in the target\n  compilation language, just the characteristics of that type.\n\n#### 11.1.3. `{:ignore}` (deprecated)\n\nIgnore the declaration (after checking for duplicate names).\n\n#### 11.1.4. `{:extern}`\n\n`{:extern}` is a target-language dependent modifier used\n\n* to alter the `CompileName` of entities such as modules, classes, methods,\n  etc.,\n* to alter the `ReferenceName` of the entities,\n* to decide how to define external abstract types,\n* to decide whether to emit target code or not, and\n* to decide whether a declaration is allowed not to have a body.\n\nThe `CompileName` is the name for the entity when translating to one of the\ntarget languages. The `ReferenceName` is the name used to refer to the entity in\nthe target language. A common use case of `{:extern}` is to avoid name clashes\nwith existing library functions.\n\n`{:extern}` takes 0, 1, or 2 (possibly empty) string arguments:\n\n* `{:extern}`: Dafny will use the Dafny-determined name as the `CompileName` and\n  not affect the `ReferenceName`\n* `{:extern s1}`: Dafny will use `s1` as the `CompileName`, and replaces the\n  last portion of the `ReferenceName` by `s1`. When used on an abstract type, s1\n  is used as a hint as to how to declare that type when compiling.\n* `{:extern s1, s2}` Dafny will use `s2` as the `CompileName`. Dafny will use a\n  combination of `s1` and `s2` such as for example `s1.s2` as the\n  `ReferenceName` It may also be the case that one of the arguments is simply\n  ignored.\n\nDafny does not perform sanity checks on the arguments—it is the user’s\nresponsibility not to generate malformed target code.\n\nFor more detail on the use of `{:extern}`, see the corresponding [section][1024]\nin the user’s guide.\n\n#### 11.1.5. `{:disableNonlinearArithmetic}`\n\nThis attribute only applies to module declarations. It overrides the global\noption `--disable-nonlinear-arithmetic` for that specific module. The attribute\ncan be given true or false to disable or enable nonlinear arithmetic. When no\nvalue is given, the default value is true.\n\n### 11.2. Attributes on functions and methods\n\n#### 11.2.1. `{:abstemious}`\n\nThe `{:abstemious}` attribute is appropriate for functions on codatatypes. If\nappropriate to a function, the attribute can aid in proofs that the function is\n*productive*. See [the section on abstemious functions][1025] for more\ndescription.\n\n#### 11.2.2. `{:autoReq}`\n\nFor a function declaration, if this attribute is set true at the nearest level,\nthen its `requires` clause is strengthened sufficiently so that it may call the\nfunctions that it calls.\n\nFor following example\n\n`function f(x:int) : bool\n  requires x > 3\n{\n  x > 7\n}\n\n// Should succeed thanks to auto_reqs\nfunction {:autoReq} g(y:int, b:bool) : bool\n{\n  if b then f(y + 2) else f(2*y)\n}\n`\n\nthe `{:autoReq}` attribute causes Dafny to deduce a `requires` clause for g as\nif it had been declared\n\n`function f(x:int) : bool\n  requires x > 3\n{\n  x > 7\n}\nfunction g(y:int, b:bool) : bool\n  requires if b then y + 2 > 3 else 2 * y > 3\n{\n  if b then f(y + 2) else f(2*y)\n}\n`\n\n#### 11.2.3. `{:autoRevealDependencies k}`\n\nWhen setting `--default-function-opacity` to `autoRevealDependencies`, the\n`{:autoRevealDependencies k}` attribute can be set on methods and functions to\nmake sure that only function dependencies of depth `k` in the call-graph or less\nare revealed automatically. As special cases, one can also use\n`{:autoRevealDependencies false}` (or `{:autoRevealDependencies 0}`) to make\nsure that no dependencies are revealed, and `{:autoRevealDependencies true}` to\nmake sure that all dependencies are revealed automatically.\n\nFor example, when the following code is run with `--default-function-opacity`\nset to `autoRevealDependencies`, the function `p()` should verify and `q()`\nshould not.\n\n`   function t1() : bool { true }\n   \n   function t2() : bool { t1() }\n\n   function {:autoRevealDependencies 1} p() : (r: bool) \n     ensures r\n   { t1() }\n   \n   function {:autoRevealDependencies 1} q() : (r: bool) \n     ensures r\n   { t2() }\n`\n\n#### 11.2.4. `{:axiom}`\n\nThe `{:axiom}` attribute may be placed on a function or method. It means that\nthe post-condition may be assumed to be true without proof. In that case also\nthe body of the function or method may be omitted.\n\nThe `{:axiom}` attribute only prevents Dafny from verifying that the body\nmatches the post-condition. Dafny still verifies the [well-formedness][1026] of\npre-conditions, of post-conditions, and of the body if provided. To prevent\nDafny from running all these checks, one would use [`{:verify false}`][1027],\nwhich is not recommended.\n\nThe compiler will still emit code for an [`{:axiom}`][1028], if it is a\n[`function`, a `method` or a `function by method`][1029] with a body.\n\n#### 11.2.5. `{:compile}`\n\nThe `{:compile}` attribute takes a boolean argument. It may be applied to any\ntop-level declaration. If that argument is false, then that declaration will not\nbe compiled at all. The difference with [`{:extern}`][1030] is that\n[`{:extern}`][1031] will still emit declaration code if necessary, whereas\n`{:compile false}` will just ignore the declaration for compilation purposes.\n\n#### 11.2.6. `{:concurrent}`\n\nThe `{:concurrent}` attribute indicates that the compiled code for a function or\nmethod may be executed concurrently. While Dafny is a sequential language and\ndoes not support any native concepts for spawning or controlling concurrent\nexecution, it does support restricting the specification of declarations such\nthat it is safe to execute them concurrently using integration with the target\nlanguage environment.\n\nCurrently, the only way to satisfy this requirement is to ensure that the\nspecification of the function or method includes the equivalent of `reads {}`\nand `modifies {}`. This ensures that the code does not read or write any shared\nmutable state, although it is free to read and write newly allocated objects.\n\n#### 11.2.7. `{:extern <name>}`\n\nSee [`{:extern <name>}`][1032].\n\n#### 11.2.8. `{:fuel X}`\n\nThe fuel attribute is used to specify how much “fuel” a function should have,\ni.e., how many times the verifier is permitted to unfold its definition. The\n`{:fuel}` annotation can be added to the function itself, in which case it will\napply to all uses of that function, or it can be overridden within the scope of\na module, function, method, iterator, calc, forall, while, assert, or assume.\nThe general format is:\n\n`{:fuel functionName,lowFuel,highFuel}\n`\n\nWhen applied as an annotation to the function itself, omit functionName. If\nhighFuel is omitted, it defaults to lowFuel + 1.\n\nThe default fuel setting for recursive functions is 1,2. Setting the fuel\nhigher, say, to 3,4, will give more unfoldings, which may make some proofs go\nthrough with less programmer assistance (e.g., with fewer assert statements),\nbut it may also increase verification time, so use it with care. Setting the\nfuel to 0,0 is similar to making the definition opaque, except when used with\nall literal arguments.\n\n#### 11.2.9. `{:id <string>}`\n\nAssign a custom unique ID to a function or a method to be used for verification\nresult caching.\n\n#### 11.2.10. `{:induction}`\n\nThe `{:induction}` attribute controls the application of proof by induction to\ntwo contexts. Given a list of variables on which induction might be applied, the\n`{:induction}` attribute selects a sub-list of those variables (in the same\norder) to which to apply induction.\n\nDafny issue [34][1033] proposes to remove the restriction that the sub-list be\nin the same order, and would apply induction in the order given in the\n`{:induction}` attribute.\n\nThe two contexts are:\n\n* A method, in which case the bound variables are all the in-parameters of the\n  method.\n* A [quantifier expression][1034], in which case the bound variables are the\n  bound variables of the quantifier expression.\n\nThe form of the `{:induction}` attribute is one of the following:\n\n* `{:induction}` or `{:induction true}` – apply induction to all bound variables\n* `{:induction false}` – suppress induction, that is, don’t apply it to any\n  bound variable\n* `{:induction L}` where `L` is a sublist of the bound variables – apply\n  induction to the specified bound variables\n* `{:induction X}` where `X` is anything else – raise an error.\n\nHere is an example of using it on a quantifier expression:\n\n`datatype Unary = Zero | Succ(Unary)\n\nfunction UnaryToNat(n: Unary): nat {\n  match n\n  case Zero => 0\n  case Succ(p) => 1 + UnaryToNat(p)\n}\n\nfunction NatToUnary(n: nat): Unary {\n  if n == 0 then Zero else Succ(NatToUnary(n - 1))\n}\n\nlemma Correspondence()\n  ensures forall n: nat {:induction n} :: UnaryToNat(NatToUnary(n)) == n\n{\n}\n`\n\n#### 11.2.11. `{:inductionTrigger}`\n\nDafny automatically generates triggers for quantified induction hypotheses. The\ndefault selection can be overridden using the `{:inductionTrigger}` attribute,\nwhich works like the usual [`{:trigger}` attribute][1035].\n\n#### 11.2.12. `{:only}`\n\n`method {:only} X() {}` or `function {:only} X() {}` temporarily disables the\nverification of all other non-`{:only}` members, e.g. other functions and\nmethods, in the same file, even if they contain [assertions with\n`{:only}`][1036].\n\n`method {:only} TestVerified() {\n  assert true;                  // Unchecked\n  assert {:only} true by {      // Checked\n    assert true;                // Checked\n  }\n  assert true;                  // Unchecked\n}\n\nmethod TestUnverified() {\n  assert true;                  // Unchecked\n  assert {:only} true by {      // Unchecked because of {:only} Test()\n    assert true;                // Unchecked\n  }\n  assert true;                  // Unchecked\n}\n`\n\n`{:only}` can help focusing on a particular member, for example a lemma or a\nfunction, as it simply disables the verification of all other lemmas, methods\nand functions in the same file. It’s equivalent to adding [`{:verify\nfalse}`][1037] to all other declarations simulatenously on the same file. Since\nit’s meant to be a temporary construct, it always emits a warning.\n\nMore information about the Boogie implementation of `{:opaque}` is [here][1038].\n\n#### 11.2.13. `{:print}`\n\nThis attribute declares that a method may have print effects, that is, it may\nuse `print` statements and may call other methods that have print effects. The\nattribute can be applied to compiled methods, constructors, and iterators, and\nit gives an error if applied to functions or ghost methods. An overriding method\nis allowed to use a `{:print}` attribute only if the overridden method does.\nPrint effects are enforced only with `--track-print-effects`.\n\n#### 11.2.14. `{:priority}`\n\n`{:priority N}` assigns a positive priority ‘N’ to a method or function to\ncontrol the order in which methods or functions are verified (default: N = 1).\n\n#### 11.2.15. `{:resource_limit}` and `{:rlimit}`\n\n`{:resource_limit N}` limits the verifier resource usage to verify the method or\nfunction to `N`.\n\nThis is the per-method equivalent of the command-line flag `/rlimit:N` or\n`--resource-limit N`. If using [`{:isolate_assertions}`][1039] as well, the\nlimit will be set for each assertion.\n\nThe attribute `{:rlimit N}` is also available, and limits the verifier resource\nusage to verify the method or function to `N * 1000`. This version is\ndeprecated, however.\n\nTo give orders of magnitude about resource usage, here is a list of examples\nindicating how many resources are used to verify each method:\n\n* 8K resource usage\n  `method f() {\n    assert true;\n  }\n  `\n* 10K resource usage using assertions that do not add assumptions:\n  `method f(a: bool, b: bool) {\n    assert a: (a ==> b) <==> (!b ==> !a);\n    assert b: (a ==> b) <==> (!b ==> !a);\n    assert c: (a ==> b) <==> (!b ==> !a);\n    assert d: (a ==> b) <==> (!b ==> !a);\n  }\n  `\n* 40K total resource usage using [`{:isolate_assertions}`][1040]\n  `method {:isolate_assertions} f(a: bool, b: bool) {\n    assert a: (a ==> b) <==> (!b ==> !a);\n    assert b: (a ==> b) <==> (!b ==> !a);\n    assert c: (a ==> b) <==> (!b ==> !a);\n    assert d: (a ==> b) <==> (!b ==> !a);\n  }\n  `\n* 37K total resource usage and thus fails with `out of resource`.\n  `method {:rlimit 30} f(a: int, b: int, c: int) {\n    assert ((1 + a*a)*c) / (1 + a*a) == c;\n  }\n  `\n\nNote that, the default solver Z3 tends to overshoot by `7K` to `8K`, so if you\nput `{:rlimit 20}` in the last example, the total resource usage would be `27K`.\n\n#### 11.2.16. `{:selective_checking}`\n\nTurn all assertions into assumptions except for the ones reachable from after\nthe assertions marked with the attribute `{:start_checking_here}`. Thus, `assume\n{:start_checking_here} something;` becomes an inverse of `assume false;`: the\nfirst one disables all verification before it, and the second one disables all\nverification after.\n\n#### 11.2.17. `{:tailrecursion}`\n\nThis attribute is used on method or function declarations. It has a boolean\nargument.\n\nIf specified with a `false` value, it means the user specifically requested no\ntail recursion, so none is done.\n\nIf specified with a `true` value, or if no argument is specified, then tail\nrecursive optimization will be attempted subject to the following conditions:\n\n* It is an error if the method is a ghost method and tail recursion was\n  explicitly requested.\n* Only direct recursion is supported, not mutually recursive methods.\n* If `{:tailrecursion true}` was specified but the code does not allow it, an\n  error message is given.\n\nIf you have a stack overflow, it might be that you have a function on which\nautomatic attempts of tail recursion failed, but for which efficient iteration\ncan be implemented by hand. To do this, use a [function by method][1041] and\ndefine the loop in the method yourself, proving that it implements the function.\n\nUsing a function by method to implement recursion can be tricky. It usually\nhelps to look at the result of the function on two to three iterations, without\nsimplification, and see what should be the first computation. For example,\nconsider the following tail-recursion implementation:\n\n`datatype Result<V,E> = Success(value: V) | Failure(error: E)\n\nfunction f(x: int): Result<int, string>\n\n//  {:tailrecursion true}  Not possible here\nfunction MakeTailRec(\n  obj: seq<int>\n): Result<seq<int>, string>\n{\n  if |obj| == 0 then Success([])\n  else\n    var tail := MakeTailRec(obj[1..]);\n    var r := f(obj[0]);\n    if r.Failure? then\n      Failure(r.error)\n    else if tail.Failure? then\n      tail\n    else\n      Success([r.value] + tail.value)\n} by method {\n  var i: nat := |obj|;\n  var tail := Success([]); // Base case\n  while i != 0\n    decreases i\n    invariant tail == MakeTailRec(obj[i..])\n  {\n    i := i - 1;\n    var r := f(obj[i]);\n    if r.Failure? {\n      tail := Failure(r.error);\n    } else if tail.Success? {\n      tail := Success([r.value] + tail.value);\n    } else {\n    }\n  }\n  return tail;\n}\n`\n\nThe rule of thumb to unroll a recursive call into a sequential one is to look at\nhow the result would be computed if the operations were not simplified. For\nexample, unrolling the function on `[1, 2, 3]` yields the result\n`Success([f(1).value] + ([f(2).value] + ([f(3).value] + [])))`. If you had to\ncompute this expression manually, you’d start with `([f(3).value] + [])`, then\nadd `[f(2).value]` to the left, then `[f(1).value]`. This is why the method loop\niterates with the objects from the end, and why the intermediate invariants are\nall about proving `tail == MakeTailRec(obj[i..])`, which makes verification\nsucceed easily because we replicate exactly the behavior of `MakeTailRec`. If we\nwere not interested in the first error but the last one, a possible optimization\nwould be, on the first error, to finish iterate with a ghost loop that is not\nexecuted.\n\nNote that the function definition can be changed by computing the tail closer to\nwhere it’s used or switching the order of computing `r` and `tail`, but the `by\nmethod` body can stay the same.\n\n#### 11.2.18. `{:test}`\n\nThis attribute indicates the target function or method is meant to be executed\nat runtime in order to test that the program is working as intended.\n\nThere are two different ways to dynamically test functionality in a test:\n\n1. A test can optionally return a single value to indicate success or failure.\n   If it does, this must be a *failure-compatible* type just as the\n   [update-with-failure statement][1042] requires. That is, the returned type\n   must define a `IsFailure()` function method. If `IsFailure()` evaluates to\n   `true` on the return value, the test will be marked a failure, and this\n   return value used as the failure message.\n2. Code in the control flow of the test can use [`expect` statements][1043] to\n   dynamically test if a boolean expression is true, and cause the test to halt\n   if not (but not the overall testing process). The optional second argument to\n   a failed `expect` statement will be used as the test failure message.\n\nNote that the `expect` keyword can also be used to form “assign or halt”\nstatements such as `var x :- expect CalculateX();`, which is a convenient way to\ninvoke a method that may produce a failure within a test without having to\nreturn a value from the test.\n\nThere are also two different approaches to executing all tests in a program:\n\n1. By default, the compiler will mark each compiled method as necessary so that\n   a designated target language testing framework will discover and run it. This\n   is currently only implemented for C#, using the xUnit `[Fact]` annotation.\n2. If `dafny test` is used, Dafny will instead produce a main method that\n   invokes each test and prints the results. This runner is currently very\n   basic, but avoids introducing any additional target language dependencies in\n   the compiled code.\n\nA method marked `{:test}` may not have any input arguments. If there is an\noutput value that does not have a failure-compatible type, that value is\nignored. A method that does have input arguments can be wrapped in a test\nharness that supplies input arguments but has no inputs of its own and that\nchecks any output values, perhaps with `expect` statements. The test harness is\nthen the method marked with `{:test}`.\n\n#### 11.2.19. `{:timeLimit N}`\n\nSet the time limit for verifying a given function or method.\n\n#### 11.2.20. `{:timeLimitMultiplier X}`\n\nThis attribute may be placed on a method or function declaration and has an\ninteger argument. If `{:timeLimitMultiplier X}` was specified a `{:timeLimit Y}`\nattribute is passed on to Boogie where `Y` is `X` times either the default\nverification time limit for a function or method, or times the value specified\nby the Boogie `-timeLimit` command-line option.\n\n#### 11.2.21. `{:transparent}`\n\nBy default, the body of a function is transparent to its users. This can be\noverridden using the `--default-function-opacity` command line flag. If default\nfunction opacity is set to `opaque` or `autoRevealDependencies`, then this\nattribute can be used on functions to make them always non-opaque.\n\n#### 11.2.22. `{:verify false}`\n\nSkip verification of a function or a method altogether, not even trying to\nverify the [well-formedness][1044] of postconditions and preconditions. We\ndiscourage using this attribute and prefer [`{:axiom}`][1045], which performs\nthese minimal checks while not checking that the body satisfies the\npostconditions.\n\nIf you simply want to temporarily disable all verification except on a single\nfunction or method, use the [`{:only}`][1046] attribute on that function or\nmethod.\n\n#### 11.2.23. `{:vcs_max_cost N}`\n\nPer-method version of the command-line option `/vcsMaxCost`.\n\nThe [assertion batch][1047] of a method will not be split unless the cost of an\n[assertion batch][1048] exceeds this number, defaults to 2000.0. In [keep-going\nmode][1049], only applies to the first round. If [`{:isolate_assertions}`][1050]\nis set, then this parameter is useless.\n\n#### 11.2.24. `{:vcs_max_keep_going_splits N}`\n\nPer-method version of the command-line option `/vcsMaxKeepGoingSplits`. If set\nto more than 1, activates the *keep going mode* where, after the first round of\nsplitting, [assertion batches][1051] that timed out are split into N [assertion\nbatches][1052] and retried until we succeed proving them, or there is only one\nsingle assertion that it timeouts (in which case an error is reported for that\nassertion). Defaults to 1. If [`{:isolate_assertions}`][1053] is set, then this\nparameter is useless.\n\n#### 11.2.25. `{:vcs_max_splits N}`\n\nPer-method version of the command-line option `/vcsMaxSplits`. Maximal number of\n[assertion batches][1054] generated for this method. In [keep-going mode][1055],\nonly applies to the first round. Defaults to 1. If\n[`{:isolate_assertions}`][1056] is set, then this parameter is useless.\n\n#### 11.2.26. `{:isolate_assertions}`\n\nPer-method version of the command-line option `/vcsSplitOnEveryAssert`\n\nIn the first and only verification round, this option will split the original\n[assertion batch][1057] into one assertion batch per assertion. This is mostly\nhelpful for debugging which assertion is taking the most time to prove, e.g. to\nprofile them.\n\n#### 11.2.27. `{:synthesize}`\n\nThe `{:synthesize}` attribute must be used on methods that have no body and\nreturn one or more fresh objects. During compilation, the postconditions\nassociated with such a method are translated to a series of API calls to the\ntarget languages’s mocking framework. The object returned, therefore, behaves\nexactly as the postconditions specify. If there is a possibility that this\nbehavior violates the specifications on the object’s instance methods or\nhardcodes the values of its fields, the compiler will throw an error but the\ncompilation will go through. Currently, this compilation pass is only supported\nin C# and requires adding the latest version of the Moq library to the .csproj\nfile before generating the binary.\n\nNot all Dafny postconditions can be successfully compiled - below is the grammar\nfor postconditions that are supported (`S` is the start symbol, `EXPR` stands\nfor an arbitrary Dafny expression, and `ID` stands for variable/method/type\nidentifiers):\n\n`S         = FORALL\n          | EQUALS\n          | S && S\nEQUALS    = ID.ID (ARGLIST) == EXPR // stubs a function call\n          | ID.ID           == EXPR // stubs field access\n          | EQUALS && EQUALS\nFORALL    = forall BOUNDVARS :: EXPR ==> EQUALS\nARGLIST   = ID   // this can be one of the bound variables\n          | EXPR // this expr may not reference any of the bound variables\n          | ARGLIST, ARGLIST\nBOUNDVARS = ID : ID\n          | BOUNDVARS, BOUNDVARS\n`\n\n#### 11.2.28. `{:options OPT0, OPT1, ... }`\n\nThis attribute applies only to modules. It configures Dafny as if `OPT0`,\n`OPT1`, … had been passed on the command line. Outside of the module, options\nrevert to their previous values.\n\nOnly a small subset of Dafny’s command line options is supported. Use the\n`/attrHelp` flag to see which ones.\n\n### 11.3. Attributes on reads and modifies clauses\n\n#### 11.3.1. `{:assume_concurrent}`\n\nThis attribute is used to allow non-empty `reads` or `modifies` clauses on\nmethods with the `{:concurrent}` attribute, which would otherwise reject them.\n\nIn some cases it is possible to know that Dafny code that reads or writes shared\nmutable state is in fact safe to use in a concurrent setting, especially when\nthat state is exclusively ghost. Since the semantics of `{:concurrent}` aren’t\ndirectly expressible in Dafny syntax, it isn’t possible to express this\nassumption with an `assume {:axiom} ...` statement.\n\nSee also the [`{:concurrent}`][1058] attribute.\n\n### 11.4. Attributes on assertions, preconditions and postconditions\n\n#### 11.4.1. `{:only}`\n\n`assert {:only} X;` temporarily transforms all other non-`{:only}` assertions in\nthe surrounding declaration into assumptions.\n\n`method Test() {\n  assert true;                  // Unchecked\n  assert {:only} true by {      // Checked\n    assert true;                // Checked\n  }\n  assert true;                  // Unchecked\n  assert {:only \"after\"} true;  // Checked\n  assert true;                  // Checked\n  assert {:only \"before\"} true; // Checked\n  assert true;                  // Unchecked\n}\n`\n\n`{:only}` can help focusing on a particular proof or a particular branch, as it\ntransforms not only other explicit assertions, but also other implicit\nassertions, and call requirements, into assumptions. Since it’s meant to be a\ntemporary construct, it always emits a warning. It also has two variants `assert\n{:only \"before\"}` and `assert {:only \"after\"}`. Here is precisely how Dafny\ndetermines what to verify or not. Each `{:only}` annotation defines a\n“verification interval” which is visual:\n\n* `assert {:only} X [by {...} | ;]` sets a verification interval that starts at\n  the keyword `assert` and ends either at the end of the proof `}` or the\n  semicolon `;`, depending on which variant of `assert` is being used.\n* `assert {:only} ...` inside another verification interval removes that\n  verification interval and sets a new one.\n* `assert {:only \"before\"} ...` inside another verification interval finishes\n  that verification interval earlier at the end of this assertion. Outside a\n  verification interval, it sets a verification interval from the beginning of\n  the declaration to the end of this assertion, but only if there were no other\n  verification intervals before.\n* `assert {:only \"after\"} ...` inside another verification interval moves the\n  start of that verification interval to the start of this new assert. Outside a\n  verification interval, it sets a verification interval from the beginning of\n  this `assert` to the end of the declaration.\n\nThe start of an asserted expression is used to determines if it’s inside a\nverification interval or not. For example, in `assert B ==> (assert {:only\n\"after\"} true; C)`, `C` is actually the start of the asserted expression, so it\nis verified because it’s after `assert {:only \"after\"} true`.\n\nAs soon as a declaration contains one `assert {:only}`, none of the\npostconditions are verified; you’d need to make them explicit with assertions if\nyou wanted to verify them at the same time.\n\nYou can also isolate the verification of a single member using [a similar\n`{:only}` attribute][1059].\n\n#### 11.4.2. `{:focus}`\n\n`assert {:focus} X;` splits verification into two [assertion batches][1060]. The\nfirst batch considers all assertions that are not on the block containing the\n`assert {:focus} X;` The second batch considers all assertions that are on the\nblock containing the `assert {:focus} X;` and those that will *always* follow\nafterwards. Hence, it might also occasionally double-report errors. If you truly\nwant a split on the batches, prefer [`{:split_here}`][1061].\n\nHere are two examples illustrating how `{:focus}` works, where `--` in the\ncomments stands for `Assumption`:\n\n`method doFocus1(x: bool) returns (y: int) {\n  y := 1;                     // Batch 1    Batch 2\n  assert y == 1;              // Assertion  --\n  if x {\n    if false {\n      assert y >= 0;          // --         Assertion\n      assert {:focus} y <= 2; // --         Assertion\n      y := 2;\n      assert y == 2;          // --         Assertion\n    }\n  } else {\n    assert y == 1;            // Assertion  --\n  }\n  assert y == 1;              // Assertion  Assertion\n  if !x {\n    assert y >= 1;            // Assertion  Assertion\n  } else {\n    assert y <= 1;            // Assertion  Assertion\n  }\n}\n`\n\nAnd another one where the focused block is guarded with a `while`, resulting in\nremaining assertions not being part of the first assertion batch:\n\n`method doFocus2(x: bool) returns (y: int) {\n  y := 1;                     // Batch 1    Batch 2\n  assert y == 1;              // Assertion  --\n  if x {\n    while false {\n      assert y >= 0;          // --         Assertion\n      assert {:focus} y <= 2; // --         Assertion\n      y := 2;\n      assert y == 2;          // --         Assertion\n    }\n  } else {\n    assert y == 1;            // Assertion  --\n  }\n  assert y == 1;              // Assertion  --\n  if !x {\n    assert y >= 1;            // Assertion  --\n  } else {\n    assert y <= 1;            // Assertion  --\n  }\n}\n`\n\n#### 11.4.3. `{:split_here}`\n\n`assert {:split_here} X;` splits verification into two [assertion\nbatches][1062]. It verifies the code leading to this point (excluded) in a first\nassertion batch, and the code leading from this point (included) to the next\n`{:split_here}` or until the end in a second assertion batch. It might help with\ntimeouts.\n\nHere is one example, where `--` in the comments stands for `Assumption`:\n\n`method doSplitHere(x: bool) returns (y: int) {\n  y := 1;                      // Batch 1    Batch 2     Batch 3\n  assert y >= 0;               // Assertion  --          --\n  if x {\n    assert y <= 1;             // Assertion  --          --\n    assert {:split_here} true; // --         Assertion   --\n    assert y <= 2;             // --         Assertion   --\n    assert {:split_here} true; // --         --          Assertion\n    if x {\n      assert y == 1;           // --         --          Assertion\n    } else {\n      assert y >= 1;           // --         --          Assertion\n    }\n  } else {\n    assert y <= 3;             // Assertion  --          --\n  }\n  assert y >= -1;              // Assertion  --          --\n}\n`\n\n#### 11.4.4. `{:subsumption n}`\n\nOverrides the `/subsumption` command-line setting for this assertion.\n`{:subsumption 0}` checks an assertion but does not assume it after proving it.\nYou can achieve the same effect using [labelled assertions][1063].\n\n#### 11.4.5. `{:error \"errorMessage\", \"successMessage\"}`\n\nProvides a custom error message in case the assertion fails. As a hint, messages\nindicating what the user needs to do to fix the error are usually better than\nmessages that indicate the error only. For example:\n\n`method Process(instances: int, price: int)\n  requires {:error \"There should be an even number of instances\", \"The number of\n instances is always even\"} instances % 2 == 0\n  requires {:error \"Could not prove that the price is positive\", \"The price is a\nlways positive\"} price >= 0\n{\n}\nmethod Test()\n{\n  if * {\n    Process(1, 0); // Error: There should be an even number of instances\n  }\n  if * {\n    Process(2, -1); // Error: Could not prove that the price is positive\n  }\n  if * {\n    Process(2, 5); // Success: The number of instances is always even\n                   // Success: The price is always positive\n  }\n}\n`\n\nThe success message is optional but is recommended if errorMessage is set.\n\n#### 11.4.6. `{:contradiction}`\n\nSilences warnings about this assertion being involved in a proof using\ncontradictory assumptions when `--warn-contradictory-assumptions` is enabled.\nThis allows clear identification of intentional proofs by contradiction.\n\n### 11.5. Attributes on variable declarations\n\n#### 11.5.1. `{:assumption}`\n\nThis attribute can only be placed on a local ghost bool variable of a method.\nIts declaration cannot have a rhs, but it is allowed to participate as the lhs\nof exactly one assignment of the form: `b := b && expr;`. Such a variable\ndeclaration translates in the Boogie output to a declaration followed by an\n`assume b` command. See [@LeinoWuestholz2015], Section 3, for example uses of\nthe `{:assumption}` attribute in Boogie.\n\n### 11.6. Attributes on quantifier expressions (forall, exists)\n\n#### 11.6.1. `{:heapQuantifier}`\n\n*This attribute has been removed.*\n\n#### 11.6.2. `{:induction}`\n\nSee [`{:induction}`][1064] for functions and methods.\n\n#### 11.6.3. `{:trigger}`\n\nTrigger attributes are used on quantifiers and comprehensions.\n\nThe verifier instantiates the body of a quantified expression only when it can\nfind an expression that matches the provided trigger.\n\nHere is an example:\n\n`predicate P(i: int)\npredicate Q(i: int)\n\nlemma {:axiom} PHoldEvenly()\n  ensures  forall i {:trigger Q(i)} :: P(i) ==> P(i + 2) && Q(i)\n\nlemma PHoldsForTwo()\n  ensures forall i :: P(i) ==> P(i + 4)\n{\n  forall j: int\n    ensures P(j) ==> P(j + 4)\n  {\n    if P(j) {\n      assert P(j); // Trivial assertion\n      \n      PHoldEvenly();\n      // Invoking the lemma assumes `forall i :: P(i) ==> P(i + 4)`,\n      // but it's not instantiated yet\n      \n      // The verifier sees `Q(j)`, so it instantiates\n      // `forall i :: P(i) ==> P(i + 4)` with `j`\n      // and we get the axiom `P(j) ==> P(j + 2) && Q(j)`\n      assert Q(j);     // hence it can prove `Q(j)`\n      assert P(j + 2); //   and it can prove `P(j + 2)`\n      assert P(j + 4); // But it cannot prove this\n      // because it did not instantiate `forall i :: P(i) ==> P(i + 4)` with `j+\n2`\n    }\n  }\n}\n`\n\nHere are ways one can prove `assert P(j + 4);`:\n\n* Add `assert Q(j + 2);` just before `assert P(j + 4);`, so that the verifier\n  sees the trigger.\n* Change the trigger `{:trigger Q(i)}` to `{:trigger P(i)}` (replace the\n  trigger)\n* Change the trigger `{:trigger Q(i)}` to `{:trigger Q(i)} {:trigger P(i)}` (add\n  a trigger)\n* Remove `{:trigger Q(i)}` so that it will automatically determine all possible\n  triggers thanks to the option `/autoTriggers:1` which is the default.\n\n### 11.7. Deprecated attributes\n\nThese attributes have been deprecated or removed. They are no longer useful (or\nperhaps never were) or were experimental. They will likely be removed entirely\nsometime soon after the release of Dafny 4.\n\nRemoved:\n\n* :heapQuantifier\n* :dllimport\n* :handle\n\nDeprecated:\n\n* :opaque : This attribute has been promoted to a first-class modifier for\n  functions. Find more information [here][1065].\n\n### 11.8. Other undocumented verification attributes\n\nA scan of Dafny’s sources shows it checks for the following attributes.\n\n* `{:$}`\n* `{:$renamed$}`\n* `{:InlineAssume}`\n* `{:PossiblyUnreachable}`\n* `{:__dominator_enabled}`\n* `{:__enabled}`\n* `{:a##post##}`\n* `{:absdomain}`\n* `{:ah}`\n* `{:assumption}`\n* `{:assumption_variable_initialization}`\n* `{:atomic}`\n* `{:aux}`\n* `{:both}`\n* `{:bvbuiltin}`\n* `{:candidate}`\n* `{:captureState}`\n* `{:checksum}`\n* `{:constructor}`\n* `{:datatype}`\n* `{:do_not_predicate}`\n* `{:entrypoint}`\n* `{:existential}`\n* `{:exitAssert}`\n* `{:expand}`\n* `{:extern}`\n* `{:focus}`\n* `{:hidden}`\n* `{:ignore}`\n* `{:inline}`\n* `{:left}`\n* `{:linear}`\n* `{:linear_in}`\n* `{:linear_out}`\n* `{:msg}`\n* `{:name}`\n* `{:originated_from_invariant}`\n* `{:partition}`\n* `{:positive}`\n* `{:post}`\n* `{:pre}`\n* `{:precondition_previous_snapshot}`\n* `{:qid}`\n* `{:right}`\n* `{:selective_checking}`\n* `{:si_fcall}`\n* `{:si_unique_call}`\n* `{:sourcefile}`\n* `{:sourceline}`\n* `{:split_here}`\n* `{:stage_active}`\n* `{:stage_complete}`\n* `{:staged_houdini_tag}`\n* `{:start_checking_here}`\n* `{:subsumption}`\n* `{:template}`\n* `{:terminates}`\n* `{:upper}`\n* `{:verified_under}`\n* `{:weight}`\n* `{:yields}`\n\n### 11.9. New attribute syntax\n\nThere is a new syntax for typed prefix attributes that is being added:\n`@Attribute(...)`. For now, the new syntax works only as top-level declarations.\nWhen all previous attributes will be migrated, this section will be rewritten.\nFor example, you can write\n\n`@IsolateAssertions\nmethod Test() {\n}\n`\n\ninstead of\n\n`method {:isolate_assertions} Test() {\n}\n`\n\nDafny rewrites `@`-attributes to old-style equivalent attributes. The definition\nof these attributes is similar to the following:\n\n`datatype Attribute =\n  | AutoContracts\n  | AutoRequires\n  | AutoRevealDependenciesAll\n  | AutoRevealDependencies\n  | Axiom\n  | Compile(bool)\n  | Concurrent\n  | DisableNonlinearArithmetic\n  | Fuel(low: int, high: int := low + 1, functionName: string := \"\")\n  | IsolateAssertions\n  | NativeUInt8 | NativeInt8 ... | NativeUInt128 | NativeInt128 | NativeInt | Na\ntiveNone | NativeIntOrReal\n  | Options(string)\n  | Print\n  | Priority(weight: int)\n  | ResourceLimit(value: string)\n  | Synthesize\n  | TimeLimit(amount: int)\n  | TimeLimitMultiplier(multiplier: int)\n  | TailRecursion\n  | Test\n  | TestEntry\n  | TestInline(amount: int)\n  | Transparent\n  | VcsMaxCost\n  | VcsMaxKeepGoingSplits\n  | VcsMaxSplits\n  | Verify(verify: bool)\n  | VerifyOnly\n  \n`\n\n@-attributes have the same checks as regular resolved datatype values\n\n* The attribute should exist\n* Arguments should be compatible with the parameters, like for a datatype\n  constructor call\n\nHowever, @-attributes have more checks:\n\n* The attribute should be applied to a place where it can be used by Dafny\n* Arguments should be literals\n\n## 12. Advanced Topics\n\n### 12.1. Type Parameter Completion\n\nGeneric types, like `A<T,U>`, consist of a *type constructor*, here `A`, and\ntype parameters, here `T` and `U`. Type constructors are not first-class\nentities in Dafny, they are always used syntactically to construct type names;\nto do so, they must have the requisite number of type parameters, which must be\neither concrete types, type parameters, or a generic type instance.\n\nHowever, those type parameters do not always have to be explicit; Dafny can\noften infer what they ought to be. For example, here is a fully parameterized\nfunction signature:\n\n`type List<T>\nfunction Elements<T>(list: List<T>): set<T>\n`\n\nHowever, Dafny also accepts\n\n`type List<T>\nfunction Elements(list: List): set\n`\n\nIn the latter case, Dafny knows that the already defined types `set` and `List`\neach take one type parameter so it fills in `<T>` (using some unique type\nparameter name) and then determines that the function itself needs a type\nparameter `<T>` as well.\n\nDafny also accepts\n\n`type List<T>\nfunction Elements<T>(list: List): set\n`\n\nIn this case, the function already has a type parameter list. `List` and `set`\nare each known to need type parameters, so Dafny takes the first `n` parameters\nfrom the function signature and applies them to `List` and `set`, where `n`\n(here `1`) is the number needed by those type constructors.\n\nIt never hurts to simply write in all the type parameters, but that can reduce\nreadability. Omitting them in cases where Dafny can intuit them makes a more\ncompact definition.\n\nThis process is described in more detail with more examples in this paper:\n[http://leino.science/papers/krml270.html][1066].\n\n### 12.2. Type Inference\n\nSignatures of methods, functions, fields (except `const` fields with a RHS), and\ndatatype constructors have to declare the types of their parameters. In other\nplaces, types can be omitted, in which case Dafny attempts to infer them. Type\ninference is “best effort” and may fail. If it fails to infer a type, the remedy\nis simply for the program to give the type explicitly.\n\nDespite being just “best effort”, the types of most local variables, bound\nvariables, and the type parameters of calls are usually inferred without the\nneed for a program to give the types explicitly. Here are some notes about type\ninference:\n\n* With some exceptions, type inference is performed across a whole method body.\n  In some cases, the information needed to infer a local variable’s type may be\n  found after the variable has been declared and used. For example, the\n  nonsensical program\n````dafny\nmethod M(n: nat) returns (y: int)\n{\n  var a, b;\n  for i := 0 to n {\n    if i % 2 == 0 {\n      a := a + b;\n    }\n  }\n  y := a;\n}\n```\n`\n\nuses `a` and `b` after their declarations. Still, their types are inferred to be\n`int`, because of the presence of the assignment `y := a;`.\n\nA more useful example is this:\n\n````dafny\nclass Cell {\n  var data: int\n}\n\nmethod LastFive(a: array<int>) returns (r: int)\n{\n  var u := null;\n  for i := 0 to a.Length {\n    if a[i] == 5 {\n      u := new Cell;\n      u.data := i;\n    }\n  }\n  r := if u == null then a.Length else u.data;\n}\n```\n`\n\nHere, using only the assignment `u := null;` to infer the type of `u` would not\nbe helpful. But Dafny looks past the initial assignment and infers the type of\n`u` to be `Cell?`.\n\n* The primary example where type inference does not inspect the entire context\n  before giving up on inference is when there is a member lookup. For example,\n````dafny\ndatatype List<T> = Nil | Cons(T, List<T>)\n\nmethod Tutone() {\n  assert forall pair :: pair.0 == 867 && pair.1 == 5309 ==> pair == (867, 5309);\n // error: members .0 and .1 not found\n  assert forall pair: (int, int) :: pair.0 == 867 && pair.1 == 5309 ==> pair == \n(867, 5309);\n}\n```\n`\n\nIn the first quantifier, type inference fails to infer the type of `pair` before\nit tries to look up the members `.0` and `.1`, which results in a “type of the\nreceiver not fully determined” error. The remedy is to provide the type of\n`pair` explicitly, as is done in the second quantifier.\n\n(In the future, Dafny may do more type inference before giving up on the member\nlookup.)\n\n* If type parameters cannot be inferred, then they can be given explicitly in\n  angle brackets. For example, in\n````dafny\ndatatype Option<T> = None | Some(T)\n\nmethod M() {\n  var a: Option<int> := None;\n  var b := None; // error: type is underspecified\n  var c := Option<int>.None;\n  var d := None;\n  d := Some(400);\n}\n```\n`\n\nthe type of `b` cannot be inferred, because it is underspecified. However, the\ntypes of `c` and `d` are inferred to be `Option<int>`.\n\nHere is another example:\n\n````dafny\nfunction EmptySet<T>(): set<T> {\n  {}\n}\n\nmethod M() {\n  var a := EmptySet(); // error: type is underspecified\n  var b := EmptySet();\n  b := b + {2, 3, 5};\n  var c := EmptySet<int>();\n}\n```\n`\n\nThe type instantiation in the initial assignment to `a` cannot be inferred,\nbecause it is underspecified. However, the type instantiation in the initial\nassignment to `b` is inferred to be `int`, and the types of `b` and `c` are\ninferred to be `set<int>`.\n\n* Even the element type of `new` is optional, if it can be inferred. For\n  example, in\n````dafny\nmethod NewArrays()\n{\n  var a := new int[3];\n  var b: array<int> := new [3];\n  var c := new [3];\n  c[0] := 200;\n  var d := new [3] [200, 800, 77];\n  var e := new [] [200, 800, 77];\n  var f := new [3](_ => 990);\n}\n```\n`\n\nthe omitted types of local variables are all inferred as `array<int>` and the\nomitted element type of each `new` is inferred to be `int`.\n\n* In the absence of any other information, integer-looking literals (like `5`\n  and `7`) are inferred to have type `int` (and not, say, `bv128` or `ORDINAL`).\n* Many of the types inferred can be inspected in the IDE.\n\n### 12.3. Ghost Inference\n\nAfter^{[14][1067]} [type inference][1068], Dafny revisits the program and makes\na final decision about which statements are to be compiled, and which statements\nare ghost. The ghost statements form what is called the *ghost context* of\nexpressions.\n\nThese statements are determined to be ghost:\n\n* [`assert`][1069], [`assume`][1070], [`reveal`][1071], and [`calc`][1072]\n  statements.\n* The body of the `by` of an [`assert`][1073] statement.\n* Calls to ghost methods, including [lemmas][1074].\n* [`if`][1075], [`match`][1076], and [`while`][1077] statements with condition\n  expressions or alternatives containing ghost expressions. Their bodies are\n  also ghost.\n* [`for`][1078] loops whose start expression contains ghost expressions.\n* [Variable declarations][1079] if they are explicitly ghost or if their\n  respective right-hand side is a ghost expression.\n* [Assignments or update statement][1080] if all updated variables are ghost.\n* [`forall`][1081] statements, unless there is exactly one assignment to a\n  non-ghost array in its body.\n\nThese statements always non-ghost:\n\n* [`expect`][1082] statements.\n* [`print`][1083] statements.\n\nThe following expressions are ghost, which is used in some of the tests above:\n\n* All [specification expressions][1084]\n* All calls to functions and predicates marked as `ghost`\n* All variables, [constants][1085] and [fields][1086] declared using the `ghost`\n  keyword\n\nNote that inferring ghostness can uncover other errors, such as updating\nnon-ghost variables in ghost contexts. For example, if `f` is a ghost function,\nin the presence of the following code:\n\n`var x := 1;\nif(f(x)) {\n  x := 2;\n}\n`\n\nDafny will infer that the entire `if` is ghost because the condition uses a\nghost function, and will then raise the error that it’s not possible to update\nthe non-ghost variable `x` in a ghost context.\n\n### 12.4. Well-founded Functions and Extreme Predicates\n\nRecursive functions are a core part of computer science and mathematics. Roughly\nspeaking, when the definition of such a function spells out a terminating\ncomputation from given arguments, we may refer to it as a *well-founded\nfunction*. For example, the common factorial and Fibonacci functions are\nwell-founded functions.\n\nThere are also other ways to define functions. An important case regards the\ndefinition of a boolean function as an extreme solution (that is, a least or\ngreatest solution) to some equation. For computer scientists with interests in\nlogic or programming languages, these *extreme predicates* are important because\nthey describe the judgments that can be justified by a given set of inference\nrules (see, e.g., [@CamilleriMelham:InductiveRelations;\n@Winskel:FormalSemantics; @LeroyGrall:CoinductiveBigStep;\n@Pierce:SoftwareFoundations; @NipkowKlein:ConcreteSemantics]).\n\nTo benefit from machine-assisted reasoning, it is necessary not just to\nunderstand extreme predicates but also to have techniques for proving theorems\nabout them. A foundation for this reasoning was developed by Paulin-Mohring\n[@PaulinMohring:InductiveCoq] and is the basis of the constructive logic\nsupported by Coq [@Coq:book] as well as other proof assistants\n[@BoveDybjerNorell:BriefAgda; @SwamyEtAl:Fstar2011]. Essentially, the idea is to\nrepresent the knowledge that an extreme predicate holds by the proof term by\nwhich this knowledge was derived. For a predicate defined as the least solution,\nsuch proof terms are values of an inductive datatype (that is, finite proof\ntrees), and for the greatest solution, a coinductive datatype (that is, possibly\ninfinite proof trees). This means that one can use induction and coinduction\nwhen reasoning about these proof trees. These extreme predicates are known as,\nrespectively, *least predicates* and *greatest predicates*. Support for extreme\npredicates is also available in the proof assistants Isabelle\n[@Paulson:CADE1994] and HOL [@Harrison:InductiveDefs].\n\nDafny supports both well-founded functions and extreme predicates. This section\ndescribes the difference in general terms, and then describes novel syntactic\nsupport in Dafny for defining and proving lemmas with extreme predicates.\nAlthough Dafny’s verifier has at its core a first-order SMT solver, Dafny’s\nlogical encoding makes it possible to reason about fixpoints in an automated\nway.\n\nThe encoding for greatest predicates in Dafny was described previously\n[@LeinoMoskal:Coinduction] and is here described in [the section about\ndatatypes][1087].\n\n#### 12.4.1. Function Definitions\n\nTo define a function $f \\colon X \\to Y$ in terms of itself, one can write a\ngeneral equation like\n\n$$f = \\mathcal{F}(f)$$\n\nwhere $\\mathcal{F}$ is a non-recursive function of type $(X \\to Y) \\to X \\to Y$.\nBecause it takes a function as an argument, $\\mathcal{F}$ is referred to as a\n*functor* (or *functional*, but not to be confused by the category-theory notion\nof a functor). Throughout, assume that $\\mathcal{F}(f)$ by itself is well\ndefined, for example that it does not divide by zero. Also assume that $f$\noccurs only in fully applied calls in $\\mathcal{F}(f)$; eta expansion can be\napplied to ensure this. If $f$ is a `boolean` function, that is, if $Y$ is the\ntype of booleans, then $f$ is called a *predicate*.\n\nFor example, the common Fibonacci function over the natural numbers can be\ndefined by the equation\n\n$$ \\mathit{fib} = \\lambda n \\bullet\\: \\mathbf{if}\\:n < 2 \\:\\mathbf{then}\\: n\n\\:\\mathbf{else}\\: \\mathit{fib}(n-2) + \\mathit{fib}(n-1) $$\n\nWith the understanding that the argument $n$ is universally quantified, we can\nwrite this equation equivalently as\n\n$$ \\mathit{fib}(n) = \\mathbf{if}\\:n <\n2\\:\\mathbf{then}\\:n\\:\\mathbf{else}\\:\\mathit{fib}(n-2)%2B\\mathit{fib}(n-1) $$\n\nThe fact that the function being defined occurs on both sides of the equation\ncauses concern that we might not be defining the function properly, leading to a\nlogical inconsistency. In general, there could be many solutions to an equation\nlike [the general equation][1088] or there could be none. Let’s consider two\nways to make sure we’re defining the function uniquely.\n\n12.4.1.1. Well-founded Functions\n\nA standard way to ensure that [the general equation][1089] has a unique solution\nin $f$ is to make sure the recursion is well-founded, which roughly means that\nthe recursion terminates. This is done by introducing any well-founded relation\n$\\ll$ on the domain of $f$ and making sure that the argument to each recursive\ncall goes down in this ordering. More precisely, if we formulate [the general\nequation][1090] as\n\n$$ f(x) = \\mathcal{F}{'}(f) $$\n\nthen we want to check $E \\ll x$ for each call $f(E)$ in $f(x) =\n\\mathcal{F}’(f)$. When a function definition satisfies this *decrement\ncondition*, then the function is said to be *well-founded*.\n\nFor example, to check the decrement condition for $\\mathit{fib}$ in [the fib\nequation][1091], we can pick $\\ll$ to be the arithmetic less-than relation on\nnatural numbers and check the following, for any $n$:\n\n$$ 2 \\leq n \\;\\Longrightarrow\\; n-2 \\ll n \\;\\wedge\\; n-1 \\ll n $$\n\nNote that we are entitled to use the antecedent $2 \\leq n$ because that is the\ncondition under which the else branch in [the fib equation][1092] is evaluated.\n\nA well-founded function is often thought of as “terminating” in the sense that\nthe recursive *depth* in evaluating $f$ on any given argument is finite. That\nis, there are no infinite descending chains of recursive calls. However, the\nevaluation of $f$ on a given argument may fail to terminate, because its *width*\nmay be infinite. For example, let $P$ be some predicate defined on the ordinals\nand let $\\mathit{P}_\\downarrow$ be a predicate on the ordinals defined by the\nfollowing equation:\n\n$\\mathit{P}_\\downarrow = P(o) \\;\\wedge\\; \\forall p \\bullet\\; p \\ll o\n\\;\\Longrightarrow\\; \\mathit{P}_\\downarrow(p)$\n\nWith $\\ll$ as the usual ordering on ordinals, this equation satisfies the\ndecrement condition, but evaluating $\\mathit{P}_\\downarrow(\\omega)$ would\nrequire evaluating $\\mathit{P}_\\downarrow(n)$ for every natural number $n$.\nHowever, what we are concerned about here is to avoid mathematical\ninconsistencies, and that is indeed a consequence of the decrement condition.\n\n12.4.1.2. Example with Well-founded Functions\n\nSo that we can later see how inductive proofs are done in Dafny, let’s prove\nthat for any $n$, $\\mathit{fib}(n)$ is even iff $n$ is a multiple of $3$. We\nsplit our task into two cases. If $n < 2$, then the property follows directly\nfrom the definition of $\\mathit{fib}$. Otherwise, note that exactly one of the\nthree numbers $n-2$, $n-1$, and $n$ is a multiple of 3. If $n$ is the multiple\nof 3, then by invoking the induction hypothesis on $n-2$ and $n-1$, we obtain\nthat $\\mathit{fib}(n-2) + \\mathit{fib}(n-1)$ is the sum of two odd numbers,\nwhich is even. If $n-2$ or $n-1$ is a multiple of 3, then by invoking the\ninduction hypothesis on $n-2$ and $n-1$, we obtain that $\\mathit{fib}(n-2) +\n\\mathit{fib}(n-1)$ is the sum of an even number and an odd number, which is odd.\nIn this proof, we invoked the induction hypothesis on $n-2$ and on $n-1$. This\nis allowed, because both are smaller than $n$, and hence the invocations go down\nin the well-founded ordering on natural numbers.\n\n12.4.1.3. Extreme Solutions\n\nWe don’t need to exclude the possibility of [the general equation][1093] having\nmultiple solutions—instead, we can just be clear about which one of them we\nwant. Let’s explore this, after a smidgen of lattice theory.\n\nFor any complete lattice $(Y,\\leq)$ and any set $X$, we can by *pointwise\nextension* define a complete lattice $(X \\to Y, \\dot{\\Rightarrow})$, where for\nany $f,g \\colon X \\to Y$,\n\n$$ f \\dot{\\Rightarrow} g \\;\\;\\equiv\\;\\; \\forall x \\bullet\\; f(x) \\leq g(x) $$\n\nIn particular, if $Y$ is the set of booleans ordered by implication (`false`\n$\\leq$ `true`), then the set of predicates over any domain $X$ forms a complete\nlattice. Tarski’s Theorem [@Tarski:theorem] tells us that any monotonic function\nover a complete lattice has a least and a greatest fixpoint. In particular, this\nmeans that $\\mathcal{F}$ has a least fixpoint and a greatest fixpoint, provided\n$\\mathcal{F}$ is monotonic.\n\nSpeaking about the *set of solutions* in $f$ to [the general equation][1094] is\nthe same as speaking about the *set of fixpoints* of functor $\\mathcal{F}$. In\nparticular, the least and greatest solutions to [the general equation][1095] are\nthe same as the least and greatest fixpoints of $\\mathcal{F}$. In casual speak,\nit happens that we say “fixpoint of [the general equation][1096]”, or more\ngrotesquely, “fixpoint of $f$” when we really mean “fixpoint of $\\mathcal{F}$”.\n\nTo conclude our little excursion into lattice theory, we have that, under the\nproviso of $\\mathcal{F}$ being monotonic, the set of solutions in $f$ to [the\ngeneral equation][1097] is nonempty, and among these solutions, there is in the\n$\\dot{\\Rightarrow}$ ordering a least solution (that is, a function that returns\n`false` more often than any other) and a greatest solution (that is, a function\nthat returns `true` more often than any other).\n\nWhen discussing extreme solutions, let’s now restrict our attention to boolean\nfunctions (that is, with $Y$ being the type of booleans). Functor $\\mathcal{F}$\nis monotonic if the calls to $f$ in $\\mathcal{F}’(f)$ are in *positive\npositions* (that is, under an even number of negations). Indeed, from now on, we\nwill restrict our attention to such monotonic functors $\\mathcal{F}$.\n\nHere is a running example. Consider the following equation, where $x$ ranges\nover the integers:\n\n$$ g(x) = (x = 0 \\:\\vee\\: g(x-2)) $$\n\nThis equation has four solutions in $g$. With $w$ ranging over the integers,\nthey are:\n\n$$ \\begin{array}{r@{}l} g(x) \\;\\;\\equiv\\;\\;{}& x \\in \\{w \\;|\\; 0 \\leq w\n\\;\\wedge\\; w\\textrm{ even}\\} \\\\ g(x) \\;\\;\\equiv\\;\\;{}& x \\in \\{w \\;|\\; w\\textrm{\neven}\\} \\\\ g(x) \\;\\;\\equiv\\;\\;{}& x \\in \\{w \\;|\\; (0 \\leq w \\;\\wedge\\; w\\textrm{\neven}) \\:\\vee\\: w\\textrm{ odd}\\} \\\\ g(x) \\;\\;\\equiv\\;\\;{}& x \\in \\{w \\;|\\;\n\\mathit{true}\\} \\end{array} $$\n\nThe first of these is the least solution and the last is the greatest solution.\n\nIn the literature, the definition of an extreme predicate is often given as a\nset of *inference rules*. To designate the least solution, a single line\nseparating the antecedent (on top) from conclusion (on bottom) is used:\n\n$$\\dfrac{}{g(0)} \\qquad\\qquad \\dfrac{g(x-2)}{g(x)}$$\n\nThrough repeated applications of such rules, one can show that the predicate\nholds for a particular value. For example, the *derivation*, or *proof tree*, to\nthe left in [the proof tree figure][1098] shows that $g(6)$ holds. (In this\nsimple example, the derivation is a rather degenerate proof “tree”.) The use of\nthese inference rules gives rise to a least solution, because proof trees are\naccepted only if they are *finite*.\n\nWhen inference rules are to designate the greatest solution, a thick line is\nused:\n\n$$\\genfrac{}{}{1.2pt}0{}{g(0)} \\qquad\\qquad \\genfrac{}{}{1.2pt}0{g(x-2)}{g(x)}$$\n\nIn this case, proof trees are allowed to be infinite. For example, the left-hand\nexample below shows a finite proof tree that uses [the inductive rules][1099] to\nestablish $g(6)$. On the right is a partial depiction of an infinite proof tree\nthat uses [the coinductive rules][1100] to establish $g(1)$.\n\n$$\\dfrac{ \\dfrac{ \\dfrac{ \\dfrac{}{g(0)} }{g(2)} }{g(4)} }{g(6)} \\qquad\\qquad\n\\genfrac{}{}{1.2pt}0{ \\genfrac{}{}{1.2pt}0{ \\genfrac{}{}{1.2pt}0{\n\\genfrac{}{}{1.2pt}0{ {} {\\vdots } }{g(-5)} }{g(-3)} }{g(-1)} }{g(1)}$$\n\nNote that derivations may not be unique. For example, in the case of the\ngreatest solution for $g$, there are two proof trees that establish $g(0)$: one\nis the finite proof tree that uses the left-hand rule of [these coinductive\nrules][1101] once, the other is the infinite proof tree that keeps on using the\nright-hand rule of [these coinductive rules][1102].\n\n#### 12.4.2. Working with Extreme Predicates\n\nIn general, one cannot evaluate whether or not an extreme predicate holds for\nsome input, because doing so may take an infinite number of steps. For example,\nfollowing the recursive calls in the definition [the EvenNat equation][1103] to\ntry to evaluate $g(7)$ would never terminate. However, there are useful ways to\nestablish that an extreme predicate holds and there are ways to make use of one\nonce it has been established.\n\nFor any $\\mathcal{F}$ as in [the general equation][1104], define two infinite\nseries of well-founded functions, ${ {}^{\\flat}\\kern-1mm f}_k$ and ${\n{}^{\\sharp}\\kern-1mm f}_k$ where $k$ ranges over the natural numbers:\n\n$$ { {}^{\\flat}\\kern-1mm f}_k(x) = \\left\\{ \\begin{array}{ll} \\mathit{false} &\n\\textrm{if } k = 0 \\\\ \\mathcal{F}({ {}^{\\flat}\\kern-1mm f}_{k-1})(x) &\n\\textrm{if } k > 0 \\end{array} \\right\\} $$\n\n$$ { {}^{\\sharp}\\kern-1mm f}_k(x) = \\left\\{ \\begin{array}{ll} \\mathit{true} &\n\\textrm{if } k = 0 \\\\ \\mathcal{F}({ {}^{\\sharp}\\kern-1mm f}_{k-1})(x) &\n\\textrm{if } k > 0 \\end{array} \\right\\} $$\n\nThese functions are called the *iterates* of $f$, and we will also refer to them\nas the *prefix predicates* of $f$ (or the *prefix predicate* of $f$, if we think\nof $k$ as being a parameter). Alternatively, we can define ${\n{}^{\\flat}\\kern-1mm f}_k$ and ${ {}^{\\sharp}\\kern-1mm f}_k$ without mentioning\n$x$: let $\\bot$ denote the function that always returns `false`, let $\\top$\ndenote the function that always returns `true`, and let a superscript on\n$\\mathcal{F}$ denote exponentiation (for example, $\\mathcal{F}^0(f) = f$ and\n$\\mathcal{F}^2(f) = \\mathcal{F}(\\mathcal{F}(f))$). Then, [the least approx\ndefinition][1105] and [the greatest approx definition][1106] can be stated\nequivalently as ${ {}^{\\flat}\\kern-1mm f}_k = \\mathcal{F}^k(\\bot)$ and ${\n{}^{\\sharp}\\kern-1mm f}_k = \\mathcal{F}^k(\\top)$.\n\nFor any solution $f$ to [the general equation][1107], we have, for any $k$ and\n$\\ell$ such that $k \\leq \\ell$:\n\n$$ {\\;{}^{\\flat}\\kern-1mm f}_k \\quad\\;\\dot{\\Rightarrow}\\;\\quad\n{\\;{}^{\\flat}\\kern-1mm f}_\\ell \\quad\\;\\dot{\\Rightarrow}\\;\\quad f\n\\quad\\;\\dot{\\Rightarrow}\\;\\quad {\\;{}^{\\sharp}\\kern-1mm f}_\\ell\n\\quad\\;\\dot{\\Rightarrow}\\;\\quad { {}^{\\sharp}\\kern-1mm f}_k $$\n\nIn other words, every ${\\;{}^{\\flat}\\kern-1mm f}_{k}$ is a *pre-fixpoint* of $f$\nand every ${\\;{}^{\\sharp}\\kern-1mm f}_{k}$ is a *post-fixpoint* of $f$. Next,\ndefine two functions, $f^{\\downarrow}$ and $f^{\\uparrow}$, in terms of the\nprefix predicates:\n\n$$ f^{\\downarrow}(x) \\;=\\; \\exists k \\bullet\\; { {}^{\\flat}\\kern-1mm f}_k(x) $$\n\n$$ f^{\\uparrow}(x) \\;=\\; \\forall k \\bullet\\; { {}^{\\sharp}\\kern-1mm f}_k(x) $$\n\nBy [the prefix postfix result][1108], we also have that $f^{\\downarrow}$ is a\npre-fixpoint of $\\mathcal{F}$ and $f^{\\uparrow}$ is a post-fixpoint of\n$\\mathcal{F}$. The marvelous thing is that, if $\\mathcal{F}$ is *continuous*,\nthen $f^{\\downarrow}$ and $f^{\\uparrow}$ are the least and greatest fixpoints of\n$\\mathcal{F}$. These equations let us do proofs by induction when dealing with\nextreme predicates. [The extreme predicate section][1109] explains how to check\nfor continuity.\n\nLet’s consider two examples, both involving function $g$ in [the EvenNat\nequation][1110]. As it turns out, $g$’s defining functor is continuous, and\ntherefore I will write $g^{\\downarrow}$ and $g^{\\uparrow}$ to denote the least\nand greatest solutions for $g$ in [the EvenNat equation][1111].\n\n12.4.2.1. Example with Least Solution\n\nThe main technique for establishing that $g^{\\downarrow}(x)$ holds for some $x$,\nthat is, proving something of the form $Q \\Longrightarrow g^{\\downarrow}(x)$, is\nto construct a proof tree like the one for $g(6)$ in [the proof tree\nfigure][1112]. For a proof in this direction, since we’re just applying the\ndefining equation, the fact that we’re using a least solution for $g$ never\nplays a role (as long as we limit ourselves to finite derivations).\n\nThe technique for going in the other direction, proving something *from* an\nestablished $g^{\\downarrow}$ property, that is, showing something of the form\n$g^{\\downarrow}(x) \\Longrightarrow R$, typically uses induction on the structure\nof the proof tree. When the antecedent of our proof obligation includes a\npredicate term $g^{\\downarrow}(x)$, it is sound to imagine that we have been\ngiven a proof tree for $g^{\\downarrow}(x)$. Such a proof tree would be a data\nstructure—to be more precise, a term in an *inductive datatype*. Least solutions\nlike $g^{\\downarrow}$ have been given the name *least predicate*.\n\nLet’s prove $g^{\\downarrow}(x) \\Longrightarrow 0 \\leq x \\wedge x \\text{ even}$.\nWe split our task into two cases, corresponding to which of the two proof rules\nin [the inductive rules][1113] was the last one applied to establish\n$g^{\\downarrow}(x)$. If it was the left-hand rule, then $x=0$, which makes it\neasy to establish the conclusion of our proof goal. If it was the right-hand\nrule, then we unfold the proof tree one level and obtain $g^{\\downarrow}(x-2)$.\nSince the proof tree for $g^{\\downarrow}(x-2)$ is smaller than where we started,\nwe invoke the *induction hypothesis* and obtain $0 \\leq (x-2) \\wedge (x-2)\n\\textrm{ even}$, from which it is easy to establish the conclusion of our proof\ngoal.\n\nHere’s how we do the proof formally using [the least exists definition][1114].\nWe massage the general form of our proof goal:\n\n$$ \\begin{array}{lll} & f^{\\uparrow}(x) \\;\\Longrightarrow\\; R & \\\\ = & &\n\\textrm{ (the least exists definition) } \\\\ & (\\exists k \\bullet\\; {\n{}^{\\flat}\\kern-1mm f}_k(x)) \\;\\Longrightarrow\\; R & \\\\ = & & \\text{distribute}\n\\;\\Longrightarrow\\; \\text{over} \\;\\exists\\; \\text{to the left} \\\\ & \\forall k\n\\bullet\\; ({ {}^{\\flat}\\kern-1mm f}_k(x) \\;\\Longrightarrow\\; R) & \\end{array} $$\n\nThe last line can be proved by induction over $k$. So, in our case, we prove ${\n{}^{\\flat}\\kern-1mm g}_k(x) \\Longrightarrow 0 \\leq x \\wedge x \\textrm{ even}$\nfor every $k$. If $k = 0$, then ${ {}^{\\flat}\\kern-1mm g}_k(x)$ is `false`, so\nour goal holds trivially. If $k > 0$, then ${ {}^{\\flat}\\kern-1mm g}_k(x) = (x =\n0 :\\vee: { {}^{\\flat}\\kern-1mm g}_{k-1}(x-2))$. Our goal holds easily for the\nfirst disjunct ($x=0$). For the other disjunct, we apply the induction\nhypothesis (on the smaller $k-1$ and with $x-2$) and obtain $0 \\leq\n(x-2)\\;\\wedge\\; (x-2) \\textrm{ even}$, from which our proof goal follows.\n\n12.4.2.2. Example with Greatest Solution\n\nWe can think of a predicate $g^{\\uparrow}(x)$ as being represented by a proof\ntree—in this case a term in a *coinductive datatype*, since the proof may be\ninfinite. Greatest solutions like $g^{\\uparrow}$ have been given the name\n*greatest predicate*. The main technique for proving something from a given\nproof tree, that is, to prove something of the form $g^{\\uparrow}(x)\n\\;\\Longrightarrow\\; R$, is to destruct the proof. Since this is just unfolding\nthe defining equation, the fact that we’re using a greatest solution for $g$\nnever plays a role (as long as we limit ourselves to a finite number of\nunfoldings).\n\nTo go in the other direction, to establish a predicate defined as a greatest\nsolution, like $Q \\Longrightarrow g^{\\uparrow}(x)$, we may need an infinite\nnumber of steps. For this purpose, we can use induction’s dual, *coinduction*.\nWere it not for one little detail, coinduction is as simple as continuations in\nprogramming: the next part of the proof obligation is delegated to the\n*coinduction hypothesis*. The little detail is making sure that it is the “next”\npart we’re passing on for the continuation, not the same part. This detail is\ncalled *productivity* and corresponds to the requirement in induction of making\nsure we’re going down a well-founded relation when applying the induction\nhypothesis. There are many sources with more information, see for example the\nclassic account by Jacobs and Rutten [@JacobsRutten:IntroductionCoalgebra] or a\nnew attempt by Kozen and Silva that aims to emphasize the simplicity, not the\nmystery, of coinduction [@KozenSilva:Coinduction].\n\nLet’s prove $\\mathit{true} \\Longrightarrow g^{\\uparrow}(x)$. The intuitive\ncoinductive proof goes like this: According to the right-hand rule of [these\ncoinductive rules][1115], $g^{\\uparrow}(x)$ follows if we establish\n$g^{\\uparrow}(x-2)$, and that’s easy to do by invoking the coinduction\nhypothesis. The “little detail”, productivity, is satisfied in this proof\nbecause we applied a rule in [these coinductive rules][1116] before invoking the\ncoinduction hypothesis.\n\nFor anyone who may have felt that the intuitive proof felt too easy, here is a\nformal proof using [the greatest forall definition][1117], which relies only on\ninduction. We massage the general form of our proof goal:\n\n$$ \\begin{array}{lll} & Q \\;\\Longrightarrow\\; f^{\\uparrow}(x) & \\\\ = & &\n\\textrm{ (the greatest forall definition) } \\\\ & Q \\;\\Longrightarrow\\; \\forall k\n\\bullet\\; { {}^{\\sharp}\\kern-1mm f}_k(x) & \\\\ = & & \\text{distribute}\n\\;\\Longrightarrow\\; \\text{over} \\;\\forall\\; \\text{to the right } \\\\ & \\forall k\n\\bullet\\; Q \\;\\Longrightarrow\\; { {}^{\\sharp}\\kern-1mm f}_k(x) & \\end{array} $$\n\nThe last line can be proved by induction over $k$. So, in our case, we prove\n$\\mathit{true} \\;\\Longrightarrow\\; { {}^{\\sharp}\\kern-1mm g}_k(x)$ for every\n$k$. If $k=0$, then ${ {}^{\\sharp}\\kern-1mm g}_k(x)$ is $\\mathit{true}$, so our\ngoal holds trivially. If $k > 0$, then ${ {}^{\\sharp}\\kern-1mm g}_k(x) = (x = 0\n:\\vee: { {}^{\\sharp}\\kern-1mm g}_{k-1}(x-2))$. We establish the second disjunct\nby applying the induction hypothesis (on the smaller $k-1$ and with $x-2$).\n\n#### 12.4.3. Other Techniques\n\nAlthough this section has considered only well-founded functions and extreme\npredicates, it is worth mentioning that there are additional ways of making sure\nthat the set of solutions to [the general equation][1118] is nonempty. For\nexample, if all calls to $f$ in $\\mathcal{F}’(f)$ are *tail-recursive calls*,\nthen (under the assumption that $Y$ is nonempty) the set of solutions is\nnonempty. To see this, consider an attempted evaluation of $f(x)$ that fails to\ndetermine a definite result value because of an infinite chain of calls that\napplies $f$ to each value of some subset $X’$ of $X$. Then, apparently, the\nvalue of $f$ for any one of the values in $X’$ is not determined by the\nequation, but picking any particular result value for these makes for a\nconsistent definition. This was pointed out by Manolios and Moore\n[@ManoliosMoore:PartialFunctions]. Functions can be underspecified in this way\nin the proof assistants ACL2 [@ACL2:book] and HOL [@Krauss:PhD].\n\n### 12.5. Functions in Dafny\n\nThis section explains with examples the support in Dafny for well-founded\nfunctions, extreme predicates, and proofs regarding these, building on the\nconcepts explained in the previous section.\n\n#### 12.5.1. Well-founded Functions in Dafny\n\nDeclarations of well-founded functions are unsurprising. For example, the\nFibonacci function is declared as follows:\n\n`function fib(n: nat): nat\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n`\n\nDafny verifies that the body (given as an expression in curly braces) is well\ndefined. This includes decrement checks for recursive (and mutually recursive)\ncalls. Dafny predefines a well-founded relation on each type and extends it to\nlexicographic tuples of any (fixed) length. For example, the well-founded\nrelation $x \\ll y$ for integers is $x < y \\;\\wedge\\; 0 \\leq y$, the one for\nreals is $x \\leq y - 1.0 \\;\\wedge\\; 0.0 \\leq y$ (this is the same ordering as\nfor integers, if you read the integer relation as $x \\leq y - 1 \\;\\wedge\\; 0\n\\leq y$), the one for inductive datatypes is structural inclusion, and the one\nfor coinductive datatypes is `false`.\n\nUsing a `decreases` clause, the programmer can specify the term in this\npredefined order. When a function definition omits a `decreases` clause, Dafny\nmakes a simple guess. This guess (which can be inspected by hovering over the\nfunction name in the Dafny IDE) is very often correct, so users are rarely\nbothered to provide explicit `decreases` clauses.\n\nIf a function returns `bool`, one can drop the result type `: bool` and change\nthe keyword `function` to `predicate`.\n\n#### 12.5.2. Proofs in Dafny\n\nDafny has `lemma` declarations, as described in [Section 6.3.3][1119]: lemmas\ncan have pre- and postcondition specifications and their body is a code block.\nHere is the lemma we stated and proved in [the fib example][1120] in the\nprevious section:\n\n`lemma FibProperty(n: nat)\n  ensures fib(n) % 2 == 0 <==> n % 3 == 0\n{\n  if n < 2 {\n  } else {\n    FibProperty(n-2); FibProperty(n-1);\n  }\n}\nfunction fib(n: nat): nat\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n`\n\nThe postcondition of this lemma (keyword `ensures`) gives the proof goal. As in\nany program-correctness logic (e.g., [@Hoare:AxiomaticBasis]), the postcondition\nmust be established on every control path through the lemma’s body. For\n`FibProperty`, I give the proof by an `if` statement, hence introducing a case\nsplit. The then branch is empty, because Dafny can prove the postcondition\nautomatically in this case. The else branch performs two recursive calls to the\nlemma. These are the invocations of the induction hypothesis and they follow the\nusual program-correctness rules, namely: the precondition must hold at the call\nsite, the call must terminate, and then the caller gets to assume the\npostcondition upon return. The “proof glue” needed to complete the proof is done\nautomatically by Dafny.\n\nDafny features an aggregate statement using which it is possible to make\n(possibly infinitely) many calls at once. For example, the induction hypothesis\ncan be called at once on all values `n'` smaller than `n`:\n\n`forall n' | 0 <= n' < n {\n  FibProperty(n');\n}\n`\n\nFor our purposes, this corresponds to *strong induction*. More generally, the\n`forall` statement has the form\n\n`forall k | P(k)\n  ensures Q(k)\n{ Statements; }\n`\n\nLogically, this statement corresponds to *universal introduction*: the body\nproves that `Q(k)` holds for an arbitrary `k` such that `P(k)`, and the\nconclusion of the `forall` statement is then $\\forall k \\bullet\\; P(k)\n\\;\\Longrightarrow\\; Q(k)$. When the body of the `forall` statement is a single\ncall (or `calc` statement), the `ensures` clause is inferred and can be omitted,\nlike in our `FibProperty` example.\n\nLemma `FibProperty` is simple enough that its whole body can be replaced by the\none `forall` statement above. In fact, Dafny goes one step further: it\nautomatically inserts such a `forall` statement at the beginning of every lemma\n[@Leino:induction]. Thus, `FibProperty` can be declared and proved simply by:\n\n`lemma FibProperty(n: nat)\n  ensures fib(n) % 2 == 0 <==> n % 3 == 0\n{ }\nfunction fib(n: nat): nat\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n`\n\nGoing in the other direction from universal introduction is existential\nelimination, also known as Skolemization. Dafny has a statement for this, too:\nfor any variable `x` and boolean expression `Q`, the *assign such that*\nstatement `x :| Q;` says to assign to `x` a value such that `Q` will hold. A\nproof obligation when using this statement is to show that there exists an `x`\nsuch that `Q` holds. For example, if the fact $\\exists k \\bullet\\; 100 \\leq\n\\mathit{fib}(k) < 200$ is known, then the statement `k :| 100 <= fib(k) < 200;`\nwill assign to `k` some value (chosen arbitrarily) for which `fib(k)` falls in\nthe given range.\n\n#### 12.5.3. Extreme Predicates in Dafny\n\nThe previous subsection explained that a `predicate` declaration introduces a\nwell-founded predicate. The declarations for introducing extreme predicates are\n`least predicate` and `greatest predicate`. Here is the definition of the least\nand greatest solutions of $g$ from above; let’s call them `g` and `G`:\n\n`least predicate g[nat](x: int) { x == 0 || g(x-2) }\ngreatest predicate G[nat](x: int) { x == 0 || G(x-2) }\n`\n\nWhen Dafny receives either of these definitions, it automatically declares the\ncorresponding prefix predicates. Instead of the names ${ {}^{\\flat}\\kern-1mm\ng}_k$ and ${ {}^{\\sharp}\\kern-1mm g}_k$ that I used above, Dafny names the\nprefix predicates `g#[k]` and `G#[k]`, respectively, that is, the name of the\nextreme predicate appended with `#`, and the subscript is given as an argument\nin square brackets. The definition of the prefix predicate derives from the body\nof the extreme predicate and follows the form in [the least approx\ndefinition][1121] and [the greatest approx definition][1122]. Using a\nfaux-syntax for illustrative purposes, here are the prefix predicates that Dafny\ndefines automatically from the extreme predicates `g` and `G`:\n\n`predicate g#[_k: nat](x: int) { _k != 0 && (x == 0 || g#[_k-1](x-2)) }\npredicate G#[_k: nat](x: int) { _k != 0 ==> (x == 0 || G#[_k-1](x-2)) }\n`\n\nThe Dafny verifier is aware of the connection between extreme predicates and\ntheir prefix predicates, [the least exists definition][1123] and [the greatest\nforall definition][1124].\n\nRemember that to be well defined, the defining functor of an extreme predicate\nmust be monotonic, and for [the least exists definition][1125] and [the greatest\nforall definition][1126] to hold, the functor must be continuous. Dafny enforces\nthe former of these by checking that recursive calls of extreme predicates are\nin positive positions. The continuity requirement comes down to checking that\nthey are also in *continuous positions*: that recursive calls to least\npredicates are not inside unbounded universal quantifiers and that recursive\ncalls to greatest predicates are not inside unbounded existential quantifiers\n[@Milner:CCS; @LeinoMoskal:Coinduction].\n\n#### 12.5.4. Proofs about Extreme Predicates\n\nFrom what has been presented so far, we can do the formal proofs for [the\nexample about the least solution][1127] and [the example about the greatest\nsolution][1128]. Here is the former:\n\n`least predicate g[nat](x: int) { x == 0 || g(x-2) }\ngreatest predicate G[nat](x: int) { x == 0 || G(x-2) }\nlemma EvenNat(x: int)\n  requires g(x)\n  ensures 0 <= x && x % 2 == 0\n{\n  var k: nat :| g#[k](x);\n  EvenNatAux(k, x);\n}\nlemma EvenNatAux(k: nat, x: int)\n  requires g#[k](x)\n  ensures 0 <= x && x % 2 == 0\n{\n  if x == 0 { } else { EvenNatAux(k-1, x-2); }\n}\n`\n\nLemma `EvenNat` states the property we wish to prove. From its precondition\n(keyword `requires`) and [the least exists definition][1129], we know there is\nsome `k` that will make the condition in the assign-such-that statement true.\nSuch a value is then assigned to `k` and passed to the auxiliary lemma, which\npromises to establish the proof goal. Given the condition `g#[k](x)`, the\ndefinition of `g#` lets us conclude `k != 0` as well as the disjunction `x == 0\n|| g#[k-1](x-2)`. The then branch considers the case of the first disjunct, from\nwhich the proof goal follows automatically. The else branch can then assume\n`g#[k-1](x-2)` and calls the induction hypothesis with those parameters. The\nproof glue that shows the proof goal for `x` to follow from the proof goal with\n`x-2` is done automatically.\n\nBecause Dafny automatically inserts the statement\n\n`forall k', x' | 0 <= k' < k && g#[k'](x') {\n  EvenNatAux(k', x');\n}\n`\n\nat the beginning of the body of `EvenNatAux`, the body can be left empty and\nDafny completes the proof automatically.\n\nHere is the Dafny program that gives the proof from [the example of the greatest\nsolution][1130]:\n\n`least predicate g[nat](x: int) { x == 0 || g(x-2) }\ngreatest predicate G[nat](x: int) { x == 0 || G(x-2) }\nlemma Always(x: int)\n  ensures G(x)\n{ forall k: nat { AlwaysAux(k, x); } }\nlemma AlwaysAux(k: nat, x: int)\n  ensures G#[k](x)\n{ }\n`\n\nWhile each of these proofs involves only basic proof rules, the setup feels a\nbit clumsy, even with the empty body of the auxiliary lemmas. Moreover, the\nproofs do not reflect the intuitive proofs described in [the example of the\nleast solution][1131] and [the example of the greatest solution][1132]. These\nshortcomings are addressed in the next subsection.\n\n#### 12.5.5. Nicer Proofs of Extreme Predicates\n\nThe proofs we just saw follow standard forms: use Skolemization to convert the\nleast predicate into a prefix predicate for some `k` and then do the proof\ninductively over `k`; respectively, by induction over `k`, prove the prefix\npredicate for every `k`, then use universal introduction to convert to the\ngreatest predicate. With the declarations `least lemma` and `greatest lemma`,\nDafny offers to set up the proofs in these standard forms. What is gained is not\njust fewer characters in the program text, but also a possible intuitive reading\nof the proofs. (Okay, to be fair, the reading is intuitive for simpler proofs;\ncomplicated proofs may or may not be intuitive.)\n\nSomewhat analogous to the creation of prefix predicates from extreme predicates,\nDafny automatically creates a *prefix lemma* `L#` from each “extreme lemma” `L`.\nThe pre- and postconditions of a prefix lemma are copied from those of the\nextreme lemma, except for the following replacements:\n\n* for a least lemma, Dafny looks in the precondition to find calls (in positive,\n  continuous positions) to least predicates `P(x)` and replaces these with\n  `P#[_k](x)`;\n* for a greatest lemma, Dafny looks in the postcondition to find calls (in\n  positive, continuous positions) to greatest predicates `P` (including equality\n  among coinductive datatypes, which is a built-in greatest predicate) and\n  replaces these with `P#[_k](x)`. In each case, these predicates `P` are the\n  lemma’s *focal predicates*.\n\nThe body of the extreme lemma is moved to the prefix lemma, but with replacing\neach recursive call `L(x)` with `L#[_k-1](x)` and replacing each occurrence of a\ncall to a focal predicate `P(x)` with `P#[_k-1](x)`. The bodies of the extreme\nlemmas are then replaced as shown in the previous subsection. By construction,\nthis new body correctly leads to the extreme lemma’s postcondition.\n\nLet us see what effect these rewrites have on how one can write proofs. Here are\nthe proofs of our running example:\n\n`least predicate g(x: int) { x == 0 || g(x-2) }\ngreatest predicate G(x: int) { x == 0 || G(x-2) }\nleast lemma EvenNat(x: int)\n  requires g(x)\n  ensures 0 <= x && x % 2 == 0\n{ if x == 0 { } else { EvenNat(x-2); } }\ngreatest lemma Always(x: int)\n  ensures G(x)\n{ Always(x-2); }\n`\n\nBoth of these proofs follow the intuitive proofs given in [the example of the\nleast solution][1133] and [the example of the greatest solution][1134]. Note\nthat in these simple examples, the user is never bothered with either prefix\npredicates nor prefix lemmas—the proofs just look like “what you’d expect”.\n\nSince Dafny automatically inserts calls to the induction hypothesis at the\nbeginning of each lemma, the bodies of the given extreme lemmas `EvenNat` and\n`Always` can be empty and Dafny still completes the proofs. Folks, it doesn’t\nget any simpler than that!\n\n### 12.6. Variable Initialization and Definite Assignment\n\nThe Dafny language semantics ensures that any use (read) of a variable (or\nconstant, parameter, object field, or array element) gives a value of the\nvariable’s type. It is easy to see that this property holds for any variable\nthat is declared with an initializing assignment. However, for many useful\nprograms, it would be too strict to require an initializing assignment at the\ntime a variable is declared. Instead, Dafny ensures the property through\n*auto-initialization* and rules for *definite assignment*.\n\nAs explained in [section 5.3.1][1135], each type in Dafny is one of the\nfollowing:\n\n* *auto-init type*: the type is nonempty and the compiler has some way to emit\n  code that constructs a value\n* *nonempty type*: the type is nonempty, but the compiler does not know how\n  perform automatic initialization\n* *possibly empty type*: the type is not known for sure to have a value\n\nFor a variable of an auto-init type, the compiler can initialize the variable\nautomatically. This means that the variable can be used immediately after\ndeclaration, even if the program does not explicitly provide an initializing\nassignment.\n\nIn a ghost context, one can an imagine a “ghost” that initializes variables.\nUnlike the compiler, such a “ghost” does not need to emit code that constructs\nan initializing value; it suffices for the ghost to know that a value exists.\nTherefore, in a ghost context, a variable of a nonempty type can be used\nimmediately after declaration.\n\nBefore a variable of a possibly empty type can be used, the program must\ninitialize it. The variable need not be given a value when it is declared, but\nit must have a value by the time it is first used. Dafny uses the precision of\nthe verifier to reason about the control flow between assignments and uses of\nvariables, and it reports an error if it cannot assure itself that the variable\nhas been given a value.\n\nThe elements of an array must be assured to have values already in the statement\nthat allocates the array. This is achieved in any of the following four ways:\n\n* If the array is allocated to be empty (that is, one of its dimensions is\n  requested to be 0), then the array allocation trivially satisfies the\n  requirement.\n* If the element type of the array is an auto-init type, then nothing further is\n  required by the program.\n* If the array allocation occurs in a ghost context and the element type is a\n  nonempty type, then nothing further is required by the program.\n* Otherwise, the array allocation must provide an initialization display or an\n  initialization function. See [section 5.10][1136] for information about array\n  initialization.\n\nThe fields of a class must have values by the end of the first phase of each\nconstructor (that is, at the explicit or implicit `new;` statement in the\nconstructor). If a class has a compiled field that is not of an auto-init type,\nor if it has a ghost field of a possibly empty type, then the class is required\nto declare a(t least one) constructor.\n\nThe yield-parameters of an `iterator` turn into fields of the corresponding\niterator class, but there is no syntactic place to give these initial values.\nTherefore, every compiled yield-parameter must be of auto-init types and every\nghost yield-parameter must be of an auto-init or nonempty type.\n\nFor local variables and out-parameters, Dafny supports two definite-assignment\nmodes:\n\n* A strict mode (the default, which is `--relax-definite-assignment=false`; or\n  `/definiteAssignment:4` in the legacy CLI), in which local variables and\n  out-parameters are always subject to definite-assignment rules, even for\n  auto-initializable types.\n* A relaxed mode (enabled by the option `--relax-definite-assignment`; or\n  `/definiteAssignment:1` in the legacy CLI), in which the auto-initialization\n  (or, for ghost variables and parametes, nonemptiness) is sufficient to satisfy\n  the definite assignment rules.\n\nA program using the strict mode can still indicate that it is okay with an\narbitrary value of a variable `x` by using an assignment statement `x := *;`,\nprovided the type of `x` is an auto-init type (or, if `x` is ghost, a nonempty\ntype). (If `x` is of a possibly nonempty type, then `x := *;` is still allowed,\nbut it sets `x` to a value of its type only if the type actually contains a\nvalue. Therefore, when `x` is of a possibly empty type, `x := *;` does not count\nas a definite assignment to `x`.)\n\nNote that auto-initialization is nondeterministic. Dafny only guarantees that\neach value it assigns to a variable of an auto-init type is *some* value of the\ntype. Indeed, a variable may be auto-initialized to different values in\ndifferent runs of the program or even at different times during the same run of\nthe program. In other words, Dafny does not guarantee the “zero-equivalent\nvalue” initialization that some languages do. Along these lines, also note that\nthe `witness` value provided in some subset-type declarations is not necessarily\nthe value chosen by auto-initialization, though it does esstablish that the type\nis an auto-init type.\n\nIn some programs (for example, in some test programs), it is desirable to avoid\nnondeterminism. For that purpose, Dafny provides an `--enforce-determinism`\noption. It forbids use of any program statement that may have nondeterministic\nbehavior and it disables auto-initialization. This mode enforces definite\nassignments everywhere, going beyond what the strict mode does by enforcing\ndefinite assignment also for fields and array elements. It also forbids the use\nof `iterator` declarations and `constructor`-less `class` declarations. It is up\nto a user’s build process to ensure that `--enforce-determinism` is used\nconsistently throughout the program. (In the legacy CLI, this mode is enabled by\n`/definiteAssignment:3`.)\n\n[This document][1137], which is intended for developers of the Dafny tool\nitself, has more detail on auto-initialization and how it is implemented.\n\nFinally, note that `--relax-definite-assignment=false` is the default in the\ncommand-based CLI, but, for backwards compatibility, the relaxed rules\n(`/definiteAssignment:1) are still the default in the legacy CLI.\n\n### 12.7. Well-founded Orders\n\nThe well-founded order relations for a variety of built-in types in Dafny are\ngiven in the following table:\n\n─────────────────────┬──────────────────────────────────────────\ntype of `X` and `x`  │`x` strictly below `X`                    \n─────────────────────┼──────────────────────────────────────────\n`bool`               │`X && !x`                                 \n─────────────────────┼──────────────────────────────────────────\n`int`                │`x < X && 0 <= X`                         \n─────────────────────┼──────────────────────────────────────────\n`real`               │`x <= X - 1.0 && 0.0 <= X`                \n─────────────────────┼──────────────────────────────────────────\n`set<T>`             │`x` is a proper subset of `X`             \n─────────────────────┼──────────────────────────────────────────\n`multiset<T>`        │`x` is a proper multiset-subset of `X`    \n─────────────────────┼──────────────────────────────────────────\n`seq<T>`             │`x` is a consecutive proper sub-sequence  \n                     │of `X`                                    \n─────────────────────┼──────────────────────────────────────────\n`map<K, V>`          │`x.Keys` is a proper subset of `X.Keys`   \n─────────────────────┼──────────────────────────────────────────\ninductive datatypes  │`x` is structurally included in `X`       \n─────────────────────┼──────────────────────────────────────────\nreference types      │`x == null && X != null`                  \n─────────────────────┼──────────────────────────────────────────\ncoinductive datatypes│`false`                                   \n─────────────────────┼──────────────────────────────────────────\ntype parameter       │`false`                                   \n─────────────────────┼──────────────────────────────────────────\narrow types          │`false`                                   \n─────────────────────┴──────────────────────────────────────────\n\nAlso, there are a few relations between the rows in the table above. For\nexample, a datatype value `x` sitting inside a set that sits inside another\ndatatype value `X` is considered to be strictly below `X`. Here’s an\nillustration of that order, in a program that verifies:\n\n`datatype D = D(s: set<D>)\n\nmethod TestD(dd: D) {\n  var d := dd;\n  while d != D({})\n    decreases d\n  {\n    var x :| x in d.s;\n    d := x;\n  }\n}\n`\n\n### 12.8. Quantifier instantiation rules\n\nDuring verification, when Dafny knows that a universal quantifier is true, such\nas when verifying the body of a function that has the requires clause `forall x\n:: f(x) == 1`, it may instantiate the quantifier. Instantiation means Dafny will\npick a value for all the variables of the quantifier, leading to a new\nexpression, which it hopes to use to prove an assertion. In the above example,\ninstantiating using `3` for `x` will lead to the expression `f(3) == 1`.\n\nFor each universal quantifier, Dafny generates rules to determine which\ninstantiations are worthwhile doing. We call these rules triggers, a term that\noriginates from SMT solvers. If Dafny can not generate triggers for a specific\nquantifier, it falls back to a set of generic rules. However, this is likely to\nbe problematic, since the generic rules can cause many useless instantiations,\nleading to verification timing out or failing to proof a valid assertion. When\nthe generic rules are used, Dafny emits a warning telling the user no triggers\nwere found for the quantifier, indicating the Dafny program should be changed so\nDafny can find triggers for this quantifier.\n\nHere follows the approach Dafny uses to generate triggers based on a quantifier.\nDafny finds terms in the quantifier body where a quantified variable is used in\nan operation, such as in a function application `P(x)`, array access `a[x]`,\nmember accesses `x.someField`, or set membership tests `x in S`. To find a\ntrigger, Dafny must find a set of such terms so that each quantified variable is\nused. You can investigate which triggers Dafny finds by hovering over\nquantifiers in the IDE and looking for ‘Selected triggers’, or by using the\noptions `--show-tooltips` when using the LCI.\n\nThere are particular expressions which, for technical reasons, Dafny can not use\nas part of a trigger. Among others, these expression include: [match][1138],\n[let][1139], [arithmetic operations and logical connectives][1140]. For example,\nin the quantifier `forall x :: x in S ⇐⇒ f(x) > f(x+1)`, Dafny will use `x in S`\nand `f(x)` as trigger terms, but will not use `x+1` or any terms that contain\nit. You can investigate which triggers Dafny can not use by hovering over\nquantifiers in the IDE and looking for ‘Rejected triggers’, or by using the\noptions `--show-tooltips` when using the LCI.\n\nBesides not finding triggers, another problematic situation is when Dafny was\nable to generate triggers, but believes the triggers it found may still cause\nuseless instantiations because they create matching loops. Dafny emits a warning\nwhen this happens, indicating the Dafny program should be changed so Dafny can\nfind triggers for this quantifier that do not cause matching loops.\n\nTo understand matching loops, one needs to understand how triggers are used.\nDuring a single verification run, such as verifying a method or function, Dafny\nmaintains a set of expressions which it believes to be true, which we call the\nground terms. For example, in the body of a method, Dafny knows the requires\nclauses of that method hold, so the expressions in those will be ground terms.\nWhen Dafny steps through the statements of the body, the set of ground terms\ngrows. For example, when an assignment `var x := 3` is evaluated, a ground term\n`x == 3` will be added. Given a universal quantifier that’s a ground term, Dafny\nwill try to pattern match its triggers on sub-expressions of other ground terms.\nIf the pattern matches, that sub-expression is used to instantiate the\nquantifier.\n\nDafny makes sure not to perform the exact same instantiation twice. However, if\nan instantiation leads to a new term that also matches the trigger, but is\ndifferent from the term used for the instantiation, the quantifier may be\ninstantiated too often, an event we call a matching loop. For example, given the\nground terms `f(3)` and `forall x {f(x)} :: f(x) + f(f(x))`, where `{f(x)}`\nindicates the trigger for the quantifier, Dafny may instantiate the quantifier\nusing `3` for `x`. This creates a new ground term `f(3) + f(f(3))`, of which the\nright hand side again matches the trigger, allowing Dafny to instantiate the\nquantifier again using `f(3)` for `x`, and again and again, leading to an\nunbounded amount of instantiations.\n\nEven existential quantifiers need triggers. This is because when Dafny\ndetermines an existential quantifier is false, for example in the body of a\nmethod that has `requires !exists x :: f(x) == 2`, Dafny will use a logical\nrewrite rule to change this existential into a universal quantifier, so it\nbecomes `requires forall x :: f(x) != 2`. Before verification, Dafny can not\ndetermine whether quantifiers will be determined to be true or false, so it must\nassume any quantifier may turn into a universal quantifier, and thus they all\nneed triggers. Besides quantifiers, comprehensions such as set and map\ncomprehensions also need triggers, since these are modeled using universal\nquantifiers.\n\nDafny may report ‘Quantifier was split into X parts’. This occurs when Dafny\ndetermines it can only generate good triggers for a quantifier by splitting it\ninto multiple smaller quantifiers, whose aggregation is logically equivalent to\nthe original one. To maintain logical equivalence, Dafny may have to generate\nmore triggers than if the split had been done manually in the Dafny source file.\nAn example is the expression `forall x :: P(x) && (Q(x) =⇒ P(x+1))`, which Dafny\nwill split into\n\n`forall x {P(x)} {Q(x)} :: P(x) &&\nforall x {(Q(x)} :: Q(x) =⇒ P(x+1)\n`\n\nNote the trigger `{Q(x)}` in the first quantifier, which was added to maintain\nequivalence with the original quantifier. If the quantifier had been split in\nsource, only the trigger `{P(x)}` would have been added for `forall x :: P(x)`.\n\n## 13. Dafny User’s Guide\n\nMost of this document describes the Dafny programming language. This section\ndescribes the `dafny` tool, a combined verifier and compiler that implements the\nDafny language.\n\nThe development of the Dafny language and tool is a GitHub project at\n[https://github.com/dafny-lang/dafny][1141]. The project is open source, with\ncollaborators from various organizations; additional contributors are welcome.\nThe software itself is licensed under the [MIT license][1142].\n\n### 13.1. Introduction\n\nThe `dafny` tool implements the following primary capabilities, implemented as\nvarious [*commands*][1143] within the `dafny` tool:\n\n* checking that the input files represent a valid Dafny program (i.e., syntax,\n  grammar and name and type resolution);\n* verifying that the program meets its specifications, by translating the\n  program to verification conditions and checking those with Boogie and an SMT\n  solver, typically Z3;\n* compiling the program to a target language, such as C#, Java, Javascript, Go\n  (and others in development);\n* running the executable produced by the compiler.\n\nIn addition there are a variety of other capabilities, such as formatting files,\nalso implemented as commands; more such commands are expected in the future.\n\n### 13.2. Installing Dafny\n\n#### 13.2.1. Command-line tools\n\nThe instructions for installing `dafny` and the required dependencies and\nenvironment are described on the Dafny wiki:\n[https://github.com/dafny-lang/dafny/wiki/INSTALL][1144]. They are not repeated\nhere to avoid replicating information that easily becomes inconsistent and out\nof date. The dafny tool can also be installed using `dotnet tool install\n--global dafny` (presuming that `dotnet` is already installed on your system).\n\nMost users will find it most convenient to install the pre-built Dafny binaries\navailable on the project release site or using the `dotnet` CLI. As is typical\nfor Open Source projects, dafny can also be built directly from the source files\nmaintained in the github project.\n\nCurrent and past Dafny binary releases can be found at\n[https://github.com/dafny-lang/dafny/releases][1145] for each supported\nplatform. Each release is a .zip file with a name combining the release name and\nthe platform. Current platforms are Windows 11, Ubuntu 20 and later, and MacOS\n10.14 and later.\n\nThe dafny tool is distributed as a standalone executable. A compatible version\nof the required Z3 solver is included in the release. There are additional\ndependencies that are needed to compile dafny to particular target languages, as\ndescribed in the release instructions. A development environment to *build*\ndafny from source requires additional dependencies, described [here][1146].\n\n#### 13.2.2. IDEs for Dafny\n\nDafny source files are text files and can of course be edited with any text\neditor. However, some tools provide syntax-aware features:\n\n* VSCode, a cross-platform editor for many programming languages has an\n  extension for Dafny. VSCode is available [here][1147] and the Dafny extension\n  can be installed from within VSCode. The [extension][1148] provides syntax\n  highlighting, in-line parser, type and verification errors, code navigation,\n  counter-example display and gutter highlights.\n* There is a [Dafny mode for Emacs][1149].\n* An old Visual Studio plugin is no longer supported\n\nInformation about installing IDE extensions for Dafny is found on the [Dafny\nINSTALL page in the wiki][1150].\n\nMore information about using VSCode IDE is [here][1151].\n\n### 13.3. Dafny Programs and Files\n\nA Dafny program is a set of modules. Modules can refer to other modules, such as\nthrough `import` declarations or `refines` clauses. A Dafny program consists of\nall the modules needed so that all module references are resolved. Dafny\nprograms are contained in files that have a `.dfy` suffix. Such files each hold\nsome number of top-level declarations. Thus a full program may be distributed\namong multiple files. To apply the `dafny` tool to a Dafny program, the `dafny`\ntool must be given all the files making up a complete program (or, possibly,\nmore than one program at a time). This can be effected either by listing all of\nthe files by name on the command-line or by using `include` directives within a\nfile to stipulate what other files contain modules that the given files need.\nThus the complete set of modules are all the modules in all the files listed on\nthe command-line or referenced, recursively, by `include` directives within\nthose files. It does not matter if files are repeated either as includes or on\nthe command-line.^{[15][1152]}\n\nNote however that although the complete set of files, command-line plus included\nfiles, make up the program, by default, only those files listed on the\ncommand-line are verified. To do a complete verification, each file must be\nverified; it may well happen that a verification failure in one file (which is\nnot on the command-line and thus not checked) may hide a verification failure in\na file that is being checked. Thus it is important to eventually check all\nfiles, preferably in an order in which the files without dependencies are\nchecked first, then those that depend on them, etc., until all files are\nchecked. The `--verify-included-files` option (`-verifyAllModules` in legacy\nmode) will cause all modules, whether the result of include directives or not,\nto be verified.\n\n#### 13.3.1. Dafny Verification Artifacts: the Library Backend and .doo Files\n\nAs of Dafny 4.1, `dafny` now supports outputting a single file containing a\nfully-verified program along with metadata about how it was verified. Such files\nuse the extension `.doo`, for Dafny Output Object, and can be used as input\nanywhere a `.dfy` file can be.\n\n`.doo` files are produced by an additional backend called the “Dafny Library”\nbackend, identified with the name `lib` on the command line. For example, to\nbuild multiple Dafny files into a single build artifact for shared reuse, the\ncommand would look something like:\n\n`dafny build -t:lib A.dfy B.dfy C.dfy --output:MyLib.doo\n`\n\nThe Dafny code contained in a `.doo` file is not re-verified when passed back to\nthe `dafny` tool, just as included files and those passed with the `--library`\noption are not. Using `.doo` files provides a guarantee that the Dafny code was\nin fact verified, however, and therefore offers protection against build system\nmistakes. `.doo` files are therefore ideal for sharing Dafny libraries between\nprojects.\n\n`.doo` files also contain metadata about the version of Dafny used to verify\nthem and the values of relevant options that affect the sound separate\nverification and compilation of Dafny code, such as `--unicode-char`. This means\nattempting to use a library that was built with options that are not compatible\nwith the currently executing command options will lead to errors. This also\nincludes attempting to use a `.doo` file built with a different version of\nDafny, although this restriction may be lifted in the future.\n\nA `.doo` file is a compressed archive of multiple files, similar to the `.jar`\nfile format for Java packages. The exact file format is internal and may evolve\nover time to support additional features.\n\nNote that the library backend only supports the [newer command-style CLI\ninterface][1153].\n\n#### 13.3.2. Dafny Translation Artifacts: .dtr Files\n\nSome options, such as `--outer-module` or\n`--optimize-erasable-datatype-wrapper`, affect what target language code the\nsame Dafny code is translated to. In order to translate Dafny libraries\nseparately from their consuming codebases, the translation process for consuming\ncode needs to be aware of what options were used when translating the library.\n\nFor example, if a library defines a `Foo()` function in an `A` module, but\n`--outer-module org.coolstuff.foolibrary.dafnyinternal` is specified when\ntranslating the library to Java, then a reference to `A.Foo()` in a consuming\nDafny project needs to be translated to\n`org.coolstuff.foolibrary.dafnyinternal.A.Foo()`, independently of what value of\n`--outer-module` is used for the consuming project.\n\nTo meet this need, `dafny translate` also outputs a `<program-name>-<target\nid>.dtr` Dafny Translation Record file. Like `.doo` files, `.dtr` files record\nall the relevant options that were used, in this case relevant to translation\nrather than verification. These files can be provided to future calls to `dafny\ntranslate` using the `--translation-record` option, in order to provide the\ndetails of how various libraries provided with the `--library` flag were\ntranslated.\n\nCurrently `--outer-module` is the only option recorded in `.dtr` files, but more\nrelevant options will be added in the future. A later version of Dafny will also\nrequire `.dtr` files that cover all modules that are defined in `--library`\noptions, to support checking that all relevant options are compatible.\n\n### 13.4. Dafny Standard Libraries\n\nAs of Dafny 4.4, the `dafny` tool includes standard libraries that any Dafny\ncode base can depend on. For now they are only available when the\n`--standard-libraries` option is provided, but they will likely be available by\ndefault in the next major version of Dafny.\n\nSee\nhttps://github.com/dafny-lang/dafny/blob/master/Source/DafnyStandardLibraries/RE\nADME.md for details.\n\n### 13.5. Dafny Code Style\n\nThere are coding style conventions for Dafny code, recorded [here][1154]. Most\nsignificantly, code is written without tabs and with a 2 space indentation.\nFollowing code style conventions improves readability but does not alter program\nsemantics.\n\n### 13.6. Using Dafny From the Command Line\n\n`dafny` is a conventional command-line tool, operating just like other\ncommand-line tools in Windows and Unix-like systems. In general, the format of a\ncommand-line is determined by the shell program that is executing the\ncommand-line (.e.g., bash, the windows shell, COMMAND, etc.), but is expected to\nbe a series of space-separated “words”, each representing a command, option,\noption argument, file, or folder.\n\n#### 13.6.1. dafny commands\n\nAs of v3.9.0, `dafny` uses a command-style command-line (like `git` for\nexample); prior to v3.9.0, the command line consisted only of options and files.\nIt is expected that additional commands will be added in the future. Each\ncommand may have its own subcommands and its own options, in addition to\ngenerally applicable options. Thus the format of the command-line is a command\nname, followed by options and files: `dafny <command> <options> <files>`; the\ncommand-name must be the first command-line argument.\n\nThe command-line `dafny --help` or `dafny -h` lists all the available commands.\n\nThe command-line `dafny <command> --help` (or `-h` or `-?`) gives help\ninformation for that particular <command>, including the list of options. Some\noptions for a particular command are intended only for internal tool\ndevelopment; those are shown using the `--help-internal` option instead of\n`--help`.\n\nAlso, the command-style command-line has modernized the syntax of options; they\nare now POSIX-compliant. Like many other tools, options now typically begin with\na double hyphen, with some options having a single-hyphen short form, such as\n`--help` and `-h`.\n\nIf no <command> is given, then the command-line is presumed to use old-style\nsyntax, so any previously written command-line will still be valid.\n\n`dafny` recognizes the commands described in the following subsections. The most\ncommonly used are [`dafny verify`][1155], [`dafny build`][1156], and [`dafny\nrun`][1157].\n\nThe command-line also expects the following:\n\n* Files are designated by absolute paths or paths relative to the current\n  working directory. A command-line argument not matching a known option is\n  considered a filepath, and likely one with an unsupported suffix, provoking an\n  error message.\n* Files containing dafny code must have a `.dfy` suffix.\n* There must be at least one `.dfy` file (except when using `--stdin` or in the\n  case of `dafny format`, see the [Dafny format section][1158])\n* The command-line may contain other kinds of files appropriate to the language\n  that the Dafny files are being compiled to. The kind of file is determined by\n  its suffix.\n* Escape characters are determined by the shell executing the command-line.\n* Per POSIX convention, the option `--` means that all subsequent command-line\n  arguments are not options to the dafny tool; they are either files or\n  arguments to the `dafny run` command.\n* If an option is repeated (e.g., with a different argument), then the later\n  instance on the command-line supersedes the earlier instance, with just a few\n  options accumulating arguments.\n* If an option takes an argument, the option name is followed by a `:` or `=` or\n  whitespace and then by the argument value; if the argument itself contains\n  white space, the argument must be enclosed in quotes. It is recommended to use\n  the `:` or `=` style to avoid misinterpretation or separation of a value from\n  its option.\n* Boolean options can take the values `true` and `false` (or any\n  case-insensitive version of those words). For example, the value of\n  `--no-verify` is by default `false` (that is, do verification). It can be\n  explicitly set to true (no verification) using `--no-verify`,\n  `--no-verify:true`, `--no-verify=true`, `--noverify true`; it can be\n  explicitly set false (do verification) using `--no-verify:false` or\n  `--no-verify=false` or `--no-verify false`.\n* There is a potential ambiguity when the form `--option value` is used if the\n  value is optional (such as for boolean values). In such a case an argument\n  after an option (that does not have an argument given with `:` or `=`) is\n  interpreted as the value if it is indeed a valid value for that option.\n  However, better style advises always using a ‘:’ or ‘=’ to set option values.\n  No valid option values in dafny look like filenames or begin with `--`.\n13.6.1.1. Options that are not associated with a command\n\nA few options are not part of a command. In these cases any single-hyphen\nspelling also permits a spelling beginning with ‘/’.\n\n* `dafny --help` or `dafny -h` lists all the available commands\n* `dafny -?` or `dafny -help` list all legacy options\n* `dafny --version` (or `-version`) prints out the number of the version this\n  build of dafny implements\n13.6.1.2. `dafny resolve`\n\nThe `dafny resolve` command checks the command-line and then parses and\ntypechecks the given files and any included files.\n\nThe set of files considered by `dafny` are those listed on the command-line,\nincluding those named in a `--library` option, and all files that are named,\nrecursively, in `include` directives in files in the set being considered by the\ntool.\n\nThe set of files presented to an invocation of the `dafny` tool must contain all\nthe declarations needed to resolve all names and types, else name or type\nresolution errors will be emitted.\n\n`dafny` can parse and verify sets of files that do not form a complete program\nbecause they are missing the implementations of some constructs such as\nfunctions, lemmas, and loop bodies.^{[16][1159]} However, `dafny` will need all\nimplementations in order to compile a working executable.\n\ndeclaration and implementation of methods, functions and types in separate\nfiles, nor, for that matter, separation of specification and declaration.\nImplementations can be omitted simply by leaving them out of the declaration (or\na lemma, for example). However, a combination of [`traits`][1160] and\n[`classes`][1161] can achieve a separation of interface and specification from\nimplementation.\n\nThe options relevant to this command are\n\n* those relevant to the command-line itself\n  \n  * `--allow-warnings` — return a success [exit code][1162], even when there are\n    warnings\n* those that affect dafny` as a whole, such as\n  \n  * `--cores` — set the number of cores dafny should use\n  * `--show-snippets` — emit a line or so of source code along with an error\n    message\n  * `--library` — include this file in the program, but do not verify or compile\n    it (multiple such library files can be listed using multiple instances of\n    the `--library` option)\n  * `--stdin` – read from standard input\n* those that affect the syntax of Dafny, such as\n  \n  * `--prelude`\n  * `--unicode-char`\n  * `--function-syntax`\n  * `--quantifier-syntax`\n  * `--track-print-effects`\n  * `--warn-shadowing`\n  * `--warn-missing-constructor-parentheses`\n13.6.1.3. `dafny verify`\n\nThe `dafny verify` command performs the [`dafny resolve`][1163] checks and then\nattempts to verify each method in the files listed on the command line. Although\nthe Dafny program being considered consists of the listed files and any included\nfiles (recursively), by default only listed files are verified.\n\nA guide to controlling and aiding the verification process is given in [a later\nsection][1164].\n\nTo be considered *verified* all the methods in all the files in a program must\nbe verified, with consistent sets of options, and with no unproven assumptions\n(see [`dafny audit`][1165] for a tool to help identify such assumptions).\n\nDafny works *modularly*, meaning that each method is considered by itself, using\nonly the specifications of other methods. So, when using the dafny tool, you can\nverify the program all at once or one file at a time or groups of files at a\ntime. On a large program, verifying all files at once can take quite a while,\nwith little feedback as to progress, though it does save a small amount of work\nby parsing all files just once. But, one way or another, to have a complete\nverification, all implementations of all methods and functions must eventually\nbe verified.\n\n* By default, only those files listed on the command-line are verified in a\n  given invocation of the `dafny` tool.\n* The option `--verify-included-files` (`-verifyAllModules` in legacy mode)\n  forces the contents of all non-library files to be verified, whether they are\n  listed on the command-line or recursively included by files on the\n  command-line.\n* The `--library` option marks files that are excluded from\n  `--verify-included-files`. Such a file may also, but need not, be the target\n  of an `include` directive in some file of the program; in any case, such files\n  are included in the program but not in the set of files verified (or\n  compiled). The intent of this option is to mark files that should be\n  considered as libraries that are independently verified prior to being\n  released for shared use.\n* Verifying files individually is equivalent to verifying them in groups,\n  presuming no other changes. It is also permitted to verify completely disjoint\n  files or programs together in a single run of `dafny`.\n\nVarious options control the verification process, in addition to all those\ndescribed for [`dafny resolve`][1166].\n\n* What is verified\n  \n  * `--verify-included-files` (when enabled, all included files are verified,\n    except library files, otherwise just those files on the command-line)\n  * `--relax-definite-assignment`\n  * `--track-print-effects`\n  * `--disable-nonlinear-arithmetic`\n  * `--filter-symbol`\n* Control of the proof engine\n  \n  * `--verification-time-limit`\n  * `--boogie`\n13.6.1.4. `dafny translate <language>`\n\nThe `dafny translate` command translates Dafny source code to source code for\nanother target programming language. The command always performs the actions of\n`dafny resolve` and, unless the `--no-verify` option is specified, does the\nactions of `dafny verify`. The language is designated by a subcommand argument,\nrather than an option, and is required. The current set of supported target\nlanguages is\n\n* cs (C#)\n* java (Java)\n* js (JavaScript)\n* py (Python)\n* go (Go)\n* cpp (C++ – but only limited support)\n\nIn addition to generating the target source code, `dafny` may generate build\nartifacts to assist in compiling the generated code. The specific files\ngenerated depend on the target programming language. More detail is given in\n[the section on compilation][1167].\n\nThe `dafny` tool intends that the compiled program in the target language be a\nsemantically faithful rendering of the (verified) Dafny program. However,\nresource and language limitations make this not always possible. For example,\nthough Dafny can express and reason about arrays of unbounded size, not all\ntarget programming languages can represent arrays larger than the maximum signed\n32-bit integer.\n\nVarious options control the translation process, in addition to all those\ndescribed for [`dafny resolve`][1168] and [`dafny verify`][1169].\n\n* General options:\n  \n  * `--no-verify` — turns off all attempts to verify the program\n  * `--verbose` — print information about generated files\n* The translation results\n  \n  * `--output` (or `-o`) — location of the generated file(s) (this specifies a\n    file path and name; a folder location for artifacts is derived from this\n    name)\n  * `--include-runtime` — include the Dafny runtime for the target language in\n    the generated artifacts\n  * `--optimize-erasable-datatype-wrapper`\n  * `--enforce-determinism`\n  * `--test-assumptions` — (experimental) inserts runtime checks for unverified\n    assumptions when they are compilable\n13.6.1.5. `dafny build`\n\nThe `dafny build` command runs `dafny translate` and then compiles the result\ninto an executable artifact for the target platform, such as a `.exe` or `.dll`\nor executable `.jar`, or just the source code for an interpreted language. If\nthe Dafny program does not have a Main entry point, then the build command\ncreates a library, such as a `.dll` or `.jar`. As with `dafny translate`, all\nthe previous phases are also executed, including verification (unless\n`--no-verify` is a command-line option). By default, the generated file is in\nthe same directory and has the same name with a different extension as the first\n.dfy file on the command line. This location and name can be set by the\n`--output` option.\n\nThe location of the `Main` entry point is described\n[here](#sec-user-guide-main}.\n\nThere are no additional options for `dafny build` beyond those for `dafny\ntranslate` and the previous compiler phases.\n\nNote that `dafny build` may do optimizations that `dafny run` does not.\n\nDetails for specific target platforms are described [in Section 25.7][1170].\n\n13.6.1.6. `dafny run`\n\nThe `dafny run` command compiles the Dafny program and then runs the resulting\nexecutable. Note that `dafny run` is engineered to quickly compile and launch\nthe program; `dafny build` may take more time to do optimizations of the build\nartifacts.\n\nThe form of the `dafny run` command-line is slightly different than for other\ncommands.\n\n* It permits just one `.dfy` file, which must be the file containing the `Main`\n  entry point; the location of the `Main` entry point is described\n  [here](#sec-user-guide-main}.\n* Other files are included in the program either by `include` directives within\n  that one file or by the `--input` option on the command-line.\n* Anything that is not an option and is not that one dfy file is an argument to\n  the program being run (and not to dafny itself).\n* If the `--` option is used, then anything after that option is a command-line\n  argument to the program being run.\n\nDuring development, users must use `dafny run --allow-warnings` if they want to\nrun their Dafny code when it contains warnings.\n\nHere are some examples:\n\n* `dafny run A.dfy` – builds and runs the Main program in `A.dfy` with no\n  command-line arguments\n* `dafny run A.dfy --no-verify` – builds the Main program in `A.dfy` using the\n  `--no-verify` option, and then runs the program with no command-line arguments\n* `dafny run A.dfy -- --no-verify` – builds the Main program in `A.dfy` (*not*\n  using the `--no-verify` option), and then runs the program with one\n  command-line argument, namely `--no-verify`\n* `dafny run A.dfy 1 2 3 B.dfy` – builds the Main program in `A.dfy` and then\n  runs it with the four command-line arguments `1 2 3 B.dfy`\n* `dafny run A.dfy 1 2 3 --input B.dfy` – builds the Main program in `A.dfy` and\n  `B.dfy`, and then runs it with the three command-line arguments `1 2 3`\n* `dafny run A.dfy 1 2 -- 3 -quiet` – builds the Main program in `A.dfy` and\n  then runs it with the four command-line arguments `1 2 3 -quiet`\n\nEach time `dafny run` is invoked, the input Dafny program is compiled before it\nis executed. If a Dafny program should be run more than once, it can be faster\nto use `dafny build`, which enables compiling a Dafny program once and then\nrunning it multiple times.\n\n**Note:** `dafny run` will typically produce the same results as the executables\nproduced by `dafny build`. The only expected differences are these:\n\n* performance — `dafny run` may not optimize as much as `dafny build`\n* target-language-specific configuration issues — e.g. encoding issues: `dafny\n  run` sets language-specific flags to request UTF-8 output for the\n  [`print`][1171] statement in all languages, whereas `dafny build` leaves\n  language-specific runtime configuration to the user.\n13.6.1.7. `dafny server`\n\nThe `dafny server` command starts the Dafny Language Server, which is an\n[LSP-compliant][1172] implementation of Dafny. The [Dafny VSCode\nextension][1173] uses this LSP implementation, which in turn uses the same core\nDafny implementation as the command-line tool.\n\nThe Dafny Language Server is described in more detail [here][1174].\n\n13.6.1.8. `dafny audit`\n\nThe `dafny audit` command reports issues in the Dafny code that might limit the\nsoundness claims of verification.\n\n*This command is under development.*\n\nThe command executes the `dafny resolve` phase (accepting its options) and has\nthe following additional options:\n\n* `--report-file:<report-file>` — specifies the path where the audit report file\n  will be stored. Without this option, the report will be issued as standard\n  warnings, written to standard-out.\n* `--report-format:<format>` — specifies the file format to use for the audit\n  report. Supported options include:\n  \n  * ‘txt, ‘text’: plain text in the format of warnings\n  * ‘html’: standalone HTML (‘html’)\n  * ‘md’, ‘markdown’, ‘md-table’, ‘markdown-table’: a Markdown table\n  * ‘md-ietf’, ‘markdown-ietf’: an IETF-language document in Markdown format\n  * The default is to infer the format from the filename extension\n* `--compare-report` — compare the report that would have been generated with\n  the existing file given by –report-file, and fail if they differ.\n\nThe command emits exit codes of\n\n* 1 for command-line errors\n* 2 for parsing, type-checking or serious errors in running the auditor (e.g.\n  failure to write a report or when report comparison fails)\n* 0 for normal operation, including operation that identifies audit findings\n\nIt also takes the `--verbose` option, which then gives information about the\nfiles being formatted.\n\nThe `dafny audit` command currently reports the following:\n\n* Any declaration marked with the `{:axiom}` attribute. This is typically used\n  to mark that a lemma with no body (and is therefore assumed to always be true)\n  is intended as an axiom. The key purpose of the `audit` command is to ensure\n  that all assumptions are intentional and acknowledged. To improve assurance,\n  however, try to provide a proof.\n* Any declaration marked with the `{:verify false}` attribute, which tells the\n  verifier to skip verifying this declaration. Removing the attribute and\n  providing a proof will improve assurance.\n* Any declaration marked with the `{:extern}` attribute that has at least one\n  `requires` or `ensures` clause. If code implemented externally, and called\n  from Dafny, has an `ensures` clause, Dafny assumes that it satisfies that\n  clause. Since Dafny cannot prove properties about code written in other\n  languages, adding tests to provide evidence that any `ensures` clauses do hold\n  can improve assurance. The same considerations apply to `requires` clauses on\n  Dafny code intended to be called from external code.\n* Any definition with an `assume` statement in its body. To improve assurance,\n  attempt to convert it to an `assert` statement and prove that it holds. Such a\n  definition will not be compilable unless the statement is also marked with\n  `{:axiom}`. Alternatively, converting it to an `expect` statement will cause\n  it to be checked at runtime.\n* Any method marked with `decreases *`. Such a method may not terminate.\n  Although this cannot cause an unsound proof, in the logic of Dafny, it’s\n  generally important that any non-termination be intentional.\n* Any `forall` statement without a body. This is equivalent to an assumption of\n  its conclusion. To improve assurance, provide a body that proves the\n  conclusion.\n* Any loop without a body. This is equivalent to an assumption of any loop\n  invariants in the code after the loop. To improve assurance, provide a body\n  that establishes any stated invariants.\n* Any declaration with no body and at least one `ensures` clause. Any code that\n  calls this declaration will assume that all `ensures` clauses are true after\n  it returns. To improve assurance, provide a body that proves that any\n  `ensures` clauses hold.\n13.6.1.9. `dafny format`\n\nDafny supports a formatter, which for now only changes the indentation of lines\nin a Dafny file, so that it conforms to the idiomatic Dafny code formatting\nstyle. For the formatter to work, the file should be parsed correctly by Dafny.\n\nThere are four ways to use the formatter:\n\n* `dafny format <one or more .dfy files or folders>` formats the given Dafny\n  files and the Dafny files in the folders, recursively, altering the files in\n  place. For example, `dafny format .` formats all the Dafny files recursively\n  in the current folder.\n* `dafny format --print <files and/or folders>` formats each file but instead of\n  altering the files, output the formatted content to stdout\n* `dafny format --check <files and/or folders>` does not alter files. It will\n  print a message concerning which files need formatting and return a non-zero\n  exit code if any files would be changed by formatting.\n\nYou can also use `--stdin` instead of providing a file, to format a full Dafny\nfile from the standard input. Input files can be named along with `--stdin`, in\nwhich case both the files and the content of the stdin are formatted.\n\nEach version of `dafny format` returns a non-zero return code if there are any\ncommand-line or parsing errors or if –check is stipulated and at least one file\nis not the same as its formatted version.\n`dafny format` does not necessarily report name or type resolution errors and\ndoes not attempt verification.\n\n13.6.1.10. `dafny test`\n\nThis command (verifies and compiles the program and) runs every method in the\nprogram that is annotated with the [`{:test}` attribute][1175]. Verification can\nbe disabled using the `--no-verify` option. `dafny test` also accepts all other\noptions of the `dafny build` command. In particular, it accepts the `--target`\noption that specifies the programming language used in the build and execution\nphases.\n\n`dafny test` also accepts these options:\n\n* `-spill-translation` - (default disabled) when enabled the compilation\n  artifacts are retained\n* `--output` - gives the folder and filename root for compilation artifacts\n* `--methods-to-test` - the value is a (.NET) regular expression that is matched\n  against the fully qualified name of the method; only those methods that match\n  are tested\n* `--coverage-report` - the value is a directory in which Dafny will save an\n  html coverage report highlighting parts of the program that execution of the\n  tests covered.\n\nThe order in which the tests are run is not specified.\n\nFor example, this code (as the file `t.dfy`)\n\n`method {:test} m() {\n  mm();\n  print \"Hi!\\n\";\n}\n\nmethod mm() {\n  print \"mm\\n\";\n}\n\nmodule M {\n  method {:test} q() {\n    print 42, \"\\n\";\n  }\n}\n\nclass A {\n  static method {:test} t() { print \"T\\n\"; }\n}\n`\n\nand this command-line\n\n`dafny test --no-verify t.dfy\n`\n\nproduce this output text:\n\n`M.q: 42\nPASSED\nA.t: T\nPASSED\nm: mm\nHi!\nPASSED\n`\n\nand this command-line\n\n`dafny test --no-verify --methods-to-test='m' t.dfy\n`\n\nproduces this output text:\n\n`m: mm\nHi!\nPASSED\n`\n13.6.1.11. `dafny doc` [Experimental]\n\nThe `dafny doc` command generates HTML documentation pages describing the\ncontents of each module in a set of files, using the documentation comments in\nthe source files. This command is experimental; user feedback and contributor\nPRs on the layout of information and the navigation are welcome.\n\n* The format of the documentation comments is described [here][1176].\n* The `dafny doc` command accepts either files or folders as command-line\n  arguments. A folder represents all the `.dfy` files contained recursively in\n  that folder. A file that is a `.toml` [project file][1177] represents all the\n  files and options listed in the project file.\n* The command first parses and resolves the given files; it only proceeds to\n  produce documentation if type resolution is successful (on all files). All the\n  command-line options relevant to `dafny resolve` are available for `dafny\n  doc`.\n* The value of the `--output` option is a folder in which all the generated\n  files will be placed. The default location is `./docs`. The folder is created\n  if it does not already exist. Any existing content of the folder is\n  overwritten.\n* If `--verbose` is enabled, a list of the generated files is emitted to stdout.\n* The output files contain information stating the source .dfy file in which the\n  module is declared. The `--file-name` option controls the form of the filename\n  in that information:\n  \n  * –file-name:none – no source file information is emitted\n  * –file-name:name – (default) just the file name is emitted (e.g., `Test.dfy`)\n  * –file-name:absolute – an absolute full path is emitted\n  * –file-name:relative= -- a file name relative to the given prefix is emitted\n* If `--modify-time` is enabled, then the generated files contain information\n  stating the last modified time of the source of the module being documented.\n* The `--program-name` option states text that will be included in the heading\n  of the TOC and index pages\n\nThe output files are HTML files, all contained in the given folder, one per\nmodule plus an `index.html` file giving an overall table of contents and a\n`nameindex.html` file containing an alphabetical by name list of all the\ndeclarations in all the modules. The documentation for the root module is in\n`_.html`.\n\n13.6.1.12. `dafny generate-tests`\n\nThis *experimental* command allows generating tests from Dafny programs. The\ntests provide complete coverage of the implementation and one can execute them\nusing the [`dafny test`][1178] command. Dafny can target different notions of\ncoverage while generating tests, with basic-block coverage being the recommended\nsetting. Basic blocks are extracted from the Boogie representation of the Dafny\nprogram, with one basic block corresponding to a statement or a\nnon-short-circuiting subexpression in the Dafny code. The underlying\nimplementation uses the verifier to reason about the reachability of different\nbasic blocks in the program and infers necessary test inputs from\ncounterexamples.\n\nFor example, this code (as the file `program.dfy`)\n\n`module M {\n  function {:testEntry} Min(a: int, b: int): int {\n    if a < b then a else b\n  }\n}\n`\n\nand this command-line\n\n`dafny generate-tests Block program.dfy\n`\n\nproduce two tests:\n\n`include \"program.dfy\"\nmodule UnitTests {\n  import M\n  method {:test} Test0() {\n    var r0 := M.Min(0, 0);\n  }\n  method {:test} Test1() {\n    var r0 := M.Min(0, 1);\n  }\n}\n`\n\nThe two tests together cover every basic block within the `Min` function in the\ninput program. Note that the `Min` function is annotated with the `{:testEntry}`\nattribute. This attribute marks `Min` as the entry point for all generated\ntests, and there must always be at least one method or function so annotated.\nAnother requirement is that any top-level declaration that is not itself a\nmodule (such as class, method, function, etc.) must be a member of an explicitly\nnamed module, which is called `M` in the example above.\n\n*This command is under development and not yet fully functional.*\n\n13.6.1.13. `Inlining`\n\nBy default, when asked to generate tests, Dafny will produce *unit tests*, which\nguarantee coverage of basic blocks within the method they call but not within\nany of its callees. By contrast, system-level tests can guarantee coverage of a\nlarge part of the program while at the same time using a single method as an\nentry point. In order to prompt Dafny to generate system-level tests, one must\nuse the `{:testInline}` attribute.\n\nFor example, this code (as the file `program.dfy`)\n\n`module M {\n  function {:testInline} Min(a: int, b: int): int {\n    if a < b then a else b\n  }\n  method {:testEntry} Max(a: int, b: int) returns (c: int)\n    // the tests convert the postcondition below into runtime check:\n    ensures c == if a > b then a else b\n  {\n    return -Min(-a, -b);\n  }\n}\n`\n\nand this command-line\n\n`dafny generate-tests Block program.dfy\n`\n\nproduce two tests:\n\n`include \"program.dfy\"\nmodule UnitTests {\n  import M\n  method {:test} Test0() {\n    var r0 := M.Max(7719, 7720);\n    expect r0 == if 7719 > 7720 then 7719 else 7720;\n  }\n  method {:test} Test1() {\n    var r0 := M.Max(1, 0);\n    expect r0 == if 1 > 0 then 1 else 0;\n  }\n}\n`\n\nWithout the use of the `{:testInline}` attribute in the example above, Dafny\nwill only generate a single test because there is only one basic-block within\nthe `Max` method itself – all the branching occurs within the `Min` function.\nNote also that Dafny automatically converts all non-ghost postconditions on the\nmethod under tests into `expect` statements, which the compiler translates to\nruntime checks in the target language of choice.\n\nWhen the inlined method or function is recursive, it might be necessary to\nunroll the recursion several times to get adequate code coverage. The depth of\nrecursion unrolling should be provided as an integer argument to the\n`{:testInline}` attribute. For example, in the program below, the function\n`Mod3` is annotated with `{:testInline 2}` and will, therefore, be unrolled\ntwice during test generation. The function naively implements division by\nrepeatedly and recursively subtracting `3` from its argument, and it returns the\nremainder of the division, which is one of the three base cases. Because the\n`TestEntry` method calls `Mod3` with an argument that is guaranteed to be at\nleast `3`, the base case will never occur on first iteration, and the function\nmust be unrolled at least twice for Dafny to generate tests covering any of the\nbase cases:\n\n`module M {\n  function {:testInline 2} Mod3 (n: nat): nat\n    decreases n\n  {\n    if n == 0 then 0 else\n    if n == 1 then 1 else\n    if n == 2 then 2 else\n    Mod3(n-3)\n  }\n  method {:testEntry} TestEntry(n: nat) returns (r: nat)\n    requires n >= 3\n  {\n    r := Mod3(n);\n  }\n}\n`\n13.6.1.14. `Command Line Options`\n\nTest generation supports a number of command-line options that control its\nbehavior.\n\nThe first argument to appear after the `generate-test` command specifies the\ncoverage criteria Dafny will attempt to satisfy. Of these, we recommend\nbasic-block coverage (specified with keyword `Block`), which is also the\ncoverage criteria used throughout the relevant parts of this reference manual.\nThe alternatives are path coverage (`Path`) and block coverage after inlining\n(`InlinedBlock`). Path coverage provides the most diverse set of tests but it is\nalso the most expensive in terms of time it takes to produce these tests. Block\ncoverage after inlining is a call-graph sensitive version of block coverage - it\ntakes into account every block in a given method for every path through the\ncall-graph to that method.\n\nThe following is a list of command-line-options supported by Dafny during test\ngeneration:\n\n* `--verification-time-limit` - the value is an integer that sets a timeout for\n  generating a single test. The default is 20 seconds.\n* `--length-limit` - the value is an integer that is used to limit the lengths\n  or all sequences and sizes of all maps and sets that test generation will\n  consider as valid test inputs. This can sometimes be necessary to prevent test\n  generation from creating unwieldy tests with excessively long strings or large\n  maps. This option is disabled by default\n* `--coverage-report` - the value is a directory in which Dafny will save an\n  html coverage report highlighting parts of the program that the generated\n  tests are expected to cover.\n* `--print-bpl` - the value is the name of the file to which Dafny will save the\n  Boogie code used for generating tests. This options is mostly useful for\n  debugging test generation functionality itself.\n* `--force-prune` - this flag enables axiom pruning, a feature which might\n  significantly speed up test generation but can also reduce coverage or cause\n  Dafny to produce tests that do not satisfy the preconditions.\n\nDafny will also automatically enforce the following options during test\ngeneration: `--enforce-determinism`, `/typeEncoding:p` (an option passed on to\nBoogie).\n\n13.6.1.15. `dafny find-dead-code`\n\nThis *experimental* command finds dead code in a program, that is, basic-blocks\nwithin a method that are not reachable by any inputs that satisfy the method’s\npreconditions. The underlying implementation is identical to that of [`dafny\ngenerate-tests`][1179] command and can be controlled by the same command line\noptions and method attributes.\n\nFor example, this code (as the file `program.dfy`)\n\n`module M {\n  function {:testEntry} DescribeProduct(a: int): string {\n    if a * a < 0 \n    then \"Product is negative\"\n    else \"Product is nonnegative\"\n  }\n}\n`\n\nand this command-line\n\n`dafny find-dead-code program.dfy\n`\n\nproduce this output:\n\n`program.dfy(5,9) is reachable.\nprogram.dfy(3,4):initialstate is reachable.\nprogram.dfy.dfy(5,9)#elseBranch is reachable.\nprogram.dfy.dfy(4,9)#thenBranch is potentially unreachable.\nOut of 4 basic blocks, 3 are reachable.\n`\n\nDafny reports that the then branch of the condition is potentially unreachable\nbecause the verifier proves that no input can reach it. In this case, this is to\nbe expected, since the product of two numbers can never be negative. In\npractice, `find-dead-code` command can produce both false positives (if the\nreachability query times out) and false negatives (if the verifier cannot prove\ntrue unreachability), so the results of such a report should always be reviewed.\n\n*This command is under development and not yet fully functional.*\n\n13.6.1.16. `dafny measure-complexity`\n\nThis *experimental* command reports complexity metrics of a program.\n\n*This command is under development and not yet functional.*\n\n13.6.1.17. Plugins\n\nThis execution mode is not a command, per se, but rather a command-line option\nthat enables executing plugins to the dafny tool.\n\nThe form of the command-line is `dafny\n--plugin:<path-to-one-assembly[,argument]*>` where the argument to `--plugin`\ngives the path to the compiled assembly of the plugin and the arguments to be\nprovided to the plugin.\n\nMore on writing and building plugins can be found [in this section][1180].\n\n13.6.1.18. Legacy operation\n\nPrior to implementing the command-based CLI, the `dafny` command-line simply\ntook files and options and the arguments to options. That legacy mode of\noperation is still supported, though discouraged. The command `dafny -?`\nproduces the list of legacy options. In particular, the common commands like\n`dafny verify` and `dafny build` are accomplished with combinations of options\nlike `-compile`, `-compileTarget` and `-spillTargetCode`.\n\nUsers are encouraged to migrate to the command-based style of command-lines and\nthe double-hyphen options.\n\n#### 13.6.2. In-tool help\n\nAs is typical for command-line tools, `dafny` provides in-tool help through the\n`-h` and `--help` options:\n\n* `dafny -h`, `dafny --help` list the commands available in the `dafny` tool\n* `dafny -?` lists all the (legacy) options implemented in `dafny`\n* `dafny <command> -h`, `dafny <command> --help`, `dafny <command> -?` list the\n  options available for that command\n\n#### 13.6.3. dafny exit codes\n\nThe basic resolve, verify, translate, build, run and commands of dafny terminate\nwith these exit codes.\n\n* 0 – success\n* 1 – invalid command-line arguments\n* 2 – syntax, parse, or name or type resolution errors\n* 3 – compilation errors\n* 4 – verification errors\n\nErrors in earlier phases of processing typically hide later errors. For example,\nif a program has parsing errors, verification or compilation will not be\nattempted.\n\nOther dafny commands may have their own conventions for exit codes. However in\nall cases, an exit code of 0 indicates successful completion of the command’s\ntask and small positive integer values indicate errors of some sort.\n\n#### 13.6.4. dafny output\n\nMost output from `dafny` is directed to the standard output of the shell\ninvoking the tool, though some goes to standard error.\n\n* Command-line errors: these are produced by the dotnet CommandLineOptions\n  package are directed to **standard-error**\n* Other errors: parsing, typechecking, verification and compilation errors are\n  directed to **standard-out**\n* Non-error progress information also is output to **standard-out**\n* Dafny `print` statements, when executed, send output to **standard-out**\n* Dafny `expect` statements (when they fail) send a message to **standard-out**.\n* Dafny I/O libraries send output explicitly to either **standard-out or\n  standard-error**\n\n#### 13.6.5. Project files\n\nCommands on the Dafny CLI that can be passed a Dafny file can also be passed a\nDafny project file. Such a project file may define which Dafny files the project\ncontains and which Dafny options it uses. The project file must be a\n[TOML][1181] file named `dfyconfig.toml` for it to work on both the CLI and in\nthe Dafny IDE, although the CLI will accept any `.toml` file. Here’s an example\nof a Dafny project file:\n\n`includes = [\"src/**/*.dfy\"]\nexcludes = [\"**/ignore.dfy\"]\n\nbase = [\"../commonOptions.dfyconfig.toml\"]\n\n[options]\nenforce-determinism = true\nwarn-shadowing = true\n`\n\n* At most one `.toml` file may be named on the command-line; when using the\n  command-line no `.toml` file is used by default.\n* In the `includes` and `excludes` lists, the file paths may have wildcards,\n  including `**` to mean any number of directory levels; filepaths are relative\n  to the location of the `.toml` file in which they are named.\n* Dafny will process the union of (a) the files on the command-line and (b) the\n  files designated in the `.toml` file, which are those specified by the\n  `includes`, omitting those specified by the `excludes`. The `excludes` does\n  not remove any files that are listed explicitly on the command-line.\n* Under the section `[options]`, any options from the Dafny CLI can be specified\n  using the option’s name without the `--` prefix.\n* When executing a `dafny` command using a project file, any options specified\n  in the file that can be applied to the command, will be. Options that can’t be\n  applied are ignored; options that are invalid for any dafny command trigger\n  warnings.\n* Options specified on the command-line take precedence over any specified in\n  the project file, no matter the order of items on the command-line.\n* When using a Dafny IDE based on the `dafny server` command, the IDE will\n  search for project files by traversing up the file tree looking for the\n  closest `dfyconfig.toml` file to the dfy being parsed that it can find.\n  Options from the project file will override options passed to `dafny server`.\n* The field ‘base’ can be used to let one project file inherit options from\n  another. If an option is specified in both, then the value specified in the\n  inheriting project is used. Includes from the inheritor override excludes from\n  the base.\n\nIt’s not possible to use Dafny project files in combination with the legacy CLI\nUI.\n\n### 13.7. Verification\n\nIn this section, we suggest a methodology to figure out [why Dafny cannot prove\na single assertion][1182], we propose techniques to deal with [assertions that\nslow a proof down][1183], we explain how to [verify assertions in parallel or in\na focused way][1184], and we also give some more examples of [useful options and\nattributes to control verification][1185].\n\n#### 13.7.1. Verification debugging when verification fails\n\nLet’s assume one assertion is failing (“assertion could not be proved” or\n“postcondition could not be proved”). What should you do next? First, it’s good\nto know that if an assertion is failing, it means that the assertion might not\nhold or that Dafny would requires more proof hints, which can be found in a\nmechanical way.\n\nThe following section is textual description of the animation below, which\nillustrates the principle of debugging an assertion by computing the weakest\nprecondition:\n[weakestpreconditionDemo]\n\n13.7.1.1. Failing postconditions\n\nLet’s look at an example of a failing postcondition.\n\n`method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    return j;\n  }//^^^^^^^ a postcondition could not be proved on this return path\n  i := 2;\n}\n`\n\nOne first thing you can do is replace the statement `return j;` by two\nstatements `i := j; return;` to better understand what is wrong:\n\n`method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    i := j;\n    return;\n  }//^^^^^^^ a postcondition could not be proved on this return path\n  i := 2;\n}\n`\n\nNow, you can assert the postcondition just before the return:\n\n`method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    i := j;\n    assert 2 <= i; // could not prove this assertion\n    return;\n  }\n  i := 2;\n}\n`\n\nThat’s it! Now the postcondition is not failing anymore, but the `assert`\ncontains the error! you can now move to the next section to find out how to\ndebug this `assert`.\n\n13.7.1.2. Failing asserts\n\nIn the [previous section][1186], we arrived at the point where we have a failing\nassertion:\n\n`method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    i := j;\n    assert 2 <= i; // could not prove this assertion\n    return;\n  }\n  i := 2;\n}\n`\n\nTo debug why Dafny cannot prove this assert, we need to *move this assert up*,\nwhich is similar to [*computing the weakest precondition*][1187]. For example,\nif we have `x := Y; assert F;` and Dafny cannot prove `assert F;`, the weakest\nprecondition for it to hold before `x := Y;` can be written as the assertion\n`assert F[x:= Y];`, where we replace every occurrence of `x` in `F` into `Y`.\nLet’s do it in our example:\n\n`method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    assert 2 <= j; // could not prove this assertion\n    i := j;\n    assert 2 <= i;\n    return;\n  }\n  i := 2;\n}\n`\n\nYay! The assertion `assert 2 <= i;` is not proven wrong, which means that if we\nmanage to prove `assert 2 <= j;`, it will work. Now, this assert should hold\nonly if we are in this branch, so to *move the assert up*, we need to guard it.\nJust before the `if`, we can add the weakest precondition `assert b ==> (2 <=\nj)`:\n\n`method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  assert b  ==>  2 <= j;  // could not prove this assertion\n  if b {\n    assert 2 <= j;\n    i := j;\n    assert 2 <= i;\n    return;\n  }\n  i := 2;\n}\n`\n\nAgain, now the error is only on the topmost assert, which means that we are\nmaking progress. Now, either the error is obvious, or we can one more time\nreplace `j` by its value and create the assert `assert b ==> ((if !b then 3 else\n1) >= 2);`\n\n`method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  assert b  ==>  2 <= (if !b then 3 else 1);  // could not prove this assertion\n  var j := if !b then 3 else 1;\n  assert b  ==>  2 <= j;\n  if b {\n    assert 2 <= j;\n    i := j;\n    assert 2 <= i;\n    return;\n  }\n  i := 2;\n}\n`\n\nAt this point, this is pure logic. We can simplify the assumption:\n\n`b ==>  2 <= (if !b then 3 else 1)\n!b ||  (if !b then 2 <= 3 else 2 <= 1)\n!b ||  (if !b then true else false)\n!b || !b;\n!b;\n`\n\nNow we can understand what went wrong: When b is true, all of these formulas\nabove are false, this is why the `dafny` verifier was not able to prove them. In\nthe next section, we will explain how to “move asserts up” in certain useful\npatterns.\n\n13.7.1.3. Failing asserts cases\n\nThis list is not exhaustive but can definitely be useful to provide the next\nstep to figure out why Dafny could not prove an assertion.\n\n───────────────────────────────┬────────────────────────────────────────────────\nFailing assert                 │Suggested rewriting                             \n───────────────────────────────┼────────────────────────────────────────────────\n                               │`assert P[x := Y];`                             \n`x := Y;`                      │`x := Y;`                                       \n`assert P;`                    │`assert P;`                                     \n───────────────────────────────┼────────────────────────────────────────────────\n                               │`assert B ==> P;`                               \n`if B {`                       │`if B {`                                        \n` assert P;`                   │` assert P;`                                    \n` ...`                         │` ...`                                          \n`}`                            │`}`                                             \n───────────────────────────────┼────────────────────────────────────────────────\n                               │`assert !B ==> P;`                              \n`if B {`                       │`if B {`                                        \n` ...`                         │` ...`                                          \n`} else {`                     │`} else {`                                      \n` assert P;`                   │` assert P;`                                    \n` ...`                         │` ...`                                          \n`}`                            │`}`                                             \n───────────────────────────────┼────────────────────────────────────────────────\n                               │`if X {`                                        \n                               │` ...`                                          \n`if X {`                       │` assert A;`                                    \n` ...`                         │`} else {`                                      \n`} else {`                     │` ...`                                          \n` ...`                         │` assert A;`                                    \n`}`                            │`}`                                             \n`assert A;`                    │`assert A;`                                     \n───────────────────────────────┼────────────────────────────────────────────────\n                               │[`forall x`][1188]                              \n                               │` ensures Q(x)`                                 \n                               │`{`                                             \n                               │` assert Q(x);`                                 \n                               │`};`                                            \n`assert forall x :: Q(x);`     │` assert forall x :: Q(x);`                     \n───────────────────────────────┼────────────────────────────────────────────────\n                               │[`forall x | P(x)`][1189]                       \n                               │` ensures Q(x)`                                 \n                               │`{`                                             \n                               │` assert Q(x);`                                 \n                               │`};`                                            \n`assert forall x :: P(x) ==>   │` assert forall x :: P(x) ==> Q(x);`            \nQ(x);`                         │                                                \n───────────────────────────────┼────────────────────────────────────────────────\n                               │`if x :| P(x) {`                                \n`assert exists x | P(x) ::     │` assert Q(x);`                                 \nQ(x);`                         │` assert Q'(x);`                                \n`assert exists x | P(x) ::     │`} else {`                                      \nQ'(x);`                        │` assert false;`                                \n                               │`}`                                             \n───────────────────────────────┼────────────────────────────────────────────────\n                               │`assert P(x0);`                                 \n`assert exists x :: P(x);`     │`assert exists x :: P(x);`                      \n                               │for a given expression `x0`.                    \n───────────────────────────────┼────────────────────────────────────────────────\n                               │`returns (j: int)`                              \n`ensures exists i :: P(i);`    │`ensures P(j) ensures exists i :: P(i)`         \n                               │in a lemma, so that the `j` can be computed     \n                               │explicitly.                                     \n───────────────────────────────┼────────────────────────────────────────────────\n                               │[`calc == {`][1190]                             \n                               │` A;`                                           \n`assert A == B;`               │` B;`                                           \n`callLemma(x);`                │` { callLemma(x); }`                            \n`assert B == C;`               │` C;`                                           \n                               │`};`                                            \n                               │`assert A == B;`                                \n                               │where the [`calc`][1191] statement can be used  \n                               │to make intermediate computation steps explicit.\n                               │Works with `<`, `>`, `<=`, `>=`, `==>`, `<==`   \n                               │and `<==>` for example.                         \n───────────────────────────────┼────────────────────────────────────────────────\n                               │`if A {`                                        \n                               │` assert B;`                                    \n                               │`};`                                            \n`assert A ==> B;`              │`assert A ==> B;`                               \n───────────────────────────────┼────────────────────────────────────────────────\n                               │`assert A;`                                     \n                               │`assert B;`                                     \n`assert A && B;`               │`assert A && B;`                                \n───────────────────────────────┼────────────────────────────────────────────────\n`ensures P ==> Q` on a lemma   │`requires P ensures Q` to avoid accidentally    \n                               │calling the lemma on inputs that do not satisfy \n                               │`P`                                             \n───────────────────────────────┼────────────────────────────────────────────────\n`seq(size, i => P)`            │`seq(size, i requires 0 <= i < size => P);`     \n───────────────────────────────┼────────────────────────────────────────────────\n                               │`assert G(i0);`                                 \n                               │`assert R(i0);`                                 \n`assert forall x :: G(i) ==>   │`assert forall i :: G(i) ==> R(i);` with a guess\nR(i);`                         │of the `i0` that makes the second assert to     \n                               │fail.                                           \n───────────────────────────────┼────────────────────────────────────────────────\n                               │`assert forall i | 0 < i < m :: P(i);`          \n                               │`assert forall i | i == m :: P(i);`             \n`assert forall i | 0 < i <= m  │`assert forall i | 0 < i <= m :: P(i);`         \n:: P(i);`                      │                                                \n───────────────────────────────┼────────────────────────────────────────────────\n                               │`assert P(m);`                                  \n                               │`assert forall i | i == m :: P(i);`             \n`assert forall i | i == m ::   │                                                \nP(m);`                         │                                                \n───────────────────────────────┼────────────────────────────────────────────────\n`method m(i) returns (j: T)`   │`method m(i) returns (j: T)`                    \n` requires A(i)`               │` requires A(i)`                                \n` ensures B(i, j)`             │` ensures B(i, j)`                              \n`{`                            │`{`                                             \n` ...`                         │` ...`                                          \n`}`                            │`}`                                             \n                               │                                                \n`method n() {`                 │`method n() {`                                  \n` ...`                         │` ...`                                          \n                               │` assert A(k);`                                 \n                               │` assert forall x :: B(k, x) ==> P(x);`         \n` var x := m(a);`              │` var x := m(k);`                               \n` assert P(x);`                │` assert P(x);`                                 \n───────────────────────────────┼────────────────────────────────────────────────\n`method m_mod(i) returns (j:   │`method m_mod(i) returns (j: T)`                \nT)`                            │` requires A(i)`                                \n` requires A(i)`               │` modifies this, i`                             \n` modifies this, i`            │` ensures B(i, j)`                              \n` ensures B(i, j)`             │`{`                                             \n`{`                            │` ...`                                          \n` ...`                         │`}`                                             \n`}`                            │                                                \n                               │`method n_mod() {`                              \n`method n_mod() {`             │` ...`                                          \n` ...`                         │` assert A(k);`                                 \n                               │` modify this, i; // Temporarily`               \n                               │` var x: T; // Temporarily`                     \n                               │` assume B(k, x);`                              \n                               │`// var x := m_mod(k);`                         \n` var x := m_mod(a);`          │` assert P(x);`                                 \n` assert P(x);`                │                                                \n───────────────────────────────┼────────────────────────────────────────────────\n                               │`assert x != z && y != z;`                      \n`modify x, y;`                 │`modify x, y;`                                  \n`assert P(x, y, z);`           │`assert P(x, y, z);`                            \n───────────────────────────────┴────────────────────────────────────────────────\n13.7.1.4. Counterexamples\n\nWhen verification fails, we can rerun Dafny with `--extract-counterexample` flag\nto get a counterexample that can potentially explain the proof failure. Note\nthat Danfy cannot guarantee that the counterexample it reports provably violates\nthe assertion it was generated for (see ^{[17][1192]}) The counterexample takes\nthe form of assumptions that can be inserted into the code to describe the\npotential conditions under which the given assertion is violated. This output\nshould be inspected manually and treated as a hint.\n\n#### 13.7.2. Verification debugging when verification is slow\n\nIn this section, we describe techniques to apply in the case when verification\nis slower than expected, does not terminate, or times out.\n\nAdditional detail is available in the [verification optimization guide][1193].\n\n13.7.2.1. `assume false;`\n\nAssuming `false` is an empirical way to short-circuit the verifier and usually\nstop verification at a given point,^{[18][1194]} and since the final compilation\nsteps do not accept this command, it is safe to use it during development.\nAnother similar command, `assert false;`, would also short-circuit the verifier,\nbut it would still make the verifier try to prove `false`, which can also lead\nto timeouts.\n\nThus, let us say a program of this shape takes forever to verify.\n\n`method NotTerminating(b: bool) {\n   assert X;\n   if b {\n     assert Y;\n   } else {\n     assert Z;\n     assert P;\n   }\n}\n`\n\nWhat we can first do is add an `assume false` at the beginning of the method:\n\n`method NotTerminating() {\n   assume false; // Will never compile, but everything verifies instantly\n   assert X;\n   if b {\n     assert Y;\n   } else {\n     assert Z;\n     assert P;\n   }\n   assert W;\n}\n`\n\nThis verifies instantly. This gives us a strategy to bisect, or do binary search\nto find the assertion that slows everything down. Now, we move the `assume\nfalse;` below the next assertion:\n\n`method NotTerminating() {\n   assert X;\n   assume false;\n   if b {\n     assert Y;\n   } else {\n     assert Z;\n     assert P;\n   }\n   assert W;\n}\n`\n\nIf verification is slow again, we can use [techniques seen before][1195] to\ndecompose the assertion and find which component is slow to prove.\n\nIf verification is fast, that’s the sign that `X` is probably not the problem,.\nWe now move the `assume false;` after the if/then block:\n\n`method NotTerminating() {\n   assert X;\n   if b {\n     assert Y;\n   } else {\n     assert Z;\n     assert P;\n   }\n   assume false;\n   assert W;\n}\n`\n\nNow, if verification is fast, we know that `assert W;` is the problem. If it is\nslow, we know that one of the two branches of the `if` is the problem. The next\nstep is to put an `assume false;` at the end of the `then` branch, and an\n`assume false` at the beginning of the else branch:\n\n`method NotTerminating() {\n   assert X;\n   if b {\n     assert Y;\n     assume false;\n   } else {\n     assume false;\n     assert Z;\n     assert P;\n   }\n   assert W;\n}\n`\n\nNow, if verification is slow, it means that `assert Y;` is the problem. If\nverification is fast, it means that the problem lies in the `else` branch. One\ntrick to ensure we measure the verification time of the `else` branch and not\nthe then branch is to move the first `assume false;` to the top of the then\nbranch, along with a comment indicating that we are short-circuiting it for now.\nThen, we can move the second `assume false;` down and identify which of the two\nassertions makes the verifier slow.\n\n`method NotTerminating() {\n   assert X;\n   if b {\n     assume false; // Short-circuit because this branch is verified anyway\n     assert Y;\n   } else {\n     assert Z;\n     assume false;\n     assert P;\n   }\n   assert W;\n}\n`\n\nIf verification is fast, which of the two assertions `assert Z;` or `assert P;`\ncauses the slowdown?^{[19][1196]}\n\nWe now hope you know enough of `assume false;` to locate assertions that make\nverification slow. Next, we will describe some other strategies at the assertion\nlevel to figure out what happens and perhaps fix it.\n\n13.7.2.2. `assert ... by {}`\n\nIf an assertion `assert X;` is slow, it is possible that calling a lemma or\ninvoking other assertions can help to prove it: The postcondition of this lemma,\nor the added assertions, could help the `dafny` verifier figure out faster how\nto prove the result.\n\n`  assert SOMETHING_HELPING_TO_PROVE_LEMMA_PRECONDITION;\n  LEMMA();\n  assert X;\n...\nlemma () \n  requires LEMMA_PRECONDITION\n  ensures X { ... }\n`\n\nHowever, this approach has the problem that it exposes the asserted expressions\nand lemma postconditions not only for the assertion we want to prove faster, but\nalso for every assertion that appears afterwards. This can result in\nslowdowns^{[20][1197]}. A good practice consists of wrapping the intermediate\nverification steps in an `assert ... by {}`, like this:\n\n`  assert X by {\n    assert SOMETHING_HELPING_TO_PROVE_LEMMA_PRECONDITION;\n    LEMMA();\n  }\n`\n\nNow, only `X` is available for the `dafny` verifier to prove the rest of the\nmethod.\n\n13.7.2.3. Labeling and revealing assertions\n\nAnother way to prevent assertions or preconditions from cluttering the\nverifier^{[20][1198]} is to label and reveal them. Labeling an assertion has the\neffect of “hiding” its result, until there is a “reveal” calling that label.\n\nThe example of the [previous section][1199] could be written like this.\n\n`  assert p: SOMETHING_HELPING_TO_PROVE_LEMMA_PRECONDITION;\n  // p is not available here.\n  assert X by {\n    reveal p;\n    LEMMA();\n  }\n`\n\nSimilarly, if a precondition is only needed to prove a specific result in a\nmethod, one can label and reveal the precondition, like this:\n\n`method Slow(i: int, j: int)\n  requires greater: i > j {\n  \n  assert i >= j by {\n    reveal greater;\n  }\n}\n`\n\nLabelled assert statements are available both in expressions and statements.\nAssertion labels are not accessible outside of the block which the assert\nstatement is in. If you need to access an assertion label outside of the\nenclosing expression or statement, you need to lift the labelled statement at\nthe right place manually, e.g. rewrite\n\n`ghost predicate P(i: int)\n\nmethod TestMethod(x: bool)\n  requires r: x <==> P(1)\n{\n  if x {\n    assert a: P(1) by { reveal r; }\n  }\n  assert x ==> P(1) by { reveal a; } // Error, a is not accessible\n}\n`\n\nto\n\n`ghost predicate P(i: int)\n\nmethod TestMethod(x: bool)\n  requires r: x <==> P(1)\n{\n  assert a: x ==> P(1) by {\n    if x {\n      assert P(1) by { reveal r; } // Proved without revealing the precondition\n    }\n  }\n  assert x ==> P(1) by { reveal a; } // Now a is accessible\n}\n`\n\nTo lift assertions, please refer to the techniques described in [Verification\nDebugging][1200].\n\n13.7.2.4. Non-opaque `function method`\n\nFunctions are normally used for specifications, but their functional syntax is\nsometimes also desirable to write application code. However, doing so naively\nresults in the body of a `function method Fun()` be available for every caller,\nwhich can cause the verifier to time out or get extremely slow^{[20][1201]}. A\nsolution for that is to add the attribute [`{:opaque}`][1202] right between\n`function method` and `Fun()`, and use [`reveal Fun();`][1203] in the calling\nfunctions or methods when needed.\n\n13.7.2.5. Conversion to and from bitvectors\n\nBitvectors and natural integers are very similar, but they are not treated the\nsame by the `dafny` verifier. As such, conversion from `bv8` to an `int` and\nvice-versa is not straightforward, and can result in slowdowns.\n\nThere are two solutions to this for now. First, one can define a [subset\ntype][1204] instead of using the built-in type `bv8`:\n\n`type byte = x | 0 <= x < 256\n`\n\nOne of the problems of this approach is that additions, subtractions and\nmultiplications do not enforce the result to be in the same bounds, so it would\nhave to be checked, and possibly truncated with modulos. For example:\n\n`type byte = x | 0 <= x < 256\nmethod m() {\n  var a: byte := 250;\n  var b: byte := 200;\n  var c := b - a;               // inferred to be an 'int', its value will be 50\n.\n  var d := a + b;               // inferred to be an 'int', its value will be 45\n0.\n  var e := (a + b) % 256;       // still inferred to be an 'int'...\n  var f: byte := (a + b) % 256; // OK\n}\n`\n\nA better solution consists of creating a [newtype][1205] that will have the\nability to check bounds of arithmetic expressions, and can actually be compiled\nto bitvectors as well.\n\n`newtype {:nativeType \"short\"} byte = x | 0 <= x < 256\nmethod m() {\n  var a: byte := 250;\n  var b: byte := 200;\n  var c := b - a; // OK, inferred to be a byte\n  var d := a + b; // Error: cannot prove that the result of a + b is of type `by\nte`.\n  var f := ((a as int + b as int) % 256) as byte; // OK\n}\n`\n\nOne might consider refactoring this code into separate functions if used over\nand over.\n\n13.7.2.6. Nested loops\n\nIn the case of nested loops, the verifier might timeout sometimes because of\ninadequate or too much available information^{[20][1206]}. One way to mitigate\nthis problem, when it happens, is to isolate the inner loop by refactoring it\ninto a separate method, with suitable pre and postconditions that will usually\nassume and prove the invariant again. For example,\n\n`while X\n   invariant Y\n {\n   while X'\n     invariant Y'\n   {\n \n   }\n }\n`\n\ncould be refactored as this:\n\n``while X\n   invariant Y\n {\n   innerLoop();\n }\n...\nmethod innerLoop()\n  require Y'\n  ensures Y'\n`\n\nIn the next section, when everything can be proven in a timely manner, we\nexplain another strategy to decrease proof time by parallelizing it if needed,\nand making the verifier focus on certain parts.\n\n#### 13.7.3. Assertion batches, well-formedness, correctness\n\nTo understand how to control verification, it is first useful to understand how\n`dafny` verifies functions and methods.\n\nFor every method (or function, constructor, etc.), `dafny` extracts\n*assertions*. Assertions can roughly be sorted into two kinds: Well-formedness\nand correctness.\n\n* *Well-formedness* assertions: All the implicit requirements of native\n  operation calls (such as indexing and asserting that divisiors are nonzero),\n  [`requires` clauses][1207] of function calls, explicit [assertion\n  expressions][1208] and [`decreases` clauses][1209] at function call sites\n  generate well-formedness assertions.\n  An expression is said to be *well-formed* in a context if all well-formedness\n  assertions can be proven in that context.\n* *Correctness* assertions: All remaining assertions and clauses\n\nFor example, given the following statements:\n\n`if b {\n  assert a*a != 0;\n}\nc := (assert b ==> a != 0; if b then 3/a else f(a));\nassert c != 5/a;\n`\n\nDafny performs the following checks:\n\n`var c: int;\nif b {\n  assert a*a != 0;   // Correctness\n}\nassert b ==> a != 0; // Well-formedness\nif b {\n  assert a != 0;     // Well-formedness\n} else {\n  assert f.requires(a); // Well-formedness\n}\nc := if b then 3/a else f(a);\nassert a != 0;       // Well-formedness\nassert c != 5/a;     // Correctness\n`\n\nWell-formedness is proved at the same time as correctness, except for\n[well-formedness of requires and ensures clauses][1210] which is proved\nseparately from the well-formedness and correctness of the rest of the\nmethod/function. For the rest of this section, we don’t differentiate between\nwell-formedness assertions and correctness assertions.\n\nWe can also classify the assertions extracted by Dafny in a few categories:\n\n**Integer assertions:**\n\n* Every [division][1211] yields an *assertion* that the divisor is never zero.\n* Every [bounded number operation][1212] yields an *assertion* that the result\n  will be within the same bounds (no overflow, no underflows).\n* Every [conversion][1213] yields an *assertion* that conversion is compatible.\n* Every [bitvector shift][1214] yields an *assertion* that the shift amount is\n  never negative, and that the shift amount is within the width of the value.\n\n**Object assertions:**\n\n* Every [object property access][1215] yields an *assertion* that the object is\n  not null.\n* Every assignment `o.f := E;` yields an *assertion* that `o` is among the set\n  of objects of the `modifies` clause of the enclosing [loop][1216] or\n  [method][1217].\n* Every read `o.f` yields an *assertion* that `o` is among the set of objects of\n  the [`reads`][1218] clause of the enclosing function or predicate.\n* Every [array access][1219] `a[x]` yields the assertion that `0 <= x <\n  a.Length`.\n* Every [sequence access][1220] `a[x]` yields an *assertion*, that `0 <= x <\n  |a|`, because sequences are never null.\n* Every [datatype update expression][1221] and [datatype destruction][1222]\n  yields an *assertion* that the object has the given property.\n* Every method overriding a [`trait`][1223] yields an *assertion* that any\n  postcondition it provides implies the postcondition of its parent trait, and\n  an *assertion* that any precondition it provides is implied by the\n  precondition of its parent trait.\n\n**Other assertions:**\n\n* Every value whose type is assigned to a [subset type][1224] yields an\n  *assertion* that it satisfies the subset type constraint.\n* Every non-empty [subset type][1225] yields an *assertion* that its witness\n  satisfies the constraint.\n* Every [Assign-such-that operator][1226] `x :| P(x)` yields an *assertion* that\n  `exists x :: P(x)`. In case `x :| P(x); Body(x)` appears in an expression and\n  `x` is non-ghost, it also yields `forall x, y | P(x) && P(y) :: Body(x) ==\n  Body(y)`.\n* Every recursive function yields an *assertion* that [it terminates][1227].\n* Every [match expression][1228] or [alternative if statement][1229] yields an\n  *assertion* that all cases are covered.\n* Every call to a function or method with a [`requires`][1230] clause yields\n  *one assertion per requires clause*^{[21][1231]} (special cases such as\n  sequence indexing come with a special `requires` clause that the index is\n  within bounds).\n\n**Specification assertions:**\n\n* Any explicit [`assert`][1232] statement is *an assertion*^{[21][1233]}.\n* A consecutive pair of lines in a [`calc`][1234] statement forms *an assertion*\n  that the expressions are related according to the common operator.\n* Every [`ensures`][1235] clause yields an *assertion* at the end of the method\n  and on every return, and on [`forall`][1236] statements.\n* Every [`invariant`][1237] clause yields an *assertion* that it holds before\n  the loop and an *assertion* that it holds at the end of the loop.\n* Every [`decreases`][1238] clause yields an *assertion* at either a call site\n  or at the end of a while loop.\n* Every [`yield ensures`][1239] clause on an [iterator][1240] yields\n  *assertions* that the clause holds at every yielding point.\n* Every [`yield requires`][1241] clause on an [iterator][1242] yields\n  *assertions* that the clause holds at every point when the iterator is called.\n\nIt is useful to mentally visualize all these assertions as a list that roughly\nfollows the order in the code, except for `ensures` or `decreases` that generate\nassertions that seem earlier in the code but, for verification purposes, would\nbe placed later. In this list, each assertion depends on other assertions,\nstatements and expressions that appear earlier in the control flow^{[22][1243]}.\n\nThe fundamental unit of verification in `dafny` is an *assertion batch*, which\nconsists of one or more assertions from this “list”, along with all the\nremaining assertions turned into assumptions. To reduce overhead, by default\n`dafny` collects all the assertions in the body of a given method into a single\nassertion batch that it sends to the verifier, which tries to prove it correct.\n\n* If the verifier says it is correct,^{[17][1244]} it means that all the\n  assertions hold.\n* If the verifier returns a counterexample, this counterexample is used to\n  determine both the failing assertion and the failing path. In order to\n  retrieve additional failing assertions, `dafny` will again query the verifier\n  after turning previously failed assertions into assumptions.^{[23][1245]}\n  ^{[24][1246]}\n* If the verifier returns `unknown` or times out, or even preemptively for\n  difficult assertions or to reduce the chance that the verifier will ‘be\n  confused’ by the many assertions in a large batch, `dafny` may partition the\n  assertions into smaller batches^{[25][1247]}. An extreme case is the use of\n  the `/vcsSplitOnEveryAssert` command-line option or the\n  [`{:isolate_assertions}` attribute][1248], which causes `dafny` to make one\n  batch for each assertion.\n13.7.3.1. Controlling assertion batches\n\nWhen Dafny verifies a symbol, such as a method, a function or a constant with a\nsubset type, that verification may contain multiple assertions. A symbol is\ngenerally verified the fastest when all assertions it in are verified together,\nin what we call a single ‘assertion batch’. However, is it possible to split\nverification of a symbol into multiple batches, and doing so makes the\nindividual batches simpler, which can lead to less brittle verification\nbehavior. Dafny contains several attributes that allow you to customize how\nverification is split into batches.\n\nFirstly, you can instruct Dafny to verify individual assertions in separate\nbatches. You can place the `{:isolate}` attribute on a single assertion to place\nit in a separate batch, or you can place `{:isolate_assertions}` on a symbol,\nsuch as a function or method declaration, to place all assertions in it into\nseparate batches. The CLI option `--isolate-assertions` will place all\nassertions into separate batches for all symbols. `{:isolate}` can be used on\n`assert`, `return` and `continue` statements. When placed on a `return`\nstatement, it will verify the postconditions for all paths leading to that\n`return` in a separate batch. When placed on a `continue`, it will verify the\nloop invariants for all paths leading to that `continue` in a separate batch.\n\nGiven an assertion that is placed into a separate batch, you can then further\nsimplify the verification of this assertion by placing each control flow path\nthat leads to this assertion into a separate batch. You can do this using the\nattribute `{:isolate \"paths\"}`.\n\n#### 13.7.4. Command-line options and other attributes to control verification\n\nThere are many great options that control various aspects of verifying dafny\nprograms. Here we mention only a few:\n\n* Control of output: [`/dprint`][1249], [`/rprint`][1250], `/stats`,\n  [`/compileVerbose`][1251]\n* Whether to print warnings: `/proverWarnings`\n* Control of time: `/timeLimit`\n* Control of resources: `/rLimit` and [`{:rlimit}`][1252]\n* Control of the prover used: `/prover`\n* Control of how many times to *unroll* functions: [`{:fuel}`][1253]\n\nYou can search for them in [this file][1254] as some of them are still\ndocumented in raw text format.\n\n#### 13.7.5. Analyzing proof dependencies\n\nWhen Dafny successfully verifies a particular definition, it can ask the solver\nfor information about what parts of the program were actually used in completing\nthe proof. The program components that can potentially form part of a proof\ninclude:\n\n* `assert` statements (and the implicit assumption that they hold in subsequent\n  code),\n* implicit assertions (such as array or sequence bounds checks),\n* `assume` statements,\n* `ensures` clauses,\n* `requires` clauses,\n* function definitions,\n* method calls, and\n* assignment statements.\n\nUnderstanding what portions of the program the proof depended on can help\nidentify mistakes, and to better understand the structure of your proof (which\ncan help when optimizing it, among other things). In particular, there are two\nkey dependency structures that tend to indicate mistakes, both focused on what\nparts of the program were *not* included in the proof.\n\n* Redundant assumptions. In some cases, a proof can be completed without the\n  need of certain `assume` statements or `requires` clauses. This situation\n  might represent a mistake, and when the mistake is corrected those program\n  elements may become required. However, they may also simply be redundant, and\n  the program will become simpler if they’re removed. Dafny will report\n  assumptions of this form when verifying with the flag\n  `--warn-redundant-assumptions`. Note that `assert` statements may be warned\n  about, as well, indicating that the fact proved by the assertion wasn’t needed\n  to prove anything else in the program.\n* Contradictory assumptions. If the combination of all assumptions in scope at a\n  particular program point is contradictory, anything can be proved at that\n  point. This indicates the serious situation that, unless done on purpose in a\n  proof by contradiction, your proof may be entirely vacuous. It therefore may\n  not say what you intended, giving you a false sense of confidence. The\n  `--warn-contradictory-assumptions` flag instructs Dafny to warn about any\n  assertion that was proved through the use of contradictions between\n  assumptions. If a particular `assert` statement is part of an intentional\n  proof by contradiction, annotating it with the `{:contradiction}` attribute\n  will silence this warning.\n\nThese options can be specified in `dfyconfig.toml`, and this is typically the\nmost convenient way to use them with the IDE.\n\nMore detailed information is available using either the `--log-format text` or\n`--verification-coverage-report` option to `dafny verify`. The former will\ninclude a list of proof dependencies (including source location and description)\nalongside every assertion batch in the generated log whenever one of the two\nwarning options above is also included. The latter will produce a highlighted\nHTML version of your source code, in the same format used by `dafny test\n--coverage-report` and `dafny generate-tests --verification-coverage-report`,\nindicating which parts of the program were used, not used, or partly used in the\nverification of the entire program.\n\n#### 13.7.6. Debugging brittle verification\n\nWhen evolving a Dafny codebase, it can sometimes occur that a proof obligation\nsucceeds at first only for the prover to time out or report a potential error\nafter minor, valid changes. We refer to such a proof obligation as *brittle*.\nThis is ultimately due to decidability limitations in the form of automated\nreasoning that Dafny uses. The Z3 SMT solver that Dafny depends on attempts to\nefficiently search for proofs, but does so using both incomplete heuristics and\na degree of randomness, with the result that it can sometimes fail to find a\nproof even when one exists (or continue searching forever).\n\nDafny provides some features to mitigate this issue, primarily focused on early\ndetection. The philosophy is that, if Dafny programmers are alerted to proofs\nthat show early signs of brittleness, before they are obviously so, they can\nrefactor the proofs to make them less brittle before further development becomes\ndifficult.\n\nThe mechanism for early detection focuses on measuring the resources used to\ndischarge a proof obligation (either using duration or a more deterministic\n“resource count” metric available from Z3). Dafny can re-run a given proof\nattempt multiple times after automatically making minor changes to the structure\nof the input or to the random choices made by the solver. If the resources used\nduring these attempts (or the ability to find a proof at all) vary widely, we\nuse this as a proxy metric indicating that the proof may be brittle.\n\n13.7.6.1. Measuring proof brittleness\n\nTo measure the brittleness of your proofs, start by using the `dafny\nmeasure-complexity` command with the `--iterations N` flag to instruct Dafny to\nattempt each proof goal `N` times, using a different random seed each time. The\nrandom seed used for each attempt is derived from the global random seed `S`\nspecified with `-randomSeed:S`, which defaults to `0`. The random seed affects\nthe structure of the SMT queries sent to the solver, changing the ordering of\nSMT commands, the variable names used, and the random seed the solver itself\nuses when making decisions that can be arbitrary.\n\nFor most use cases, it also makes sense to specify the `--log-format csv` flag,\nto log verification cost statistics to a CSV file. By default, the resulting CSV\nfiles will be created in the `TestResults` folder of the current directory.\n\nOnce Dafny has completed, the [`dafny-reportgenerator`][1255] tool is a\nconvenient way to process the output. It allows you to specify several limits on\nstatistics computed from the elapsed time or solver resource use of each proof\ngoal, returning an error code when it detects violations of these limits. You\ncan find documentation on the full set of options for `dafny-reportgenerator` in\nits [`README.md`][1256] file.\n\nIn general, we recommend something like the following:\n\n`dafny-reportgenerator --max-resource-cv-pct 10 TestResults/*.csv\n`\n\nThis bounds the [coefficient of variation][1257] of the solver resource count at\n10% (0.10). We recommend a limit of less than 20%, perhaps even as low as 5%.\nHowever, when beginning to analyze a new project, it may be necessary to set\nlimits as high as a few hundred percent and incrementally ratchet down the limit\nover time.\n\nWhen first analyzing proof brittleness, you may also find that certain proof\ngoals succeed on some iterations and fail on others. If your aim is first to\nensure that brittleness doesn’t worsen and then to start reducing it,\nintegrating `dafny-reportgenerator` into CI and using the\n`--allow-different-outcomes` flag may be appropriate. Then, once you’ve improved\nbrittleness sufficiently, you can likely remove that flag (and likely have\nsignificantly lower limits on other metrics).\n\n13.7.6.2. Improving proof brittleness\n\nReducing proof brittleness is typically closely related to improving performance\noverall. As such, [techniques for debugging slow verification][1258] are\ntypically useful for debugging brittle proofs, as well. See also the\n[verification optimization guide][1259].\n\n### 13.8. Compilation\n\nThe `dafny` tool can compile a Dafny program to one of several target languages.\nDetails and idiosyncrasies of each of these are described in the following\nsubsections. In general note the following:\n\n* The compiled code originating from `dafny` can be combined with other source\n  and binary code, but only the `dafny`-originated code is verified.\n* Output file or folder names can be set using `--output`.\n* Code generated by `dafny` requires a Dafny-specific runtime library. By\n  default the runtime is included in the generated code. However for `dafny\n  translate` it is not included by default and must be explicitly requested\n  using `--include-runtime`. All runtime libraries are part of the Binary\n  (`./DafnyRuntime.*`) and Source (`./Source/DafnyRuntime/DafnyRuntime.*`)\n  releases.\n* Names in Dafny are written out as names in the target language. In some cases\n  this can result in naming conflicts. Thus if a Dafny program is intended to be\n  compiled to a target language X, you should avoid using Dafny identifiers that\n  are not legal identifiers in X or that conflict with reserved words in X.\n\nTo be compilable to an executable program, a Dafny program must contain a `Main`\nentry point, as described [here][1260].\n\n#### 13.8.1.1 Built-in declarations\n\nDafny includes several built-in types such as tuples, arrays, arrows\n(functions), and the `nat` subset type. The supporting target language code for\nthese declarations could be emitted on-demand, but these could then become\nmultiple definitions of the same symbols when compiling multiple components\nseparately. Instead, all such built-ins up to a pre-configured maximum size are\nincluded in most of the runtime libraries. This means that when compiling to\ncertain target languages, the use of such built-ins above these maximum sizes,\nsuch as tuples with more than 20 elements, is not supported. See the [Supported\nfeatures by target language][1261] table for the details on these limits.\n\n#### 13.8.2. `extern` declarations\n\nA Dafny declaration can be marked with the [`{:extern}`][1262] attribute to\nindicate that it refers to an external definition that is already present in the\nlanguage that the Dafny code will be compiled to (or will be present by the time\nthe final target-language program is compiled or run).\n\nBecause the [`{:extern}`][1263] attribute controls interaction with code written\nin one of many languages, it has some language-specific behavior, documented in\nthe following sections. However, some aspects are target-language independent\nand documented here.\n\nThe attribute can also take several forms, each defining a different\nrelationship between a Dafny name and a target language name. In the form\n[`{:extern}`][1264], the name of the external definition is assumed to be the\nname of the Dafny declaration after some target-specific name mangling. However,\nbecause naming conventions (and the set of allowed identifiers) vary between\nlanguages, Dafny allows additional forms for the `{:extern}` attribute.\n\nThe form `{:extern <s1>}` instructs `dafny` to compile references to most\ndeclarations using the name `s1` instead of the Dafny name. For [abstract\ntypes][1265], however, `s1` is sometimes used as a hint as to how to declare\nthat type when compiling. This hint is interpreted differently by each compiler.\n\nFinally, the form `{:extern <s1>, <s2>}` instructs `dafny` to use `s2` as the\ndirect name of the declaration. `dafny` will typically use a combination of `s1`\nand `s2`, such as `s1.s2`, to reference the declaration. It may also be the case\nthat one of the arguments is simply ignored, depending on the target language.\n\nThe recommended style is to prefer `{:extern}` when possible, and use similar\nnames across languages. This is usually feasible because existing external code\nis expected to have the same interface as the code that `dafny` would generate\nfor a declaration of that form. Because many Dafny types compile down to custom\ntypes defined in the Dafny runtime library, it’s typically necessary to write\nwrappers by hand that encapsulate existing external code using a compatible\ninterface, and those wrappers can have names chosen for compatibility. For\nexample, retrieving the list of command line arguments when compiling to C#\nrequires a wrapper such as the following:\n\n`using icharseq = Dafny.ISequence<char>;\nusing charseq = Dafny.Sequence<char>;\n\nnamespace Externs_Compile {\n  public partial class __default {\n    public static Dafny.ISequence<icharseq> GetCommandLineArgs() {\n      var dafnyArgs = Environment\n                      .GetCommandLineArgs()\n                      .Select(charseq.FromString);\n      return Dafny.Sequence<icharseq>.FromArray(dafnyArgs.ToArray());\n    }\n}\n`\n\nThis serves as an example of implementing an extern, but was only necessary to\nretrieve command line arguments historically, as `dafny` now supports capturing\nthese arguments via a main method that accepts a `seq<string>` (see the section\non the [Main method][1266]).\n\nNote that `dafny` does not check the arguments to `{:extern}`, so it is the\nuser’s responsibility to ensure that the provided names result in code that is\nwell-formed in the target language.\n\nAlso note that the interface the external code needs to implement may be\naffected by compilation flags. In this case, if `--unicode-char:true` is\nprovided, `dafny` will compile its `char` type to the `Dafny.Rune` C# type\ninstead, so the references to the C# type `char` above would need to be changed\naccordingly. The reference to `charseq.FromString` would in turn need to be\nchanged to `charseq.UnicodeFromString` to return the correct type.\n\nMost declarations, including those for modules, classes, traits, member\nvariables, constructors, methods, function methods, and abstract types, can be\nmarked with `{:extern}`.\n\nMarking a module with `{:extern}` indicates that the declarations contained\nwithin can be found within the given module, namespace, package, or similar\nconstruct within the target language. Some members of the Dafny module may\ncontain definitions, in which case code for those definitions will be generated.\nWhether this results in valid target code may depend on some target language\nsupport for something resembling “partial” modules, where different subsets of\nthe contents are defined in different places.\n\nThe story for classes is similar. Code for a class will be generated if any of\nits members are not `{:extern}`. Depending on the target language, making either\nall or none of the members `{:extern}` may be the only options that result in\nvalid target code. Traits with `{:extern}` can refer to existing traits or\ninterfaces in the target language, or can refer to the interfaces of existing\nclasses.\n\nMember variables marked with `{:extern}` refer to fields or properties in\nexisting target-language code. Constructors, methods, and functions refer to the\nequivalent concepts in the target language. They can have contracts, which are\nthen assumed to hold for the existing target-language code. They can also have\nbodies, but the bodies will not be compiled in the presence of the `{:extern}`\nattribute. Bodies can still be used for reasoning, however, so may be valuable\nin some cases, especially for function methods.\n\nTypes marked with `{:extern}` must be opaque. The name argument, if any, usually\nrefers to the type name in the target language, but some compilers treat it\ndifferently.\n\nDetailed description of the `dafny build` and `dafny run` commands and the\n`--input` option (needed when `dafny run` has more than one input file) is\ncontained [in the section on command-line structure][1267].\n\n#### 13.8.3. Replaceable modules\n\nTo enable easily customising runtime behavior across an entire Dafny program,\nDafny has placeholder modules. Here follows an example:\n\n`replaceable module Foo {\n  method Bar() returns (i: int) \n    ensures i >= 2\n}\n\nmethod Main() {\n  var x := Foo.Bar();\n  print x;\n}\n// At this point, the program can be verified but not run.\n\nmodule ConcreteFoo replaces Foo {\n  method Bar() returns (i: int) {\n    return 3; // Main will print 3.\n  }\n}\n// ConcreteFoo can be swapped out for different replacements of Foo, to customiz\ne runtime behavior.\n`\n\nWhen replacing a replaceable module, the same rules apply as when refining an\nabstract module. However, unlike an abstract module, a placeholder module can be\nused as if it is a concrete module. When executing code, using for example\n`dafny run` or `dafny translate`, any program that contains a placeholder module\nmust also contain a replacement of this placeholder. When using `dafny verify`,\nplaceholder modules do not have to be replaced.\n\nReplaceable modules are particularly useful for defining behavior that depends\non which target language Dafny is translated to.\n\n#### 13.8.4. C#\n\nFor a simple Dafny-only program, the translation step converts a `A.dfy` file\ninto `A.cs`; the build step then produces a `A.dll`, which can be used as a\nlibrary or as an executable (run using `dotnet A.dll`).\n\nIt is also possible to run the dafny files as part of a `csproj` project, with\nthese steps:\n\n* create a dotnet project file with the command `dotnet new console`\n* delete the `Program.cs` file\n* build the dafny program: `dafny build A.dfy`\n* run the built program `dotnet A.dll`\n\nThe last two steps can be combined: `dafny run A.dfy`\n\nNote that all input `.dfy` files and any needed runtime library code are\ncombined into a single `.cs` file, which is then compiled by `dotnet` to a\n`.dll`.\n\nExamples of how to integrate C# libraries and source code with Dafny source code\nare contained in [this separate document][1268].\n\n#### 13.8.5. Java\n\nThe Dafny-to-Java compiler translation phase writes out the translated files of\na file *A*`.dfy` to a directory *A*`-java`. The build phase writes out a library\nor executable jar file. The `--output` option (`-out` in the legacy CLI) can be\nused to choose a different jar file path and name and correspondingly different\ndirectory for .java and .class files.\n\nThe compiler produces a single wrapper method that then calls classes in\nrelevant other `.java` files. Because Java files must be named consistent with\nthe class they contain, but Dafny files do not, there may be no relation between\nthe Java file names and the Dafny file names. However, the wrapper class that\ncontains the Java `main` method is named for the first `.dfy` file on the\ncommand-line.\n\nThe step of compiling Java files (using `javac`) requires the Dafny runtime\nlibrary. That library is automatically included if dafny is doing the\ncompilation, but not if dafny is only doing translation.\n\nExamples of how to integrate Java source code and libraries with Dafny source\nare contained in [this separate document][1269].\n\n#### 13.8.6. Javascript\n\nThe Dafny-to-Javascript compiler translates all the given `.dfy` files into a\nsingle `.js` file, which can then be run using `node`. (Javascript has no\ncompilation step). The build and run steps are simply\n\n* `dafny build --target:js A.dfy`\n* `node A.js`\n\nOr, in one step,\n\n* `dafny run A.dfy`\n\nExamples of how to integrate Javascript libraries and source code with Dafny\nsource are contained in [this separate document][1270].\n\n#### 13.8.7. Go\n\nThe Dafny-to-Go compiler translates all the given `.dfy` files into a single\n`.go` file in `A-go/src/A.go`; the output folder can be specified with the\n`-out` option. For an input file `A.dfy` the default output folder is `A-go`.\nThen, Dafny compiles this program and creates an `A.exe` executable in the same\nfolder as `A.dfy`. Some system runtime code is also placed in `A-go/src`. The\nbuild and run steps are\n\n* `dafny build --target:go A.dfy`\n* `./A`\n\nThe uncompiled code can be compiled and run by `go` itself using\n\n* `(cd A-go; GO111MODULE=auto GOPATH=`pwd` go run src/A.go)`\n\nThe one-step process is\n\n* `dafny run --target:go A.dfy`\n\nThe `GO111MODULE` variable is used because Dafny translates to pre-module Go\ncode. When the implementation changes to current Go, the above command-line will\nchange, though the `./A` alternative will still be supported.\n\nExamples of how to integrate Go source code and libraries with Dafny source are\ncontained in [this separate document][1271].\n\n#### 13.8.8. Python\n\nThe Dafny-to-Python compiler is still under development. However, simple Dafny\nprograms can be built and run as follows. The Dafny-to-Python compiler\ntranslates the `.dfy` files into a single `.py` file along with supporting\nruntime library code, all placed in the output location (`A-py` for an input\nfile A.dfy, by default).\n\nThe build and run steps are\n\n* `dafny build --target:py A.dfy`\n* `python A-py/A.py`\n\nIn one step:\n\n* `dafny run --target:py A.dfy`\n\nExamples of how to integrate Python libraries and source code with Dafny source\nare contained in [this separate document][1272].\n\n#### 13.8.9. C++\n\nThe C++ backend was written assuming that it would primarily support writing\nC/C++ style code in Dafny, which leads to some limitations in the current\nimplementation.\n\n* The C++ compiler does not support BigIntegers, so do not use `int`, or raw\n  instances of `arr.Length`, or sequence length, etc. in executable code. You\n  can however, use `arr.Length as uint64` if you can prove your array is an\n  appropriate size. The compiler will report inappropriate integer use.\n* The C++ compiler does not support advanced Dafny features like traits or\n  coinductive types.\n* There is very limited support for higher order functions even for array\n  initialization. Use extern definitions like newArrayFill (see\n  [extern.dfy][1273]) or similar. See also the example in [`functions.dfy`]\n  (https://github.com/dafny-lang/dafny/blob/master/Test/c++/functions.dfy).\n* The current backend also assumes the use of C++17 in order to cleanly and\n  performantly implement datatypes.\n\n#### 13.8.10. Supported features by target language\n\nSome Dafny features are not supported by every target language. The table below\nshows which features are supported by each backend. An empty cell indicates that\na feature is not supported, while an X indicates that it is.\n\n────────────────────────────────────────┬──┬──────┬──┬───┬────┬───┬─────────────\nFeature                                 │C#│JavaSc│Go│Jav│Pyth│C++│Dafny Library\n                                        │  │ript  │  │a  │on  │   │(.doo)       \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Unbounded integers][1274]              │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Real numbers][1275]                    │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Ordinals][1276]                        │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Function values][1277]                 │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Iterators][1278]                       │X │X     │X │   │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Collections with trait element         │X │X     │X │X  │X   │   │X            \ntypes][1279]                            │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[External module names with only        │X │X     │  │X  │X   │X  │X            \nunderscores][1280]                      │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Co-inductive datatypes][1281]          │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Multisets][1282]                       │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Runtime type descriptors][1283]        │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Multi-dimensional arrays][1284]        │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Map comprehensions][1285]              │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Traits][1286]                          │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Let-such-that expressions][1287]       │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Non-native numeric newtypes][1288]     │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Method synthesis][1289]                │X │      │  │   │    │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[External classes][1290]                │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Instantiating the `object` type][1291] │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[`forall` statements that cannot be     │X │X     │X │X  │X   │   │X            \nsequentialized][1292]^{[26][1293]}      │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Taking an array’s length][1294]        │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[`m.Items` when `m` is a map][1295]     │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[The /runAllTests option][1296]         │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Integer range constraints in           │X │X     │X │X  │X   │X  │X            \nquantifiers (e.g. `a <= x <= b`)][1297] │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Exact value constraints in quantifiers │X │X     │X │X  │X   │   │X            \n(`x == C`)][1298]                       │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Sequence displays of                   │X │X     │X │X  │X   │   │X            \ncharacters][1299]^{[27][1300]}          │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Type test expressions (`x is T`)][1301]│X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Type test expressions on subset        │  │      │  │   │    │   │X            \ntypes][1302]                            │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Quantifiers][1303]                     │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Bitvector RotateLeft/RotateRight       │X │X     │X │X  │X   │   │X            \nfunctions][1304]                        │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[`for` loops][1305]                     │X │X     │X │X  │X   │X  │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[`continue` statements][1306]           │X │X     │X │X  │X   │X  │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Assign-such-that statements with       │X │X     │X │X  │X   │X  │X            \npotentially infinite                    │  │      │  │   │    │   │             \nbounds][1307]^{[28][1308]}              │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Sequence update expressions][1309]     │X │X     │X │X  │X   │X  │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Sequence constructions with non-lambda │X │X     │X │X  │X   │X  │X            \ninitializers][1310]^{[29][1311]}        │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Externally-implemented                 │X │      │  │X  │X   │X  │X            \nconstructors][1312]                     │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Auto-initialization of tuple           │X │X     │X │X  │X   │X  │X            \nvariables][1313]                        │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Subtype constraints in                 │X │X     │X │X  │X   │X  │X            \nquantifiers][1314]                      │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Tuples with more than 20               │  │X     │X │   │X   │X  │X            \narguments][1315]                        │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Arrays with more than 16               │  │X     │X │   │X   │X  │X            \ndimensions][1316]                       │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Arrow types with more than 16          │  │X     │X │   │X   │X  │X            \narguments][1317]                        │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Unicode chars][1318]                   │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Converting values to strings][1319]    │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Legacy CLI without commands][1320]     │X │X     │X │X  │X   │X  │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Separate compilation][1321]            │X │      │X │X  │X   │X  │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[All built-in types in runtime          │X │X     │X │X  │X   │   │X            \nlibrary][1322]                          │  │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Execution coverage report][1323]       │X │      │  │   │    │   │             \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Standard libraries][1324]              │X │X     │X │X  │X   │   │X            \n────────────────────────────────────────┼──┼──────┼──┼───┼────┼───┼─────────────\n[Standard library ActionsExterns][1325] │X │      │  │X  │    │   │X            \n────────────────────────────────────────┴──┴──────┴──┴───┴────┴───┴─────────────\n\n### 13.9. Dafny Command Line Options\n\nThere are many command-line options to the `dafny` tool. The most current\ndocumentation of the options is within the tool itself, using the `-?` or\n`--help` or `-h` options.\n\nRemember that options are typically stated with either a leading `--`.\n\nLegacy options begin with either ‘-‘ or ‘/’; however they are being migrated to\nthe POSIX-compliant `--` form as needed.\n\n#### 13.9.1. Help and version information\n\nThese options emit general information about commands, options and attributes.\nWhen present, the dafny program will terminates after emitting the requested\ninformation but without processing any files.\n\n* `--help`, `-h` - shows the various commands (which have help information under\n  them as `dafny <command> -h`\n* `--version` - show the version of the build\n\nLegacy options:\n\n* `-?` - print out the legacy list of command-line options and terminate. All of\n  these options are also described in this and the following sections.\n* `-attrHelp` - print out the current list of supported attribute declarations\n  and terminate.\n* `-env:<n>` - print the command-line arguments supplied to the program. The\n  value of `<n>` can be one of the following.\n  \n  * `0` - never print command-line arguments.\n  * `1` (default) - print them to Boogie (`.bpl`) files and prover logs.\n  * `2` - operate like with option `1` but also print to standard output.\n* `-wait` - wait for the user to press `Enter` before terminating after a\n  successful execution.\n\n#### 13.9.2. Controlling input\n\nThese options control how Dafny processes its input.\n\n* `-stdin` - read standard input and treat it as Dafny source code, instead of\n  reading from a file.\n* `--library:<files>` - treat the given files as *library* code, namely, skip\n  these files (and any files recursively included) during verification; the\n  value may be a comma-separated-list of files or folders; folders are expanded\n  into a list of all .dfy files contained, recursively, in those folders\n* `--prelude:<file>` (was `-dprelude`) - select an alternative Dafny prelude\n  file. This file contains Boogie definitions (including many axioms) required\n  by the translator from Dafny to Boogie. Using an alternative prelude is\n  primarily useful if you’re extending the Dafny language or changing how Dafny\n  constructs are modeled. The default prelude is [here][1326].\n\n#### 13.9.3. Controlling plugins\n\nDafny has a plugin capability. A plugin has access to an AST of the dafny input\nfiles after all parsing and resolution are performed (but not verification) and\nalso to the command-line options.\n\nThis facility is still *experimental* and very much in flux, particularly the\nform of the AST. The best guides to writing a new plugin are (a) the\ndocumentation in [the section of this manual on plugins][1327] and (b) example\nplugins in the `src/Tools` folder of the `dafny-lang/compiler-bootstrap` repo.\n\nThe value of the option `--plugin` is a path to a dotnet dll that contains the\ncompiled plugin.\n\n#### 13.9.4. Controlling output\n\nThese options instruct Dafny to print various information about your program\nduring processing, including variations of the original source code (which can\nbe helpful for debugging).\n\n* `--use-basename-for-filename` - when enabled, just the filename without the\n  directory path is used in error messages; this make error message shorter and\n  not tied to the local environment (which is a help in testing)\n* `--output`, `-o` - location of output files [translate, build]\n* `--show-snippets` - include with an error message some of the source code text\n  in the neighborhood of the error; the error location (file, line, column) is\n  always given\n* `--solver-log <file>` - [verification only] the file in which to place the SMT\n  text sent to the solver\n* `--log-format <configuration>` - [verification only] (was\n  `-verificationLogger:<configuration string>`) log verification results to the\n  given test result logger. The currently supported loggers are `trx`, `csv`,\n  and `text`. These are the XML-based formats commonly used for test results for\n  .NET languages, a custom CSV schema, and a textual format meant for human\n  consumption, respectively. You can provide configuration using the same string\n  format as when using the `--logger` option for dotnet test, such as:\n  \n  `  -verificationLogger:trx;LogFileName=<...>\n  `\n  \n  The exact mapping of verification concepts to these formats is experimental\n  and subject to change!\n  \n  The `trx` and `csv` loggers automatically choose an output file name by\n  default, and print the name of this file to the console. The `text` logger\n  prints its output to the console by default, but can send output to a file\n  given the `LogFileName` option.\n  \n  The `text` logger also includes a more detailed breakdown of what assertions\n  appear in each assertion batch. When combined with the\n  `-vcsSplitOnEveryAssert` option, it will provide approximate time and resource\n  use costs for each assertion, allowing identification of especially expensive\n  assertions.\n\nLegacy options:\n\n* `-stats` - print various statistics about the Dafny files supplied on the\n  command line. The statistics include the number of total functions, recursive\n  functions, total methods, ghost methods, classes, and modules. They also\n  include the maximum call graph width and the maximum module height.\n* `-dprint:<file>` - print the Dafny program after parsing (use `-` for `<file>`\n  to print to the console).\n* `-rprint:<file>` - print the Dafny program after type resolution (use `-` for\n  `<file>` to print to the console).\n* `-printMode:<Everything|DllEmbed|NoIncludes|NoGhost>` - select what to include\n  in the output requested by `-dprint` or `-rprint`. The argument can be one of\n  the following.\n  \n  * `Everything` (default) - include everything.\n  * `DllEmbed`- print the source that will be included in a compiled DLL.\n  * `NoIncludes` - disable printing of methods incorporated via the include\n    mechanism that have the `{:verify false}` attribute, as well as datatypes\n    and fields included from other files.\n  * `NoGhost` - disables printing of functions, ghost methods, and proof\n    statements in implementation methods. Also disable anything `NoIncludes`\n    disables.\n* `-printIncludes:<None|Immediate|Transitive>` - select what information from\n  included files to incorporate into the output selected by `-dprint` or\n  `-rprint`. The argument can be one of the following.\n  \n  * `None` (default) - don’t print anything from included files.\n  * `Immediate` - print files directly included by files specified on the\n    command line. Exit after printing.\n  * `Transitive` - print files transitively included by files specified on the\n    command line. Exit after printing.\n* `-view:<view1, view2>` - this option limits what is printed by /rprint for a\n  module to the names that are part of the given export set; the option argument\n  is a comma-separated list of fully-qualified export set names.\n* `-funcCallGraph` - print out the function call graph. Each line has the format\n  `func,mod=callee*`, where `func` is the name of a function, `mod` is the name\n  of its containing module, and `callee*` is a space-separated list of the\n  functions that `func` calls.\n* `--show-snippets` (was `-showSnippets:<n>` ) - show a source code snippet for\n  each Dafny message. The legacy option was `-showSnippets` with values 0 and 1\n  for false and true.\n* `-printTooltips` - dump additional positional information (displayed as\n  mouse-over tooltips by LSP clients) to standard output as `Info` messages.\n* `-pmtrace` - print debugging information from the pattern-match compiler.\n* `-titrace` - print debugging information during the type inference process.\n* `-diagnosticsFormat:<text|json>` - control how to report errors, warnings, and\n  info messages. `<fmt>` may be one of the following:\n  \n  * `text` (default): Report diagnostics in human-readable format.\n  * `json`: Report diagnostics in JSON format, one object per diagnostic, one\n    diagnostic per line. Info-level messages are only included with\n    `-printTooltips`. End positions are only included with `-showSnippets:1`.\n    Diagnostics are the following format (but without newlines):\n    \n    `{\n      \"location\": {\n        \"filename\": \"xyz.dfy\",\n        \"range\": { // Start and (optional) end of diagnostic\n          \"start\": {\n            \"pos\": 83, // 0-based character offset in input\n            \"line\": 6, // 1-based line number\n            \"character\": 0 // 0-based column number\n          },\n          \"end\": { \"pos\": 86, \"line\": 6, \"character\": 3 }\n        }\n      },\n      \"severity\": 2, // 1: error; 2: warning; 4: info\n      \"message\": \"module-level const declarations are always non-instance ...\",\n      \"source\": \"Parser\",\n      \"relatedInformation\": [ // Additional messages, if any\n        {\n          \"location\": { ... }, // Like above\n          \"message\": \"...\",\n        }\n      ]\n    }\n    `\n\n#### 13.9.5. Controlling language features\n\nThese options allow some Dafny language features to be enabled or disabled. Some\nof these options exist for backward compatibility with older versions of Dafny.\n\n* `--default-function-opacity:<transparent|autoRevealDependencies|opaque>` -\n  Change the default opacity of functions.\n  \n  * `transparent` (default) means functions are transparent, can be manually\n    made opaque and then revealed.\n  * `autoRevealDependencies` makes all functions not explicitly labelled as\n    opaque to be opaque but reveals them automatically in scopes which do not\n    have `{:autoRevealDependencies false}`.\n  * `opaque` means functions are always opaque so the opaque keyword is not\n    needed, and functions must be revealed everywhere needed for a proof.\n* `--function-syntax` (value ‘3’ or ‘4’) - permits a choice of using the Dafny 3\n  syntax (`function` and `function method`) or the Dafny 4 syntax (`ghost\n  function` and `function`)\n* `--quantifier-syntax` (value ‘3’ or ‘4’) - permits a choice between the Dafny\n  3 and Dafny 4 syntax for quantifiers\n* `--unicode-char` - if false, the `char` type represents any UTF-16 code unit,\n  that is, any 16-bit value, including surrogate code points and allows `\\uXXXX`\n  escapes in string and character literals. If true, `char` represents any\n  Unicode scalar value, that is, any Unicode code point excluding surrogates and\n  allows `\\U{X..X}` escapes in string and character literals. The default is\n  false for Dafny version 3 and true for version 4. The legacy option was\n  `-unicodeChar:<n>` with values 0 and 1 for false and true above.\n\nLegacy options:\n\n* `-noIncludes` - ignore `include` directives in the program.\n* `-noExterns` - ignore `extern` attributes in the program.\n\n\n* `--function-syntax:<version>` (was `-functionSyntax:<version>` ) - select what\n  function syntax to recognize. The syntax for functions is changing from Dafny\n  version 3 to version 4. This switch gives early access to the new syntax, and\n  also provides a mode to help with migration. The valid arguments include the\n  following.\n  \n  * `3` (default) - compiled functions are written `function method` and\n    `predicate method`. Ghost functions are written `function` and `predicate`.\n  * `4` - compiled functions are written `function` and `predicate`. Ghost\n    functions are written `ghost function` and `ghost predicate`.\n  * `migration3to4` - compiled functions are written `function method` and\n    `predicate method`. Ghost functions are written `ghost function` and `ghost\n    predicate`. To migrate from version 3 to version 4, use this flag on your\n    version 3 program to flag all occurrences of `function` and `predicate` as\n    parsing errors. These are ghost functions, so change those into the new\n    syntax `ghost function` and `ghost predicate`. Then, start using\n    `-functionSyntax:4`. This will flag all occurrences of `function method` and\n    `predicate method` as parsing errors. So, change those to just `function`\n    and `predicate`. As a result, your program will use version 4 syntax and\n    have the same meaning as your previous version 3 program.\n  * `experimentalDefaultGhost` - like `migration3to4`, but allow `function` and\n    `predicate` as alternatives to declaring ghost functions and predicates,\n    respectively\n  * `experimentalDefaultCompiled` - like `migration3to4`, but allow `function`\n    and `predicate` as alternatives to declaring compiled functions and\n    predicates, respectively\n  * `experimentalPredicateAlwaysGhost` - compiled functions are written\n    `function`. Ghost functions are written `ghost function`. Predicates are\n    always ghost and are written `predicate`.\n  \n  This option can also be set locally (at the module level) using the `:options`\n  attribute:\n`  module {:options \"--function-syntax:4\"} M {\n    predicate CompiledPredicate() { true }\n  }\n`\n\n* `--quantifier-syntax:<version>` (was `-quantifierSyntax:<version>` ) - select\n  what quantifier syntax to recognize. The syntax for quantification domains is\n  changing from Dafny version 3 to version 4, more specifically where quantifier\n  ranges (`| <Range>`) are allowed. This switch gives early access to the new\n  syntax.\n  \n  * `3` (default) - Ranges are only allowed after all quantified variables are\n    declared. (e.g. `set x, y | 0 <= x < |s| && y in s[x] && 0 <= y :: y`)\n  * `4` - Ranges are allowed after each quantified variable declaration. (e.g.\n    `set x | 0 <= x < |s|, y <- s[x] | 0 <= y :: y`)\n  \n  Note that quantifier variable domains (`<- <Domain>`) are available in both\n  syntax versions.\n* `-disableScopes` - treat all export sets as `export reveal *` to never hide\n  function bodies or type definitions during translation.\n* `-allowsGlobals` - allow the implicit class `_default` to contain fields,\n  instance functions, and instance methods. These class members are declared at\n  the module scope, outside of explicit classes. This command-line option is\n  provided to simplify a transition from the behavior in the language prior to\n  version 1.9.3, from which point onward all functions and methods declared at\n  the module scope are implicitly static and field declarations are not allowed\n  at the module scope.\n\n#### 13.9.6. Controlling warnings\n\nThese options control what warnings Dafny produces, and whether to treat\nwarnings as errors.\n\n* `--warn-as-errors` (was `-warningsAsErrors`) - treat warnings as errors.\n* `--warn-shadowing` (was `-warnShadowing`) - emit a warning if the name of a\n  declared variable caused another variable to be shadowed.\n* `--warn-missing-constructor-parentheses` - warn if a constructor name in a\n  pattern might be misinterpreted\n\nLegacy options\n\n* `-deprecation:<n>` - control warnings about deprecated features. The value of\n  `<n>` can be any of the following.\n  \n  * `0` - don’t issue any warnings.\n  * `1` (default) - issue warnings.\n  * `2` - issue warnings and advise about alternate syntax.\n\n#### 13.9.7. Controlling verification\n\nThese options control how Dafny verifies the input program, including how much\nit verifies, what techniques it uses to perform verification, and what\ninformation it produces about the verification process.\n\n* `--no-verify` - turns off verification (for translate, build, run commands)\n* `--verify-included-files` (was `-verifyAllModules`) - verify modules that come\n  from include directives.\n  \n  By default, Dafny only verifies files explicitly listed on the command line:\n  if `a.dfy` includes `b.dfy`, a call to `Dafny a.dfy` will detect and report\n  verification errors from `a.dfy` but not from `b.dfy`.\n  \n  With this option, Dafny will instead verify everything: all input modules and\n  all their transitive dependencies. This way `Dafny a.dfy` will verify `a.dfy`\n  and all files that it includes (here `b.dfy`), as well all files that these\n  files include, etc.\n  \n  Running Dafny with this option on the file containing your main result is a\n  good way to ensure that all its dependencies verify.\n* `--track-print-effects` - If true, a compiled method, constructor, or iterator\n  is allowed to have print effects only if it is marked with . (default false)\n  The legacy option was `-trackPrintEffects:<n>`) with values 0 or 1 for false\n  and true.\n* `--relax-definite-assignment` - control the rules governing definite\n  assignment, the property that every variable is eventually assigned a value\n  before it is used.\n  \n  * if false (default), enforce definite-assignment for all non-yield-parameter\n    variables and fields, regardless of their types\n  * if false and `--enforce-determinism` is true, then also performs checks in\n    the compiler that no nondeterministic statements are used\n  * if true, enforce definite-assignment rules for compiled variables and fields\n    whose types do not support auto-initialization and for ghost variables and\n    fields whose type is possibly empty.\n* `--disable-nonlinear-arithmetic` (was `-noNLarith`) - reduce Z3’s knowledge of\n  non-linear arithmetic (the operators `*`, `/`, and `%`). Enabling this option\n  will typically require more manual work to complete proofs (by explicitly\n  applying lemmas about non-linear operators), but will also result in more\n  predictable behavior, since Z3 can sometimes get stuck down an unproductive\n  path while attempting to prove things about those operators. (This option will\n  perhaps be replaced by `-arith` in the future. For now, it takes precedence\n  over `-arith`.)\n  \n  The behavior of `disable-nonlinear-arithmetic` can be turned on and off on a\n  per-module basis by placing the attribute\n  [`{:disable-nonlinear-arithmetic}`][1328] after the module keyword. The\n  attribute optionally takes the value `false` to enable nonlinear arithmetic.\n* `--manual-lemma-induction` - disables automatic inducntion for lemmas\n* `--isolate-assertions` - verify assertions individually\n* `--extract-counterexample` - if verification fails, report a potential\n  counterexample as a set of assumptions that can be inserted into the code.\n  Note that Danfy cannot guarantee that the counterexample it reports provably\n  violates the assertion or that the assumptions are not mutually inconsistent\n  (see ^{[17][1329]}), so this output should be inspected manually and treated\n  as a hint.\n\nControlling the proof engine:\n\n* `--cores:<n>` - sets the number or percent of the available cores to be used\n  for verification\n* `--verification-time-limit <seconds>` - imposes a time limit on each\n  verification attempt\n* `--verification-error-limit <number>` - limits the number of verification\n  errors reported (0 is no limit)\n* `--resource-limit` - states a resource limit (to be used by the backend\n  solver)\n\nLegacy options:\n\n* `-dafnyVerify:<n>` [discouraged] - turn verification of the program on or off.\n  The value of `<n>` can be any of the following.\n  \n  * `0` - stop after type checking.\n  * `1` - continue on to verification and compilation.\n* `-separateModuleOutput` - output verification results for each module\n  separately, rather than aggregating them after they are all finished.\n* `-mimicVerificationOf:<dafny version>` - let `dafny` attempt to mimic the\n  verification behavior of a previous version of `dafny`. This can be useful\n  during migration to a newer version of `dafny` when a Dafny program has\n  proofs, such as methods or lemmas, that are highly variable in the sense that\n  their verification may become slower or fail altogether after logically\n  irrelevant changes are made in the verification input.\n  \n  Accepted versions are: `3.3`. Note that falling back on the behavior of\n  version 3.3 turns off features that prevent certain classes of verification\n  variability.\n* `-noCheating:<n>` - control whether certain assumptions are allowed. The value\n  of `<n>` can be one of the following.\n  \n  * `0` (default) - allow `assume` statements and free invariants.\n  * `1` - treat all assumptions as `assert` statements, and drop free\n    invariants.\n* `-induction:<n>` - control the behavior of induction. The value of `<n>` can\n  be one of the following.\n  \n  * `0` - never do induction, not even when attributes request it.\n  * `1` - apply induction only when attributes request it.\n  * `2` - apply induction as requested (by attributes) and also for\n    heuristically chosen quantifiers.\n  * `3` - apply induction as requested, and for heuristically chosen quantifiers\n    and lemmas.\n  * `4` (default) - apply induction as requested, and for all lemmas.\n* `-inductionHeuristic:<n>` - control the heuristics used for induction. The\n  value of `<n>` can be one of the following.\n  \n  * `0` - use the least discriminating induction heuristic (that is, lean toward\n    applying induction more often).\n  * `1`, `2`, `3`, `4`, `5` - use an intermediate heuristic, ordered as follows\n    as far as how discriminating they are: 0 < 1 < 2 < (3,4) < 5 < 6.\n  * `6` (default) - use the most discriminating induction heuristic.\n* `-allocated:<n>` - specify defaults for where Dafny should assert and assume\n  `allocated(x)` for various parameters `x`, local variables `x`, bound\n  variables `x`, etc. Lower `<n>` may require more manual `allocated(x)`\n  annotations and thus may be more difficult to use. The value of `<n>` can be\n  one of the following.\n  \n  * `0` - never assume or assert `allocated(x)` by default.\n  * `1` - assume `allocated(x)` only for non-ghost variables and fields. (These\n    assumptions are free, since non-ghost variables always contain allocated\n    values at run-time.) This option may speed up verification relative to\n    `-allocated:2`.\n  * `2` - assert/assume `allocated(x)` on all variables, even bound variables in\n    quantifiers. This option is the easiest to use for code that uses the heap\n    heavily.\n  * `3` - (default) make frugal use of heap parameters.\n  * `4` - like `3` but add `allocated` antecedents when ranges don’t imply\n    allocatedness.\n  \n  Warning: this option should be chosen consistently across an entire project;\n  it would be unsound to use different defaults for different files or modules\n  within a project. Furthermore, modes `-allocated:0` and `-allocated:1` let\n  functions depend on the allocation state, which is not sound in general.\n* `-noAutoReq` - ignore `autoReq` attributes, and therefore do not automatically\n  generate `requires` clauses.\n* `-autoReqPrint:<file>` - print the requires clauses that were automatically\n  generated by `autoReq` to the given `<file>`.\n* `-arith:<n>` - control how arithmetic is modeled during verification. This is\n  an experimental switch, and its options may change. The value of `<n>` can be\n  one of the following.\n  \n  * `0` - use Boogie/Z3 built-ins for all arithmetic operations.\n  * `1` (default) - like `0`, but introduce symbolic synonyms for `*`, `/`, and\n    `%`, and allow these operators to be used in triggers.\n  * `2` - like `1`, but also introduce symbolic synonyms for `+` and `-`.\n  * `3` - turn off non-linear arithmetic in the SMT solver. Still use Boogie/Z3\n    built-in symbols for all arithmetic operations.\n  * `4` - like `3`, but introduce symbolic synonyms for `*`, `/`, and `%`, and\n    allow these operators to be used in triggers.\n  * `5` - like `4`, but also introduce symbolic synonyms for `+` and `-`.\n  * `6` - like `5`, and introduce axioms that distribute `+` over `*`.\n  * `7` - like `6`, and introduce facts about the associativity of literal\n    arguments over `*`.\n  * `8` - like `7`, and introduce axioms for the connection between `*`, `/`,\n    and `%`.\n  * `9` - like `8`, and introduce axioms for sign of multiplication.\n  * `10` - like `9`, and introduce axioms for commutativity and associativity of\n    `*`.\n* `-autoTriggers:<n>` - control automatic generation of `{:trigger}`\n  annotations. See [triggers][1330]. The value of `<n>` can be one of the\n  following.\n  \n  * `0` - do not generate `{:trigger}` annotations for user-level quantifiers.\n  * `1` (default) - add a `{:trigger}` annotation to each user-level quantifier.\n    Existing annotations are preserved.\n* `-rewriteFocalPredicates:<n>` - control rewriting of predicates in the body of\n  prefix lemmas. See [the section about nicer extreme proofs][1331]. The value\n  of `<n>` can be one of the following.\n  \n  * `0` - don’t rewrite predicates in the body of prefix lemmas.\n  * `1` (default) - in the body of prefix lemmas, rewrite any use of a focal\n    predicate `P` to `P#[_k-1]`.\n\n#### 13.9.8. Controlling compilation\n\nThese options control what code gets compiled, what target language is used, how\ncompilation proceeds, and whether the compiled program is immediately executed.\n\n* `--target:<s>` or `-t:<s>` (was `-compileTarget:<s>`) - set the target\n  programming language for the compiler. The value of `<s>` can be one of the\n  following.\n  \n  * `cs` - C# . Produces a .dll file that can be run using `dotnet`. For\n    example, `dafny Hello.dfy` will produce `Hello.dll` and\n    `Hello.runtimeconfig.json`. The dll can be run using `dotnet Hello.dll`.\n  * `go` - Go. The default output of `dafny Hello.dfy -compileTarget:go` is in\n    the `Hello-go` folder. It is run using `GOPATH=`pwd`/Hello-go/\n    GO111MODULE=auto go run Hello-go/src/Hello.go`\n  * `js` - Javascript. The default output of `dafny Hello.dfy -compileTarget:js`\n    is the file `Hello.js`, which can be run using `node Hello.js`. (You must\n    have `bignumber.js` installed.)\n  * `java` - Java. The default output of `dafny Hello.dfy -compileTarget:java`\n    is in the `Hello-java` folder. The compiled program can be run using `java\n    -cp Hello-java:Hello-java/DafnyRuntime.jar Hello`.\n  * `py` - Python. The default output of `dafny Hello.dfy -compileTarget:py` is\n    in the `Hello-py` folder. The compiled program can be run using `python\n    Hello-py/Hello.py`, where `python` is Python version 3.\n  * `cpp` - C++. The default output of `dafny Hello.dfy -compileTarget:cpp` is\n    `Hello.exe` and other files written to the current folder. The compiled\n    program can be run using `./Hello.exe`.\n* `--input <file>` - designates files to be include in the compilation in\n  addition to the main file in `dafny run`; these may be non-.dfy files; this\n  option may be specified more than once\n* `--output:<file>` or `-o:<file>` (was `-out:<file>`) - set the name to use for\n  compiled code files.\n\nBy default, `dafny` reuses the name of the Dafny file being compiled. Compilers\nthat generate a single file use the file name as-is (e.g. the C# backend will\ngenerate `<file>.dll` and optionally `<file>.cs` with `-spillTargetCode`).\nCompilers that generate multiple files use the file name as a directory name\n(e.g. the Java backend will generate files in directory `<file>-java/`). Any\nfile extension is ignored, so `-out:<file>` is the same as `-out:<file>.<ext>`\nif `<file>` contains no periods.\n\n* `--include-runtime` - include the runtime library for the target language in\n  the generated artifacts. This is true by default for build and run, but false\n  by default for translate. The legacy option `-useRuntimeLib` had the opposite\n  effect: when enabled, the compiled assembly referred to the pre-built\n  `DafnyRuntime.dll` in the compiled assembly rather than including\n  `DafnyRuntime.cs` in the build process.\n\nLegacy options:\n\n* `-compile:<n>` - [obsolete - use `dafny build` or `dafny run`] control whether\n  compilation happens. The value of `<n>` can be one of the following. Note that\n  if the program is compiled, it will be compiled to the target language\n  determined by the `-compileTarget` option, which is C# by default.\n  \n  * `0` - do not compile the program\n  * `1` (default) - upon successful verification, compile the program to the\n    target language.\n  * `2` - always compile, regardless of verification success.\n  * `3` - if verification is successful, compile the program (like option `1`),\n    and then if there is a `Main` method, attempt to run the program.\n  * `4` - always compile (like option `2`), and then if there is a `Main`\n    method, attempt to run the program.\n* `-spillTargetCode:<n>` - [obsolete - use `dafny translate`) control whether to\n  write out compiled code in the target language (instead of just holding it in\n  internal temporary memory). The value of `<n>` can be one of the following.\n  \n  * `0` (default) - don’t make any extra effort to write the textual target\n    program (but still compile it, if `-compile` indicates to do so).\n  * `1` - write it out to the target language, if it is being compiled.\n  * `2` - write the compiled program if it passes verification, regardless of\n    the `-compile` setting.\n  * `3` - write the compiled program regardless of verification success and the\n    `-compile` setting.\n\nNote that some compiler targets may (always or in some situations) write out the\ntextual target program as part of compilation, in which case\n`-spillTargetCode:0` behaves the same way as `-spillTargetCode:1`.\n\n* `-Main:<name>` - specify the (fully-qualified) name of the method to use as\n  the executable entry point. The default is the method with the `{:main}`\n  attribute, or else the method named `Main`.\n* `-compileVerbose:<n>` - control whether to write out compilation progress\n  information. The value of `<n>` can be one of the following.\n  \n  * `0` - do not print any information (silent mode)\n  * `1` (default) - print information such as the files being created by the\n    compiler\n* `-coverage:<file>` - emit branch-coverage calls and outputs into `<file>`,\n  including a legend that gives a description of each source-location identifier\n  used in the branch-coverage calls. (Use `-` as `<file>` to print to the\n  console.)\n* `-optimize` - produce optimized C# code by passing the `/optimize` flag to the\n  `csc` executable.\n* `-optimizeResolution:<n>` - control optimization of method target resolution.\n  The value of `<n>` can be one of the following.\n  \n  * `0` - resolve and translate all methods.\n  * `1` - translate methods only in the call graph of the current verification\n    target.\n  * `2` (default) - as in `1`, but resolve only methods that are defined in the\n    current verification target file, not in included files.\n* `-testContracts:<mode>` - test certain function and method contracts at\n  runtime. This works by generating a wrapper for each function or method to be\n  tested that includes a sequence of `expect` statements for each requires\n  clause, a call to the original, and sequence of `expect` statements for each\n  `ensures` clause. This is particularly useful for code marked with the\n  `{:extern}` attribute and implemented in the target language instead of Dafny.\n  Having runtime checks of the contracts on such code makes it possible to\n  gather evidence that the target-language code satisfies the assumptions made\n  of it during Dafny verification through mechanisms ranging from manual tests\n  through fuzzing to full verification. For the latter two use cases, having\n  checks for `requires` clauses can be helpful, even if the Dafny calling code\n  will never violate them.\n  \n  The `<mode>` parameter can currently be one of the following.\n  \n  * `Externs` - insert dynamic checks when calling any function or method marked\n    with the `{:extern}` attribute, wherever the call occurs.\n  * `TestedExterns` - insert dynamic checks when calling any function or method\n    marked with the `{:extern}` attribute directly from a function or method\n    marked with the `{:test}` attribute.\n\n#### 13.9.9. Controlling Boogie\n\nDafny builds on top of Boogie, a general-purpose intermediate language for\nverification. Options supported by Boogie on its own are also supported by\nDafny. Some of the Boogie options most relevant to Dafny users include the\nfollowing. We use the term “procedure” below to refer to a Dafny function,\nlemma, method, or predicate, following Boogie terminology.\n\n* `--solver-path` - specifies a custom SMT solver to use\n* `--solver-plugin` - specifies a plugin to use as the SMT solver, instead of an\n  external pdafny translaterocess\n* `--boogie` - arguments to send to boogie\n\nLegacy options:\n\n* `-proc:<name>` - verify only the procedure named `<name>`. The name can\n  include `*` to indicate arbitrary sequences of characters.\n* `-trace` - print extra information during verification, including timing,\n  resource use, and outcome for each procedure incrementally, as verification\n  finishes.\n* `-randomSeed:<n>` - turn on randomization of the input that Boogie passes to\n  the SMT solver and turn on randomization in the SMT solver itself.\n  \n  Certain Boogie inputs cause proof variability in the sense that changes to the\n  input that preserve its meaning may cause the output to change. The\n  `-randomSeed` option simulates meaning-preserving changes to the input without\n  requiring the user to actually make those changes.\n  \n  The `-randomSeed` option is implemented by renaming variables and reordering\n  declarations in the input, and by setting solver options that have similar\n  effects.\n* `-randomSeedIterations:<n>` - attempt to prove each VC `<n>` times with `<n>`\n  random seeds. If `-randomSeed` has been provided, each proof attempt will use\n  a new random seed derived from this original seed. If not, it will implicitly\n  use `-randomSeed:0` to ensure a difference between iterations. This option can\n  be very useful for identifying input programs for which verification is highly\n  variable. If the verification times or solver resource counts associated with\n  each proof attempt vary widely for a given procedure, small changes to that\n  procedure might be more likely to cause proofs to fail in the future.\n* `-vcsSplitOnEveryAssert` - prove each (explicit or implicit) assertion in each\n  procedure separately. See also the attribute [`{:isolate_assertions}`][1332]\n  for restricting this option on specific procedures. By default, Boogie\n  attempts to prove that every assertion in a given procedure holds all at once,\n  in a single query to an SMT solver. This usually performs well, but sometimes\n  causes the solver to take longer. If a proof that you believe should succeed\n  is timing out, using this option can sometimes help.\n* `-timeLimit:<n>` - spend at most `<n>` seconds attempting to prove any single\n  SMT query. This setting can also be set per method using the attribute\n  [`{:timeLimit n}`][1333].\n* `-rlimit:<n>` - set the maximum solver resource count to use while proving a\n  single SMT query. This can be a more deterministic approach than setting a\n  time limit. To choose an appropriate value, please refer to the documentation\n  of the attribute [`{:rlimit}`][1334] that can be applied per procedure.\n* `-print:<file>` - print the translation of the Dafny file to a Boogie file.\n\nIf you have Boogie installed locally, you can run the printed Boogie file with\nthe following script:\n\n`DOTNET=$(which dotnet)\n\nBOOGIE_ROOT=\"path/to/boogie/Source\"\nBOOGIE=\"$BOOGIE_ROOT/BoogieDriver/bin/Debug/net8.0/BoogieDriver.dll\"\n\nif [[ ! -x \"$DOTNET\" ]]; then\n    echo \"Error: Dafny requires .NET Core to run on non-Windows systems.\"\n    exit 1\nfi\n\n#Uncomment if you prefer to use the executable instead of the DLL\n#BOOGIE=$(which boogie)\n\nBOOGIE_OPTIONS=\"/infer:j\"\nPROVER_OPTIONS=\"\\\n  /proverOpt:O:auto_config=false \\\n  /proverOpt:O:type_check=true \\\n  /proverOpt:O:smt.case_split=3 \\\n  /proverOpt:O:smt.qi.eager_threshold=100 \\\n  /proverOpt:O:smt.delay_units=true \\\n  /proverOpt:O:smt.arith.solver=2 \\\n  \"\n\n\"$DOTNET\" \"$BOOGIE\" $BOOGIE_OPTIONS $PROVER_OPTIONS \"$@\"\n#Uncomment if you want to use the executable instead of the DLL\n#\"$BOOGIE\" $BOOGIE_OPTIONS $PROVER_OPTIONS \"$@\"\n`\n\n#### 13.9.10. Controlling the prover\n\nMuch of controlling the prover is accomplished by controlling verification\ncondition generation ([25.9.7][1335]) or Boogie ([Section 13.9.9][1336]). The\nfollowing options are also commonly used:\n\n* `--verification-error-limit:<n>` - limits the number of verification errors\n  reported per procedure. Default is 5; 0 means as many as possible; a small\n  positive number runs faster but a large positive number reports more errors\n  per run\n* `--verification-time-limit:<n>` (was `-timeLimit:<n>`) - limits the number of\n  seconds spent trying to verify each assertion batch.\n\n#### 13.9.11. Controlling test generation\n\nDafny is capable of generating unit (runtime) tests. It does so by asking the\nprover to solve for values of inputs to a method that cause the program to\nexecute specific blocks or paths. A detailed description of how to do this is\ngiven in [a separate document][1337].\n\n## 14. Dafny VSCode extension and the Dafny Language Server\n\n### 14.1. Dafny functionality within VSCode\n\nThere is a language server for Dafny, which [implements][1338] the [Language\nServer Protocol][1339]. This server is used by the Dafny VSCode Extension; it\ncurrently offers the following features:\n\n* Quick syntax highlighting\n* As-you-type parsing, resolution and verification diagnostics\n* Support for [Dafny plugins][1340]\n* Expanded explanations (in addition to the error message) for selected errors\n  (and more being added), shown by hovering\n* Quick fixes for selected errors (and more being added)\n* Limited support for symbol completion\n* Limited support for code navigation\n* Counter-example display\n* Highlighting of ghost statements\n* Gutter highlights\n* A variety of Preference settings\n\nMost of the Dafny functionality is simply there when editing a .dfy file with\nVSCode that has the Dafny extension installed. Some actions are available\nthrough added menu items. The Dafny functionality within VSCode can be found in\nthese locations:\n\n* The preferences are under the menu Code->Preferences->Settings->Dafny\n  extension configuration. There are two sections of settings.\n* A hover over an error location will bring up a hover popup, which will show\n  expanded error information and any quick fix options that are available.\n* Within a .dfy editor, a right-click brings up a context menu, which has a menu\n  item ‘Dafny’. Under it are actions to Build or Run a program, to turn on or\n  off counterexample display, find definitions, and the like.\n\n### 14.2. Gutter highlights\n\nFeedback on a program is show visually as underlining with squiggles within the\ntext and as various markings in various colors in the *gutter* down the left\nside of an editor window.\n\nThe first time a file is loaded, the gutter will highlight in a transparent\nsquiggly green line all the methods that need to be verified, like this:\n\n[image]\n\nWhen the file is saved (in verification on save), or whenever the Dafny verifier\nis ready (in verification on change), it will start to verify methods. That line\nwill turn into a thin green rectangle on methods that have been verified, and\ndisplay an animated less transparent green squiggly line on methods that are\nbeing actively verified:\n\n[image]\n\nWhen the verification finishes, if a method, a function, a constant with default\ninitialization or a subset type with a witness has some verification errors in\nit, the editor will display two yellow vertical rails indicating an error\ncontext.\n\n[image]\n\nInside this context, if there is a failing assertion on a line, it will fill the\ngap between the vertical yellow bars with a red rectangle, even if there might\nbe other assertions that are verified on the line. If there is no error on a\nline, but there is at least one assertion that verified, it will display a green\ndisk with a white checkmark on it, which can be used to check progress in a\nproof search.\n\nAs soon as a line is changed, the gutter icons turn transparent and squiggly, to\nindicate their obsolescence.\n\n[image]\n\nThe red error rectangles occupy only half the horizontal space, to visualise\ntheir possible obsolescence.\n\nWhen the file is saved (in verification on save), or as soon as possible\notherwise, these squiggly icons will be animated while the Dafny verifier\ninspect the area.\n\n[image]\n\nIf the method was verifying before a change, instead of two yellow vertical bars\nwith a red squiggly line, the gutter icons display an animated squiggly but more\nfirm green line, thereby indicating that the method used to verify, but Dafny is\nstill re-verifying it.\n\n[image]\n\nIf there is a parse or resolution error, the previous gutter icons turn gray and\na red triangle indicates the position of the parse or resolution error.\n\n[image]\n\n### 14.3. The Dafny Server\n\nBefore Dafny [implemented][1341] the official [Language Server Protocol][1342],\nit implemented its own protocol for [Emacs][1343], which resulted in a project\ncalled [DafnyServer][1344]. While the latest Dafny releases still contain a\nworking DafnyServer binary, this component has been feature frozen since 2022,\nand it may not support features that were added to Dafny after that time. We do\nnot recommend using it.\n\nThe Dafny Server has [integration tests][1345] that serve as the basis of the\ndocumentation.\n\nThe server is essentially a REPL, which produces output in the same format as\nthe Dafny CLI; clients thus do not need to understand the internals of Dafny’s\ncaching. A typical editing session proceeds as follows:\n\n* When a new Dafny file is opened, the editor starts a new instance of the Dafny\n  server. The cache is blank at that point.\n* The editor sends a copy of the buffer for initial verification. This takes\n  some time, after which the server returns a list of errors.\n* The user makes modifications; the editor periodically sends a new copy of the\n  buffer’s contents to the Dafny server, which quickly returns an updated list\n  of errors.\n\nThe client-server protocol is sequential, uses JSON, and works over ASCII pipes\nby base64-encoding utf-8 queries. It defines one type of query, and two types of\nresponses:\n\nQueries are of the following form:\n\n` verify\n <base64 encoded JSON payload>\n [[DAFNY-CLIENT: EOM]]\n`\n\nResponses are of the following form:\n\n` <list of errors and usual output, as produced by the Dafny CLI>\n [SUCCESS] [[DAFNY-SERVER: EOM]]\n`\n\nor\n\n` <error message>\n [FAILURE] [[DAFNY-SERVER: EOM]]\n`\n\nThe JSON payload is an utf-8 encoded string resulting of the serialization of a\ndictionary with 4 fields:\n\n* args: An array of Dafny arguments, as passed to the Dafny CLI\n* source: A Dafny program, or the path to a Dafny source file.\n* sourceIsFile: A boolean indicating whether the ‘source’ argument is a Dafny\n  program or the path to one.\n* filename: The name of the original source file, to be used in error messages\n\nFor small files, embedding the Dafny source directly into a message is\nconvenient; for larger files, however, it is generally better for performance to\nwrite the source snapshot to a separate file, and to pass that to Dafny by\nsetting the ‘sourceIsFile’ flag to true.\n\nFor example, if you compile and run `DafnyServer.exe`, you could paste the\nfollowing command:\n\n`verify\neyJhcmdzIjpbIi9jb21waWxlOjAiLCIvcHJpbnRUb29sdGlwcyIsIi90aW1lTGltaXQ6MjAiXSwi\nZmlsZW5hbWUiOiJ0cmFuc2NyaXB0Iiwic291cmNlIjoibWV0aG9kIEEoYTppbnQpIHJldHVybnMg\nKGI6IGludCkge1xuICBiIDo9IGE7XG4gIGFzc2VydCBmYWxzZTtcbn1cbiIsInNvdXJjZUlzRmls\nZSI6ZmFsc2V9\n[[DAFNY-CLIENT: EOM]]\n`\n\nThe interpreter sees the command `verify`, and then starts reading every line\nuntil it sees `[[DAFNY-CLIENT: EOM]]` The payload is a base64 encoded string\nthat you could encode or decode using JavaScript’s `atob` and `btoa` function.\nFor example, the payload above was generated using the following code:\n\n`btoa(JSON.stringify({\n  \"args\": [\n    \"/compile:0\",\n    \"/printTooltips\",\n    \"/timeLimit:20\"\n   ],\n   \"filename\":\"transcript\",\n   \"source\":\n`method A(a:int) returns (b: int) {\n   b := a;\n   assert false;\n}\n`,\"sourceIsFile\": false}))\n=== \"eyJhcmdzIjpbIi9jb21waWxlOjAiLCIvcHJpbnRUb29sdGlwcyIsIi90aW1lTGltaXQ6MjAiXSw\niZmlsZW5hbWUiOiJ0cmFuc2NyaXB0Iiwic291cmNlIjoibWV0aG9kIEEoYTppbnQpIHJldHVybnMgKGI\n6IGludCkge1xuICBiIDo9IGE7XG4gIGFzc2VydCBmYWxzZTtcbn1cbiIsInNvdXJjZUlzRmlsZSI6ZmF\nsc2V9\"\n`\n\nThus to decode such output, you’d manually use `JSON.parse(atob(payload))`.\n\n## 15. Plugins to Dafny\n\nDafny has a plugin architecture that permits users to build tools for the Dafny\nlanguage without having to replicate parsing and name/type resolution of Dafny\nprograms. Such a tool might just do some analysis on the Dafny program, without\nconcern for verifying or compiling the program. Or it might modify the program\n(actually, modify the program’s AST) and then continue on with verification and\ncompilation with the core Dafny tool. A user plugin might also be used in the\nLanguage Server and thereby be available in the VSCode (or other) IDE.\n\n***This is an experimental aspect of Dafny.** The plugin API directly exposes\nthe Dafny AST, which is constantly evolving. Hence, always recompile your plugin\nagainst the binary of Dafny that will be importing your plugin.*\n\nPlugins are libraries linked to a `Dafny.dll` of the same version as the\nLanguage Server. A plugin typically defines:\n\n* Zero or one class extending `Microsoft.Dafny.Plugins.PluginConfiguration`,\n  which receives plugins arguments in its method `ParseArguments`, and\n  \n  1. Can return a list of `Microsoft.Dafny.Plugins.Rewriter`s when its method\n     `GetRewriters()` is called by Dafny,\n  2. Can return a list of `Microsoft.Dafny.Plugins.Compiler`s when its method\n     `GetCompilers()` is called by Dafny,\n  3. If the configuration extends the subclass\n     `Microsoft.Dafny.LanguageServer.Plugins.PluginConfiguration`:\n     \n     1. Can return a list of\n        `Microsoft.Dafny.LanguageServer.Plugins.DafnyCodeActionProvider`s when\n        its method `GetDafnyCodeActionProviders()` is called by the Dafny\n        Language Server.\n     2. Can return a modified version of\n        `OmniSharp.Extensions.LanguageServer.Server.LanguageServerOptions` when\n        its method `WithPluginHandlers()` is called by the Dafny Language\n        Server.\n* Zero or more classes extending `Microsoft.Dafny.Plugins.Rewriter`. If a\n  configuration class is provided, it is responsible for instantiating them and\n  returning them in `GetRewriters()`. If no configuration class is provided, an\n  automatic configuration will load every defined `Rewriter` automatically.\n* Zero or more classes extending `Microsoft.Dafny.Plugins.Compiler`. If a\n  configuration class is provided, it is responsible for instantiating them and\n  returning them in `GetCompilers()`. If no configuration class is provided, an\n  automatic configuration will load every defined `Compiler` automatically.\n* Zero or more classes extending\n  `Microsoft.Dafny.LanguageServer.Plugins.DafnyCodeActionProvider`. Only a\n  configuration class of type\n  `Microsoft.Dafny.LanguageServer.Plugins.PluginConfiguration` can be\n  responsible for instantiating them and returning them in\n  `GetDafnyCodeActionProviders()`.\n\nThe most important methods of the class `Rewriter` that plugins override are\n\n* (experimental) `PreResolve(ModuleDefinition)`: Here you can optionally modify\n  the AST before it is resolved.\n* `PostResolve(ModuleDefinition)`: This method is repeatedly called with every\n  resolved and type-checked module, before verification. Plugins override this\n  method typically to report additional diagnostics.\n* `PostResolve(Program)`: This method is called once after all\n  `PostResolve(ModuleDefinition)` have been called.\n\nPlugins are typically used to report additional diagnostics such as unsupported\nconstructs for specific compilers (through the methods `Èrror(...)` and\n`Warning(...)` of the field `Reporter` of the class `Rewriter`)\n\nNote that all plugin errors should use the original program’s expressions’ token\nand NOT `Token.NoToken`, else no error will be displayed in the IDE.\n\n### 15.1. Language Server plugin tutorial\n\nIn this section, we will create a plugin that enhances the functionality of the\nLanguage Server. We will start by showing the steps needed to create a plugin,\nfollowed by an example implementation that demonstrates how to provide more code\nactions and add custom request handlers.\n\n#### 15.1.1. Create plugin project\n\nAssuming the Dafny source code is installed in the folder `dafny/` start by\ncreating an empty folder next to it, e.g. `PluginTutorial/`\n\n`mkdir PluginTutorial\ncd PluginTutorial\n`\n\nThen, create a dotnet class project\n\n`dotnet new classlib\n`\n\nIt will create a file `Class1.cs` that you can rename\n\n`mv Class1.cs MyPlugin.cs\n`\n\nOpen the newly created file `PluginTutorial.csproj`, and add the following after\n`</PropertyGroup>`:\n\n`  <ItemGroup>\n    <ProjectReference Include=\"../dafny/source/DafnyLanguageServer/DafnyLanguage\nServer.csproj\" />\n  </ItemGroup>\n`\n\n#### 15.1.2. Implement plugin\n\n15.1.2.1. Code actions plugin\n\nThis code action plugin will add a code action that allows you to place a dummy\ncomment in front of the first method name, only if the selection is on the line\nof the method.\n\nOpen the file `MyPlugin.cs`, remove everything, and write the imports and a\nnamespace:\n\n`using Microsoft.Dafny;\nusing Microsoft.Dafny.LanguageServer.Plugins;\nusing Microsoft.Boogie;\nusing Microsoft.Dafny.LanguageServer.Language;\nusing System.Linq;\nusing Range = OmniSharp.Extensions.LanguageServer.Protocol.Models.Range;\n\nnamespace MyPlugin;\n`\n\nAfter that, add a `PluginConfiguration` that will expose all the quickfixers of\nyour plugin. This class will be discovered and instantiated automatically by\nDafny.\n\n`public class TestConfiguration : PluginConfiguration {\n  public override DafnyCodeActionProvider[] GetDafnyCodeActionProviders() {\n    return new DafnyCodeActionProvider[] { new AddCommentDafnyCodeActionProvider\n() };\n  }\n}\n`\n\nNote that you could also override the methods `GetRewriters()` and\n`GetCompilers()` for other purposes, but this is out of scope for this tutorial.\n\nThen, we need to create the quickFixer `AddCommentDafnyCodeActionProvider`\nitself:\n\n`public class AddCommentDafnyCodeActionProvider : DafnyCodeActionProvider {\n  public override IEnumerable<DafnyCodeAction> GetDafnyCodeActions(IDafnyCodeAct\nionInput input, Range selection) {\n    return new DafnyCodeAction[] { };\n  }\n}\n`\n\nFor now, this quick fixer returns nothing. `input` is the program state, and\n`selection` is where the caret is. We replace the return statement with a\nconditional that tests whether the selection is on the first line:\n\n`    var firstTokenRange = input.Program?.GetFirstTopLevelToken()?.GetLspRange()\n;\n    if(firstTokenRange != null && firstTokenRange.Start.Line == selection.Start.\nLine) {\n      return new DafnyCodeAction[] {\n        // TODO\n      };\n    } else {\n      return new DafnyCodeAction[] { };\n    }\n`\n\nEvery quick fix consists of a title (provided immediately), and zero or more\n`DafnyCodeActionEdit` (computed lazily). A `DafnyCodeActionEdit` has a `Range`\nto remove and some `string` to insert instead. All `DafnyCodeActionEdit`s of the\nsame `DafnyCodeAction` are applied at the same time if selected.\n\nTo create a `DafnyCodeAction`, we can either use the easy-to-use\n`InstantDafnyCodeAction`, which accepts a title and an array of edits:\n\n`  return new DafnyCodeAction[] {\n    new InstantDafnyCodeAction(\"Insert comment\", new DafnyCodeActionEdit[] {\n      new DafnyCodeActionEdit(firstTokenRange.GetStartRange(), \"/*First comment*\n/\")\n    })\n  };\n`\n\nor we can implement our custom inherited class of `DafnyCodeAction`:\n\n`public class CustomDafnyCodeAction: DafnyCodeAction {\n  public Range whereToInsert;\n  \n  public CustomDafnyCodeAction(Range whereToInsert): base(\"Insert comment\") {\n    this.whereToInsert = whereToInsert;\n  }\n  public override DafnyCodeActionEdit[] GetEdits() {\n    return new DafnyCodeActionEdit[] {\n      new DafnyCodeActionEdit(whereToInsert.GetStartRange(), \"/*A comment*/\")\n    };\n  }\n}\n`\n\nIn that case, we could return:\n\n`  return new DafnyCodeAction[] {\n    new CustomDafnyCodeAction(firstTokenRange)\n  };\n`\n15.1.2.2. Request handler plugin\n\nThis request handler plugin enhances the Language Server to support a request\nwith a `TextDocumentIdentifier` as parameter, which will return a `bool` value\ndenoting whether the provided `DocumentUri` has any `LoopStmt`’s in it.\n\nOpen the file `MyPlugin.cs`, remove everything, and write the imports and a\nnamespace:\n\n`using OmniSharp.Extensions.JsonRpc;\nusing OmniSharp.Extensions.LanguageServer.Server;\nusing OmniSharp.Extensions.LanguageServer.Protocol.Models;\nusing Microsoft.Dafny.LanguageServer.Plugins;\nusing Microsoft.Dafny.LanguageServer.Workspace;\nusing MediatR;\nusing Microsoft.Dafny;\n\nnamespace MyPlugin;\n`\n\nAfter that, add a `PluginConfiguration` that will add all the request handlers\nof your plugin. This class will be discovered and instantiated automatically by\nDafny.\n\n`public class TestConfiguration : PluginConfiguration {\n  public override LanguageServerOptions WithPluginHandlers(LanguageServerOptions\n options) {\n    return options.WithHandler<DummyHandler>();\n  }\n}\n`\n\nThen, we need to create the request handler `DummyHandler` itself:\n\n`[Parallel]\n[Method(\"dafny/request/dummy\", Direction.ClientToServer)]\npublic record DummyParams : TextDocumentIdentifier, IRequest<bool>;\n\npublic class DummyHandler : IJsonRpcRequestHandler<DummyParams, bool> {\n  private readonly IProjectDatabase projects;\n  public DummyHandler(IProjectDatabase projects) {\n    this.projects = projects;\n  }\n  public async Task<bool> Handle(DummyParams request, CancellationToken cancella\ntionToken) {\n    var state = await projects.GetParsedDocumentNormalizeUri(request);\n    if (state == null) {\n      return false;\n    }\n    return state.Program.Descendants().OfType<LoopStmt>().Any();\n  }\n}\n`\n\nFor more advanced example implementations of request handlers, look at\n`dafny/Source/DafnyLanguageServer/Handlers/*`.\n\n#### 15.1.3. Building plugin\n\nThat’s it! Now, build your library while inside your folder:\n\n`> dotnet build\n`\n\nThis will create the file `PluginTutorial/bin/Debug/net8.0/PluginTutorial.dll`.\nNow, open VSCode, open Dafny settings, and enter the absolute path to this DLL\nin the plugins section. Restart VSCode, and it should work!\n\n## 16. Full list of legacy command-line options {#sec-full-command-line-options}\n\nFor the on-line version only, the output of `dafny -?` follows. Note that with\nthe advent of [dafny commands][1346], many options are only applicable to some\n(if any) commands, some are renamed, and some are obsolete and will eventually\nbe removed.\n\n`Use 'dafny --help' to see help for the new Dafny CLI format.\nUsage: dafny [ option ... ] [ filename ... ]\n\n  ---- General options -------------------------------------------------------\n\n  /version      print the dafny version number\n  /help         print this message\n  /attrHelp     print a message about supported declaration attributes\n  /env:<n>      print command line arguments\n                  0 - never, 1 (default) - during BPL print and prover log,\n                  2 - like 1 and also to standard output\n  /printVerifiedProceduresCount:<n>\n                0 - no\n                1 (default) - yes\n  /wait         await Enter from keyboard before terminating program\n  /xml:<file>   also produce output in XML format to <file>\n\n  All the .dfy files supplied on the command line along with files recursively\n  included by 'include' directives are considered a single Dafny program;\n  however only those files listed on the command line are verified.\n  \n  Exit code: 0 -- success; 1 -- invalid command-line; 2 -- parse or type errors;\n             3 -- compilation errors; 4 -- verification errors\n  \n  ---- Input configuration ---------------------------------------------------\n  \n  /dprelude:<file>\n      Choose the Dafny prelude file.\n\n  /stdin\n      Read standard input and treat it as an input .dfy file.\n  \n  ---- Plugins ---------------------------------------------------------------\n  \n  ---- Overall reporting and printing ----------------------------------------\n  \n  /showSnippets:<value>\n      0 (default) - Don't show source code snippets for Dafny messages.\n      1 - Show a source code snippet for each Dafny message.\n\n  /stats\n      Print interesting statistics about the Dafny files supplied.\n  \n  /printIncludes:<None|Immediate|Transitive>\n      None (default) - Print nothing.\n      Immediate - Print files included by files listed on the command line.\n      Transitive - Recurses on the files printed by Immediate.\n  \n      Immediate and Transitive will exit after printing.\n  \n  /view:<view1, view2>\n      Print the filtered views of a module after it is resolved (/rprint).\n      If print before the module is resolved (/dprint), then everything in\n      the module is printed. If no view is specified, then everything in\n      the module is printed.\n  /funcCallGraph\n      Print out the function call graph. Format is: func,mod=callee*\n  \n  /pmtrace\n      Print pattern-match compiler debug info.\n  \n  /printTooltips\n      Dump additional positional information (displayed as mouse-over\n      tooltips by the VS Code plugin) to stdout as 'Info' messages.\n  \n  /diagnosticsFormat:<text|json>\n      Choose how to report errors, warnings, and info messages.\n      text (default) - Use human readable output\n      json - Print each message as a JSON object, one per line.\n  \n  ---- Language feature selection --------------------------------------------\n  \n  /defaultFunctionOpacity:<value>\n      Change the default opacity of functions. \n      `transparent` (default) means functions are transparent, can be manually m\nade opaque and then revealed. \n      `autoRevealDependencies` makes all functions not explicitly labelled as op\naque to be opaque but reveals them automatically in scopes which do not have `{:\nautoRevealDependencies false}`. \n      `opaque` means functions are always opaque so the opaque keyword is not ne\neded, and functions must be revealed everywhere needed for a proof.\n\n  /readsClausesOnMethods:<value>\n      0 (default) - Reads clauses on methods are forbidden.\n      1 - Reads clauses on methods are permitted (with a default of 'reads *').\n\n  /standardLibraries:<value>\n      0 (default) - Do not allow Dafny code to depend on the standard libraries \nincluded with the Dafny distribution.\n      1 - Allow Dafny code to depend on the standard libraries included with the\n Dafny distribution.\n      See https://github.com/dafny-lang/dafny/blob/master/Source/DafnyStandardLi\nbraries/README.md for more information.\n      Not compatible with the /unicodeChar:0 option.\n\n  /noIncludes\n      Ignore include directives.\n  \n  /noExterns\n      Ignore extern attributes.\n  \n  /functionSyntax:<version>\n      The syntax for functions is changing from Dafny version 3 to version\n      4. This switch gives early access to the new syntax, and also\n      provides a mode to help with migration.\n  \n      3 - Compiled functions are written `function method` and\n          `predicate method`. Ghost functions are written `function` and\n          `predicate`.\n      4 (default) - Compiled functions are written `function` and `predicate`. G\nhost\n          functions are written `ghost function` and `ghost predicate`.\n      migration3to4 - Compiled functions are written `function method` and\n          `predicate method`. Ghost functions are written `ghost function`\n          and `ghost predicate`. To migrate from version 3 to version 4,\n          use this flag on your version 3 program. This will give flag all\n          occurrences of `function` and `predicate` as parsing errors.\n          These are ghost functions, so change those into the new syntax\n          `ghost function` and `ghost predicate`. Then, start using\n          /functionSyntax:4. This will flag all occurrences of `function\n          method` and `predicate method` as parsing errors. So, change\n          those to just `function` and `predicate`. Now, your program uses\n          version 4 syntax and has the exact same meaning as your previous\n          version 3 program.\n      experimentalDefaultGhost - Like migration3to4, but allow `function`\n          and `predicate` as alternatives to declaring ghost functions and\n          predicates, respectively.\n      experimentalDefaultCompiled - Like migration3to4, but allow\n          `function` and `predicate` as alternatives to declaring compiled\n          functions and predicates, respectively.\n      experimentalPredicateAlwaysGhost - Compiled functions are written\n          `function`. Ghost functions are written `ghost function`.\n          Predicates are always ghost and are written `predicate`.\n  \n  /quantifierSyntax:<version>\n      The syntax for quantification domains is changing from Dafny version\n      3 to version 4, more specifically where quantifier ranges (|\n      <Range>) are allowed. This switch gives early access to the new\n      syntax.\n  \n      3 - Ranges are only allowed after all quantified variables\n          are declared. (e.g. set x, y | 0 <= x < |s| && y in s[x] && 0 <=\n          y :: y)\n      4 (default) - Ranges are allowed after each quantified variable declaratio\nn.\n          (e.g. set x | 0 <= x < |s|, y <- s[x] | 0 <= y :: y)\n  \n      Note that quantifier variable domains (<- <Domain>) are available in\n      both syntax versions.\n  \n  /disableScopes\n      Treat all export sets as 'export reveal *'. i.e. don't hide function\n      bodies or type definitions during translation.\n  \n  ---- Warning selection -----------------------------------------------------\n  \n  /warnShadowing\n      Emits a warning if the name of a declared variable caused another\n      variable to be shadowed.\n  \n  /warnMissingConstructorParenthesis\n      Emits a warning when a constructor name in a case pattern is not\n      followed by parentheses.\n  \n  /deprecation:<n>\n      0 - Don't give any warnings about deprecated features.\n      1 (default) - Show warnings about deprecated features.\n  \n  /warningsAsErrors\n      Treat warnings as errors.\n  \n  ---- Verification options -------------------------------------------------\n  \n  /allowAxioms:<value>\n      Prevents a warning from being generated for axioms, such as assume stateme\nnts and functions or methods without a body, that don't have an {:axiom} attribu\nte.\n\n  /verificationLogger:<configuration>\n      Logs verification results using the given test result format. The currentl\ny supported formats are `trx`, `csv`, and `text`. These are: the XML-based forma\nt commonly used for test results for .NET languages, a custom CSV schema, and a \ntextual format meant for human consumption. You can provide configuration using \nthe same string format as when using the --logger option for dotnet test, such a\ns: --format \"trx;LogFileName=<...>\");\n      \n      The `trx` and `csv` formats automatically choose an output file name by de\nfault, and print the name of this file to the console. The `text` format prints \nits output to the console by default, but can send output to a file given the `L\nogFileName` option.\n      \n      The `text` format also includes a more detailed breakdown of what assertio\nns appear in each assertion batch. When combined with the isolate-assertions opt\nion, it will provide approximate time and resource use costs for each assertion,\n allowing identification of especially expensive assertions.\n\n  /dafnyVerify:<n>\n      0 - Stop after resolution and typechecking.\n      1 - Continue on to verification and compilation.\n  \n  /verifyAllModules\n      Verify modules that come from an include directive.\n  \n  /emitUncompilableCode\n      Allow compilers to emit uncompilable code that usually contain useful\n      information about what feature is missing, rather than\n      stopping on the first problem\n  \n  /separateModuleOutput\n      Output verification results for each module separately, rather than\n      aggregating them after they are all finished.\n  \n  /noCheating:<n>\n      0 (default) - Allow assume statements and free invariants.\n      1 - Treat all assumptions as asserts, and drop free.\n  \n  /induction:<n>\n      0 - Never do induction, not even when attributes request it.\n      1 - Only apply induction when attributes request it.\n      2 - Apply induction as requested (by attributes) and also for\n          heuristically chosen quantifiers.\n      3 - Apply induction as requested, and for heuristically chosen\n          quantifiers and lemmas.\n      4 (default) - Apply induction as requested, and for lemmas.\n  \n  /inductionHeuristic:<n>\n      0 - Least discriminating induction heuristic (that is, lean toward\n          applying induction more often).\n      1,2,3,4,5 - Levels in between, ordered as follows as far as how\n          discriminating they are: 0 < 1 < 2 < (3,4) < 5 < 6.\n      6 (default) - Most discriminating.\n  \n  /trackPrintEffects:<n>\n      0 (default) - Every compiled method, constructor, and iterator,\n         whether or not it bears a {:print} attribute, may have print\n         effects.\n      1 - A compiled method, constructor, or iterator is allowed to have\n         print effects only if it is marked with {:print}.\n  \n  /definiteAssignment:<n>\n      0 - Ignores definite-assignment rules. This mode is for testing\n          only--it is not sound.\n      1 (default) - Enforces definite-assignment rules for compiled\n          variables and fields whose types do not support\n          auto-initialization, and for ghost variables and fields whose\n          type is possibly empty.\n      2 - Enforces definite-assignment for all non-yield-parameter\n          variables and fields, regardless of their types.\n      3 - Like 2, but also performs checks in the compiler that no\n          nondeterministic statements are used; thus, a program that\n          passes at this level 3 is one that the language guarantees that\n          values seen during execution will be the same in every run of\n          the program.\n      4 - Like 1, but enforces definite assignment for all local variables\n          and out-parameters, regardless of their types. (Whether or not\n          fields and new arrays are subject to definite assignments depends\n          on their types.)\n  \n  /noAutoReq\n      Ignore autoReq attributes.\n  \n  /autoReqPrint:<file>\n      Print out requirements that were automatically generated by autoReq.\n  \n  /noNLarith\n      Reduce Z3's knowledge of non-linear arithmetic (*,/,%).\n  \n      Results in more manual work, but also produces more predictable\n      behavior. (This switch will perhaps be replaced by /arith in the\n      future. For now, it takes precedence of /arith.)\n  \n  /arith:<n>\n      (experimental) Adjust how Dafny interprets arithmetic operations.\n  \n      0 - Use Boogie/Z3 built-ins for all arithmetic operations.\n      1 (default) - Like 0, but introduce symbolic synonyms for *,/,%, and\n          allow these operators to be used in triggers.\n      2 - Like 1, but introduce symbolic synonyms also for +,-.\n      3 - Turn off non-linear arithmetic in the SMT solver. Still, use\n          Boogie/Z3 built-in symbols for all arithmetic operations.\n      4 - Like 3, but introduce symbolic synonyms for *,/,%, and allow\n          these operators to be used in triggers.\n      5 - Like 4, but introduce symbolic synonyms also for +,-.\n      6 - Like 5, and introduce axioms that distribute + over *.\n      7 - like 6, and introduce facts that associate literals arguments of *.\n      8 - Like 7, and introduce axiom for the connection between *,/,%.\n      9 - Like 8, and introduce axioms for sign of multiplication.\n      10 - Like 9, and introduce axioms for commutativity and\n          associativity of *.\n  \n  /autoTriggers:<n>\n      0 - Do not generate {:trigger} annotations for user-level\n          quantifiers.\n      1 (default) - Add a {:trigger} to each user-level quantifier.\n          Existing annotations are preserved.\n  \n  /rewriteFocalPredicates:<n>\n      0 - Don't rewrite predicates in the body of prefix lemmas.\n      1 (default) - In the body of prefix lemmas, rewrite any use of a\n          focal predicate P to P#[_k-1].\n  \n  /extractCounterexample\n      If verification fails, report a detailed counterexample for the\n      first failing assertion (experimental).\n  \n  ---- Compilation options ---------------------------------------------------\n  \n  /compileTarget:<language>\n      cs (default) - Compile to .NET via C#.\n      go - Compile to Go.\n      js - Compile to JavaScript.\n      java - Compile to Java.\n      py - Compile to Python.\n      cpp - Compile to C++.\n      dfy - Compile to Dafny.\n      \n      Note that the C++ backend has various limitations (see\n      Docs/Compilation/Cpp.md). This includes lack of support for\n      BigIntegers (aka int), most higher order functions, and advanced\n      features like traits or co-inductive types.\n\n  /library:<value>\n      The contents of this file and any files it includes can be referenced from\n other files as if they were included. \n      However, these contents are skipped during code generation and verificatio\nn.\n      This option is useful in a diamond dependency situation, \n      to prevent code from the bottom dependency from being generated more than \nonce.\n      The value may be a comma-separated list of files and folders.\n\n  /optimizeErasableDatatypeWrapper:<value>\n      0 - Include all non-ghost datatype constructors in the compiled code\n      1 (default) - In the compiled target code, transform any non-extern\n          datatype with a single non-ghost constructor that has a single\n          non-ghost parameter into just that parameter. For example, the type\n              datatype Record = Record(x: int)\n          is transformed into just 'int' in the target code.\n\n  /out:<file>\n      Specify the filename and location for the generated target language files.\n\n  /runAllTests:<n>\n      0 (default) - Annotates compiled methods with the {:test}\n              attribute such that they can be tested using a testing framework\n              in the target language (e.g. xUnit for C#).\n          1 - Emits a main method in the target language that will execute\n              every method in the program with the {:test} attribute. Cannot\n              be used if the program already contains a main method. Note that\n              /compile:3 or 4 must be provided as well to actually execute\n              this main method!\n\n  /compile:<n>\n      0 - Do not compile Dafny program.\n      1 (default) - Upon successful verification of the Dafny program,\n          compile it to the designated target language. (/noVerify\n          automatically counts as a failed verification.)\n      2 - Always attempt to compile Dafny program to the target language,\n          regardless of verification outcome.\n      3 - If there is a Main method and there are no verification errors\n          and /noVerify is not used, compiles program in memory (i.e.,\n          does not write an output file) and runs it.\n      4 - Like (3), but attempts to compile and run regardless of\n          verification outcome.\n  /Main:<name>\n      Specify the (fully-qualified) name of the method to use as the executable \nentry point.\n      Default is the method with the {:main} attribute, or else the method named\n 'Main'.\n      A Main method can have at most one (non-ghost) argument of type `seq<strin\ng>`\n  --args <arg1> <arg2> ...\n      When running a Dafny file through /compile:3 or /compile:4, '--args' provi\ndes\n      all arguments after it to the Main function, at index starting at 1.\n      Index 0 is used to store the executable's name if it exists.\n  \n  /compileVerbose:<n>\n      0 - Don't print status of compilation to the console.\n      1 (default) - Print information such as files being written by the\n          compiler to the console.\n  \n  /spillTargetCode:<n>\n      Explicitly writes the code in the target language to one or more files.\n      This is not necessary to run a Dafny program, but may be of interest when\n      building multi-language programs or for debugging.\n  \n      0 (default) - Don't make any extra effort to write the textual\n          target program (but still compile it, if /compile indicates to\n          do so).\n      1 - Write the textual target program, if it is being compiled.\n      2 - Write the textual target program, provided it passes the\n          verifier (and /noVerify is NOT used), regardless of /compile\n          setting.\n      3 - Write the textual target program, regardless of verification\n          outcome and /compile setting.\n      Note, some compiler targets may (always or in some situations) write\n      out the textual target program as part of compilation, in which case\n      /spillTargetCode:0 behaves the same way as /spillTargetCode:1.\n  /coverage:<file>\n      The compiler emits branch-coverage calls and outputs into <file> a\n      legend that gives a description of each source-location identifier\n      used in the branch-coverage calls. (Use - as <file> to print to the\n      console.)\n  \n  /optimize\n      Produce optimized C# code by passing the /optimize flag to csc.exe.\n  \n  /optimizeResolution:<n>\n      0 - Resolve and translate all methods.\n      1 - Translate methods only in the call graph of current verification\n          target.\n      2 (default) - As in 1, but only resolve method bodies in\n          non-included Dafny sources.\n  /useRuntimeLib\n      Refer to a pre-built DafnyRuntime.dll in the compiled assembly\n      rather than including DafnyRuntime.cs verbatim.\n  \n  /testContracts:<Externs|TestedExterns>\n      Enable run-time testing of the compilable portions of certain function\n      or method contracts, at their call sites. The current implementation\n      focuses on {:extern} code but may support other code in the future.\n  \n      Externs - Check contracts on every call to a function or method marked\n          with the {:extern} attribute, regardless of where it occurs.\n      TestedExterns - Check contracts on every call to a function or method\n          marked with the {:extern} attribute when it occurs in a method\n          with the {:test} attribute, and warn if no corresponding test\n          exists for a given external declaration.\n  \n  ----------------------------------------------------------------------------\n  \n  Dafny generally accepts Boogie options and passes these on to Boogie.\n  However, some Boogie options, like /loopUnroll, may not be sound for\n  Dafny or may not have the same meaning for a Dafny program as it would\n  for a similar Boogie program.\n  \n  ---- Boogie options --------------------------------------------------------\n\n  Multiple .bpl files supplied on the command line are concatenated into one\n  Boogie program.\n\n  /lib:<name>   Include definitions in library <name>. The file <name>.bpl\n                must be an included resource in Core.dll. Currently, the\n                following libraries are supported---base, node.\n  /proc:<p>     Only check procedures matched by pattern <p>. This option\n                may be specified multiple times to match multiple patterns.\n                The pattern <p> matches the whole procedure name and may\n                contain * wildcards which match any character zero or more\n                times.\n  /noProc:<p>   Do not check procedures matched by pattern <p>. Exclusions\n                with /noProc are applied after inclusions with /proc.\n  /noResolve    parse only\n  /noTypecheck  parse and resolve only\n  /print:<file>\n                print Boogie program after parsing it\n                (use - as <file> to print to console)\n  /pretty:<n>   0 - print each Boogie statement on one line (faster).\n                1 (default) - pretty-print with some line breaks.\n  /printWithUniqueIds\n                print augmented information that uniquely identifies variables\n  /printUnstructured\n                with /print option, desugars all structured statements\n  /printPassive\n                with /print option, prints passive version of program\n  /printDesugared\n                with /print option, desugars calls\n  /printLambdaLifting\n                with /print option, desugars lambda lifting\n  /freeVarLambdaLifting\n                Boogie's lambda lifting transforms the bodies of lambda\n                expressions into templates with holes. By default, holes\n                are maximally large subexpressions that do not contain\n                bound variables. This option performs a form of lambda\n                lifting in which holes are the lambda's free variables.\n  /overlookTypeErrors\n                skip any implementation with resolution or type checking errors\n  /loopUnroll:<n>\n                unroll loops, following up to n back edges (and then some)\n                default is -1, which means loops are not unrolled\n  /extractLoops\n                convert all irreducible loops to reducible forms by node splitti\nng\n                and extract all loops into recursive procedures\n  /soundLoopUnrolling\n                sound loop unrolling\n  /kInductionDepth:<k>\n                uses combined-case k-induction to soundly eliminate loops,\n                by unwinding proportional to the supplied parameter\n  /inferModifies\n                automatically infer modifies clauses\n  /printModel:<n>\n                0 (default) - do not print Z3's error model\n                1 - print Z3's error model\n  /printModelToFile:<file>\n                print model to <file> instead of console\n  /mv:<file>    Specify file to save the model with captured states\n                (see documentation for :captureState attribute)\n  /enhancedErrorMessages:<n>\n                0 (default) - no enhanced error messages\n                1 - Z3 error model enhanced error messages\n  /printCFG:<prefix> : print control flow graph of each implementation in\n                       Graphviz format to files named:\n                         <prefix>.<procedure name>.dot\n  /useBaseNameForFileName : When parsing use basename of file for tokens instead\n                            of the path supplied on the command line\n  /emitDebugInformation:<n>\n                0 - do not emit debug information\n                1 (default) - emit the debug information :qid, :skolemid and set\n-info :boogie-vc-id\n  /normalizeNames:<n>\n                0 (default) - Keep Boogie program names when generating SMT comm\nands\n                1 - Normalize Boogie program names when generating SMT commands.\n \n                  This keeps SMT solver input, and thus output, \n                  constant when renaming declarations in the input program.\n  /normalizeDeclarationOrder:<n>\n                0 - Keep order of top-level declarations when generating SMT com\nmands.\n                1 (default) - Normalize order of top-level declarations when gen\nerating SMT commands.\n                  This keeps SMT solver input, and thus output, \n                  constant when reordering declarations in the input program.\n\n  ---- Inference options -----------------------------------------------------\n\n  /infer:<flags>\n                use abstract interpretation to infer invariants\n                <flags> must specify exactly one of the following domains:\n                   t = trivial bottom/top lattice\n                   j = stronger intervals\n                together with any of the following options:\n                   s = debug statistics\n                0..9 = number of iterations before applying a widen (default=0)\n  /checkInfer   instrument inferred invariants as asserts to be checked by\n                theorem prover\n  /contractInfer\n                perform procedure contract inference\n  /instrumentInfer\n                h - instrument inferred invariants only at beginning of\n                    loop headers (default)\n                e - instrument inferred invariants at beginning and end\n                    of every block (this mode is intended for use in\n                    debugging of abstract domains)\n  /printInstrumented\n                print Boogie program after it has been instrumented with\n                invariants\n\n  ---- Debugging and general tracing options ---------------------------------\n\n  /silent       print nothing at all\n  /quiet        print nothing but warnings and errors\n  /trace        blurt out various debug trace information\n  /traceTimes   output timing information at certain points in the pipeline\n  /tracePOs     output information about the number of proof obligations\n                (also included in the /trace output)\n  /forceBplErrors\n                show boogie errors even if {:msg ...} attribute is present\n  /break        launch and break into debugger\n\n  ---- Civl options ----------------------------------------------------------\n\n  /trustMoverTypes\n                do not verify mover type annotations on atomic action declaratio\nns\n  /trustNoninterference\n                do not perform noninterference checks\n  /trustRefinement\n                do not perform refinement checks\n  /trustLayersUpto:<n>\n                do not verify layers <n> and below\n  /trustLayersDownto:<n>\n                do not verify layers <n> and above\n  /trustSequentialization\n                do not perform sequentialization checks\n  /civlDesugaredFile:<file>\n                print plain Boogie program to <file>\n\n  ---- Verification-condition generation options -----------------------------\n\n  /liveVariableAnalysis:<c>\n                0 = do not perform live variable analysis\n                1 = perform live variable analysis (default)\n                2 = perform interprocedural live variable analysis\n  /noVerify     skip VC generation and invocation of the theorem prover\n  /verifySnapshots:<n>\n                verify several program snapshots (named <filename>.v0.bpl\n                to <filename>.vN.bpl) using verification result caching:\n                0 - do not use any verification result caching (default)\n                1 - use the basic verification result caching\n                2 - use the more advanced verification result caching\n                3 - use the more advanced caching and report errors according\n                    to the new source locations for errors and their\n                    related locations (but not /errorTrace and CaptureState\n                    locations)\n  /traceCaching:<n>\n                0 (default) - none\n                1 - for testing\n                2 - for benchmarking\n                3 - for testing, benchmarking, and debugging\n  /verifySeparately\n                verify each input program separately\n  /removeEmptyBlocks:<c>\n                0 - do not remove empty blocks during VC generation\n                1 - remove empty blocks (default)\n  /coalesceBlocks:<c>\n                0 = do not coalesce blocks\n                1 = coalesce blocks (default)\n  /traceverify  print debug output during verification condition generation\n  /subsumption:<c>\n                apply subsumption to asserted conditions:\n                0 - never, 1 - not for quantifiers, 2 (default) - always\n  /alwaysAssumeFreeLoopInvariants\n                usually, a free loop invariant (or assume\n                statement in that position) is ignored in checking contexts\n                (like other free things); this option includes these free\n                loop invariants as assumes in both contexts\n  /inline:<i>   use inlining strategy <i> for procedures with the :inline\n                attribute, see /attrHelp for details:\n                  none\n                  assume (default)\n                  assert\n                  spec\n  /printInlined\n                print the implementation after inlining calls to\n                procedures with the :inline attribute (works with /inline)\n  /recursionBound:<n>\n                Set the recursion bound for stratified inlining to\n                be n (default 500)\n  /smoke        Soundness Smoke Test: try to stick assert false; in some\n                places in the BPL and see if we can still prove it\n  /smokeTimeout:<n>\n                Timeout, in seconds, for a single theorem prover\n                invocation during smoke test, defaults to 10.\n  /typeEncoding:<t>\n                Encoding of types when generating VC of a polymorphic program:\n                   m = monomorphic (default)\n                   p = predicates\n                   a = arguments\n                Boogie automatically detects monomorphic programs and enables\n                monomorphic VC generation, thereby overriding the above option.\n                If the latter two options are used, then arrays are handled via \naxioms.\n  /useArrayAxioms\n                If monomorphic type encoding is used, arrays are handled by defa\nult with\n                the SMT theory of arrays. This option allows the use of axioms i\nnstead.\n  /reflectAdd   In the VC, generate an auxiliary symbol, elsewhere defined\n                to be +, instead of +.\n  /prune:<n>\n                0 - Turn off pruning.\n                1 - Turn on pruning (default). Pruning will remove any top-level\n                Boogie declarations that are not accessible by the implementatio\nn\n                that is about to be verified. Without pruning, due to the unstab\nle\n                nature of SMT solvers, a change to any part of a Boogie program\n                has the potential to affect the verification of any other part o\nf\n                the program.\n\n                Only use this if your program contains uses clauses\n                where required, otherwise pruning will break your program.\n                More information can be found here: https://github.com/boogie-or\ng/boogie/blob/afe8eb0ffbb48d593de1ae3bf89712246444daa8/Source/ExecutionEngine/Co\nmmandLineOptions.cs#L160\n  /printPruned:<file>\n                After pruning, print the Boogie program to the specified file.\n  /relaxFocus   Process foci in a bottom-up fashion. This way only generates\n                a linear number of splits. The default way (top-down) is more\n                aggressive and it may create an exponential number of splits.\n  /randomSeed:<s>\n                Supply the random seed for /randomizeVcIterations option.\n  /randomizeVcIterations:<n>\n                Turn on randomization of the input that Boogie passes to the\n                SMT solver and turn on randomization in the SMT solver itself.\n                Attempt to randomize and prove each VC n times using the random\n                seed s provided by the option /randomSeed:<s>. If /randomSeed op\ntion\n                is not provided, s is chosen to be zero.\n\n                Certain Boogie inputs are unstable in the sense that changes to \n                the input that preserve its meaning may cause the output to chan\nge.\n                This option simulates meaning-preserving changes to the input\n                without requiring the user to actually make those changes.\n                This option is implemented by renaming variables and reordering\n                declarations in the input, and by setting solver options that ha\nve\n                similar effects.\n  /trackVerificationCoverage\n                Track and report which program elements labeled with an\n                `{:id ...}` attribute were necessary to complete verification.\n                Assumptions, assertions, requires clauses, ensures clauses,\n                assignments, and calls can be labeled for inclusion in this\n                report. This generalizes and replaces the previous\n                (undocumented) `/printNecessaryAssertions` option.\n  /warnVacuousProofs\n                Automatically add missing `{:id ...}` attributes to assumptions,\n                assertions, requires clauses, ensures clauses, and calls; enable\n the\n                `/trackVerificationCoverage` option; and warn when proof goals a\nre\n                not covered by a proof.\n  /keepQuantifier\n                If pool-based quantifier instantiation creates instances of a qu\nantifier\n                then keep the quantifier along with the instances. By default, t\nhe quantifier\n                is dropped if any instances are created.\n\n  ---- Verification-condition splitting --------------------------------------\n\n  /vcsMaxCost:<f>\n                VC will not be split unless the cost of a VC exceeds this\n                number, defaults to 2000.0. This does NOT apply in the\n                keep-going mode after first round of splitting.\n  /vcsMaxSplits:<n>\n                Maximal number of VC generated per method. In keep\n                going mode only applies to the first round.\n                Defaults to 1.\n  /vcsMaxKeepGoingSplits:<n>\n                If set to more than 1, activates the keep\n                going mode, where after the first round of splitting,\n                VCs that timed out are split into <n> pieces and retried\n                until we succeed proving them, or there is only one\n                assertion on a single path and it timeouts (in which\n                case error is reported for that assertion).\n                Defaults to 1.\n  /vcsKeepGoingTimeout:<n>\n                Timeout in seconds for a single theorem prover\n                invocation in keep going mode, except for the final\n                single-assertion case. Defaults to 1s.\n  /vcsFinalAssertTimeout:<n>\n                Timeout in seconds for the single last\n                assertion in the keep going mode. Defaults to 30s.\n  /vcsPathJoinMult:<f>\n                If more than one path join at a block, by how much\n                multiply the number of paths in that block, to accomodate\n                for the fact that the prover will learn something on one\n                paths, before proceeding to another. Defaults to 0.8.\n  /vcsPathCostMult:<f1>\n  /vcsAssumeMult:<f2>\n                The cost of a block is\n                    (<assert-cost> + <f2>*<assume-cost>) *\n                    (1.0 + <f1>*<entering-paths>)\n                <f1> defaults to 1.0, <f2> defaults to 0.01.\n                The cost of a single assertion or assumption is\n                currently always 1.0.\n  /vcsPathSplitMult:<f>\n                If the best path split of a VC of cost A is into\n                VCs of cost B and C, then the split is applied if\n                A >= <f>*(B+C), otherwise assertion splitting will be\n                applied. Defaults to 0.5 (always do path splitting if\n                possible), set to more to do less path splitting\n                and more assertion splitting.\n  /vcsSplitOnEveryAssert\n                Splits every VC so that each assertion is isolated\n                into its own VC. May result in VCs without any assertions.\n  /vcsDumpSplits\n                For split #n dump split.n.dot and split.n.bpl.\n                Warning: Affects error reporting.\n  /vcsCores:<n>\n                Try to verify <n> VCs at once. Defaults to 1.\n  /vcsLoad:<f>  Sets vcsCores to the machine's ProcessorCount * f,\n                rounded to the nearest integer (where 0.0 <= f <= 3.0),\n                but never to less than 1.\n\n  ---- Prover options --------------------------------------------------------\n\n  /errorLimit:<num>\n                Limit the number of errors produced for each procedure\n                (default is 5, some provers may support only 1).\n                Set num to 0 to find as many assertion failures as possible.\n  /timeLimit:<num>\n                Limit the number of seconds spent trying to verify\n                each procedure\n  /rlimit:<num>\n                Limit the Z3 resource spent trying to verify each procedure.\n  /errorTrace:<n>\n                0 - no Trace labels in the error output,\n                1 (default) - include useful Trace labels in error output,\n                2 - include all Trace labels in the error output\n  /vcBrackets:<b>\n                bracket odd-charactered identifier names with |'s.  <b> is:\n                   0 - no (default),\n                   1 - yes\n  /proverDll:<tp>\n                use theorem prover <tp>, where <tp> is either the name of\n                a DLL containing the prover interface located in the\n                Boogie directory, or a full path to a DLL containing such\n                an interface. The default interface shipped is:\n                    SMTLib (uses the SMTLib2 format and calls an SMT solver)\n  /proverOpt:KEY[=VALUE]\n                Provide a prover-specific option (short form /p).\n  /proverHelp   Print prover-specific options supported by /proverOpt.\n  /proverLog:<file>\n                Log input for the theorem prover.  Like filenames\n                supplied as arguments to other options, <file> can use the\n                following macros:\n                    @TIME@    expands to the current time\n                    @PREFIX@  expands to the concatenation of strings given\n                              by /logPrefix options\n                    @FILE@    expands to the last filename specified on the\n                              command line\n                In addition, /proverLog can also use the macro '@PROC@',\n                which causes there to be one prover log file per\n                verification condition, and the macro then expands to the\n                name of the procedure that the verification condition is for.\n  /logPrefix:<str>\n                Defines the expansion of the macro '@PREFIX@', which can\n                be used in various filenames specified by other options.\n  /proverLogAppend\n                Append (not overwrite) the specified prover log file\n  /proverWarnings\n                0 (default) - don't print, 1 - print to stdout,\n                2 - print to stderr\n  /restartProver\n                Restart the prover after each query\n`\n\n## 17. Dafny Grammar\n\nThe Dafny grammar has a traditional structure: a scanner tokenizes the textual\ninput into a sequence of tokens; the parser consumes the tokens to produce an\nAST. The AST is then passed on for name and type resolution and further\nprocessing.\n\nDafny uses the Coco/R lexer and parser generator for its lexer and parser\n([http://www.ssw.uni-linz.ac.at/Research/Projects/Coco][1347])[@Linz:Coco]. See\nthe [Coco/R Reference manual][1348] for details. The Dafny input file to Coco/R\nis the `Dafny.atg` file in the source tree.\n\nThe grammar is an *attributed extended BNF* grammar. The *attributed* adjective\nindicates that the BNF productions are parameterized by boolean parameters that\ncontrol variations of the production rules, such as whether a particular\nalternative is permitted or not. Using such attributes allows combining\nnon-terminals with quite similar production rules, making a simpler, more\ncompact and more readable grammer.\n\nThe grammar rules presented here replicate those in the source code, but omit\nsemantic actions, error recovery markers, and conflict resolution syntax. Some\nuses of the attribute parameters are described informally.\n\nThe names of character sets and tokens start with a lower case letter; the names\nof grammar non-terminals start with an upper-case letter.\n\n### 17.1. Dafny Syntax\n\nThis section gives the definitions of Dafny tokens.\n\n#### 17.1.1. Classes of characters\n\nThese definitions define some names as representing subsets of the set of\ncharacters. Here,\n\n* double quotes enclose the set of characters constituting the class,\n* single quotes enclose a single character (perhaps an escaped representation\n  using `\\`),\n* the binary `+` indicates set union,\n* binary `-` indicates set difference, and\n* `ANY` indicates the set of all (unicode) characters.\n`letter = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndigit = \"0123456789\"\nposDigit = \"123456789\"\nposDigitFrom2 = \"23456789\"\n\nhexdigit = \"0123456789ABCDEFabcdef\"\n\nspecial = \"'_?\"\n\ncr        = '\\r'\n\nlf        = '\\n'\n\ntab       = '\\t'\n\nspace     = ' '\n\nnondigitIdChar = letter + special\n\nidchar = nondigitIdChar + digit\n\nnonidchar = ANY - idchar\n\ncharChar = ANY - '\\'' - '\\\\' - cr - lf\n\nstringChar = ANY - '\"' - '\\\\' - cr - lf\n\nverbatimStringChar = ANY - '\"'\n`\n\nA `nonidchar` is any character except those that can be used in an identifier.\nHere the scanner generator will interpret `ANY` as any unicode character.\nHowever, `nonidchar` is used only to mark the end of the `!in` token; in this\ncontext any character other than [whitespace or printable ASCII][1349] will\ntrigger a subsequent scanning or parsing error.\n\n#### 17.1.2. Definitions of tokens\n\nThese definitions use\n\n* double-quotes to indicate a verbatim string (with no escaping of characters)\n* `'\"'` to indicate a literal double-quote character\n* vertical bar to indicate alternatives\n* square brackets to indicate an optional part\n* curly braces to indicate 0-or-more repetitions\n* parentheses to indicate grouping\n* a `-` sign to indicate set difference: any character sequence matched by the\n  left operand except character sequences matched by the right operand\n* a sequence of any of the above to indicate concatenation without whitespace\n`reservedword =\n    \"abstract\" | \"allocated\" | \"as\" | \"assert\" | \"assume\" |\n    \"bool\" | \"break\" | \"by\" |\n    \"calc\" | \"case\" | \"char\" | \"class\" | \"codatatype\" |\n    \"const\" | \"constructor\" | \"continue\" |\n    \"datatype\" | \"decreases\" |\n    \"else\" | \"ensures\" | \"exists\" | \"expect\" | \"export\" | \"extends\" |\n    \"false\" | \"for\" | \"forall\" | \"fp32\" | \"fp64\" | \"fresh\" | \"function\" | \"ghost\n\" |\n    \"if\" | \"imap\" | \"import\" | \"in\" | \"include\" |\n    \"int\" | \"invariant\" | \"is\" | \"iset\" | \"iterator\" |\n    \"label\" | \"lemma\" | \"map\" | \"match\" | \"method\" |\n    \"modifies\" | \"modify\" | \"module\" | \"multiset\" |\n    \"nameonly\" | \"nat\" | \"new\" | \"newtype\" | \"null\" |\n    \"object\" | \"object?\" | \"old\" | \"opaque\" | \"opened\" | \"ORDINAL\"\n    \"predicate\" | \"print\" | \"provides\" |\n    \"reads\" | \"real\" | \"refines\" | \"requires\" | \"return\" |\n    \"returns\" | \"reveal\" | \"reveals\" |\n    \"seq\" | \"set\" | \"static\" | \"string\" |\n    \"then\" | \"this\" | \"trait\" | \"true\" | \"twostate\" | \"type\" |\n    \"unchanged\" | \"var\" | \"while\" | \"witness\" |\n    \"yield\" | \"yields\" |\n    arrayToken | bvToken\n\narrayToken = \"array\" [ posDigitFrom2 | posDigit digit { digit }][\"?\"]\n\nbvToken = \"bv\" ( 0 | posDigit { digit } )\n\nident = nondigitIdChar { idchar } - charToken - reservedword\n\ndigits = digit {[\"_\"] digit}\n\nhexdigits = \"0x\" hexdigit {[\"_\"] hexdigit}\n\nrealnumber = digit {[\"_\"] digit}\n             ( '.' digit {[\"_\"] digit} ['e' ['-'] digit {[\"_\"] digit}]\n             | 'e' ['-'] digit {[\"_\"] digit}\n             )\n\nescapedChar =\n    ( \"\\'\" | \"\\\"\" | \"\\\\\" | \"\\0\" | \"\\n\" | \"\\r\" | \"\\t\"\n      | \"\\u\" hexdigit hexdigit hexdigit hexdigit\n      | \"\\U{\" hexdigit { hexdigit } \"}\"\n    )\n\ncharToken = \"'\" ( charChar | escapedChar ) \"'\"\n\nstringToken =\n    '\"' { stringChar | escapedChar }  '\"'\n  | \"@\" '\"' { verbatimStringChar | '\"' '\"' } '\"'\n\nellipsis = \"...\"\n`\n\nThere are a few words that have a special meaning in certain contexts, but are\nnot reserved words and can be used as identifiers outside of those contexts:\n\n* `least` and `greatest` are recognized as adjectives to the keyword `predicate`\n  (cf. [Section 12.4][1350]).\n* `older` is a modifier for parameters of non-extreme predicates (cf. [Section\n  6.4.6][1351]).\n\nThe `\\uXXXX` form of an `escapedChar` is only used when the option\n`--unicode-char=false` is set (which is the default for Dafny 3.x); the\n`\\U{XXXXXX}` form of an `escapedChar` is only used when the option\n`--unicode-char=true` is set (which is the default for Dafny 4.x).\n\n### 17.2. Dafny Grammar productions\n\nThe grammar productions are presented in the following Extended BNF syntax:\n\n* identifiers starting with a lower case letter denote terminal symbols (tokens)\n  as defined in the [previous subsection][1352]\n* identifiers starting with an upper case letter denote nonterminal symbols\n* strings (a sequence of characters enclosed by double quote characters) denote\n  the sequence of enclosed characters\n* `=` separates the sides of a production, e.g. `A = a b c`\n* `|` separates alternatives, e.g. `a b | c | d e` means `a b` or `c` or `d e`\n* `(` `)` groups alternatives, e.g. `(a | b) c` means `a c` or `b c`\n* `[ ]` option, e.g. `[a] b` means `a b` or `b`\n* `{ }` iteration (0 or more times), e.g. `{a} b` means `b` or `a b` or `a a b`\n  or …\n* We allow `|` inside `[ ]` and `{ }`. So `[a | b]` is short for `[(a | b)]` and\n  `{a | b}` is short for `{(a | b)}`.\n* `//` in a line introduces a comment that extends to the end-of-the line, but\n  does not terminate the production\n* The first production defines the name of the grammar, in this case `Dafny`.\n\nIn addition to the Coco rules, for the sake of readability we have adopted these\nadditional conventions.\n\n* We allow `-` to be used. `a - b` means it matches if it matches `a` but not\n  `b`.\n* We omit the `.` that marks the end of a CoCo/R production.\n* we omit deprecated features.\n\nTo aid in explaining the grammar we have added some additional productions that\nare not present in the original grammar. We name these with a trailing\nunderscore. Inlining these where they are referenced will reconstruct the\noriginal grammar.\n\n#### 17.2.1. Programs\n\n([discussion][1353])\n\n`Dafny = { IncludeDirective_ } { TopDecl(isTopLevel:true, isAbstract: false) } E\nOF\n`\n17.2.1.1. Include directives\n\n([discussion][1354])\n\n`IncludeDirective_ = \"include\" stringToken\n`\n17.2.1.2. Top-level declarations\n\n([discussion][1355])\n\n`TopDecl(isTopLevel, isAbstract) =\n  { DeclModifier }\n  ( SubModuleDecl(isTopLevel)\n  | ClassDecl\n  | DatatypeDecl\n  | NewtypeDecl\n  | SynonymTypeDecl  // includes abstract types\n  | IteratorDecl\n  | TraitDecl\n  | ClassMemberDecl(allowConstructors: false, isValueType: true, moduleLevelDecl\n: true)\n  )\n`\n17.2.1.3. Declaration modifiers\n\n([discussion][1356])\n\n`DeclModifier = ( \"abstract\" | \"ghost\" | \"static\" | \"opaque\" )\n`\n\n#### 17.2.2. Modules\n\n`SubModuleDecl(isTopLevel) = ( ModuleDefinition | ModuleImport | ModuleExport )\n`\n\nModule export declarations are not permitted if `isTopLevel` is true.\n\n17.2.2.1. Module Definitions\n\n([discussion][1357])\n\n`ModuleDefinition(isTopLevel) = \n  \"module\" { Attribute } ModuleQualifiedName\n  [ \"refines\" ModuleQualifiedName ]\n  \"{\" { TopDecl(isTopLevel:false, isAbstract) } \"}\"\n`\n\nThe `isAbstract` argument is true if the preceding `DeclModifiers` include\n“abstract”.\n\n17.2.2.2. Module Imports\n\n([discussion][1358])\n\n`ModuleImport =\n  \"import\"\n  [ \"opened\" ]\n  ( QualifiedModuleExport\n  | ModuleName \"=\" QualifiedModuleExport\n  | ModuleName \":\" QualifiedModuleExport\n  )\n\nQualifiedModuleExport =\n    ModuleQualifiedName [ \"`\" ModuleExportSuffix ]\n\nModuleExportSuffix =\n  ( ExportId\n  | \"{\" ExportId { \",\" ExportId } \"}\"\n  )\n`\n17.2.2.3. Module Export Definitions\n\n([discussion][1359])\n\n`ModuleExport =\n  \"export\"\n  [ ExportId ]\n  [ \"...\" ]\n  {\n    \"extends\"  ExportId { \",\" ExportId }\n  | \"provides\" ( ExportSignature { \",\" ExportSignature } | \"*\" )\n  | \"reveals\"  ( ExportSignature { \",\" ExportSignature } | \"*\" )\n  }\n\nExportSignature = TypeNameOrCtorSuffix [ \".\" TypeNameOrCtorSuffix ]\n`\n\n#### 17.2.3. Types\n\n([discussion][1360])\n\n`Type = DomainType_ | ArrowType_\n\nDomainType_ =\n  ( BoolType_ | CharType_ | IntType_ | RealType_ | FloatType_\n  | OrdinalType_ | BitVectorType_ | ObjectType_\n  | FiniteSetType_ | InfiniteSetType_\n  | MultisetType_\n  | FiniteMapType_ | InfiniteMapType_\n  | SequenceType_\n  | NatType_\n  | StringType_\n  | ArrayType_\n  | TupleType\n  | NamedType\n  )\n\nNamedType = NameSegmentForTypeName { \".\" NameSegmentForTypeName }\n\nNameSegmentForTypeName = Ident [ GenericInstantiation ]\n`\n17.2.3.1. Basic types\n\n([discussion][1361])\n\n`BoolType_ = \"bool\"\nIntType_ = \"int\"\nRealType_ = \"real\"\nFloatType_ = \"fp32\" | \"fp64\"\nBitVectorType_ = bvToken\nOrdinalType_ = \"ORDINAL\"\nCharType_ = \"char\"\n`\n17.2.3.2. Generic instantiation\n\n([discussion][1362])\n\n`GenericInstantiation = \"<\" Type { \",\" Type } \">\"\n`\n17.2.3.3. Type parameter\n\n([discussion][1363])\n\n`GenericParameters(allowVariance) =\n  \"<\" [ Variance ] TypeVariableName { TypeParameterCharacteristics }\n  { \",\" [ Variance ] TypeVariableName { TypeParameterCharacteristics } }\n  \">\"\n\n// The optional Variance indicator is permitted only if allowVariance is true\nVariance = ( \"*\" | \"+\" | \"!\" | \"-\" )\n\nTypeParameterCharacteristics = \"(\" TPCharOption { \",\" TPCharOption } \")\"\n\nTPCharOption = ( \"==\" | \"0\" | \"00\" | \"!\" \"new\" )\n`\n17.2.3.4. Collection types\n\n([discussion][1364])\n\n`FiniteSetType_ = \"set\" [ GenericInstantiation ]\n\nInfiniteSetType_ = \"iset\" [ GenericInstantiation ]\n\nMultisetType_ = \"multiset\" [ GenericInstantiation ]\n\nSequenceType_ = \"seq\" [ GenericInstantiation ]\n\nStringType_ = \"string\"\n\nFiniteMapType_ = \"map\" [ GenericInstantiation ]\n\nInfiniteMapType_ = \"imap\" [ GenericInstantiation ]\n`\n17.2.3.5. Type definitions\n\n([discussion][1365])\n\n`SynonymTypeDecl =\n  SynonymTypeDecl_ | OpaqueTypeDecl_ | SubsetTypeDecl_\n\nSynonymTypeName = NoUSIdent\n\nSynonymTypeDecl_ =\n  \"type\" { Attribute } SynonymTypeName\n   { TypeParameterCharacteristics }\n   [ GenericParameters ]\n   \"=\" Type\n\nOpaqueTypeDecl_ =\n  \"type\" { Attribute } SynonymTypeName\n   { TypeParameterCharacteristics }\n   [ GenericParameters ]\n   [ TypeMembers ]\n\nTypeMembers =\n  \"{\"\n  {\n    { DeclModifier }\n    ClassMemberDecl(allowConstructors: false,\n                    isValueType: true,\n                    moduleLevelDecl: false,\n                    isWithinAbstractModule: module.IsAbstract)\n  }\n  \"}\"\n\nSubsetTypeDecl_ =\n  \"type\"\n  { Attribute }\n  SynonymTypeName [ GenericParameters ]\n  \"=\"\n  LocalIdentTypeOptional\n  \"|\"\n  Expression(allowLemma: false, allowLambda: true)\n  [ \"ghost\" \"witness\" Expression(allowLemma: false, allowLambda: true)\n  | \"witness\" Expression((allowLemma: false, allowLambda: true)\n  | \"witness\" \"*\"\n  ]\n\nNatType_ = \"nat\"\n\nNewtypeDecl = \"newtype\" { Attribute } NewtypeName \"=\"\n  [ ellipsis ]\n  ( LocalIdentTypeOptional\n    \"|\"\n    Expression(allowLemma: false, allowLambda: true)\n    [ \"ghost\" \"witness\" Expression(allowLemma: false, allowLambda: true)\n    | \"witness\" Expression((allowLemma: false, allowLambda: true)\n    | \"witness\" \"*\"\n    ]\n  | Type\n  )\n  [ TypeMembers ]\n`\n17.2.3.6. Class type\n\n([discussion][1366])\n\n`ClassDecl = \"class\" { Attribute } ClassName [ GenericParameters ]\n  [\"extends\" Type {\",\" Type} | ellipsis ]\n  \"{\" { { DeclModifier }\n        ClassMemberDecl(modifiers,\n                        allowConstructors: true,\n                        isValueType: false,\n                        moduleLevelDecl: false) \n      }\n  \"}\"\n\nClassMemberDecl(modifiers, allowConstructors, isValueType, moduleLevelDecl) =\n  ( FieldDecl(isValueType) // allowed iff moduleLevelDecl is false\n  | ConstantFieldDecl(moduleLevelDecl)\n  | FunctionDecl(isWithinAbstractModule)\n  | MethodDecl(modifiers, allowConstructors)\n  )\n`\n17.2.3.7. Trait types\n\n([discussion][1367])\n\n`TraitDecl =\n  \"trait\" { Attribute } ClassName [ GenericParameters ]\n  [ \"extends\" Type { \",\" Type } | ellipsis ]\n  \"{\"\n   { { DeclModifier } ClassMemberDecl(allowConstructors: true,\n                                      isValueType: false,\n                                      moduleLevelDecl: false,\n                                      isWithinAbstractModule: false) }\n  \"}\"\n`\n17.2.3.8. Object type\n\n([discussion][1368])\n\n`ObjectType_ = \"object\" | \"object?\"\n`\n17.2.3.9. Array types\n\n([discussion][1369])\n\n`ArrayType_ = arrayToken [ GenericInstantiation ]\n`\n17.2.3.10. Iterator types\n\n([discussion][1370])\n\n`IteratorDecl = \"iterator\" { Attribute } IteratorName\n  ( [ GenericParameters ]\n    Formals(allowGhostKeyword: true, allowNewKeyword: false, \n                                     allowOlderKeyword: false)\n    [ \"yields\" Formals(allowGhostKeyword: true, allowNewKeyword: false, \n                                                allowOlderKeyword: false) ]\n  | ellipsis\n  )\n  IteratorSpec\n  [ BlockStmt ]\n`\n17.2.3.11. Arrow types\n\n([discussion][1371])\n\n`ArrowType_ = ( DomainType_ \"~>\" Type\n             | DomainType_ \"-->\" Type\n             | DomainType_ \"->\" Type\n             )\n`\n17.2.3.12. Algebraic datatypes\n\n([discussion][1372])\n\n`DatatypeDecl =\n  ( \"datatype\" | \"codatatype\" )\n  { Attribute }\n  DatatypeName [ GenericParameters ]\n  \"=\" \n  [ ellipsis ]\n  [ \"|\" ] DatatypeMemberDecl\n  { \"|\" DatatypeMemberDecl }\n  [ TypeMembers ]\n\nDatatypeMemberDecl =\n  { Attribute } DatatypeMemberName [ FormalsOptionalIds ]\n`\n\n#### 17.2.4. Type member declarations\n\n([discussion][1373])\n\n17.2.4.1. Fields\n\n([discussion][1374])\n\n`FieldDecl(isValueType) =\n  \"var\" { Attribute } FIdentType { \",\" FIdentType }\n`\n\nA `FieldDecl` is not permitted if `isValueType` is true.\n\n17.2.4.2. Constant fields\n\n([discussion][1375])\n\n`ConstantFieldDecl(moduleLevelDecl) =\n  \"const\" { Attribute } CIdentType [ ellipsis ]\n   [ \":=\" Expression(allowLemma: false, allowLambda:true) ]\n`\n\nIf `moduleLevelDecl` is true, then the `static` modifier is not permitted (the\nconstant field is static implicitly).\n\n17.2.4.3. Method declarations\n\n([discussion][1376])\n\n`MethodDecl(isGhost, allowConstructors, isWithinAbstractModule) =\n  MethodKeyword_ { Attribute } [ MethodFunctionName ]\n  ( MethodSignature_(isGhost, isExtreme: true iff this is a least\n                                   or greatest lemma declaration)\n  | ellipsis\n  )\n  MethodSpec(isConstructor: true iff this is a constructor declaration)\n  [ BlockStmt ]\n\nMethodKeyword_ = ( \"method\"\n                 | \"constructor\"\n                 | \"lemma\"\n                 | \"twostate\" \"lemma\"\n                 | \"least\" \"lemma\"\n                 | \"greatest\" \"lemma\"\n                 )\n\n\nMethodSignature_(isGhost, isExtreme) =\n  [ GenericParameters ]\n  [ KType ]    // permitted only if isExtreme == true\n  Formals(allowGhostKeyword: !isGhost, allowNewKeyword: isTwostateLemma, \n          allowOlderKeyword: false, allowDefault: true)\n  [ \"returns\" Formals(allowGhostKeyword: !isGhost, allowNewKeyword: false, \n                      allowOlderKeyword: false, allowDefault: false) ]\n\nKType = \"[\" ( \"nat\" | \"ORDINAL\" ) \"]\"\n\nFormals(allowGhostKeyword, allowNewKeyword, allowOlderKeyword, allowDefault) =\n  \"(\" [ { Attribute } GIdentType(allowGhostKeyword, allowNewKeyword, allowOlderK\neyword,\n                   allowNameOnlyKeyword: true, allowDefault)\n        { \",\" { Attribute } GIdentType(allowGhostKeyword, allowNewKeyword, allow\nOlderKeyword,\n                         allowNameOnlyKeyword: true, allowDefault) }\n      ]\n  \")\"\n`\n\nIf `isWithinAbstractModule` is false, then the method must have a body for the\nprogram that contains the declaration to be compiled.\n\nThe `KType` may be specified only for least and greatest lemmas.\n\n17.2.4.4. Function declarations\n\n([discussion][1377])\n\n`FunctionDecl(isWithinAbstractModule) =\n  ( [ \"twostate\" ] \"function\" [ \"method\" ] { Attribute }\n    MethodFunctionName\n    FunctionSignatureOrEllipsis_(allowGhostKeyword:\n                                           (\"method\" present),\n                                 allowNewKeyword:\n                                           \"twostate\" present)\n  | \"predicate\" [ \"method\" ] { Attribute }\n    MethodFunctionName\n    PredicateSignatureOrEllipsis_(allowGhostKeyword:\n                                           (\"method\" present),\n                                  allowNewKeyword:\n                                           \"twostate\" present,\n                                  allowOlderKeyword: true)\n  | ( \"least\" | \"greatest\" ) \"predicate\" { Attribute }\n    MethodFunctionName\n    PredicateSignatureOrEllipsis_(allowGhostKeyword: false,\n                         allowNewKeyword: \"twostate\" present,\n                         allowOlderKeyword: false))\n  )\n  FunctionSpec\n  [ FunctionBody ]\n\nFunctionSignatureOrEllipsis_(allowGhostKeyword) =\n  FunctionSignature_(allowGhostKeyword) | ellipsis\n\nFunctionSignature_(allowGhostKeyword, allowNewKeyword) =\n  [ GenericParameters ]\n  Formals(allowGhostKeyword, allowNewKeyword, allowOlderKeyword: true, \n          allowDefault: true)\n  \":\"\n  ( Type\n  | \"(\" GIdentType(allowGhostKeyword: false,\n                   allowNewKeyword: false,\n                   allowOlderKeyword: false,\n                   allowNameOnlyKeyword: false,\n                   allowDefault: false)\n    \")\"\n  )\n\nPredicateSignatureOrEllipsis_(allowGhostKeyword, allowNewKeyword, \n                              allowOlderKeyword) =\n    PredicateSignature_(allowGhostKeyword, allowNewKeyword, allowOlderKeyword) \n  | ellipsis\n\nPredicateSignature_(allowGhostKeyword, allowNewKeyword, allowOlderKeyword) =\n  [ GenericParameters ]\n  [ KType ]\n  Formals(allowGhostKeyword, allowNewKeyword, allowOlderKeyword, \n          allowDefault: true)\n  [\n    \":\"\n    ( Type\n    | \"(\" Ident \":\" \"bool\" \")\"\n    )\n  ]\n\nFunctionBody = \"{\" Expression(allowLemma: true, allowLambda: true)\n               \"}\" [ \"by\" \"method\" BlockStmt ]\n`\n\n#### 17.2.5. Specifications\n\n17.2.5.1. Method specifications\n\n([discussion][1378])\n\n`MethodSpec =\n  { ModifiesClause(allowLambda: false)\n  | RequiresClause(allowLabel: true)\n  | EnsuresClause(allowLambda: false)\n  | DecreasesClause(allowWildcard: true, allowLambda: false)\n  }\n`\n17.2.5.2. Function specifications\n\n([discussion][1379])\n\n`FunctionSpec =\n  { RequiresClause(allowLabel: true)\n  | ReadsClause(allowLemma: false, allowLambda: false, allowWild: true)\n  | EnsuresClause(allowLambda: false)\n  | DecreasesClause(allowWildcard: false, allowLambda: false)\n  }\n`\n17.2.5.3. Lambda function specifications\n\n([discussion][1380])\n\n`LambdaSpec =\n  { ReadsClause(allowLemma: true, allowLambda: false, allowWild: true)\n  | \"requires\" Expression(allowLemma: false, allowLambda: false)\n  }\n`\n17.2.5.4. Iterator specifications\n\n([discussion][1381])\n\n`IteratorSpec =\n  { ReadsClause(allowLemma: false, allowLambda: false,\n                                  allowWild: false)\n  | ModifiesClause(allowLambda: false)\n  | [ \"yield\" ] RequiresClause(allowLabel: !isYield)\n  | [ \"yield\" ] EnsuresClause(allowLambda: false)\n  | DecreasesClause(allowWildcard: false, allowLambda: false)\n  }\n`\n17.2.5.5. Loop specifications\n\n([discussion][1382])\n\n`LoopSpec =\n  { InvariantClause_\n  | DecreasesClause(allowWildcard: true, allowLambda: true)\n  | ModifiesClause(allowLambda: true)\n  }\n`\n17.2.5.6. Requires clauses\n\n([discussion][1383])\n\n`RequiresClause(allowLabel) =\n  \"requires\" { Attribute }\n  [ LabelName \":\" ]  // Label allowed only if allowLabel is true\n  Expression(allowLemma: false, allowLambda: false)\n`\n17.2.5.7. Ensures clauses\n\n([discussion][1384])\n\n`EnsuresClause(allowLambda) =\n  \"ensures\" { Attribute } Expression(allowLemma: false, allowLambda)\n`\n17.2.5.8. Decreases clauses\n\n([discussion][1385])\n\n`DecreasesClause(allowWildcard, allowLambda) =\n  \"decreases\" { Attribute } DecreasesList(allowWildcard, allowLambda)\n\nDecreasesList(allowWildcard, allowLambda) =\n  PossiblyWildExpression(allowLambda, allowWildcard)\n  { \",\" PossiblyWildExpression(allowLambda, allowWildcard) }\n\nPossiblyWildExpression(allowLambda, allowWild) =\n  ( \"*\"  // if allowWild is false, using '*' provokes an error\n  | Expression(allowLemma: false, allowLambda)\n  )\n`\n17.2.5.9. Modifies clauses\n\n([discussion][1386])\n\n`ModifiesClause(allowLambda) =\n  \"modifies\" { Attribute }\n  FrameExpression(allowLemma: false, allowLambda)\n  { \",\" FrameExpression(allowLemma: false, allowLambda) }\n`\n17.2.5.10. Invariant clauses\n\n([discussion][1387])\n\n`InvariantClause_ =\n  \"invariant\" { Attribute }\n  Expression(allowLemma: false, allowLambda: true)\n`\n17.2.5.11. Reads clauses\n\n([discussion][1388])\n\n`ReadsClause(allowLemma, allowLambda, allowWild) =\n  \"reads\" { Attribute }\n  PossiblyWildFrameExpression(allowLemma, allowLambda, allowWild)\n  { \",\" PossiblyWildFrameExpression(allowLemma, allowLambda, allowWild) }\n`\n17.2.5.12. Frame expressions\n\n([discussion][1389])\n\n`FrameExpression(allowLemma, allowLambda) =\n  ( Expression(allowLemma, allowLambda) [ FrameField ]\n  | FrameField\n  )\n\nFrameField = \"`\" IdentOrDigits\n\nPossiblyWildFrameExpression(allowLemma, allowLambda, allowWild) =\n  ( \"*\"  // error if !allowWild and '*'\n  | FrameExpression(allowLemma, allowLambda)\n  )\n`\n\n#### 17.2.6. Statements\n\n17.2.6.1. Labeled statement\n\n([discussion][1390])\n\n`Stmt = { \"label\" LabelName \":\" } NonLabeledStmt\n`\n17.2.6.2. Non-Labeled statement\n\n([discussion][1391])\n\n`NonLabeledStmt =\n  ( AssertStmt | AssumeStmt | BlockStmt | BreakStmt\n  | CalcStmt | ExpectStmt | ForallStmt | IfStmt\n  | MatchStmt | ModifyStmt\n  | PrintStmt | ReturnStmt | RevealStmt\n  | UpdateStmt | UpdateFailureStmt\n  | VarDeclStatement | WhileStmt | ForLoopStmt | YieldStmt\n  )\n`\n17.2.6.3. Break and continue statements\n\n([discussion][1392])\n\n`BreakStmt =\n  ( \"break\" LabelName \";\"\n  | \"continue\" LabelName \";\"\n  | { \"break\" } \"break\" \";\"\n  | { \"break\" } \"continue\" \";\"\n  )\n`\n17.2.6.4. Block statement\n\n([discussion][1393])\n\n`BlockStmt = \"{\" { Stmt } \"}\"\n`\n17.2.6.5. Return statement\n\n([discussion][1394])\n\n`ReturnStmt = \"return\" [ Rhs { \",\" Rhs } ] \";\"\n`\n17.2.6.6. Yield statement\n\n([discussion][1395])\n\n`YieldStmt = \"yield\" [ Rhs { \",\" Rhs } ] \";\"\n`\n17.2.6.7. Update and call statement\n\n([discussion][1396])\n\n`UpdateStmt =\n  Lhs\n  ( {Attribute} \";\"\n  |\n    { \",\" Lhs }\n    ( \":=\" Rhs { \",\" Rhs }\n    | \":|\" [ \"assume\" ]\n               Expression(allowLemma: false, allowLambda: true)\n    )\n    \";\"\n  )\n`\n17.2.6.8. Update with failure statement\n\n([discussion][1397])\n\n`UpdateFailureStmt  =\n  [ Lhs { \",\" Lhs } ]\n  \":-\"\n  [ \"expect\"  | \"assert\" | \"assume\" ]\n  Expression(allowLemma: false, allowLambda: false)\n  { \",\" Rhs }\n  \";\"\n`\n17.2.6.9. Variable declaration statement\n\n([discussion][1398])\n\n`VarDeclStatement =\n  [ \"ghost\" ] \"var\" { Attribute }\n  (\n    LocalIdentTypeOptional\n    { \",\" { Attribute } LocalIdentTypeOptional }\n    [ \":=\"\n      Rhs { \",\" Rhs }\n    | \":-\"\n      [ \"expect\" | \"assert\" | \"assume\" ]\n      Expression(allowLemma: false, allowLambda: false)\n      { \",\" Rhs }\n    | { Attribute }\n      \":|\"\n      [ \"assume\" ] Expression(allowLemma: false, allowLambda: true)\n    ]\n  |\n    CasePatternLocal\n    ( \":=\" | { Attribute } \":|\" )\n    Expression(allowLemma: false, allowLambda: true)\n  )\n  \";\"\n\nCasePatternLocal = \n  ( [ Ident ] \"(\" CasePatternLocal { \",\" CasePatternLocal } \")\"\n  | LocalIdentTypeOptional\n  )\n`\n17.2.6.10. Guards\n\n([discussion][1399])\n\n`Guard = ( \"*\"\n        | \"(\" \"*\" \")\"\n        | Expression(allowLemma: true, allowLambda: true)\n        )\n`\n17.2.6.11. Binding guards\n\n([discussion][1400])\n\n`BindingGuard(allowLambda) =\n  IdentTypeOptional { \",\" IdentTypeOptional }\n  { Attribute }\n  \":|\"\n  Expression(allowLemma: true, allowLambda)\n`\n17.2.6.12. If statement\n\n([discussion][1401])\n\n`IfStmt = \"if\"\n  ( AlternativeBlock(allowBindingGuards: true)\n  |\n    ( BindingGuard(allowLambda: true)\n    | Guard\n    )\n    BlockStmt [ \"else\" ( IfStmt | BlockStmt ) ]\n  )\n\nAlternativeBlock(allowBindingGuards) =\n  ( { AlternativeBlockCase(allowBindingGuards) }\n  | \"{\" { AlternativeBlockCase(allowBindingGuards) } \"}\"\n  )\n\nAlternativeBlockCase(allowBindingGuards) =\n  { \"case\"\n    (\n    BindingGuard(allowLambda: false) //permitted iff allowBindingGuards == true\n    | Expression(allowLemma: true, allowLambda: false)\n    ) \"=>\" { Stmt }\n  }\n`\n17.2.6.13. While Statement\n\n([discussion][1402])\n\n`WhileStmt =\n  \"while\"\n  ( LoopSpec\n    AlternativeBlock(allowBindingGuards: false)\n  | Guard\n    LoopSpec\n    ( BlockStmt\n    |           // no body\n    )\n  )\n`\n17.2.6.14. For statement\n\n([discussion][1403])\n\n`ForLoopStmt =\n  \"for\" IdentTypeOptional \":=\"\n  Expression(allowLemma: false, allowLambda: false)\n  ( \"to\" | \"downto\" )\n  ( \"*\" | Expression(allowLemma: false, allowLambda: false)\n  )\n  LoopSpec\n  ( BlockStmt\n  |           // no body\n  )\n`\n17.2.6.15. Match statement\n\n([discussion][1404])\n\n`MatchStmt =\n  \"match\"\n  Expression(allowLemma: true, allowLambda: true)\n  ( \"{\" { CaseStmt } \"}\"\n  | { CaseStmt }\n  )\n\nCaseStmt = \"case\" ExtendedPattern \"=>\" { Stmt }\n`\n17.2.6.16. Assert statement\n\n([discussion][1405])\n\n`AssertStmt =\n  \"assert\"\n  { Attribute }\n  [ LabelName \":\" ]\n  Expression(allowLemma: false, allowLambda: true)\n  ( \";\"\n  | \"by\" BlockStmt\n  )\n`\n17.2.6.17. Assume statement\n\n([discussion][1406])\n\n`AssumeStmt =\n  \"assume\"\n  { Attribute }\n  Expression(allowLemma: false, allowLambda: true)\n  \";\"\n`\n17.2.6.18. Expect statement\n\n([discussion][1407])\n\n`ExpectStmt =\n  \"expect\"\n  { Attribute }\n  Expression(allowLemma: false, allowLambda: true)\n  [ \",\" Expression(allowLemma: false, allowLambda: true) ]\n  \";\"\n`\n17.2.6.19. Print statement\n\n([discussion][1408])\n\n`PrintStmt =\n  \"print\"\n  Expression(allowLemma: false, allowLambda: true)\n  { \",\" Expression(allowLemma: false, allowLambda: true) }\n  \";\"\n`\n17.2.6.20. Reveal statement\n\n([discussion][1409])\n\n`RevealStmt =\n  \"reveal\"\n  Expression(allowLemma: false, allowLambda: true)\n  { \",\" Expression(allowLemma: false, allowLambda: true) }\n  \";\"\n`\n17.2.6.21. Forall statement\n\n([discussion][1410])\n\n`ForallStmt =\n  \"forall\"\n  ( \"(\" [ QuantifierDomain ] \")\"\n  | [ QuantifierDomain ]\n  )\n  { EnsuresClause(allowLambda: true) }\n  [ BlockStmt ]\n`\n17.2.6.22. Modify statement\n\n([discussion][1411])\n\n`ModifyStmt =\n  \"modify\"\n  { Attribute }\n  FrameExpression(allowLemma: false, allowLambda: true)\n  { \",\" FrameExpression(allowLemma: false, allowLambda: true) }\n  \";\"\n`\n17.2.6.23. Calc statement\n\n([discussion][1412])\n\n`CalcStmt = \"calc\" { Attribute } [ CalcOp ] \"{\" CalcBody_ \"}\"\n\nCalcBody_ = { CalcLine_ [ CalcOp ] Hints_ }\n\nCalcLine_ = Expression(allowLemma: false, allowLambda: true) \";\"\n\nHints_ = { ( BlockStmt | CalcStmt ) }\n\nCalcOp =\n  ( \"==\" [ \"#\" \"[\"\n           Expression(allowLemma: true, allowLambda: true) \"]\" ]\n  | \"<\" | \">\"\n  | \"!=\" | \"<=\" | \">=\"\n  | \"<==>\" | \"==>\" | \"<==\"\n  )\n`\n17.2.6.24. Opaque block\n\n([discussion][1413])\n\n`OpaqueBlock = \"opaque\" OpaqueSpec BlockStmt\n  \nOpaqueSpec = {\n  | ModifiesClause(allowLambda: false)\n  | EnsuresClause(allowLambda: false)\n}\n`\n\n#### 17.2.7. Expressions\n\n17.2.7.1. Top-level expression\n\n([discussion][1414])\n\n`Expression(allowLemma, allowLambda, allowBitwiseOps = true) =\n  EquivExpression(allowLemma, allowLambda, allowBitwiseOps)\n  [ \";\" Expression(allowLemma, allowLambda, allowBitwiseOps) ]\n`\n\nThe “allowLemma” argument says whether or not the expression to be parsed is\nallowed to have the form `S;E` where `S` is a call to a lemma. “allowLemma”\nshould be passed in as “false” whenever the expression to be parsed sits in a\ncontext that itself is terminated by a semi-colon.\n\nThe “allowLambda” says whether or not the expression to be parsed is allowed to\nbe a lambda expression. More precisely, an identifier or parenthesized,\ncomma-delimited list of identifiers is allowed to continue as a lambda\nexpression (that is, continue with a `reads`, `requires`, or `=>`) only if\n“allowLambda” is true. This affects function/method/iterator specifications,\nif/while statements with guarded alternatives, and expressions in the\nspecification of a lambda expression itself.\n\n17.2.7.2. Equivalence expression\n\n([discussion][1415])\n\n`EquivExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  ImpliesExpliesExpression(allowLemma, allowLambda, allowBitwiseOps)\n  { \"<==>\" ImpliesExpliesExpression(allowLemma, allowLambda, allowBitwiseOps) }\n`\n17.2.7.3. Implies expression\n\n([discussion][1416])\n\n`ImpliesExpliesExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  LogicalExpression(allowLemma, allowLambda)\n  [ (  \"==>\" ImpliesExpression(allowLemma, allowLambda, allowBitwiseOps)\n    | \"<==\" LogicalExpression(allowLemma, allowLambda, allowBitwiseOps)\n            { \"<==\" LogicalExpression(allowLemma, allowLambda, allowBitwiseOps) \n}\n    )\n  ]\n\nImpliesExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  LogicalExpression(allowLemma, allowLambda, allowBitwiseOps)\n  [  \"==>\" ImpliesExpression(allowLemma, allowLambda, allowBitwiseOps) ]\n`\n17.2.7.4. Logical expression\n\n([discussion][1417])\n\n`LogicalExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  [ \"&&\" | \"||\" ]\n  RelationalExpression(allowLemma, allowLambda, allowBitwiseOps)\n  { ( \"&&\" | \"||\" )\n    RelationalExpression(allowLemma, allowLambda, allowBitwiseOps)\n  }\n`\n17.2.7.5. Relational expression\n\n([discussion][1418])\n\n`RelationalExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  ShiftTerm(allowLemma, allowLambda, allowBitwiseOps)\n  { RelOp ShiftTerm(allowLemma, allowLambda, allowBitwiseOps) }\n\nRelOp =\n  ( \"==\"\n    [ \"#\" \"[\" Expression(allowLemma: true, allowLambda: true) \"]\" ]\n  | \"!=\"\n    [ \"#\" \"[\" Expression(allowLemma: true, allowLambda: true) \"]\" ]\n  | \"<\" | \">\" | \"<=\" | \">=\"\n  | \"in\"\n  | \"!in\"\n  | \"!!\"\n  )\n`\n17.2.7.6. Bit-shift expression\n\n([discussion][1419])\n\n`ShiftTerm(allowLemma, allowLambda, allowBitwiseOps) =\n  Term(allowLemma, allowLambda, allowBitwiseOps)\n  { ShiftOp Term(allowLemma, allowLambda, allowBitwiseOps) }\n\nShiftOp = ( \"<<\" | \">>\" )\n`\n17.2.7.7. Term (addition operations)\n\n([discussion][1420])\n\n`Term(allowLemma, allowLambda, allowBitwiseOps) =\n  Factor(allowLemma, allowLambda, allowBitwiseOps)\n  { AddOp Factor(allowLemma, allowLambda, allowBitwiseOps) }\n\nAddOp = ( \"+\" | \"-\" )\n`\n17.2.7.8. Factor (multiplication operations)\n\n([discussion][1421])\n\n`Factor(allowLemma, allowLambda, allowBitwiseOps) =\n  BitvectorFactor(allowLemma, allowLambda, allowBitwiseOps)\n  { MulOp BitvectorFactor(allowLemma, allowLambda, allowBitwiseOps) }\n\nMulOp = ( \"*\" | \"/\" | \"%\" )\n`\n17.2.7.9. Bit-vector expression\n\n([discussion][1422])\n\n`BitvectorFactor(allowLemma, allowLambda, allowBitwiseOps) =\n  AsExpression(allowLemma, allowLambda, allowBitwiseOps)\n  { BVOp AsExpression(allowLemma, allowLambda, allowBitwiseOps) }\n\nBVOp = ( \"|\" | \"&\" | \"^\" )\n`\n\nIf `allowBitwiseOps` is false, it is an error to have a bitvector operation.\n\n17.2.7.10. As/Is expression\n\n([discussion][1423])\n\n`AsExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  UnaryExpression(allowLemma, allowLambda, allowBitwiseOps)\n  { ( \"as\" | \"is\" ) Type }\n`\n17.2.7.11. Unary expression\n\n([discussion][1424])\n\n`UnaryExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  ( \"-\" UnaryExpression(allowLemma, allowLambda, allowBitwiseOps)\n  | \"!\" UnaryExpression(allowLemma, allowLambda, allowBitwiseOps)\n  | PrimaryExpression(allowLemma, allowLambda, allowBitwiseOps)\n  )\n`\n17.2.7.12. Primary expression\n\n([discussion][1425])\n\n`PrimaryExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  ( NameSegment { Suffix }\n  | LambdaExpression(allowLemma, allowBitwiseOps)\n  | MapDisplayExpr { Suffix }\n  | SeqDisplayExpr { Suffix }\n  | SetDisplayExpr { Suffix }\n  | EndlessExpression(allowLemma, allowLambda, allowBitwiseOps)\n  | ConstAtomExpression { Suffix }\n  )\n`\n17.2.7.13. Lambda expression\n\n([discussion][1426])\n\n`LambdaExpression(allowLemma, allowBitwiseOps) =\n  ( WildIdent\n  | \"(\" [ IdentTypeOptional { \",\" IdentTypeOptional } ] \")\"\n  )\n  LambdaSpec\n  \"=>\"\n  Expression(allowLemma, allowLambda: true, allowBitwiseOps)\n`\n17.2.7.14. Left-hand-side expression\n\n([discussion][1427]) {\n\n`Lhs =\n  ( NameSegment { Suffix }\n  | ConstAtomExpression Suffix { Suffix }\n  )\n`\n17.2.7.15. Right-hand-side expression\n\n([discussion][1428])\n\n`Rhs =\n    ArrayAllocation\n  | ObjectAllocation_\n  | Expression(allowLemma: false, allowLambda: true, allowBitwiseOps: true)\n  | HavocRhs_\n  )\n  { Attribute }\n`\n17.2.7.16. Array allocation right-hand-side expression\n\n([discussion][1429])\n\n`ArrayAllocation_ =\n  \"new\" [ Type ] \"[\" [ Expressions ] \"]\"\n  [ \"(\" Expression(allowLemma: true, allowLambda: true) \")\"\n  | \"[\" [ Expressions ] \"]\"\n  ]\n`\n17.2.7.17. Object allocation right-hand-side expression\n\n([discussion][1430])\n\n`ObjectAllocation_ = \"new\" Type [ \".\" TypeNameOrCtorSuffix ]\n                               [ \"(\" [ Bindings ] \")\" ]\n`\n17.2.7.18. Havoc right-hand-side expression\n\n([discussion][1431])\n\n`HavocRhs_ = \"*\"\n`\n17.2.7.19. Atomic expressions\n\n([discussion][1432])\n\n`ConstAtomExpression =\n  ( LiteralExpression\n  | ThisExpression_\n  | FreshExpression_\n  | AllocatedExpression_\n  | UnchangedExpression_\n  | OldExpression_\n  | CardinalityExpression_\n  | ParensExpression\n  )\n`\n17.2.7.20. Literal expressions\n\n([discussion][1433])\n\n`LiteralExpression =\n ( \"false\" | \"true\" | \"null\" | Nat | Dec | ApproxLiteral |\n   charToken | stringToken )\n\nApproxLiteral = \"~\" [ \"-\" ] Dec\n\nNat = ( digits | hexdigits )\n\nDec = ( realnumber | digits \".\" | \".\" ( digits | realnumber ) )\n`\n17.2.7.21. This expression\n\n([discussion][1434])\n\n`ThisExpression_ = \"this\"\n`\n17.2.7.22. Old and Old@ Expressions\n\n([discussion][1435])\n\n`OldExpression_ =\n  \"old\" [ \"@\" LabelName ]\n  \"(\" Expression(allowLemma: true, allowLambda: true) \")\"\n`\n17.2.7.23. Fresh Expressions\n\n([discussion][1436])\n\n`FreshExpression_ =\n  \"fresh\" [ \"@\" LabelName ]\n  \"(\" Expression(allowLemma: true, allowLambda: true) \")\"\n`\n17.2.7.24. Allocated Expressions\n\n([discussion][1437])\n\n`AllocatedExpression_ =\n  \"allocated\" \"(\" Expression(allowLemma: true, allowLambda: true) \")\"\n`\n17.2.7.25. Unchanged Expressions\n\n([discussion][1438])\n\n`UnchangedExpression_ =\n  \"unchanged\" [ \"@\" LabelName ]\n  \"(\" FrameExpression(allowLemma: true, allowLambda: true)\n      { \",\" FrameExpression(allowLemma: true, allowLambda: true) }\n  \")\"\n`\n17.2.7.26. Cardinality Expressions\n\n([discussion][1439])\n\n`CardinalityExpression_ =\n  \"|\" Expression(allowLemma: true, allowLambda: true) \"|\"\n`\n17.2.7.27. Parenthesized Expression\n\n([discussion][1440])\n\n`ParensExpression =\n  \"(\" [ TupleArgs ] \")\"\n\nTupleArgs =\n  [ \"ghost\" ]\n  ActualBinding(isGhost) // argument is true iff the ghost modifier is present\n  { \",\"\n    [ \"ghost\" ]\n    ActualBinding(isGhost) // argument is true iff the ghost modifier is present\n  }\n`\n17.2.7.28. Sequence Display Expression\n\n([discussion][1441])\n\n`SeqDisplayExpr =\n  ( \"[\" [ Expressions ] \"]\"\n  | \"seq\" [ GenericInstantiation ]\n    \"(\" Expression(allowLemma: true, allowLambda: true)\n    \",\" Expression(allowLemma: true, allowLambda: true)\n    \")\"\n  )\n`\n17.2.7.29. Set Display Expression\n\n([discussion][1442])\n\n`SetDisplayExpr =\n  ( [ \"iset\" | \"multiset\" ] \"{\" [ Expressions ] \"}\"\n  | \"multiset\" \"(\" Expression(allowLemma: true,\n                              allowLambda: true) \")\"\n  )\n`\n17.2.7.30. Map Display Expression\n\n([discussion][1443])\n\n`MapDisplayExpr =\n  (\"map\" | \"imap\" ) \"[\" [ MapLiteralExpressions ] \"]\"\n\nMapLiteralExpressions =\n  Expression(allowLemma: true, allowLambda: true)\n  \":=\" \n  Expression(allowLemma: true, allowLambda: true)\n  { \",\" \n    Expression(allowLemma: true, allowLambda: true)\n    \":=\" \n    Expression(allowLemma: true, allowLambda: true)\n  }\n`\n17.2.7.31. Endless Expression\n\n([discussion][1444])\n\n`EndlessExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  ( IfExpression(allowLemma, allowLambda, allowBitwiseOps)\n  | MatchExpression(allowLemma, allowLambda, allowBitwiseOps)\n  | QuantifierExpression(allowLemma, allowLambda)\n  | SetComprehensionExpr(allowLemma, allowLambda, allowBitwiseOps)\n  | StmtInExpr\n    Expression(allowLemma, allowLambda, allowBitwiseOps)\n  | LetExpression(allowLemma, allowLambda, allowBitwiseOps)\n  | MapComprehensionExpr(allowLemma, allowLambda, allowBitwiseOps)\n  )\n`\n17.2.7.32. If expression\n\n([discussion][1445])\n\n`IfExpression(allowLemma, allowLambda, allowBitwiseOps) =\n    \"if\" ( BindingGuard(allowLambda: true)\n         | Expression(allowLemma: true, allowLambda: true, allowBitwiseOps: true\n)\n         )\n    \"then\" Expression(allowLemma: true, allowLambda: true, allowBitwiseOps: true\n)\n    \"else\" Expression(allowLemma, allowLambda, allowBitwiseOps)\n`\n17.2.7.33. Match Expression\n\n([discussion][1446])\n\n`MatchExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  \"match\"\n  Expression(allowLemma, allowLambda, allowBitwiseOps)\n  ( \"{\" { CaseExpression(allowLemma: true, allowLambda, allowBitwiseOps: true) }\n \"}\"\n  | { CaseExpression(allowLemma, allowLambda, allowBitwiseOps) }\n  )\n\nCaseExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  \"case\" { Attribute } ExtendedPattern \"=>\" Expression(allowLemma, allowLambda, \nallowBitwiseOps)\n`\n17.2.7.34. Case and Extended Patterns\n\n([discussion][1447])\n\n`CasePattern =\n  ( IdentTypeOptional\n  | [Ident] \"(\" [ CasePattern { \",\" CasePattern } ] \")\"\n  )\n\nSingleExtendedPattern =\n  ( PossiblyNegatedLiteralExpression\n  | IdentTypeOptional\n  | [ Ident ] \"(\" [ SingleExtendedPattern { \",\" SingleExtendedPattern } ] \")\"\n  )\n\nExtendedPattern =\n  ( [ \"|\" ] SingleExtendedPattern { \"|\" SingleExtendedPattern } )\n\nPossiblyNegatedLiteralExpression =\n  ( \"-\" ( Nat | Dec )\n  | LiteralExpression\n  )\n`\n17.2.7.35. Quantifier expression\n\n([discussion][1448])\n\n`QuantifierExpression(allowLemma, allowLambda) =\n  ( \"forall\" | \"exists\" ) QuantifierDomain \"::\"\n  Expression(allowLemma, allowLambda)\n`\n17.2.7.36. Set Comprehension Expressions\n\n([discussion][1449])\n\n`SetComprehensionExpr(allowLemma, allowLambda) =\n  [ \"set\" | \"iset\" ]\n  QuantifierDomain(allowLemma, allowLambda)\n  [ \"::\" Expression(allowLemma, allowLambda) ]\n`\n17.2.7.37. Map Comprehension Expression\n\n([discussion][1450])\n\n`MapComprehensionExpr(allowLemma, allowLambda) =\n  ( \"map\" | \"imap\" )\n  QuantifierDomain(allowLemma, allowLambda)\n  \"::\"\n  Expression(allowLemma, allowLambda)\n  [ \":=\" Expression(allowLemma, allowLambda) ]\n`\n17.2.7.38. Statements in an Expression\n\n([discussion][1451])\n\n`StmtInExpr = ( AssertStmt | AssumeStmt | ExpectStmt\n             | RevealStmt | CalcStmt | ForallStmt\n             )\n`\n17.2.7.39. Let and Let or Fail Expression\n\n([discussion][1452])\n\n`LetExpression(allowLemma, allowLambda) =\n  (\n    [ \"ghost\" ] \"var\" CasePattern { \",\" CasePattern }\n    ( \":=\" | \":-\" | { Attribute } \":|\" )\n    Expression(allowLemma: false, allowLambda: true)\n    { \",\" Expression(allowLemma: false, allowLambda: true) }\n  |\n    \":-\"\n    Expression(allowLemma: false, allowLambda: true)\n  )\n  \";\"\n  Expression(allowLemma, allowLambda)\n`\n17.2.7.40. Name Segment\n\n([discussion][1453])\n\n`NameSegment = Ident [ GenericInstantiation | HashCall ]\n`\n17.2.7.41. Hash Call\n\n([discussion][1454])\n\n`HashCall = \"#\" [ GenericInstantiation ]\n  \"[\" Expression(allowLemma: true, allowLambda: true) \"]\"\n  \"(\" [ Bindings ] \")\"\n`\n17.2.7.42. Suffix\n\n([discussion][1455])\n\n`Suffix =\n  ( AugmentedDotSuffix_\n  | DatatypeUpdateSuffix_\n  | SubsequenceSuffix_\n  | SlicesByLengthSuffix_\n  | SequenceUpdateSuffix_\n  | SelectionSuffix_\n  | ArgumentListSuffix_\n  )\n`\n17.2.7.43. Augmented Dot Suffix\n\n([discussion][1456])\n\n`AugmentedDotSuffix_ = \".\" DotSuffix\n                      [ GenericInstantiation | HashCall ]\n`\n17.2.7.44. Datatype Update Suffix\n\n([discussion][1457])\n\n`DatatypeUpdateSuffix_ =\n  \".\" \"(\" MemberBindingUpdate { \",\" MemberBindingUpdate } \")\"\n\nMemberBindingUpdate =\n  ( ident | digits )\n  \":=\" Expression(allowLemma: true, allowLambda: true)\n`\n17.2.7.45. Subsequence Suffix\n\n([discussion][1458])\n\n`SubsequenceSuffix_ =\n  \"[\" [ Expression(allowLemma: true, allowLambda: true) ]\n      \"..\" [ Expression(allowLemma: true, allowLambda: true) ]\n  \"]\"\n`\n17.2.7.46. Subsequence Slices Suffix\n\n([discussion][1459])\n\n`SlicesByLengthSuffix_ =\n  \"[\" Expression(allowLemma: true, allowLambda: true) \":\"\n      [\n        Expression(allowLemma: true, allowLambda: true)\n        { \":\" Expression(allowLemma: true, allowLambda: true) }\n        [ \":\" ]\n      ]\n  \"]\"\n`\n17.2.7.47. Sequence Update Suffix\n\n([discussion][1460])\n\n`SequenceUpdateSuffix_ =\n  \"[\" Expression(allowLemma: true, allowLambda: true)\n      \":=\" Expression(allowLemma: true, allowLambda: true)\n  \"]\"\n`\n17.2.7.48. Selection Suffix\n\n([discussion][1461])\n\n`SelectionSuffix_ =\n  \"[\" Expression(allowLemma: true, allowLambda: true)\n      { \",\" Expression(allowLemma: true, allowLambda: true) }\n  \"]\"\n`\n17.2.7.49. Argument List Suffix\n\n([discussion][1462])\n\n`ArgumentListSuffix_ = \"(\" [ Expressions ] \")\"\n`\n17.2.7.50. Expression Lists\n\n([discussion][1463])\n\n`Expressions =\n  Expression(allowLemma: true, allowLambda: true)\n  { \",\" Expression(allowLemma: true, allowLambda: true) }\n`\n17.2.7.51. Parameter Bindings\n\n([discussion][1464])\n\n`ActualBindings =\n  ActualBinding\n  { \",\" ActualBinding }\n\nActualBinding(isGhost = false) =\n  [ NoUSIdentOrDigits \":=\" ]\n  Expression(allowLemma: true, allowLambda: true)\n`\n17.2.7.52. Quantifier domains\n`QuantifierDomain(allowLemma, allowLambda) =\n  QuantifierVarDecl(allowLemma, allowLambda) \n  { \",\" QuantifierVarDecl(allowLemma, allowLambda) }\n\nQuantifierVarDecl(allowLemma, allowLambda) =\n  IdentTypeOptional\n  [ \"<-\" Expression(allowLemma, allowLambda) ]\n  { Attribute }\n  [ | Expression(allowLemma, allowLambda) ]\n`\n17.2.7.53. Basic name and type combinations\n`Ident = ident\n\nDotSuffix = ( ident | digits | \"requires\" | \"reads\" )\n\nNoUSIdent = ident - \"_\" { idchar }\n\nWildIdent = NoUSIdent | \"_\"\n\nIdentOrDigits = Ident | digits\nNoUSIdentOrDigits = NoUSIdent | digits\nModuleName = NoUSIdent\nClassName = NoUSIdent    // also traits\nDatatypeName = NoUSIdent\nDatatypeMemberName = NoUSIdentOrDigits\nNewtypeName = NoUSIdent\nSynonymTypeName = NoUSIdent\nIteratorName = NoUSIdent\nTypeVariableName = NoUSIdent\nMethodFunctionName = NoUSIdentOrDigits\nLabelName = NoUSIdentOrDigits\nAttributeName = NoUSIdent\nExportId = NoUSIdentOrDigits\nTypeNameOrCtorSuffix = NoUSIdentOrDigits\n\nModuleQualifiedName = ModuleName { \".\" ModuleName }\n\nIdentType = WildIdent \":\" Type\n\nFIdentType = NoUSIdentOrDigits \":\" Type\n\nCIdentType = NoUSIdentOrDigits [ \":\" Type ]\n\nGIdentType(allowGhostKeyword, allowNewKeyword, allowOlderKeyword, allowNameOnlyK\neyword, allowDefault) =\n  { \"ghost\" | \"new\" | \"nameonly\" | \"older\" } IdentType\n  [ \":=\" Expression(allowLemma: true, allowLambda: true) ]\n\nLocalIdentTypeOptional = WildIdent [ \":\" Type ]\n\nIdentTypeOptional = WildIdent [ \":\" Type ]\n\nTypeIdentOptional =\n  { Attribute }\n  { \"ghost\" | \"nameonly\" } [ NoUSIdentOrDigits \":\" ] Type\n  [ \":=\" Expression(allowLemma: true, allowLambda: true) ]\n\nFormalsOptionalIds = \"(\" [ TypeIdentOptional\n                           { \",\" TypeIdentOptional } ] \")\"\n\n`\n\n## 18. Testing syntax rendering\n\nSample math B: $a \\to b$ or\n\n$$ a \\to \\pi $$\n\nor ( a \\top ) or [ a \\to \\pi ]\n\nColors\n\n`integer literal:  10\nhex literal:      0xDEAD\nreal literal:     1.1\nboolean literal:  true false\nchar literal:     'c'\nstring literal:   \"abc\"\nverbatim string:  @\"abc\"\nident:            ijk\ntype:             int\ngeneric type:     map<int,T>\noperator:         <=\npunctuation:      { }\nkeyword:          while\nspec:             requires\ncomment:          // comment\nattribute         {: name }\nerror:            $\n`\n\nSyntax color tests:\n\n`integer: 0 00 20 01 0_1\nfloat:   .0 1.0 1. 0_1.1_0\nbad:    0_\nhex:    0x10_abcdefABCDEF\nstring:   \"string \\n \\t \\r \\0\" \"a\\\"b\" \"'\" \"\\'\" \"\"\nstring:   \"!@#$%^&*()_-+={}[]|:;\\\\<>,.?/~`\"\nstring:   \"\\u1234 \"\nstring:   \"     \" : \"\\0\\n\\r\\t\\'\\\"\\\\\"\nnotstring: \"abcde\nnotstring: \"\\u123 \" : \"x\\Zz\" : \"x\\ux\"\nvstring:  @\"\" @\"a\" @\"\"\"\" @\"'\\\" @\"\\u\"\nvstring:  @\"xx\"\"y y\"\"zz \"\nvstring:  @\" \" @\"       \"\nvstring:  @\"x\nx\"\nbad:      @!\nchar:    'a' '\\n' '\\'' '\"' '\\\"' ' ' '\\\\'\nchar:    '\\0' '\\r' '\\t'  '\\u1234'\nbadchar:  $ `\nids:  '\\u123'   '\\Z'  '\\u'  '\\u2222Z'\nids:  '\\u123ZZZ'     '\\u2222Z'\nids: 'a : a' : 'ab' :  'a'b' : 'a''b'\nids:  a_b _ab ab? _0\nid-label:  a@label\nliteral:  true false null\nop:      - ! ~ x  -!~x\nop:      a + b - c * d / e % f a+b-c*d/e%f\nop:      <= >= < > == != b&&c || ==> <==> <==\nop:      !=# !! in !in\nop:      !in∆  !iné\nnot op:  !inx\npunc:    . , :: | :| := ( ) [ ] { }\ntypes:   int real string char bool nat ORDINAL\ntypes:   object object?\ntypes:   bv1 bv10 bv0\ntypes:   array array2 array20 array10\ntypes:   array? array2? array20? array10?\nids:     array1 array0 array02 bv02 bv_1\nids:     intx natx int0 int_ int? bv1_ bv1x array2x\ntypes:   seq<int>  set < bool >\ntypes:   map<bool,bool>  imap < bool , bool >\ntypes:   seq<Node> seq< Node >\ntypes:   seq<set< real> >\ntypes:   map<set<int>,seq<bool>>\ntypes:   G<A,int> G<G<A>,G<bool>>\ntypes:   seq map imap set iset multiset\nids:     seqx mapx\nno arg:  seq < >  seq < , >  seq <bool , , bool >  seq<bool,>\nkeywords: if while assert assume\nspec:    requires  reads modifies\nattribute:  {: MyAttribute \"asd\", 34 }\nattribute:  {: MyAttribute }\ncomment:  // comment\ncomment:  /* comment */ after\ncomment:  // comment /* asd */ dfg\ncomment:  /* comment /* embedded */ tail */ after\ncomment:  /* comment // embedded */ after\ncomment: /* comment\n   /* inner comment\n   */\n   outer comment\n   */ after\n   more after\n`\n\n## 19. References\n\n1.  The binding power of shift and bit-wise operations is different than in\n    C-like languages. [↩][1465]\n2.  This is likely to change in the future to disallow multiple occurrences of\n    the same key. [↩][1466]\n3.  This is likely to change in the future as follows: The `in` and `!in`\n    operations will no longer be supported on maps, with `x in m` replaced by `x\n    in m.Keys`, and similarly for `!in`. [↩][1467]\n4.  Traits are new to Dafny and are likely to evolve for a while. [↩][1468]\n5.  It is possible to conceive of a mechanism for disambiguating conflicting\n    names, but this would add complexity to the language that does not appear to\n    be needed, at least as yet. [↩][1469]\n6.  It would make sense to rename the special fields `_reads` and `_modifies` to\n    have the same names as the corresponding keywords, `reads` and `modifies`,\n    as is done for function values. Also, the various `_decreases\\(_i_\\)` fields\n    can be combined into one field named `decreases` whose type is a *n*-tuple.\n    These changes may be incorporated into a future version of Dafny. [↩][1470]\n7.  To be specific, Dafny has two forms of [↩][1471]\n8.  Note, two places where co-predicates and co-lemmas are not analogous are (a)\n    co-predicates must not make recursive calls to their prefix predicates and\n    (b) co-predicates cannot mention `_k`. [↩][1472]\n9.  The `:-` token is called the elephant symbol or operator. [↩][1473]\n10. The semantics of `old` in Dafny differs from similar constructs in other\n    specification languages like ACSL or JML. [↩][1474]\n11. In order to be deterministic, the result of a function should only depend on\n    the arguments and of the objects it [reads][1475], and Dafny does not\n    provide a way to explicitly pass the entire heap as the argument to a\n    function. See [this post][1476] for more insights. [↩][1477]\n12. This set of operations that are constant-folded may be enlarged in future\n    versions of `dafny`. [↩][1478]\n13. All entities that Dafny translates to Boogie have their attributes passed on\n    to Boogie except for the [`{:axiom}`][1479] attribute (which conflicts with\n    Boogie usage) and the [`{:trigger}`][1480] attribute which is instead\n    converted into a Boogie quantifier *trigger*. See Section 11 of\n    [@Leino:Boogie2-RefMan]. [↩][1481]\n14. Ghost inference has to be performed after type inference, at least because\n    it is not possible to determine if a member access `a.b` refers to a ghost\n    variable until the type of `a` is determined. [↩][1482]\n15. File names are considered equal if they have the same absolute path,\n    compared as case-sensitive strings (regardless of whether the underlying\n    file-system is case sensitive). Using symbolic links may make the same file\n    have a different absolute path; this will generally cause duplicate\n    declaration errors. [↩][1483]\n16. Unlike some languages, Dafny does not allow separation of [↩][1484]\n17. The formula sent to the underlying SMT solver is the negation of the formula\n    that the verifier wants to prove - also called a VC or verification\n    condition. Hence, if the SMT solver returns “unsat”, it means that the SMT\n    formula is always false, meaning the verifier’s formula is always true. On\n    the other side, if the SMT solver returns “sat”, it means that the SMT\n    formula can be made true with a special variable assignment, which means\n    that the verifier’s formula is false under that same variable assignment,\n    meaning it’s a counter-example for the verifier. In practice and because of\n    quantifiers, the SMT solver will usually return “unknown” instead of “sat”,\n    but will still provide a variable assignment that it couldn’t prove that it\n    does not make the formula true. `dafny` reports it as a “counter-example”\n    but it might not be a real counter-example, only provide hints about what\n    `dafny` knows. [↩][1485] [↩²][1486] [↩³][1487]\n18. `assume false` tells the `dafny` verifier “Assume everything is true from\n    this point of the program”. The reason is that, ‘false’ proves anything. For\n    example, `false ==> A` is always true because it is equivalent to `!false ||\n    A`, which reduces to `true || A`, which reduces to `true`. [↩][1488]\n19. `assert P;`. [↩][1489]\n20. By default, the expression of an assertion or a precondition is added to the\n    knowledge base of the `dafny` verifier for further assertions or\n    postconditions. However, this is not always desirable, because if the\n    verifier has too much knowledge, it might get lost trying to prove something\n    in the wrong direction. [↩][1490] [↩²][1491] [↩³][1492] [↩⁴][1493]\n21. `dafny` actually breaks things down further. For example, a precondition\n    `requires A && B` or an assert statement `assert A && B;` turns into two\n    assertions, more or less like `requires A requires B` and `assert A; assert\n    B;`. [↩][1494] [↩²][1495]\n22. All the complexities of the execution paths (if-then-else, loops, goto,\n    break….) are, down the road and for verification purposes, cleverly encoded\n    with variables recording the paths and guarding assumptions made on each\n    path. In practice, a second clever encoding of variables enables grouping\n    many assertions together, and recovers which assertion is failing based on\n    the value of variables that the SMT solver returns. [↩][1496]\n23. This [post][1497] gives an overview of how assertions are turned into\n    assumptions for verification purposes. [↩][1498]\n24. Caveat about assertion and assumption: One big difference between an\n    “assertion transformed in an assumption” and the original “assertion” is\n    that the original “assertion” can unroll functions twice, whereas the\n    “assumed assertion” can unroll them only once. Hence, `dafny` can still\n    continue to analyze assertions after a failing assertion without\n    automatically proving “false” (which would make all further assertions\n    vacuous). [↩][1499]\n25. To create a smaller batch, `dafny` duplicates the assertion batch, and\n    arbitrarily transforms the clones of an assertion into assumptions except in\n    exactly one batch, so that each assertion is verified only in one batch.\n    This results in “easier” formulas for the verifier because it has less to\n    prove, but it takes more overhead because every verification instance have a\n    common set of axioms and there is no knowledge sharing between instances\n    because they run independently. [↩][1500]\n26. ‘Sequentializing’ a `forall` statement refers to compiling it directly to a\n    series of nested loops with the statement’s body directly inside. The\n    alternative, default compilation strategy is to calculate the quantified\n    variable bindings separately as a collection of tuples, and then execute the\n    statement’s body for each tuple. Not all `forall` statements can be\n    sequentialized. [↩][1501]\n27. This refers to an expression such as `['H', 'e', 'l', 'l', 'o']`, as opposed\n    to a string literal such as `\"Hello\"`. [↩][1502]\n28. This refers to assign-such-that statements with multiple variables, and\n    where at least one variable has potentially infinite bounds. For example,\n    the implementation of the statement `var x: nat, y: nat :| 0 < x && 0 < y &&\n    x*x == y*y*y + 1;` needs to avoid the naive approach of iterating all\n    possible values of `x` and `y` in a nested loop. [↩][1503]\n29. Sequence construction expressions often use a direct lambda expression, as\n    in `seq(10, x => x * x)`, but they can also be used with arbitrary function\n    values, as in `seq(10, squareFn)`. [↩][1504]\n\n[1]: https://dafny-lang.github.io/dafny/DafnyRef/DafnyRef\n[2]: #sec-introduction\n[3]: #11-dafny-40\n[4]: #sec-example\n[5]: #sec-lexical-grammar\n[6]: #sec-unicode\n[7]: #sec-token-types\n[8]: #sec-character-classes\n[9]: #sec-comments\n[10]: #sec-documentation-comments\n[11]: #sec-tokens\n[12]: #sec-reserved-words\n[13]: #sec-identifiers\n[14]: #sec-digits\n[15]: #sec-escaped-characters\n[16]: #sec-character-constant-token\n[17]: #sec-string-constant-token\n[18]: #sec-ellipsis\n[19]: #sec-grammar\n[20]: #sec-identifier-variations\n[21]: #2711-identifier\n[22]: #2712-no-underscore-identifier\n[23]: #sec-wild-identifier\n[24]: #272-qualified-names\n[25]: #273-identifier-type-combinations\n[26]: #sec-quantifier-domains\n[27]: #sec-numeric-literals\n[28]: #sec-program\n[29]: #sec-include-directive\n[30]: #sec-top-level-declaration\n[31]: #sec-declaration-modifier\n[32]: #sec-user-guide-main\n[33]: #sec-modules\n[34]: #sec-module-definition\n[35]: #42-declaring-nested-modules-standalone\n[36]: #sec-importing-modules\n[37]: #sec-opening-modules\n[38]: #sec-export-sets\n[39]: #sec-provided-and-revealed-names\n[40]: #sec-extends-list\n[41]: #sec-module-abstraction\n[42]: #sec-module-ordering\n[43]: #sec-name-resolution\n[44]: #481-modules-and-name-spaces\n[45]: #482-module-id-context-name-resolution\n[46]: #483-expression-context-name-resolution\n[47]: #484-type-context-name-resolution\n[48]: #sec-types\n[49]: #51-kinds-of-types\n[50]: #511-value-types\n[51]: #sec-reference-types\n[52]: #513-named-types-grammar\n[53]: #sec-basic-type\n[54]: #sec-booleans\n[55]: #sec-equivalence-operator\n[56]: #sec-conjunction-and-disjunction\n[57]: #sec-implication-and-reverse-implication\n[58]: #sec-numeric-types\n[59]: #sec-floating-point-type\n[60]: #5231-literals\n[61]: #5232-special-values\n[62]: #5233-classification-predicates\n[63]: #5234-arithmetic-operations\n[64]: #5235-equality\n[65]: #5236-unchecked-arithmetic-and-comparison-methods\n[66]: #5237-mathematical-functions\n[67]: #5238-type-conversions\n[68]: #5239-inexact-conversion-methods\n[69]: #52310-comparison-of-numeric-types\n[70]: #sec-bit-vector-types\n[71]: #sec-ordinals\n[72]: #sec-characters\n[73]: #sec-type-parameters\n[74]: #sec-type-characteristics\n[75]: #sec-equality-supporting\n[76]: #sec-auto-init\n[77]: #sec-nonempty-types\n[78]: #sec-non-heap-based\n[79]: #sec-type-parameter-variance\n[80]: #sec-generic-instantiation\n[81]: #sec-collection-types\n[82]: #sec-sets\n[83]: #sec-multisets\n[84]: #sec-sequences\n[85]: #sec-sequence-displays\n[86]: #5532-sequence-relational-operators\n[87]: #5533-sequence-concatenation\n[88]: #sec-other-sequence-expressions\n[89]: #sec-strings\n[90]: #sec-maps\n[91]: #555-iterating-over-collections\n[92]: #5551-sequences-and-arrays\n[93]: #5552-sets\n[94]: #5553-maps\n[95]: #sec-type-definition\n[96]: #sec-synonym-type\n[97]: #sec-abstract-types\n[98]: #sec-subset-types\n[99]: #5631-type-nat\n[100]: #5632-non-null-types\n[101]: #sec-arrow-subset-types\n[102]: #sec-witness\n[103]: #sec-newtypes\n[104]: #sec-conversion\n[105]: #sec-class-types\n[106]: #sec-trait-types\n[107]: #sec-object-type\n[108]: #sec-inheritance\n[109]: #593-example-of-traits\n[110]: #sec-array-type\n[111]: #5101-one-dimensional-arrays\n[112]: #sec-array-to-seq\n[113]: #sec-multi-dimensional-arrays\n[114]: #sec-iterator-types\n[115]: #sec-arrow-types\n[116]: #sec-tuple-types\n[117]: #sec-datatype\n[118]: #sec-inductive-datatypes\n[119]: #sec-coinductive-datatypes\n[120]: #sec-coinduction\n[121]: #51431-well-founded-functionmethod-definitions\n[122]: #51432-defining-coinductive-datatypes\n[123]: #51433-creating-values-of-co-datatypes\n[124]: #sec-co-equality\n[125]: #sec-copredicates\n[126]: #51436-coinductive-proofs\n[127]: #514361-properties-of-prefix-predicates\n[128]: #sec-colemmas\n[129]: #sec-prefix-lemmas\n[130]: #sec-abstemious\n[131]: #sec-member-declaration\n[132]: #sec-field-declaration\n[133]: #sec-constant-field-declaration\n[134]: #sec-method-declaration\n[135]: #631-ordinary-methods\n[136]: #sec-constructor-methods\n[137]: #6321-classes-with-no-explicit-constructors\n[138]: #6322-classes-with-one-or-more-constructors\n[139]: #6323-two-phase-constructors\n[140]: #sec-lemmas\n[141]: #sec-two-state\n[142]: #sec-function-declaration\n[143]: #641-functions\n[144]: #642-predicates\n[145]: #sec-function-by-method\n[146]: #sec-opaque\n[147]: #645-extreme-least-or-greatest-predicates-and-lemmas\n[148]: #sec-older-parameters\n[149]: #65-nameonly-formal-parameters-and-default-value-expressions\n[150]: #sec-specifications\n[151]: #sec-specification-clauses\n[152]: #sec-requires-clause\n[153]: #sec-ensures-clause\n[154]: #sec-decreases-clause\n[155]: #sec-frame-expression\n[156]: #sec-reads-clause\n[157]: #sec-modifies-clause\n[158]: #sec-invariant-clause\n[159]: #sec-method-specification\n[160]: #sec-function-specification\n[161]: #sec-lambda-specification\n[162]: #sec-iterator-specification\n[163]: #sec-loop-specification\n[164]: #77-auto-generated-boilerplate-specifications\n[165]: #sec-well-formedness-specifications\n[166]: #sec-statements\n[167]: #sec-labeled-statement\n[168]: #sec-block-statement\n[169]: #sec-return-statement\n[170]: #sec-yield-statement\n[171]: #sec-update-and-call-statement\n[172]: #851-method-call-with-no-out-parameters\n[173]: #852-method-call-with-out-parameters\n[174]: #853-parallel-assignment\n[175]: #sec-havoc-statement\n[176]: #855-such-that-assignment\n[177]: #856-method-call-with-a-by-proof\n[178]: #sec-update-with-failure-statement\n[179]: #sec-failure-compatible-types\n[180]: #sec-simple-fc-return\n[181]: #sec-multiple-output-fc\n[182]: #sec-value-carrying\n[183]: #sec-failure-expressions\n[184]: #sec-failure-with-declaration\n[185]: #sec-failure-return-keyword\n[186]: #868-key-points\n[187]: #sec-failure-return-and-exceptions\n[188]: #sec-variable-declaration-statement\n[189]: #sec-guard\n[190]: #sec-binding-guards\n[191]: #sec-if-statement\n[192]: #sec-match-statement\n[193]: #sec-while-statement\n[194]: #sec-for-statement\n[195]: #sec-break-continue-statement\n[196]: #sec-loop-specifications\n[197]: #sec-loop-invariants\n[198]: #sec-loop-termination\n[199]: #sec-loop-framing\n[200]: #sec-bodyless-constructs\n[201]: #sec-print-statement\n[202]: #sec-assert-statement\n[203]: #sec-assume-statement\n[204]: #sec-expect-statement\n[205]: #sec-reveal-statement\n[206]: #sec-reveal-assertions\n[207]: #8202-revealing-preconditions\n[208]: #hide-statement\n[209]: #8204-revealing-constants\n[210]: #sec-forall-statement\n[211]: #sec-modify-statement\n[212]: #sec-calc-statement\n[213]: #sec-opaque-block\n[214]: #sec-expressions\n[215]: #sec-top-level-expression\n[216]: #sec-equivalence-expression\n[217]: #sec-implies-expression\n[218]: #sec-logical-expression\n[219]: #sec-relational-expression\n[220]: #sec-bit-shift-expression\n[221]: #sec-addition-expression\n[222]: #sec-multiplication-expression\n[223]: #sec-bitvector-expression\n[224]: #sec-as-is-expression\n[225]: #sec-unary-expression\n[226]: #sec-primary-expression\n[227]: #sec-lambda-expression\n[228]: #sec-lhs-expression\n[229]: #sec-rhs-expression\n[230]: #sec-array-allocation\n[231]: #sec-object-allocation\n[232]: #sec-havoc-expression\n[233]: #sec-atomic-expression\n[234]: #sec-literal-expression\n[235]: #sec-this-expression\n[236]: #sec-old-expression\n[237]: #sec-fresh-expression\n[238]: #sec-allocated-expression\n[239]: #sec-unchanged-expression\n[240]: #sec-cardinality-expression\n[241]: #sec-parenthesized-expression\n[242]: #sec-seq-comprehension\n[243]: #sec-set-display-expression\n[244]: #sec-map-display-expression\n[245]: #sec-endless-expression\n[246]: #sec-if-expression\n[247]: #sec-case-pattern\n[248]: #sec-match-expression\n[249]: #sec-quantifier-expression\n[250]: #sec-set-comprehension-expression\n[251]: #sec-statement-in-an-expression\n[252]: #sec-let-expression\n[253]: #sec-map-comprehension-expression\n[254]: #sec-name-segment\n[255]: #sec-hash-call\n[256]: #sec-suffix\n[257]: #sec-augmented-dot-suffix\n[258]: #sec-datatype-update-suffix\n[259]: #sec-subsequence-suffix\n[260]: #sec-subsequence-slices-suffix\n[261]: #sec-sequence-update-suffix\n[262]: #sec-selection-suffix\n[263]: #sec-argument-list-suffix\n[264]: #sec-expression-list\n[265]: #sec-parameter-bindings\n[266]: #sec-assigned-expression\n[267]: #sec-termination-ordering-expressions\n[268]: #sec-compile-time-constants\n[269]: #sec-list-of-specification-expressions\n[270]: #sec-module-refinement\n[271]: #101-export-set-declarations\n[272]: #102-import-declarations\n[273]: #103-sub-module-declarations\n[274]: #104-const-declarations\n[275]: #105-method-declarations\n[276]: #106-lemma-declarations\n[277]: #107-function-and-predicate-declarations\n[278]: #108-class-trait-and-iterator-declarations\n[279]: #109-type-declarations\n[280]: #1010-statements\n[281]: #sec-attributes\n[282]: #111-attributes-on-top-level-declarations\n[283]: #sec-attributes-autocontracts\n[284]: #sec-nativetype\n[285]: #1113-ignore-deprecated\n[286]: #sec-extern\n[287]: #sec-disable-nonlinear-arithmetic\n[288]: #112-attributes-on-functions-and-methods\n[289]: #1121-abstemious\n[290]: #1122-autoreq\n[291]: #sec-autorevealdependencies\n[292]: #sec-axiom\n[293]: #1125-compile\n[294]: #sec-concurrent-attribute\n[295]: #sec-extern-method\n[296]: #sec-fuel\n[297]: #1129-id-string\n[298]: #sec-induction\n[299]: #sec-induction-trigger\n[300]: #sec-only-functions-methods\n[301]: #sec-print\n[302]: #11214-priority\n[303]: #sec-rlimit\n[304]: #11216-selective_checking\n[305]: #11217-tailrecursion\n[306]: #sec-test-attribute\n[307]: #sec-time-limit\n[308]: #11220-timelimitmultiplier-x\n[309]: #sec-transparent\n[310]: #sec-verify\n[311]: #sec-vcs_max_cost\n[312]: #sec-vcs_max_keep_going_splits\n[313]: #sec-vcs_max_splits\n[314]: #sec-isolate_assertions\n[315]: #sec-synthesize-attr\n[316]: #sec-attr-options\n[317]: #113-attributes-on-reads-and-modifies-clauses\n[318]: #1131-assume_concurrent\n[319]: #sec-verification-attributes-on-assertions\n[320]: #sec-only\n[321]: #sec-focus\n[322]: #sec-split_here\n[323]: #1144-subsumption-n\n[324]: #sec-error-attribute\n[325]: #1146-contradiction\n[326]: #115-attributes-on-variable-declarations\n[327]: #sec-assumption\n[328]: #116-attributes-on-quantifier-expressions-forall-exists\n[329]: #1161-heapquantifier\n[330]: #sec-induction-quantifier\n[331]: #sec-trigger\n[332]: #117-deprecated-attributes\n[333]: #118-other-undocumented-verification-attributes\n[334]: #sec-at-attributes\n[335]: #sec-advanced-topics\n[336]: #sec-type-parameter-completion\n[337]: #sec-type-inference\n[338]: #sec-ghost-inference\n[339]: #sec-extreme\n[340]: #1241-function-definitions\n[341]: #12411-well-founded-functions\n[342]: #sec-fib-example\n[343]: #12413-extreme-solutions\n[344]: #sec-extreme-predicates\n[345]: #sec-example-least-solution\n[346]: #sec-example-greatest-solution\n[347]: #1243-other-techniques\n[348]: #125-functions-in-dafny\n[349]: #1251-well-founded-functions-in-dafny\n[350]: #sec-proofs-in-dafny\n[351]: #sec-friendliness\n[352]: #1254-proofs-about-extreme-predicates\n[353]: #sec-nicer-proofs-of-extremes\n[354]: #sec-definite-assignment\n[355]: #sec-well-founded-orders\n[356]: #sec-quantifier-triggers\n[357]: #sec-user-guide\n[358]: #131-introduction\n[359]: #132-installing-dafny\n[360]: #1321-command-line-tools\n[361]: #sec-ides\n[362]: #133-dafny-programs-and-files\n[363]: #sec-doo-files\n[364]: #sec-dtr-files\n[365]: #sec-dafny-standard-libraries\n[366]: #135-dafny-code-style\n[367]: #command-line\n[368]: #sec-dafny-commands\n[369]: #13611-options-that-are-not-associated-with-a-command\n[370]: #sec-dafny-resolve\n[371]: #sec-dafny-verify\n[372]: #sec-dafny-translate\n[373]: #sec-dafny-build\n[374]: #sec-dafny-run\n[375]: #sec-dafny-server\n[376]: #sec-dafny-audit\n[377]: #sec-dafny-format\n[378]: #sec-dafny-test\n[379]: #sec-dafny-doc\n[380]: #sec-dafny-generate-tests\n[381]: #sec-dafny-generate-tests-inlining\n[382]: #sec-dafny-generate-tests-clo\n[383]: #sec-dafny-find-dead-code\n[384]: #sec-dafny-measure-complexity\n[385]: #136117-plugins\n[386]: #136118-legacy-operation\n[387]: #1362-in-tool-help\n[388]: #sec-exit-codes\n[389]: #1364-dafny-output\n[390]: #sec-project-files\n[391]: #sec-verification\n[392]: #sec-verification-debugging\n[393]: #sec-failing-postconditions\n[394]: #sec-failing-asserts\n[395]: #sec-failing-asserts-special-cases\n[396]: #sec-counterexamples\n[397]: #sec-verification-debugging-slow\n[398]: #sec-assume-false\n[399]: #sec-verification-debugging-assert-by\n[400]: #sec-labeling-revealing-assertions\n[401]: #sec-non-opaque-function-method\n[402]: #sec-conversion-to-and-from-bitvectors\n[403]: #sec-nested-loops\n[404]: #sec-assertion-batches\n[405]: #sec-assertion-batches-control\n[406]: #sec-command-line-options-and-attributes-for-verification\n[407]: #sec-proof-dependencies\n[408]: #sec-brittle-verification\n[409]: #13761-measuring-proof-brittleness\n[410]: #13762-improving-proof-brittleness\n[411]: #sec-compilation\n[412]: #sec-compilation-built-ins\n[413]: #sec-extern-decls\n[414]: #1383-replaceable-modules\n[415]: #1384-c\n[416]: #1385-java\n[417]: #1386-javascript\n[418]: #1387-go\n[419]: #1388-python\n[420]: #1389-c\n[421]: #sec-supported-features-by-target-language\n[422]: #sec-command-line-options\n[423]: #sec-controlling-help\n[424]: #sec-controlling-input\n[425]: #sec-controlling-plugins\n[426]: #sec-controlling-output\n[427]: #sec-controlling-language\n[428]: #sec-controlling-warnings\n[429]: #sec-controlling-verification\n[430]: #sec-controlling-compilation\n[431]: #sec-controlling-boogie\n[432]: #sec-controlling-prover\n[433]: #sec-controlling-test-gen\n[434]: #sec-dafny-language-server-vscode\n[435]: #141-dafny-functionality-within-vscode\n[436]: #sec-gutter-highlights\n[437]: #sec-old-dafny-server\n[438]: #sec-plugins\n[439]: #151-language-server-plugin-tutorial\n[440]: #1511-create-plugin-project\n[441]: #1512-implement-plugin\n[442]: #15121-code-actions-plugin\n[443]: #15122-request-handler-plugin\n[444]: #1513-building-plugin\n[445]: #16-full-list-of-legacy-command-line-options-sec-full-command-line-option\ns-\n[446]: #sec-grammar-details\n[447]: #171-dafny-syntax\n[448]: #1711-classes-of-characters\n[449]: #sec-g-tokens\n[450]: #172-dafny-grammar-productions\n[451]: #g-program\n[452]: #g-include-directive\n[453]: #g-top-level-declaration\n[454]: #g-declaration-modifier\n[455]: #g-module\n[456]: #g-module-definition\n[457]: #g-module-import\n[458]: #g-module-export\n[459]: #g-type\n[460]: #g-basic-type\n[461]: #g-generic-instantiation\n[462]: #g-type-parameter\n[463]: #g-collection-type\n[464]: #g-type-definition\n[465]: #g-class-type\n[466]: #g-trait-type\n[467]: #g-object-type\n[468]: #g-array-type\n[469]: #g-iterator-type\n[470]: #g-arrow-type\n[471]: #g-datatype\n[472]: #g-member-declaration\n[473]: #g-field-declaration\n[474]: #g-const-declaration\n[475]: #g-method-declaration\n[476]: #g-function-declaration\n[477]: #1725-specifications\n[478]: #g-method-specification\n[479]: #g-function-specification\n[480]: #g-lambda-specification\n[481]: #g-iterator-specification\n[482]: #g-loop-specification\n[483]: #g-requires-clause\n[484]: #g-ensures-clause\n[485]: #g-decreases-clause\n[486]: #g-modifies-clause\n[487]: #g-invariant-clause\n[488]: #g-reads-clause\n[489]: #g-frame-expression\n[490]: #g-statement\n[491]: #g-labeled-statement\n[492]: #g-nonlabeled-statement\n[493]: #g-break-continue-statement\n[494]: #g-block-statement\n[495]: #g-return-statement\n[496]: #g-yield-statement\n[497]: #g-update-and-call-statement\n[498]: #g-update-with-failure-statement\n[499]: #g-variable-declaration-statement\n[500]: #g-guard\n[501]: #g-binding-guard\n[502]: #g-if-statement\n[503]: #g-while-statement\n[504]: #g-for-statement\n[505]: #g-match-statement\n[506]: #g-assert-statement\n[507]: #g-assume-statement\n[508]: #g-expect-statement\n[509]: #g-print-statement\n[510]: #g-reveal-statement\n[511]: #g-forall-statement\n[512]: #g-modify-statement\n[513]: #g-calc-statement\n[514]: #g-opaque-block\n[515]: #1727-expressions\n[516]: #g-top-level-expression\n[517]: #g-equivalence-expression\n[518]: #g-implies-expression\n[519]: #g-logical-expression\n[520]: #g-relational-expression\n[521]: #g-bit-shift-expression\n[522]: #g-term\n[523]: #g-factor\n[524]: #g-bit-vector-expression\n[525]: #g-as-is-expression\n[526]: #g-unary-expression\n[527]: #g-primary-expression\n[528]: #g-lambda-expression\n[529]: #g-lhs-expression\n[530]: #g-rhs-expression\n[531]: #g-array-allocation-expression\n[532]: #g-object-allocation-expression\n[533]: #g-havoc-expression\n[534]: #g-atomic-expression\n[535]: #g-literal-expression\n[536]: #g-this-expression\n[537]: #g-old-expression\n[538]: #g-fresh-expression\n[539]: #g-allocated-expression\n[540]: #g-unchanged-expression\n[541]: #g-cardinality-expression\n[542]: #g-parenthesized-expression\n[543]: #g-sequence-display-expression\n[544]: #g-set-display-expression\n[545]: #g-map-display-expression\n[546]: #g-endless-expression\n[547]: #g-if-expression\n[548]: #g-match-expression\n[549]: #g-pattern\n[550]: #g-quantifier-expression\n[551]: #g-set-comprehension-expression\n[552]: #g-map-comprehension-expression\n[553]: #g-statement-in-expression\n[554]: #g-let-expression\n[555]: #g-name-segment\n[556]: #g-hash-call\n[557]: #g-suffix\n[558]: #g-augmented-dot-suffix\n[559]: #g-datatype-update-suffix\n[560]: #g-subsequence-suffix\n[561]: #g-subsequence-slices-suffix\n[562]: #g-sequence-update-suffix\n[563]: #g-selection-suffix\n[564]: #g-argument-list-suffix\n[565]: #g-expression-list\n[566]: #g-parameter-bindings\n[567]: #g-quantifier-domain\n[568]: #172753-basic-name-and-type-combinations\n[569]: #18-testing-syntax-rendering\n[570]: #19-references\n[571]: https://github.com/dafny-lang/dafny/releases\n[572]: ../OnlineTutorial/guide\n[573]: http://research.microsoft.com/boogie\n[574]: https://github.com/z3prover\n[575]: http://research.microsoft.com/en-us/um/people/leino/papers/krml230.pdf\n[576]: #sec-user-guide\n[577]: https://github.com/dafny-lang/ide-vscode/wiki/Quick-migration-guide-from-\nDafny-3.X-to-Dafny-4.0\n[578]: https://mitpress.mit.edu/9780262546232/program-proofs/\n[579]: #sec-grammar-details\n[580]: #sec-grammar-details\n[581]: #sec-unicode\n[582]: #sec-unicode\n[583]: #sec-g-tokens\n[584]: #sec-g-tokens\n[585]: #sec-unicode\n[586]: #sec-requires-clause\n[587]: #sec-reads-clause\n[588]: #sec-wild-identifier\n[589]: #g-quantifier-domain\n[590]: #sec-assertion-batches\n[591]: #sec-controlling-language\n[592]: #g-literal-expression\n[593]: #g-program\n[594]: #sec-user-guide-main\n[595]: #g-include-directive\n[596]: #g-top-level-declaration\n[597]: #sec-types\n[598]: #g-declaration-modifier\n[599]: #g-module\n[600]: #g-module-definition\n[601]: #g-module-import\n[602]: #sec-module-abstraction\n[603]: #g-module-export\n[604]: #sec-module-refinement\n[605]: #sec-name-resolution\n[606]: #sec-module-refinement\n[607]: #sec-basic-type\n[608]: #sec-collection-types\n[609]: #sec-class-types\n[610]: #sec-array-type\n[611]: #sec-iterator-types\n[612]: #sec-trait-types\n[613]: #sec-tuple-types\n[614]: #sec-datatype\n[615]: #sec-coinductive-datatypes\n[616]: #sec-arrow-subset-types\n[617]: #sec-subset-types\n[618]: #sec-subset-types\n[619]: #g-type\n[620]: #sec-name-segment\n[621]: #g-basic-type\n[622]: #sec-reference-types\n[623]: #sec-assertion-batches\n[624]: #sec-assertion-batches\n[625]: #sec-assertion-batches\n[626]: #sec-assertion-batches\n[627]: #sec-quantifier-expression\n[628]: #g-basic-type\n[629]: #sec-subset-types\n[630]: #sec-newtypes\n[631]: #sec-subset-types\n[632]: #sec-as-is-expression\n[633]: #sec-as-is-expression\n[634]: #g-basic-type\n[635]: #fn:binding\n[636]: #g-basic-type\n[637]: #sec-extreme\n[638]: #g-basic-type\n[639]: https://en.wikipedia.org/wiki/UTF-16\n[640]: https://unicode.org/glossary/#unicode_scalar_value\n[641]: https://en.wikipedia.org/wiki/UTF-16\n[642]: https://unicode.org/glossary/#unicode_scalar_value\n[643]: #sec-strings\n[644]: #sec-strings\n[645]: #g-type-parameter\n[646]: #sec-type-inference\n[647]: #sec-definite-assignment\n[648]: ../Compilation/AutoInitialization\n[649]: #sec-definite-assignment\n[650]: http://leino.science/papers/krml280.html\n[651]: #g-generic-instantiation\n[652]: #sec-type-inference\n[653]: #g-collection-type\n[654]: #sec-equality-supporting\n[655]: #sec-set-display-expression\n[656]: #sec-set-comprehension-expression\n[657]: #g-collection-type\n[658]: #sec-equality-supporting\n[659]: #g-collection-type\n[660]: #sec-seq-comprehension\n[661]: #sec-equality-supporting\n[662]: #sec-equality-supporting\n[663]: #g-collection-type\n[664]: #sec-characters\n[665]: #g-collection-type\n[666]: #sec-equality-supporting\n[667]: #sec-map-display-expression\n[668]: #fn:fn-map-display\n[669]: #sec-map-comprehension-expression\n[670]: #fn:fn-map-membership\n[671]: http://leino.science/papers/krml275.html\n[672]: #sec-forall-statement\n[673]: #sec-array-to-seq\n[674]: #g-type-definition\n[675]: #sec-synonym-type\n[676]: #sec-abstract-types\n[677]: #sec-subset-types\n[678]: #sec-newtypes\n[679]: #g-type-definition\n[680]: #sec-abstract-types\n[681]: #sec-type-characteristics\n[682]: #sec-type-characteristics\n[683]: #sec-strings\n[684]: #g-type-definition\n[685]: #sec-type-characteristics\n[686]: #g-type-definition\n[687]: #sec-as-is-expression\n[688]: #sec-witness\n[689]: #sec-arrow-types\n[690]: #sec-arrow-types\n[691]: #g-type-definition\n[692]: #sec-witness\n[693]: #sec-subset-types\n[694]: #sec-conversion\n[695]: #sec-nativetype\n[696]: #sec-compile-time-constants\n[697]: #sec-as-is-expression\n[698]: #sec-numeric-types\n[699]: #sec-as-is-expression\n[700]: #g-class-type\n[701]: #sec-constructor-methods\n[702]: #sec-constructor-methods\n[703]: #g-trait-type\n[704]: #fn:fn-traits\n[705]: #sec-inheritance\n[706]: #g-object-type\n[707]: #fn:overload\n[708]: #g-array-type\n[709]: #sec-reserved-words\n[710]: #sec-array-allocation\n[711]: #sec-assertion-batches\n[712]: #sec-array-allocation\n[713]: #g-iterator-type\n[714]: #sec-iterator-specification\n[715]: #fn:fn-iterator-field-names\n[716]: https://github.com/dafny-lang/dafny/issues/2440\n[717]: #g-arrow-type\n[718]: #sec-arrow-subset-types\n[719]: #sec-lambda-expression\n[720]: #sec-lambda-expression\n[721]: #g-datatype\n[722]: #sec-assertion-batches\n[723]: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/coind\nuction.pdf\n[724]: #sec-colemmas\n[725]: #fn:fn-copredicate-restriction\n[726]: #fn:fn-co-predicate-co-lemma-diffs\n[727]: #g-field-declaration\n[728]: #g-const-declaration\n[729]: #sec-reveal-statement\n[730]: #g-method-declaration\n[731]: #sec-module-refinement\n[732]: #sec-method-specification\n[733]: #sec-friendliness\n[734]: #sec-constructor-methods\n[735]: #sec-lemmas\n[736]: #sec-colemmas\n[737]: #sec-class-types\n[738]: sec-top-level-expression\n[739]: #sec-proofs-in-dafny\n[740]: ../OnlineTutorial/Lemmas\n[741]: #g-function-declaration\n[742]: #sec-function-specification\n[743]: #sec-function-syntax\n[744]: #sec-module-refinement\n[745]: #command-line\n[746]: #hide-statement\n[747]: #sec-transparent\n[748]: #sec-transparent\n[749]: #sec-transparent\n[750]: #sec-autorevealdependencies\n[751]: #sec-transparent\n[752]: https://github.com/dafny-lang/dafny/blob/master/docs/Compilation/Boogie.m\nd\n[753]: #sec-friendliness\n[754]: #sec-non-heap-based\n[755]: #sec-assertion-batches\n[756]: #sec-list-of-specification-expressions\n[757]: #sec-expressions\n[758]: #g-requires-clause\n[759]: #sec-verification-attributes-on-assertions\n[760]: #sec-error-attribute\n[761]: #g-ensures-clause\n[762]: #sec-verification-attributes-on-assertions\n[763]: #sec-error-attribute\n[764]: #g-decreases-clause\n[765]: #sec-termination-ordering-expressions\n[766]: #g-frame-expression\n[767]: #g-reads-clause\n[768]: #sec-concurrent-attribute\n[769]: #sec-frame-expression\n[770]: #sec-iterator-types\n[771]: #g-modifies-clause\n[772]: #sec-frame-expression\n[773]: #g-invariant-clause\n[774]: #sec-error-attribute\n[775]: #g-method-specification\n[776]: #sec-concurrent-attribute\n[777]: #g-function-specification\n[778]: #g-lambda-specification\n[779]: #g-iterator-specification\n[780]: #sec-iterator-types\n[781]: #sec-iterator-types\n[782]: #g-loop-specification\n[783]: #sec-requires-clause\n[784]: #sec-ensures-clause\n[785]: #sec-assertion-batches\n[786]: #sec-assertion-batches\n[787]: #sec-assertion-batches\n[788]: #g-statement\n[789]: #g-labeled-statement\n[790]: #sec-break-continue-statement\n[791]: #sec-old-expression\n[792]: #sec-two-state\n[793]: #sec-fresh-expression\n[794]: #sec-unchanged-expression\n[795]: #sec-allocated-expression\n[796]: #sec-two-state\n[797]: #g-block-statement\n[798]: #g-return-statement\n[799]: #g-yield-statement\n[800]: #sec-iterator-types\n[801]: #g-update-and-call-statement\n[802]: #g-update-with-failure-statement\n[803]: #fn:elephant\n[804]: #sec-failure-return-keyword\n[805]: #sec-simple-fc-return\n[806]: #sec-assert-statement\n[807]: #sec-assume-statement\n[808]: #sec-expect-statement\n[809]: #g-variable-declaration-statement\n[810]: #sec-let-expression\n[811]: #sec-update-and-call-statement\n[812]: #sec-update-with-failure-statement\n[813]: #g-guard\n[814]: #g-binding-guard\n[815]: #g-if-statement\n[816]: #g-match-statement\n[817]: #sec-case-pattern\n[818]: #sec-case-pattern\n[819]: #g-while-statement\n[820]: #sec-loop-specification\n[821]: #sec-loop-specifications\n[822]: #sec-bodyless-constructs\n[823]: #g-for-statement\n[824]: #sec-bodyless-constructs\n[825]: #g-break-continue-statement\n[826]: ../OnlineTutorial/guide\n[827]: #sec-well-founded-orders\n[828]: #sec-assertion-batches\n[829]: #sec-loop-framing\n[830]: #g-print-statement\n[831]: #g-assert-statement\n[832]: #sec-lemmas\n[833]: #sec-calc-statement\n[834]: #sec-reveal-statements\n[835]: #sec-reveal-statement\n[836]: http://leino.science/papers/krml276.html\n[837]: #sec-reveal-assertions\n[838]: #sec-verification-attributes-on-assertions\n[839]: #sec-error-attribute\n[840]: #g-assume-statement\n[841]: #g-expect-statement\n[842]: #g-reveal-statement\n[843]: http://leino.science/papers/krml276.html\n[844]: #g-forall-statement\n[845]: #sec-quantifier-domains\n[846]: http://research.microsoft.com/en-us/um/people/leino/papers/krml233.pdf\n[847]: #sec-coinductive-datatypes\n[848]: #g-modify-statement\n[849]: #sec-frame-expression\n[850]: #sec-havoc-statement\n[851]: #g-calc-statement\n[852]: http://research.microsoft.com/en-us/um/people/leino/papers/krml231.pdf\n[853]: #g-opaque-block\n[854]: #sec-rhs-expression\n[855]: #sec-rhs-expression\n[856]: #sec-primary-expression\n[857]: #sec-argument-list-suffix\n[858]: #sec-list-of-specification-expressions\n[859]: #sec-top-level-expression\n[860]: #sec-equivalence-expression\n[861]: #sec-implies-expression\n[862]: #sec-implies-expression\n[863]: #sec-logical-expression\n[864]: #sec-logical-expression\n[865]: #sec-co-equality\n[866]: #sec-co-equality\n[867]: #sec-bit-shift-expression\n[868]: #sec-bit-shift-expression\n[869]: #sec-bitvector-expression\n[870]: #sec-bitvector-expression\n[871]: #sec-bitvector-expression\n[872]: #sec-as-is-expression\n[873]: #sec-as-is-expression\n[874]: #g-top-level-expression\n[875]: #g-equivalence-expression\n[876]: #sec-equivalence-operator\n[877]: #g-implies-expression\n[878]: #sec-implication-and-reverse-implication\n[879]: #g-logical-expression\n[880]: #sec-conjunction-and-disjunction\n[881]: #g-relational-expression\n[882]: #sec-basic-type\n[883]: #sec-collection-types\n[884]: #sec-sets\n[885]: #sec-multisets\n[886]: #sec-co-equality\n[887]: #g-bit-shift-expression\n[888]: #g-term\n[889]: #sec-numeric-types\n[890]: #sec-sets\n[891]: #sec-multisets\n[892]: #sec-sequences\n[893]: #sec-maps\n[894]: #g-factor\n[895]: #sec-numeric-types\n[896]: #sec-sets\n[897]: #sec-multisets\n[898]: #g-bit-vector-expression\n[899]: #sec-cardinality-expression\n[900]: #g-as-is-expression\n[901]: #g-unary-expression\n[902]: #sec-booleans\n[903]: #sec-bit-vector-types\n[904]: #sec-numeric-types\n[905]: #sec-bit-vector-types\n[906]: #g-primary-expression\n[907]: #g-lambda-expression\n[908]: #sec-lambda-specification\n[909]: #sec-assertion-batches\n[910]: #sec-assertion-batches\n[911]: #g-lhs-expression\n[912]: #sec-update-and-call-statement\n[913]: #sec-update-with-failure-statement\n[914]: #g-rhs-expression\n[915]: #sec-return-statement\n[916]: #sec-yield-statement\n[917]: #sec-update-and-call-statement\n[918]: #sec-update-with-failure-statement\n[919]: #sec-variable-declaration-statement\n[920]: #g-array-allocation-expression\n[921]: #sec-array-type\n[922]: #g-object-allocation-expression\n[923]: #sec-class-types\n[924]: #g-havoc-expression\n[925]: #sec-update-and-call-statement\n[926]: #g-atomic-expression\n[927]: #sec-literal-expression\n[928]: #sec-parenthesized-expression\n[929]: #sec-this-expression\n[930]: #sec-fresh-expression\n[931]: #sec-allocated-expression\n[932]: #sec-unchanged-expression\n[933]: #sec-old-expression\n[934]: #sec-cardinality-expression\n[935]: #sec-assigned-expression\n[936]: #g-literal-expression\n[937]: #g-this-expression\n[938]: #g-old-expression\n[939]: #fn:Old\n[940]: #sec-fresh-expression\n[941]: #sec-unchanged-expression\n[942]: #sec-two-state\n[943]: #sec-two-state-lemma\n[944]: #g-fresh-expression\n[945]: #sec-labeled-statement\n[946]: #sec-labeled-statement\n[947]: #sec-labeled-statement\n[948]: #sec-object-type\n[949]: #sec-allocated-expression\n[950]: #sec-allocated-expression\n[951]: #g-allocated-expression\n[952]: #sec-old-expression\n[953]: #sec-old-expression\n[954]: #sec-fresh-expression\n[955]: #g-unchanged-expression\n[956]: #g-cardinality-expression\n[957]: #sec-collection-types\n[958]: #g-parenthesized-expression\n[959]: #sec-tuple-types\n[960]: #g-sequence-display-expression\n[961]: #sec-sequences\n[962]: #g-set-display-expression\n[963]: #sec-sets\n[964]: #sec-multisets\n[965]: #g-map-display-expression\n[966]: #sec-maps\n[967]: #g-endless-expression\n[968]: #g-if-expression\n[969]: #sec-if-statement\n[970]: #g-pattern\n[971]: #sec-match-statement\n[972]: #sec-match-expression\n[973]: #sec-let-expression\n[974]: #sec-variable-declaration-statement\n[975]: #g-match-expression\n[976]: #sec-case-pattern\n[977]: #g-quantifier-expression\n[978]: #sec-quantifier-domains\n[979]: #g-set-comprehension-expression\n[980]: #sec-quantifier-domains\n[981]: #fn:set-of-objects-not-in-functions\n[982]: #g-statement-in-expression\n[983]: #g-let-expression\n[984]: #sec-update-with-failure-statement\n[985]: #sec-update-with-failure-statement\n[986]: #g-map-comprehension-expression\n[987]: #sec-quantifier-domains\n[988]: #g-name-segment\n[989]: #sec-suffix\n[990]: #sec-copredicates\n[991]: #sec-prefix-lemmas\n[992]: #sec-hash-call\n[993]: #g-hash-call\n[994]: #sec-copredicates\n[995]: #sec-prefix-lemmas\n[996]: #g-suffix\n[997]: #g-augmented-dot-suffix\n[998]: #sec-identifier-variations\n[999]: #g-datatype-update-suffix\n[1000]: #g-subsequence-suffix\n[1001]: #sec-other-sequence-expressions\n[1002]: #g-subsequence-slices-suffix\n[1003]: #sec-other-sequence-expressions\n[1004]: #g-sequence-update-suffix\n[1005]: #g-selection-suffix\n[1006]: #g-argument-list-suffix\n[1007]: #sec-rhs-expression\n[1008]: #g-expression-list\n[1009]: #g-parameter-bindings\n[1010]: #sec-definite-assignment\n[1011]: #sec-decreases-clause\n[1012]: #fn:CTC\n[1013]: #sec-fresh-expression\n[1014]: #sec-allocated-expression\n[1015]: #sec-unchanged-expression\n[1016]: #sec-old-expression\n[1017]: #sec-assigned-expression\n[1018]: #sec-statement-in-an-expression\n[1019]: #sec-hash-call\n[1020]: #sec-termination-ordering-expressions\n[1021]: #g-module-export\n[1022]: #sec-module-abstraction\n[1023]: #fn:boogie-attributes\n[1024]: #sec-extern-decls\n[1025]: #sec-abstemious\n[1026]: #sec-assertion-batches\n[1027]: #sec-verify\n[1028]: #sec-axiom\n[1029]: #sec-function-declarations\n[1030]: #sec-extern\n[1031]: #sec-extern\n[1032]: #sec-extern\n[1033]: https://github.com/Microsoft/dafny/issues/34\n[1034]: #sec-induction-quantifier\n[1035]: #sec-trigger\n[1036]: #sec-only\n[1037]: #sec-verify\n[1038]: https://github.com/dafny-lang/dafny/blob/master/docs/Compilation/Boogie.\nmd\n[1039]: #sec-isolate_assertions\n[1040]: #sec-isolate_assertions\n[1041]: #sec-function-by-method\n[1042]: #sec-update-with-failure-statement\n[1043]: #sec-expect-statement\n[1044]: #sec-assertion-batches\n[1045]: #sec-axiom\n[1046]: #sec-only-functions-methods\n[1047]: #sec-assertion-batches\n[1048]: #sec-assertion-batches\n[1049]: #sec-vcs_max_keep_going_splits\n[1050]: #sec-isolate_assertions\n[1051]: #sec-assertion-batches\n[1052]: #sec-assertion-batches\n[1053]: #sec-isolate_assertions\n[1054]: #sec-assertion-batches\n[1055]: #sec-vcs_max_keep_going_splits\n[1056]: #sec-isolate_assertions\n[1057]: #sec-assertion-batches\n[1058]: #sec-concurrent-attribute\n[1059]: #sec-only-functions-methods\n[1060]: #sec-assertion-batches\n[1061]: #sec-split_here\n[1062]: #sec-assertion-batches\n[1063]: #sec-labeling-revealing-assertions\n[1064]: #sec-induction\n[1065]: #sec-opaque\n[1066]: http://leino.science/papers/krml270.html\n[1067]: #fn:why-after-type-inference\n[1068]: #sec-type-inference\n[1069]: #sec-assert-statement\n[1070]: #sec-assume-statement\n[1071]: #sec-reveal-statement\n[1072]: #sec-calc-statement\n[1073]: #sec-assert-statement\n[1074]: #sec-lemmas\n[1075]: #sec-if-statement\n[1076]: #sec-match-statement\n[1077]: #sec-while-statement\n[1078]: #sec-for-statement\n[1079]: #sec-variable-declaration-statement\n[1080]: #sec-update-and-call-statement\n[1081]: #sec-forall-statement\n[1082]: #sec-expect-statement\n[1083]: #sec-print-statement\n[1084]: #sec-list-of-specification-expressions\n[1085]: #sec-constant-field-declaration\n[1086]: #sec-field-declaration\n[1087]: #sec-coinductive-datatypes\n[1088]: #eq-general\n[1089]: #eq-general\n[1090]: #eq-general\n[1091]: #eq-fib\n[1092]: #eq-fib\n[1093]: #eq-general\n[1094]: #eq-general\n[1095]: #eq-general\n[1096]: #eq-general\n[1097]: #eq-general\n[1098]: #fig-proof-trees\n[1099]: #g-ind-rule\n[1100]: #g-coind-rule\n[1101]: #g-coind-rule\n[1102]: #g-coind-rule\n[1103]: #eq-EvenNat\n[1104]: #eq-general\n[1105]: #eq-least-approx\n[1106]: #eq-greatest-approx\n[1107]: #eq-general\n[1108]: #eq-prefix-postfix\n[1109]: #sec-friendliness\n[1110]: #eq-EvenNat\n[1111]: #eq-EvenNat\n[1112]: #fig-proof-trees\n[1113]: #g-ind-rule\n[1114]: #eq-least-is-exists\n[1115]: #g-coind-rule\n[1116]: #g-coind-rule\n[1117]: #eq-greatest-is-forall\n[1118]: #eq-general\n[1119]: #sec-lemmas\n[1120]: #sec-fib-example\n[1121]: #eq-least-approx\n[1122]: #eq-greatest-approx\n[1123]: #eq-least-is-exists\n[1124]: #eq-greatest-is-forall\n[1125]: #eq-least-is-exists\n[1126]: #eq-greatest-is-forall\n[1127]: #sec-example-least-solution\n[1128]: #sec-example-greatest-solution\n[1129]: #eq-least-is-exists\n[1130]: #sec-example-greatest-solution\n[1131]: #sec-example-least-solution\n[1132]: #sec-example-greatest-solution\n[1133]: #sec-example-least-solution\n[1134]: #sec-example-greatest-solution\n[1135]: #sec-type-characteristics\n[1136]: #sec-array-type\n[1137]: ../Compilation/AutoInitialization\n[1138]: #sec-match-expression\n[1139]: #sec-let-expression\n[1140]: #sec-expressions\n[1141]: https://github.com/dafny-lang/dafny\n[1142]: https://github.com/dafny-lang/dafny/blob/master/LICENSE.txt\n[1143]: #sec-dafny-commands\n[1144]: https://github.com/dafny-lang/dafny/wiki/INSTALL\n[1145]: https://github.com/dafny-lang/dafny/releases\n[1146]: https://github.com/dafny-lang/dafny/wiki/INSTALL#building-and-developing\n-from-source-code\n[1147]: http://code.visualstudio.com\n[1148]: #sec-dafny-language-server-vscode\n[1149]: https://github.com/boogie-org/boogie-friends\n[1150]: https://github.com/dafny-lang/dafny/wiki/INSTALL\n[1151]: #sec-dafny-language-server-vscode\n[1152]: #fn:fn-duplicate-files\n[1153]: #sec-dafny-commands\n[1154]: https://dafny-lang.github.io/dafny/StyleGuide/Style-Guide\n[1155]: #sec-dafny-verify\n[1156]: #sec-dafny-build\n[1157]: #sec-dafny-run\n[1158]: #sec-dafny-format\n[1159]: #fn:incomplete\n[1160]: #sec-trait-types\n[1161]: #sec-class-types\n[1162]: #sec-exit-codes\n[1163]: #sec-dafny-resolve\n[1164]: #sec-verification\n[1165]: #sec-dafny-audit\n[1166]: #sec-dafny-resolve\n[1167]: #sec-compilation\n[1168]: #sec-dafny-resolve\n[1169]: #sec-dafny-verify\n[1170]: #sec-compilation\n[1171]: #print-encoding\n[1172]: https://microsoft.github.io/language-server-protocol/\n[1173]: \n[1174]: #sec-dafny-language-server-vscode\n[1175]: #sec-test-attribute\n[1176]: #sec-documentation-comments\n[1177]: #sec-project-files\n[1178]: #sec-dafny-test\n[1179]: #sec-dafny-test\n[1180]: #sec-plugins\n[1181]: https://toml.io/en/\n[1182]: #sec-verification-debugging\n[1183]: #sec-verification-debugging-slow\n[1184]: #sec-assertion-batches\n[1185]: #sec-command-line-options-and-attributes-for-verification\n[1186]: #sec-failing-postconditions\n[1187]: https://en.wikipedia.org/wiki/Predicate_transformer_semantics#Weakest_pr\neconditions\n[1188]: #sec-forall-statement\n[1189]: #sec-forall-statement\n[1190]: #sec-calc-statement\n[1191]: #sec-calc-statement\n[1192]: #fn:smt-encoding\n[1193]: ../VerificationOptimization/VerificationOptimization\n[1194]: #fn:explainer-assume-false\n[1195]: #sec-verification-debugging\n[1196]: #fn:answer-slowdown\n[1197]: #fn:verifier-lost\n[1198]: #fn:verifier-lost\n[1199]: #sec-verification-debugging-assert-by\n[1200]: #sec-verification-debugging\n[1201]: #fn:verifier-lost\n[1202]: #sec-opaque\n[1203]: #sec-reveal-statement\n[1204]: #sec-subset-types\n[1205]: #sec-newtypes\n[1206]: #fn:verifier-lost\n[1207]: #sec-requires-clause\n[1208]: #sec-statement-in-an-expression\n[1209]: #sec-decreases-clause\n[1210]: #sec-well-formedness-specifications\n[1211]: #sec-numeric-types\n[1212]: #sec-numeric-types\n[1213]: #sec-as-is-expression\n[1214]: #sec-bit-vector-types\n[1215]: #sec-class-types\n[1216]: #sec-loop-framing\n[1217]: #sec-modifies-clause\n[1218]: #sec-reads-clause\n[1219]: #sec-array-type\n[1220]: #sec-sequences\n[1221]: #sec-datatype-update-suffix\n[1222]: #sec-algebraic-datatype\n[1223]: #sec-trait-types\n[1224]: #sec-subset-types\n[1225]: #sec-subset-types\n[1226]: #sec-update-and-call-statement\n[1227]: #sec-loop-termination\n[1228]: #sec-match-expression\n[1229]: #sec-if-statement\n[1230]: #sec-requires-clause\n[1231]: #fn:precision-requires-clause\n[1232]: #sec-assert-statement\n[1233]: #fn:precision-requires-clause\n[1234]: #sec-calc-statement\n[1235]: #sec-ensures-clause\n[1236]: #sec-forall-statement\n[1237]: #sec-invariant-clause\n[1238]: #sec-decreases-clause\n[1239]: #sec-iterator-specification\n[1240]: #sec-iterator-types\n[1241]: #sec-iterator-specification\n[1242]: #sec-iterator-types\n[1243]: #fn:complexity-path-encoding\n[1244]: #fn:smt-encoding\n[1245]: #fn:example-assertion-turned-into-assumption\n[1246]: #fn:caveat-about-assertion-and-assumption\n[1247]: #fn:smaller-batches\n[1248]: #sec-isolate_assertions\n[1249]: #sec-controlling-output\n[1250]: #sec-controlling-output\n[1251]: #sec-controlling-compilation\n[1252]: #sec-rlimit\n[1253]: #sec-fuel\n[1254]: https://dafny-lang.github.io/dafny/DafnyRef/DafnyRef\n[1255]: https://github.com/dafny-lang/dafny-reportgenerator/\n[1256]: https://github.com/dafny-lang/dafny-reportgenerator/blob/main/README.md\n[1257]: https://en.wikipedia.org/wiki/Coefficient_of_variation\n[1258]: #sec-verification-debugging-slow\n[1259]: ../VerificationOptimization/VerificationOptimization\n[1260]: #sec-user-guide-main\n[1261]: #sec-supported-features-by-target-language\n[1262]: #sec-extern\n[1263]: #sec-extern\n[1264]: #sec-extern\n[1265]: #sec-abstract-types\n[1266]: #sec-user-guide-main\n[1267]: #command-line\n[1268]: integration-cs/IntegrationCS\n[1269]: integration-java/IntegrationJava\n[1270]: integration-js/IntegrationJS\n[1271]: integration-go/IntegrationGo\n[1272]: integration-py/IntegrationPython\n[1273]: https://github.com/dafny-lang/dafny/blob/master/Test/c++/extern.dfy\n[1274]: #sec-numeric-types\n[1275]: #sec-numeric-types\n[1276]: #sec-ordinals\n[1277]: #sec-arrow-subset-types\n[1278]: #sec-iterator-types\n[1279]: #sec-collection-types\n[1280]: #sec-extern-decls\n[1281]: #sec-coinductive-datatypes\n[1282]: #sec-multisets\n[1283]: #\n[1284]: #sec-multi-dimensional-arrays\n[1285]: #sec-map-comprehension-expression\n[1286]: #sec-trait-types\n[1287]: #sec-let-expression\n[1288]: #sec-newtypes\n[1289]: #sec-synthesize-attr\n[1290]: #sec-extern-decls\n[1291]: #sec-object-type\n[1292]: #sec-forall-statement\n[1293]: #fn:compiler-feature-forall-note\n[1294]: #sec-array-type\n[1295]: #sec-maps\n[1296]: #sec-test-attribute\n[1297]: #sec-quantifier-domains\n[1298]: #sec-quantifier-domains\n[1299]: #sec-sequence-displays\n[1300]: #fn:compiler-sequence-display-of-characters-note\n[1301]: #sec-as-is-expression\n[1302]: #sec-as-is-expression\n[1303]: #sec-quantifier-expression\n[1304]: #sec-bit-vector-types\n[1305]: #sec-for-statement\n[1306]: #sec-break-continue-statement\n[1307]: #sec-update-and-call-statement\n[1308]: #fn:compiler-infinite-assign-such-that-note\n[1309]: #sec-other-sequence-expressions\n[1310]: #sec-sequence-displays\n[1311]: #fn:compiler-sequence-display-nolambda-note\n[1312]: #sec-extern-decls\n[1313]: #sec-tuple-types\n[1314]: #sec-quantifier-expression\n[1315]: ##sec-compilation-built-ins\n[1316]: ##sec-compilation-built-ins\n[1317]: ##sec-compilation-built-ins\n[1318]: ##sec-characters\n[1319]: #sec-print-statement\n[1320]: #sec-dafny-commands\n[1321]: #sec-compilation\n[1322]: #sec-compilation-built-ins\n[1323]: #sec-dafny-test\n[1324]: #sec-dafny-standard-libraries\n[1325]: #sec-dafny-standard-libraries\n[1326]: https://github.com/dafny-lang/dafny/blob/master/Source/DafnyCore/DafnyPr\nelude.bpl\n[1327]: #sec-plugins\n[1328]: #sec-disable-nonlinear-arithmetic\n[1329]: #fn:smt-encoding\n[1330]: #sec-trigger\n[1331]: #sec-nicer-proofs-of-extremes\n[1332]: #sec-isolate_assertions\n[1333]: #sec-time-limit\n[1334]: #sec-rlimit\n[1335]: #sec-controlling-verification\n[1336]: #sec-controlling-boogie\n[1337]: https://github.com/dafny-lang/dafny/blob/master/Source/DafnyTestGenerati\non/README.md\n[1338]: https://github.com/dafny-lang/dafny/tree/master/Source/DafnyLanguageServ\ner\n[1339]: https://microsoft.github.io/language-server-protocol/\n[1340]: https://github.com/dafny-lang/dafny/tree/master/Source/DafnyLanguageServ\ner#plugins\n[1341]: https://github.com/dafny-lang/dafny/tree/master/Source/DafnyLanguageServ\ner\n[1342]: https://microsoft.github.io/language-server-protocol/\n[1343]: https://github.com/boogie-org/boogie-friends\n[1344]: https://github.com/dafny-lang/dafny/tree/master/Source/DafnyServer\n[1345]: https://github.com/dafny-lang/dafny/tree/master/Test/server\n[1346]: #sec-dafny-commands\n[1347]: http://www.ssw.uni-linz.ac.at/Research/Projects/Coco\n[1348]: http://www.ssw.uni-linz.ac.at/Research/Projects/Coco/Doc/UserManual.pdf\n[1349]: #sec-unicode\n[1350]: #sec-extreme\n[1351]: #sec-older-parameters\n[1352]: #sec-g-tokens\n[1353]: #sec-program\n[1354]: #sec-include-directive\n[1355]: #sec-top-level-declaration\n[1356]: #sec-declaration-modifier\n[1357]: #sec-module-definition\n[1358]: #sec-importing-modules\n[1359]: #sec-export-sets\n[1360]: #sec-types\n[1361]: #sec-basic-type\n[1362]: #sec-generic-instantiation\n[1363]: #sec-type-parameters\n[1364]: #sec-collection-types\n[1365]: #sec-type-definition\n[1366]: #sec-class-types\n[1367]: #sec-trait-types\n[1368]: #sec-object-type\n[1369]: #sec-array-type\n[1370]: #sec-iterator-types\n[1371]: #sec-arrow-types\n[1372]: #sec-datatype\n[1373]: #sec-member-declaration\n[1374]: #sec-field-declaration\n[1375]: #sec-constant-field-declaration\n[1376]: #sec-method-declaration\n[1377]: #sec-function-declaration\n[1378]: #sec-method-specification\n[1379]: #sec-function-specification\n[1380]: #sec-lambda-specification\n[1381]: #sec-iterator-specification\n[1382]: #sec-loop-specification\n[1383]: #sec-requires-clause\n[1384]: #sec-ensures-clause\n[1385]: #sec-decreases-clause\n[1386]: #sec-modifies-clause\n[1387]: #sec-invariant-clause\n[1388]: #sec-reads-clause\n[1389]: #sec-frame-expression\n[1390]: #sec-labeled-statement\n[1391]: #sec-statements\n[1392]: #sec-break-continue-statement\n[1393]: #sec-block-statement\n[1394]: #sec-return-statement\n[1395]: #sec-yield-statement\n[1396]: #sec-update-and-call-statement\n[1397]: #sec-update-with-failure-statement\n[1398]: #sec-variable-declaration-statement\n[1399]: #sec-guard\n[1400]: #sec-binding-guards\n[1401]: #sec-if-statement\n[1402]: #sec-while-statement\n[1403]: #sec-for-statement\n[1404]: #sec-match-statement\n[1405]: #sec-assert-statement\n[1406]: #sec-assume-statement\n[1407]: #sec-expect-statement\n[1408]: #sec-print-statement\n[1409]: #sec-reveal-statement\n[1410]: #sec-forall-statement\n[1411]: #sec-modify-statement\n[1412]: #sec-calc-statement\n[1413]: #sec-opaque-block\n[1414]: #sec-top-level-expression\n[1415]: #sec-equivalence-expression\n[1416]: #sec-implies-expression\n[1417]: #sec-logical-expression\n[1418]: #sec-relational-expression\n[1419]: #sec-bit-shift-expression\n[1420]: #sec-addition-expression\n[1421]: #sec-multiplication-expression\n[1422]: #sec-bitvector-expression\n[1423]: #sec-as-is-expression\n[1424]: #sec-unary-expression\n[1425]: #sec-primary-expression\n[1426]: #sec-lambda-expression\n[1427]: #sec-lhs-expression\n[1428]: #sec-rhs-expression\n[1429]: #sec-array-allocation\n[1430]: #sec-object-allocation\n[1431]: #sec-havoc-expression\n[1432]: #sec-atomic-expression\n[1433]: #sec-literal-expression\n[1434]: #sec-this-expression\n[1435]: #sec-old-expression\n[1436]: #sec-fresh-expression\n[1437]: #sec-allocated-expression\n[1438]: #sec-unchanged-expression\n[1439]: #sec-cardinality-expression\n[1440]: #sec-parenthesized-expression\n[1441]: #sec-seq-comprehension\n[1442]: #sec-set-display-expression\n[1443]: #sec-map-display-expression\n[1444]: #sec-endless-expression\n[1445]: #sec-if-expression\n[1446]: #sec-match-expression\n[1447]: #sec-case-pattern\n[1448]: #sec-quantifier-expression\n[1449]: #sec-set-comprehension-expression\n[1450]: #sec-map-comprehension-expression\n[1451]: #sec-statement-in-an-expression\n[1452]: #sec-let-expression\n[1453]: #sec-name-segment\n[1454]: #sec-hash-call\n[1455]: #sec-suffix\n[1456]: #sec-augmented-dot-suffix\n[1457]: #sec-datatype-update-suffix\n[1458]: #sec-subsequence-suffix\n[1459]: #sec-subsequence-slices-suffix\n[1460]: #sec-sequence-update-suffix\n[1461]: #sec-selection-suffix\n[1462]: #sec-argument-list-suffix\n[1463]: #sec-expression-list\n[1464]: #sec-parameter-bindings\n[1465]: #fnref:binding\n[1466]: #fnref:fn-map-display\n[1467]: #fnref:fn-map-membership\n[1468]: #fnref:fn-traits\n[1469]: #fnref:overload\n[1470]: #fnref:fn-iterator-field-names\n[1471]: #fnref:fn-copredicate-restriction\n[1472]: #fnref:fn-co-predicate-co-lemma-diffs\n[1473]: #fnref:elephant\n[1474]: #fnref:Old\n[1475]: #sec-reads-clause\n[1476]: https://github.com/dafny-lang/dafny/issues/1366\n[1477]: #fnref:set-of-objects-not-in-functions\n[1478]: #fnref:CTC\n[1479]: #sec-axiom\n[1480]: #sec-trigger\n[1481]: #fnref:boogie-attributes\n[1482]: #fnref:why-after-type-inference\n[1483]: #fnref:fn-duplicate-files\n[1484]: #fnref:incomplete\n[1485]: #fnref:smt-encoding\n[1486]: #fnref:smt-encoding:1\n[1487]: #fnref:smt-encoding:2\n[1488]: #fnref:explainer-assume-false\n[1489]: #fnref:answer-slowdown\n[1490]: #fnref:verifier-lost\n[1491]: #fnref:verifier-lost:1\n[1492]: #fnref:verifier-lost:2\n[1493]: #fnref:verifier-lost:3\n[1494]: #fnref:precision-requires-clause\n[1495]: #fnref:precision-requires-clause:1\n[1496]: #fnref:complexity-path-encoding\n[1497]: https://github.com/dafny-lang/dafny/discussions/1898\n[1498]: #fnref:example-assertion-turned-into-assumption\n[1499]: #fnref:caveat-about-assertion-and-assumption\n[1500]: #fnref:smaller-batches\n[1501]: #fnref:compiler-feature-forall-note\n[1502]: #fnref:compiler-sequence-display-of-characters-note\n[1503]: #fnref:compiler-infinite-assign-such-that-note\n[1504]: #fnref:compiler-sequence-display-nolambda-note\n",
  "content_type": "Reference",
  "fetched_at": "2025-12-19T17:31:47.481679Z",
  "metadata": {
    "sections": [
      "1. Introduction",
      "1.1. Dafny 4.0",
      "1.2. Dafny Example",
      "2. Lexical and Low Level Grammar",
      "2.1. Dafny Input",
      "2.2. Tokens and whitespace",
      "2.3. Character Classes",
      "2.4. Comments",
      "2.5. Documentation comments",
      "2.6. Tokens (grammar)",
      "2.7. Low Level Grammar Productions",
      "3. Programs (grammar)",
      "3.1. Include Directives (grammar)",
      "3.2. Top Level Declarations (grammar)",
      "3.3. Declaration Modifiers (grammar)",
      "3.4. Executable programs",
      "4. Modules (grammar)",
      "4.1. Declaring New Modules (grammar)",
      "4.2. Declaring nested modules standalone",
      "4.3. Importing Modules (grammar)",
      "4.4. Opening Modules",
      "4.5. Export Sets and Access Control (grammar)",
      "4.6. Module Abstraction",
      "4.7. Module Ordering and Dependencies",
      "4.8. Name Resolution",
      "5. Types",
      "5.1. Kinds of types",
      "5.2. Basic types",
      "5.3. Type parameters (grammar)",
      "5.4. Generic Instantiation (grammar)",
      "5.5. Collection types",
      "5.6. Types that stand for other types (grammar)",
      "5.7. Newtypes (grammar)",
      "5.8. Class types (grammar)",
      "5.9. Trait types (grammar)",
      "5.10. Array types (grammar)",
      "5.11. Iterator types (grammar)",
      "5.12. Arrow types (grammar)",
      "5.13.  Tuple types",
      "5.14. Algebraic Datatypes (grammar)",
      "6. Member declarations",
      "6.1. Field Declarations (grammar)",
      "6.2. Constant Field Declarations (grammar)",
      "6.3. Method Declarations (grammar)",
      "6.4. Function Declarations (grammar)",
      "6.5. Nameonly Formal Parameters and Default-Value Expressions",
      "7. Specifications",
      "7.1. Specification Clauses",
      "7.2. Method Specification (grammar)",
      "7.3. Function Specification (grammar)",
      "7.4. Lambda Specification (grammar)",
      "7.5. Iterator Specification (grammar)",
      "7.6. Loop Specification (grammar)",
      "7.7. Auto-generated boilerplate specifications",
      "7.8. Well-formedness of specifications",
      "8. Statements (grammar)",
      "8.1. Labeled Statement (grammar)",
      "8.2. Block Statement (grammar)",
      "8.3. Return Statement (grammar)",
      "8.4. Yield Statement (grammar)",
      "8.5. Update and Call Statements (grammar)",
      "8.6. Update with Failure Statement (:-) (grammar)",
      "8.7. Variable Declaration Statement (grammar)",
      "8.8. Guards (grammar)",
      "8.9. Binding Guards (grammar)",
      "8.10. If Statement (grammar)",
      "8.11. Match Statement (grammar)",
      "8.12. While Statement (grammar)",
      "8.13. For Loops (grammar)",
      "8.14. Break and Continue Statements (grammar)",
      "8.15. Loop Specifications",
      "8.16. Print Statement (grammar)",
      "8.17. Assert statement (grammar)",
      "8.18. Assume Statement (grammar)",
      "8.19. Expect Statement (grammar)",
      "8.20. Reveal Statement (grammar)",
      "8.21. Forall Statement (grammar)",
      "8.22. Modify Statement (grammar)",
      "8.23. Calc Statement (grammar)",
      "8.24. Opaque Block (grammar)",
      "9. Expressions",
      "9.1. Lemma-call expressions (grammar)",
      "9.2. Equivalence Expressions (grammar)",
      "9.3. Implies or Explies Expressions (grammar)",
      "9.4. Logical Expressions (grammar)",
      "9.5. Relational Expressions (grammar)",
      "9.6. Bit Shifts (grammar)",
      "9.7. Terms (grammar)",
      "9.8. Factors (grammar)",
      "9.9. Bit-vector Operations (grammar)",
      "9.10. As (Conversion) and Is (type test) Expressions (grammar)",
      "9.11. Unary Expressions (grammar)",
      "9.12. Primary Expressions (grammar)",
      "9.13. Lambda expressions (grammar)",
      "9.14. Left-Hand-Side Expressions (grammar)",
      "9.15. Right-Hand-Side Expressions (grammar)",
      "9.16. Array Allocation (grammar)",
      "9.17. Object Allocation (grammar)",
      "9.18. Havoc Right-Hand-Side (grammar)",
      "9.19. Constant Or Atomic Expressions (grammar)",
      "9.20. Literal Expressions (grammar}",
      "9.21. this Expression (grammar)",
      "9.22. Old and Old@ Expressions (grammar)",
      "9.23. Fresh Expressions (grammar)",
      "9.24. Allocated Expressions (grammar)",
      "9.25. Unchanged Expressions (grammar)",
      "9.26. Cardinality Expressions (grammar)",
      "9.27. Parenthesized Expressions (grammar)",
      "9.28. Sequence Display Expression (grammar)",
      "9.29. Set Display Expression (grammar)",
      "9.30. Map Display Expression (grammar)",
      "9.31. Endless Expression (grammar)",
      "9.32. Name Segment (grammar)",
      "9.33. Hash call (grammar)",
      "9.34. Suffix (grammar)",
      "9.35. Expression Lists (grammar)",
      "9.36. Parameter Bindings (grammar)",
      "9.37. Assigned Expressions",
      "9.38. Termination Ordering Expressions",
      "9.39. Compile-Time Constants",
      "9.40. List of specification expressions",
      "10. Refinement",
      "10.1. Export set declarations",
      "10.2. Import declarations",
      "10.3. Sub-module declarations",
      "10.4. Const declarations",
      "10.5. Method declarations",
      "10.6. Lemma declarations",
      "10.7. Function and predicate declarations",
      "10.8. Class, trait and iterator declarations",
      "10.9. Type declarations",
      "10.10. Statements",
      "11. Attributes",
      "11.1. Attributes on top-level declarations",
      "11.2. Attributes on functions and methods",
      "11.3. Attributes on reads and modifies clauses",
      "11.4. Attributes on assertions, preconditions and postconditions",
      "11.5. Attributes on variable declarations",
      "11.6. Attributes on quantifier expressions (forall, exists)",
      "11.7. Deprecated attributes",
      "11.8. Other undocumented verification attributes",
      "11.9. New attribute syntax",
      "12. Advanced Topics",
      "12.1. Type Parameter Completion",
      "12.2. Type Inference",
      "12.3. Ghost Inference",
      "12.4. Well-founded Functions and Extreme Predicates",
      "12.5. Functions in Dafny",
      "12.6. Variable Initialization and Definite Assignment",
      "12.7. Well-founded Orders",
      "12.8. Quantifier instantiation rules",
      "13. Dafny User’s Guide",
      "13.1. Introduction",
      "13.2. Installing Dafny",
      "13.3. Dafny Programs and Files",
      "13.4. Dafny Standard Libraries",
      "13.5. Dafny Code Style",
      "13.6. Using Dafny From the Command Line",
      "13.7. Verification",
      "13.8. Compilation",
      "13.9. Dafny Command Line Options",
      "14. Dafny VSCode extension and the Dafny Language Server",
      "14.1. Dafny functionality within VSCode",
      "14.2. Gutter highlights",
      "14.3. The Dafny Server",
      "15. Plugins to Dafny",
      "15.1. Language Server plugin tutorial",
      "16. Full list of legacy command-line options {#sec-full-command-line-options} ",
      "17. Dafny Grammar",
      "17.1. Dafny Syntax",
      "17.2. Dafny Grammar productions",
      "18. Testing syntax rendering",
      "19. References"
    ],
    "tags": [],
    "code_blocks": [
      {
        "language": "text",
        "code": "// VSComp 2010, problem 3, find a 0 in a linked list and return\n// how many nodes were skipped until the first 0 (or end-of-list)\n// was found.\n// Rustan Leino, 18 August 2010.\n//\n// The difficulty in this problem lies in specifying what the\n// return value 'r' denotes and in proving that the program\n// terminates.  Both of these are addressed by declaring a ghost\n// field 'List' in each linked-list node, abstractly representing\n// the linked-list elements from the node to the end of the linked\n// list.  The specification can now talk about that sequence of\n// elements and can use 'r' as an index into the sequence, and\n// termination can be proved from the fact that all sequences in\n// Dafny are finite.\n//\n// We only want to deal with linked lists whose 'List' field is\n// properly filled in (which can only happen in an acyclic list,\n// for example).  To that end, the standard idiom in Dafny is to\n// declare a predicate 'Valid()' that is true of an object when\n// the data structure representing that object's abstract value\n// is properly formed.  The definition of 'Valid()' is what one\n// intuitively would think of as the ''object invariant'', and\n// it is mentioned explicitly in method pre- and postconditions.\n//\n// As part of this standard idiom, one also declares a ghost\n// variable 'Repr' that is maintained as the set of objects that\n// make up the representation of the aggregate object--in this\n// case, the Node itself and all its successors.\nmodule {:options \"--function-syntax:4\"} M {\nclass Node {\n  ghost var List: seq<int>\n  ghost var Repr: set<Node>\n  var head: int\n  var next: Node? // Node? means a Node value or null\n\n  ghost predicate Valid()\n    reads this, Repr\n  {\n    this in Repr &&\n    1 <= |List| && List[0] == head &&\n    (next == null ==> |List| == 1) &&\n    (next != null ==>\n      next in Repr && next.Repr <= Repr && this !in next.Repr &&\n      next.Valid() && next.List == List[1..])\n  }\n\n  static method Cons(x: int, tail: Node?) returns (n: Node)\n    requires tail == null || tail.Valid()\n    ensures n.Valid()\n    ensures if tail == null then n.List == [x]\n                            else n.List == [x] + tail.List\n  {\n    n := new Node;\n    n.head, n.next := x, tail;\n    if (tail == null) {\n      n.List := [x];\n      n.Repr := {n};\n    } else {\n      n.List := [x] + tail.List;\n      n.Repr := {n} + tail.Repr;\n    }\n  }\n}\n\nmethod Search(ll: Node?) returns (r: int)\n  requires ll == null || ll.Valid()\n  ensures ll == null ==> r == 0\n  ensures ll != null ==>\n            0 <= r && r <= |ll.List| &&\n            (r < |ll.List| ==>\n              ll.List[r] == 0 && 0 !in ll.List[..r]) &&\n            (r == |ll.List| ==> 0 !in ll.List)\n{\n  if (ll == null) {\n    r := 0;\n  } else {\n    var jj,i := ll,0;\n    while (jj != null && jj.head != 0)\n      invariant jj != null ==>\n            jj.Valid() &&\n            i + |jj.List| == |ll.List| &&\n            ll.List[i..] == jj.List\n      invariant jj == null ==> i == |ll.List|\n      invariant 0 !in ll.List[..i]\n      decreases |ll.List| - i\n    {\n      jj := jj.next;\n      i := i + 1;\n    }\n    r := i;\n  }\n}\n\nmethod Main()\n{\n  var list: Node? := null;\n  list := list.Cons(0, list);\n  list := list.Cons(5, list);\n  list := list.Cons(0, list);\n  list := list.Cons(8, list);\n  var r := Search(list);\n  print \"Search returns \", r, \"\\n\";\n  assert r == 1;\n}\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "// VSComp 2010, problem 3, find a 0 in a linked list and return\n// how many nodes were skipped until the first 0 (or end-of-list)\n// was found.\n// Rustan Leino, 18 August 2010.\n//\n// The difficulty in this problem lies in specifying what the\n// return value 'r' denotes and in proving that the program\n// terminates.  Both of these are addressed by declaring a ghost\n// field 'List' in each linked-list node, abstractly representing\n// the linked-list elements from the node to the end of the linked\n// list.  The specification can now talk about that sequence of\n// elements and can use 'r' as an index into the sequence, and\n// termination can be proved from the fact that all sequences in\n// Dafny are finite.\n//\n// We only want to deal with linked lists whose 'List' field is\n// properly filled in (which can only happen in an acyclic list,\n// for example).  To that end, the standard idiom in Dafny is to\n// declare a predicate 'Valid()' that is true of an object when\n// the data structure representing that object's abstract value\n// is properly formed.  The definition of 'Valid()' is what one\n// intuitively would think of as the ''object invariant'', and\n// it is mentioned explicitly in method pre- and postconditions.\n//\n// As part of this standard idiom, one also declares a ghost\n// variable 'Repr' that is maintained as the set of objects that\n// make up the representation of the aggregate object--in this\n// case, the Node itself and all its successors.\nmodule {:options \"--function-syntax:4\"} M {\nclass Node {\n  ghost var List: seq<int>\n  ghost var Repr: set<Node>\n  var head: int\n  var next: Node? // Node? means a Node value or null\n\n  ghost predicate Valid()\n    reads this, Repr\n  {\n    this in Repr &&\n    1 <= |List| && List[0] == head &&\n    (next == null ==> |List| == 1) &&\n    (next != null ==>\n      next in Repr && next.Repr <= Repr && this !in next.Repr &&\n      next.Valid() && next.List == List[1..])\n  }\n\n  static method Cons(x: int, tail: Node?) returns (n: Node)\n    requires tail == null || tail.Valid()\n    ensures n.Valid()\n    ensures if tail == null then n.List == [x]\n                            else n.List == [x] + tail.List\n  {\n    n := new Node;\n    n.head, n.next := x, tail;\n    if (tail == null) {\n      n.List := [x];\n      n.Repr := {n};\n    } else {\n      n.List := [x] + tail.List;\n      n.Repr := {n} + tail.Repr;\n    }\n  }\n}\n\nmethod Search(ll: Node?) returns (r: int)\n  requires ll == null || ll.Valid()\n  ensures ll == null ==> r == 0\n  ensures ll != null ==>\n            0 <= r && r <= |ll.List| &&\n            (r < |ll.List| ==>\n              ll.List[r] == 0 && 0 !in ll.List[..r]) &&\n            (r == |ll.List| ==> 0 !in ll.List)\n{\n  if (ll == null) {\n    r := 0;\n  } else {\n    var jj,i := ll,0;\n    while (jj != null && jj.head != 0)\n      invariant jj != null ==>\n            jj.Valid() &&\n            i + |jj.List| == |ll.List| &&\n            ll.List[i..] == jj.List\n      invariant jj == null ==> i == |ll.List|\n      invariant 0 !in ll.List[..i]\n      decreases |ll.List| - i\n    {\n      jj := jj.next;\n      i := i + 1;\n    }\n    r := i;\n  }\n}\n\nmethod Main()\n{\n  var list: Node? := null;\n  list := list.Cons(0, list);\n  list := list.Cons(5, list);\n  list := list.Cons(0, list);\n  list := list.Cons(8, list);\n  var r := Search(list);\n  print \"Search returns \", r, \"\\n\";\n  assert r == 1;\n}\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  /* comment\n     /* nested comment\n     */\n     rest of outer comment\n  */\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  /* comment\n     /* nested comment\n     */\n     rest of outer comment\n  */\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  /* var i: int;\n     // */ line comment\n     var j: int;\n  */\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  /* var i: int;\n     // */ line comment\n     var j: int;\n  */\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  /* var i: int;\n     var s: string := \"a*/b\";\n     var j: int;\n   */\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  /* var i: int;\n     var s: string := \"a*/b\";\n     var j: int;\n   */\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "/* Just a comment */\nconst c0: int := 8 // docstring about c0\n// Just a comment\n\n/** docstring about c1 */\nnewtype c1 = x : int | x > 8 // Just a comment\n\n/* Just a comment */\nfunction c2(): (r: int) // Docstring about c2\n  ensures r > 0\n{ 8 } // Just a comment\n\n// just a comment\nconst c5 := 8\n",
        "description": null
      },
      {
        "language": "text",
        "code": "/* Just a comment */\nconst c0: int := 8 // docstring about c0\n// Just a comment\n\n/** docstring about c1 */\nnewtype c1 = x : int | x > 8 // Just a comment\n\n/* Just a comment */\nfunction c2(): (r: int) // Docstring about c2\n  ensures r > 0\n{ 8 } // Just a comment\n\n// just a comment\nconst c5 := 8\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype T // Docstring for T\n= | A(x: int,\n      y: int) // Docstring for A\n  | B()       /* Docstring for B */ |\n    C()       // Docstring for C\n\n/** Docstring for T0 */\ndatatype T0 =\n  | /** Docstring for A */\n    A(x: int,\n      y: int)\n  | /** Docstring for B */\n    B()\n  | /** Docstring for C */\n    C()\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype T // Docstring for T\n= | A(x: int,\n      y: int) // Docstring for A\n  | B()       /* Docstring for B */ |\n    C()       // Docstring for C\n\n/** Docstring for T0 */\ndatatype T0 =\n  | /** Docstring for A */\n    A(x: int,\n      y: int)\n  | /** Docstring for B */\n    B()\n  | /** Docstring for C */\n    C()\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\n  const A: int\n  const B: int\n  const C: int\n  const D: int\n\n  export\n    // This is the docstring of the eponymous export set intended for most clients\n    provides A, B, C\n\n  /** This is the docstring */\n  export AB provides A, B\n\n  export Friends extends AB\n    // This is the docstring of the export set is for clients who need to know more of the\n    // details of the module's definitions.\n    reveals A\n    provides D\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\n  const A: int\n  const B: int\n  const C: int\n  const D: int\n\n  export\n    // This is the docstring of the eponymous export set intended for most clients\n    provides A, B, C\n\n  /** This is the docstring */\n  export AB provides A, B\n\n  export Friends extends AB\n    // This is the docstring of the export set is for clients who need to know more of the\n    // details of the module's definitions.\n    reveals A\n    provides D\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var i: int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var i: int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "include \"MyProgram.dfy\"\ninclude @\"/home/me/MyFile.dfy\"\n",
        "description": null
      },
      {
        "language": "text",
        "code": "include \"MyProgram.dfy\"\ninclude @\"/home/me/MyFile.dfy\"\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module M { }\ntrait R { }\nclass C { }\ndatatype D = A | B\nnewtype pos = i: int | i >= 0\ntype T = i: int | 0 <= i < 100\nmethod m() {}\nfunction f(): int\nconst c: bool\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module M { }\ntrait R { }\nclass C { }\ndatatype D = A | B\nnewtype pos = i: int | i >= 0\ntype T = i: int | 0 <= i < 100\nmethod m() {}\nfunction f(): int\nconst c: bool\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module M {\n  class C {\n    static method m() {}\n  }\n}\nghost opaque const c : int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module M {\n  class C {\n    static method m() {}\n  }\n}\nghost opaque const c : int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module N  { }\nimport A\nexport A reveals f\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module N  { }\nimport A\nexport A reveals f\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module P { const i: int }\nabstract module A.Q { method m() {} }\nmodule M { module N { } }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module P { const i: int }\nabstract module A.Q { method m() {} }\nmodule M { module N { } }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Mod {\n  class C {\n    var f: int\n    method m()\n  }\n  datatype Option = A(int) | B(int)\n  type T\n  method m()\n  function f(): int\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Mod {\n  class C {\n    var f: int\n    method m()\n  }\n  datatype Option = A(int) | B(int)\n  type T\n  method m()\n  function f(): int\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Mod {\n  module Helpers {\n    class C {\n      method doIt()\n      var f: int\n    }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Mod {\n  module Helpers {\n    class C {\n      method doIt()\n      var f: int\n    }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Mod {\n  module Helpers {\n    class C {\n      constructor () { f := 0; }\n      method doIt()\n      var f: int\n    }\n  }\n  method m() {\n    var x := new Helpers.C();\n    x.doIt();\n    x.f := 4;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Mod {\n  module Helpers {\n    class C {\n      constructor () { f := 0; }\n      method doIt()\n      var f: int\n    }\n  }\n  method m() {\n    var x := new Helpers.C();\n    x.doIt();\n    x.f := 4;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Mod {\n  module Helpers {\n    function addOne(n: nat): nat {\n      n + 1\n    }\n  }\n  method m() {\n    var x := 5;\n    x := Helpers.addOne(x); // x is now 6\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Mod {\n  module Helpers {\n    function addOne(n: nat): nat {\n      n + 1\n    }\n  }\n  method m() {\n    var x := 5;\n    x := Helpers.addOne(x); // x is now 6\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n  module B {\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n  module B {\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n}\nmodule A.B {\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n}\nmodule A.B {\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "import A\nimport opened B\nimport A = B\nimport A : B\nimport A.B\nimport A`E\nimport X = A.B`{E,F}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "import A\nimport opened B\nimport A = B\nimport A : B\nimport A.B\nimport A`E\nimport X = A.B`{E,F}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Helpers {\n  function addOne(n: nat): nat {\n    n + 1\n  }\n}\nmodule Mod {\n  import A = Helpers\n  method m() {\n    assert A.addOne(5) == 6;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Helpers {\n  function addOne(n: nat): nat {\n    n + 1\n  }\n}\nmodule Mod {\n  import A = Helpers\n  method m() {\n    assert A.addOne(5) == 6;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module MyModule { } // declare MyModule\nimport MyModule  // error: cannot add a module named MyModule\n                 // because there already is one\nimport M = MyModule // OK. M and MyModule are equivalent\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module MyModule { } // declare MyModule\nimport MyModule  // error: cannot add a module named MyModule\n                 // because there already is one\nimport M = MyModule // OK. M and MyModule are equivalent\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Helpers {\n  function addOne(n: nat): nat {\n    n + 1\n  }\n}\nmodule Mod {\n  import opened Helpers\n  method m() {\n    assert addOne(5) == 6;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Helpers {\n  function addOne(n: nat): nat {\n    n + 1\n  }\n}\nmodule Mod {\n  import opened Helpers\n  method m() {\n    assert addOne(5) == 6;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Helpers {\n  function addOne(n: nat): nat {\n    n + 1\n  }\n}\nmodule Mod {\n  import opened H = Helpers\n  function addOne(n: nat): nat {\n    n - 1\n  }\n  method m() {\n    assert addOne(5) == 6; // this is now false,\n                           // as this is the function just defined\n    assert H.addOne(5) == 6; // this is still true\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Helpers {\n  function addOne(n: nat): nat {\n    n + 1\n  }\n}\nmodule Mod {\n  import opened H = Helpers\n  function addOne(n: nat): nat {\n    n - 1\n  }\n  method m() {\n    assert addOne(5) == 6; // this is now false,\n                           // as this is the function just defined\n    assert H.addOne(5) == 6; // this is still true\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module MyModule {  } // declares MyModule\nimport opened MyModule // does not declare a new module, but does\n                       // make all names in MyModule available in\n                       // the current scope, without needing\n                       // qualification\nimport opened M = MyModule // names in MyModule are available in\n                       // the current scope without qualification\n                       // or qualified with either M (because of this\n                       // import) or MyModule (because of the original\n                       // module definition)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module MyModule {  } // declares MyModule\nimport opened MyModule // does not declare a new module, but does\n                       // make all names in MyModule available in\n                       // the current scope, without needing\n                       // qualification\nimport opened M = MyModule // names in MyModule are available in\n                       // the current scope without qualification\n                       // or qualified with either M (because of this\n                       // import) or MyModule (because of the original\n                       // module definition)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Option {\n  const a := 1\n  datatype Option = A|B { static const a := 2 }\n}\n\nmodule X {\n  import opened Option\n  method M() { print Option.a; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Option {\n  const a := 1\n  datatype Option = A|B { static const a := 2 }\n}\n\nmodule X {\n  import opened Option\n  method M() { print Option.a; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "export E extends F reveals f,g provides g,h\nexport E reveals *\nexport reveals f,g provides g,h\nexport E\nexport E ... reveals f\n",
        "description": null
      },
      {
        "language": "text",
        "code": "export E extends F reveals f,g provides g,h\nexport E reveals *\nexport reveals f,g provides g,h\nexport E\nexport E ... reveals f\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n  const a := 10\n  const z := 10\n}\nmodule B {\n  import opened Z = A // includes a, declares Z\n  const b := Z.a // OK\n}\nmodule C {\n  import opened B // includes b, Z, but not a\n  method m() {\n    //assert b == a; // error: a is not known\n    //assert b == B.a; // error: B.a is not valid\n    //assert b == A.a; // error: A is not known\n    assert b == Z.a; // OK: module Z is known and includes a\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n  const a := 10\n  const z := 10\n}\nmodule B {\n  import opened Z = A // includes a, declares Z\n  const b := Z.a // OK\n}\nmodule C {\n  import opened B // includes b, Z, but not a\n  method m() {\n    //assert b == a; // error: a is not known\n    //assert b == B.a; // error: B.a is not valid\n    //assert b == A.a; // error: A is not known\n    assert b == Z.a; // OK: module Z is known and includes a\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\nexport\nleast predicate P() { true }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\nexport\nleast predicate P() { true }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n  export provides a\n  const a := 10\n  const b := 20\n}\n\nmodule B {\n  import A\n  method m() {\n    assert A.a == 10; // a is known, but not its value\n    // assert A.b == 20; // b is not known through A`A\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n  export provides a\n  const a := 10\n  const b := 20\n}\n\nmodule B {\n  import A\n  method m() {\n    assert A.a == 10; // a is known, but not its value\n    // assert A.b == 20; // b is not known through A`A\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n  export reveals a\n  const a := 10\n  const b := 20\n}\n\nmodule B {\n  import A\n  method m() {\n    assert A.a == 10; // a and its value are known\n    // assert A.b == 20; // b is not known through A`A\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n  export reveals a\n  const a := 10\n  const b := 20\n}\n\nmodule B {\n  import A\n  method m() {\n    assert A.a == 10; // a and its value are known\n    // assert A.b == 20; // b is not known through A`A\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": " declaration         | what is exported    | what is exported\n                     | with provides       | with reveals\n---------------------|---------------------|---------------------\n const x: X := E     | const x: X          | const x: X := E\n---------------------|---------------------|---------------------\n var x: X            | var x: X            | not allowed\n---------------------|---------------------|---------------------\n function F(x: X): Y | function F(x: X): Y | function F(x: X): Y\n   specification...  |   specification...  |   specification...\n {                   |                     | {\n   Body              |                     |   Body\n }                   |                     | }\n---------------------|---------------------|---------------------\n method M(x: X)      | method M(x: X)      | not allowed\n   returns (y: Y)    |   returns (y: Y)    |\n   specification...  |   specification...  |\n {                   |                     |\n   Body;             |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n type Opaque         | type Opaque         | type Opaque\n {                   |                     |\n   // members...     |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n type Synonym = T    | type Synonym        | type Synonym = T\n---------------------|---------------------|---------------------\n type S = x: X       | type S              | type S = x: X\n   | P witness E     |                     |   | P witness E\n---------------------|---------------------|---------------------\n newtype N = x: X    | type N              | newtype N = x: X\n   | P witness E     |                     |   | P witness E\n {                   |                     |\n   // members...     |                     |\n }                   |                     |\n",
        "description": null
      },
      {
        "language": "text",
        "code": " declaration         | what is exported    | what is exported\n                     | with provides       | with reveals\n---------------------|---------------------|---------------------\n const x: X := E     | const x: X          | const x: X := E\n---------------------|---------------------|---------------------\n var x: X            | var x: X            | not allowed\n---------------------|---------------------|---------------------\n function F(x: X): Y | function F(x: X): Y | function F(x: X): Y\n   specification...  |   specification...  |   specification...\n {                   |                     | {\n   Body              |                     |   Body\n }                   |                     | }\n---------------------|---------------------|---------------------\n method M(x: X)      | method M(x: X)      | not allowed\n   returns (y: Y)    |   returns (y: Y)    |\n   specification...  |   specification...  |\n {                   |                     |\n   Body;             |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n type Opaque         | type Opaque         | type Opaque\n {                   |                     |\n   // members...     |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n type Synonym = T    | type Synonym        | type Synonym = T\n---------------------|---------------------|---------------------\n type S = x: X       | type S              | type S = x: X\n   | P witness E     |                     |   | P witness E\n---------------------|---------------------|---------------------\n newtype N = x: X    | type N              | newtype N = x: X\n   | P witness E     |                     |   | P witness E\n {                   |                     |\n   // members...     |                     |\n }                   |                     |\n",
        "description": null
      },
      {
        "language": "text",
        "code": "---------------------|---------------------|---------------------\n datatype D =        | type D              | datatype D =\n     Ctor0(x0: X0)   |                     |    Ctor0(x0: X0)\n   | Ctor1(x1: X1)   |                     |  | Ctor1(x1: X1)\n   | ...             |                     |  | ...\n {                   |                     |\n   // members...     |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n class Cl            | type Cl             | class Cl\n   extends T0, ...   |                     |   extends T0, ...\n {                   |                     | {\n   constructor ()    |                     |   constructor ()\n     spec...         |                     |     spec...\n   {                 |                     |\n     Body;           |                     |\n   }                 |                     |\n   // members...     |                     |\n }                   |                     | }\n---------------------|---------------------|---------------------\n trait Tr            | type Tr             | trait Tr\n   extends T0, ...   |                     |   extends T0, ...\n {                   |                     |\n   // members...     |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n iterator Iter(x: X) | type Iter           | iterator Iter(x: X)\n   yields (y: Y)     |                     |   yields (y: Y)\n   specification...  |                     |   specification...\n {                   |                     |\n   Body;             |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n module SubModule    | module SubModule    | not allowed\n   ...               |   ...               |\n {                   | {                   |\n   export SubModule  |   export SubModule  |\n     ...             |     ...             |\n   export A ...      |                     |\n   // decls...       |   // decls...       |\n }                   | }                   |\n---------------------|---------------------|---------------------\n import L = MS       | import L = MS       | not allowed\n---------------------|---------------------|---------------------\n",
        "description": null
      },
      {
        "language": "text",
        "code": "---------------------|---------------------|---------------------\n datatype D =        | type D              | datatype D =\n     Ctor0(x0: X0)   |                     |    Ctor0(x0: X0)\n   | Ctor1(x1: X1)   |                     |  | Ctor1(x1: X1)\n   | ...             |                     |  | ...\n {                   |                     |\n   // members...     |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n class Cl            | type Cl             | class Cl\n   extends T0, ...   |                     |   extends T0, ...\n {                   |                     | {\n   constructor ()    |                     |   constructor ()\n     spec...         |                     |     spec...\n   {                 |                     |\n     Body;           |                     |\n   }                 |                     |\n   // members...     |                     |\n }                   |                     | }\n---------------------|---------------------|---------------------\n trait Tr            | type Tr             | trait Tr\n   extends T0, ...   |                     |   extends T0, ...\n {                   |                     |\n   // members...     |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n iterator Iter(x: X) | type Iter           | iterator Iter(x: X)\n   yields (y: Y)     |                     |   yields (y: Y)\n   specification...  |                     |   specification...\n {                   |                     |\n   Body;             |                     |\n }                   |                     |\n---------------------|---------------------|---------------------\n module SubModule    | module SubModule    | not allowed\n   ...               |   ...               |\n {                   | {                   |\n   export SubModule  |   export SubModule  |\n     ...             |     ...             |\n   export A ...      |                     |\n   // decls...       |   // decls...       |\n }                   | }                   |\n---------------------|---------------------|---------------------\n import L = MS       | import L = MS       | not allowed\n---------------------|---------------------|---------------------\n",
        "description": null
      },
      {
        "language": "text",
        "code": "trait Tr {\n  function F(x: int): int { 10 }\n  function G(x: int): int { 12 }\n  function H(x: int): int { 14 }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "trait Tr {\n  function F(x: int): int { 10 }\n  function G(x: int): int { 12 }\n  function H(x: int): int { 14 }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "trait Tr {\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "trait Tr {\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Tr {\n  function F(x: int): int\n  function H(x: int): int { 14 }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Tr {\n  function F(x: int): int\n  function H(x: int): int { 14 }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Library {\n  const xyz := 16\n}\n\nmodule M {\n  export\n    provides Lib\n    provides xyz // error: 'xyz' is not declared locally\n\n  import opened Lib = Library\n\n  const k0 := Lib.xyz\n  const k1 := xyz\n}\n\nmodule Client {\n  import opened M\n\n  const a0 := M.Lib.xyz\n  const a1 := Lib.xyz\n  const a2 := M.xyz // error: M does not have a declaration 'xyz'\n  const a3 := xyz // error: unresolved identifier 'xyz'\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Library {\n  const xyz := 16\n}\n\nmodule M {\n  export\n    provides Lib\n    provides xyz // error: 'xyz' is not declared locally\n\n  import opened Lib = Library\n\n  const k0 := Lib.xyz\n  const k1 := xyz\n}\n\nmodule Client {\n  import opened M\n\n  const a0 := M.Lib.xyz\n  const a1 := Lib.xyz\n  const a2 := M.xyz // error: M does not have a declaration 'xyz'\n  const a3 := xyz // error: unresolved identifier 'xyz'\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\n  const a := 10\n  const b := 10\n  const c := 10\n  export A reveals a\n  export B reveals b\n  export C extends A, B\n    reveals c\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\n  const a := 10\n  const b := 10\n  const c := 10\n  export A reveals a\n  export B reveals b\n  export C extends A, B\n    reveals c\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module Interface {\n  function addSome(n: nat): nat\n    ensures addSome(n) > n\n}\nabstract module Mod {\n  import A : Interface\n  method m() {\n    assert 6 <= A.addSome(5);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module Interface {\n  function addSome(n: nat): nat\n    ensures addSome(n) > n\n}\nabstract module Mod {\n  import A : Interface\n  method m() {\n    assert 6 <= A.addSome(5);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Implementation {\n  function addSome(n: nat): nat\n    ensures addSome(n) == n + 1\n  {\n    n + 1\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module Implementation {\n  function addSome(n: nat): nat\n    ensures addSome(n) == n + 1\n  {\n    n + 1\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module Interface {\n  function addSome(n: nat): nat\n    ensures addSome(n) > n\n}\nabstract module Mod {\n  import A : Interface\n  method m() {\n    assert 6 <= A.addSome(5);\n  }\n}\nmodule Implementation {\n  function addSome(n: nat): nat\n    ensures addSome(n) == n + 1\n  {\n    n + 1\n  }\n}\nmodule Mod2 refines Mod {\n  import A = Implementation\n  ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module Interface {\n  function addSome(n: nat): nat\n    ensures addSome(n) > n\n}\nabstract module Mod {\n  import A : Interface\n  method m() {\n    assert 6 <= A.addSome(5);\n  }\n}\nmodule Implementation {\n  function addSome(n: nat): nat\n    ensures addSome(n) == n + 1\n  {\n    n + 1\n  }\n}\nmodule Mod2 refines Mod {\n  import A = Implementation\n  ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "import A = B\nimport B = A // error: circular\n",
        "description": null
      },
      {
        "language": "text",
        "code": "import A = B\nimport B = A // error: circular\n",
        "description": null
      },
      {
        "language": "text",
        "code": "import A = B\nmethod m() {\n  A.whatever();\n}\nmodule B { method whatever() {} }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "import A = B\nmethod m() {\n  A.whatever();\n}\nmodule B { method whatever() {} }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method doIt() { }\nmodule M {\n  method m() {\n    doIt(); // error: M precedes doIt\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method doIt() { }\nmodule M {\n  method m() {\n    doIt(); // error: M precedes doIt\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n  const a := 10\n}\n\nmodule B refines A { // the top-level A, not the submodule A\n  module A { const a := 30 }\n  method m() { assert a == 10; } // true\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n  const a := 10\n}\n\nmodule B refines A { // the top-level A, not the submodule A\n  module A { const a := 30 }\n  method m() { assert a == 10; } // true\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A && B || C    // error\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A && B || C    // error\n",
        "description": null
      },
      {
        "language": "text",
        "code": "(A && B) || C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "(A && B) || C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A && (B || C)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A && (B || C)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A <==> B <==> C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A <==> B <==> C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A <==> (B <==> C)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A <==> (B <==> C)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "(A <==> B) <==> C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "(A <==> B) <==> C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A == B == C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A == B == C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A == B && B == C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A == B && B == C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A <==> B == C <==> D\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A <==> B == C <==> D\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A <==> (B == C) <==> D\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A <==> (B == C) <==> D\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A ==> B ==> C\nA ==> (B ==> C) // parentheses redundant, ==> is right associative\nC <== B <== A\n(C <== B) <== A // parentheses redundant, <== is left associative\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A ==> B ==> C\nA ==> (B ==> C) // parentheses redundant, ==> is right associative\nC <== B <== A\n(C <== B) <== A // parentheses redundant, <== is left associative\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a != null ==> 0 <= a.Length\n0 <= a.Length <== a != null\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a != null ==> 0 <= a.Length\n0 <= a.Length <== a != null\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a.Length < 0 ==> a == null  // not well-formed\na == null <== a.Length < 0  // not well-formed\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a.Length < 0 ==> a == null  // not well-formed\na == null <== a.Length < 0  // not well-formed\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a == null || 0 <= a.Length\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a == null || 0 <= a.Length\n",
        "description": null
      },
      {
        "language": "text",
        "code": "0 <= a.Length || a == null  // not well-formed\n",
        "description": null
      },
      {
        "language": "text",
        "code": "0 <= a.Length || a == null  // not well-formed\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const c1 := 1_000_000        // easier to read than 1000000\nconst c2 := 0_12_345_6789    // strange but legal formatting of 123456789\nconst c3 := 0x8000_0000      // same as 0x80000000 -- hex digits are\n                             // often placed in groups of 4\nconst c4 := 0.000_000_000_1  // same as 0.0000000001 -- 1 Angstrom\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const c1 := 1_000_000        // easier to read than 1000000\nconst c2 := 0_12_345_6789    // strange but legal formatting of 123456789\nconst c3 := 0x8000_0000      // same as 0x80000000 -- hex digits are\n                             // often placed in groups of 4\nconst c4 := 0.000_000_000_1  // same as 0.0000000001 -- 1 Angstrom\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A <= B < C == D <= E\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A <= B < C == D <= E\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A <= B && B < C && C == D && D <= E\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A <= B && B < C && C == D && D <= E\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A < B > C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A < B > C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a == a / b * b + a % b\n0 <= a % b < B\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a == a / b * b + a % b\n0 <= a % b < B\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(r: real, r': real) {\n  assert 3.14.Floor == 3;\n  assert (-2.5).Floor == -3;\n  assert -2.5.Floor == -2; // This is -(2.5.Floor)\n  assert r.Floor as real <= r;\n  assert r <= r' ==> r.Floor <= r'.Floor;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(r: real, r': real) {\n  assert 3.14.Floor == 3;\n  assert (-2.5).Floor == -3;\n  assert -2.5.Floor == -2; // This is -(2.5.Floor)\n  assert r.Floor as real <= r;\n  assert r <= r' ==> r.Floor <= r'.Floor;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FloatingPointLiterals() {\n  var exact: fp64 := 0.5;      // Exact: 0.5 = 2^(-1)\n  var approx: fp64 := ~0.1;    // Approximate: 0.1 cannot be exactly represented\n\n  // Scientific notation is supported\n  var large: fp64 := 1.23e10;  // 12300000000.0\n  var small: fp64 := ~1.5e-10; // Very small number\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FloatingPointLiterals() {\n  var exact: fp64 := 0.5;      // Exact: 0.5 = 2^(-1)\n  var approx: fp64 := ~0.1;    // Approximate: 0.1 cannot be exactly represented\n\n  // Scientific notation is supported\n  var large: fp64 := 1.23e10;  // 12300000000.0\n  var small: fp64 := ~1.5e-10; // Very small number\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method ClassificationExample() {\n  var nan := fp64.NaN;\n  var inf := fp64.PositiveInfinity;\n  var zero: fp64 := 0.0;\n  var normal: fp64 := 1.0;\n\n  assert nan.IsNaN;\n  assert inf.IsInfinite && inf.IsPositive;\n  assert zero.IsZero && zero.IsFinite;\n  assert normal.IsNormal && normal.IsFinite;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method ClassificationExample() {\n  var nan := fp64.NaN;\n  var inf := fp64.PositiveInfinity;\n  var zero: fp64 := 0.0;\n  var normal: fp64 := 1.0;\n\n  assert nan.IsNaN;\n  assert inf.IsInfinite && inf.IsPositive;\n  assert zero.IsZero && zero.IsFinite;\n  assert normal.IsNormal && normal.IsFinite;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FloatingPointArithmetic() {\n  var a: fp64 := ~0.1;\n  var b: fp64 := ~0.2;\n  var c: fp64 := ~0.3;\n\n  assert a + b != c;  // 0.1 + 0.2 != 0.3 due to rounding\n}\n\nmethod SafeArithmetic(x: fp64, y: fp64) returns (result: fp64)\n  requires !x.IsNaN && !y.IsNaN\n  requires !(x.IsInfinite && y.IsInfinite && x.IsPositive != y.IsPositive)\n{\n  result := x + y;  // OK: preconditions established\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FloatingPointArithmetic() {\n  var a: fp64 := ~0.1;\n  var b: fp64 := ~0.2;\n  var c: fp64 := ~0.3;\n\n  assert a + b != c;  // 0.1 + 0.2 != 0.3 due to rounding\n}\n\nmethod SafeArithmetic(x: fp64, y: fp64) returns (result: fp64)\n  requires !x.IsNaN && !y.IsNaN\n  requires !(x.IsInfinite && y.IsInfinite && x.IsPositive != y.IsPositive)\n{\n  result := x + y;  // OK: preconditions established\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method EqualityExample(x: fp64, y: fp64) {\n  var nan := fp64.NaN;\n  var posZero: fp64 := 0.0;\n  var negZero: fp64 := -0.0;\n\n  // In ghost context - no well-formedness restrictions\n  assert nan == nan;           // true (bitwise comparison)\n  assert posZero != negZero;   // true (different bit patterns)\n\n  // In compiled context - well-formedness restrictions verified statically\n  // var b1 := x == y;              // ERROR: verifier cannot prove x and y are not NaN\n  // var b2 := posZero == negZero;  // ERROR: verifier knows they have different signs\n\n  // Valid use of == when preconditions can be verified\n  if !x.IsNaN {\n    // Can compare posZero with x since we know posZero is not NaN,\n    // and if x is also zero, we'd need to check signs match\n    if !x.IsZero || !x.IsNegative {\n      var equal := posZero == x;  // OK: not NaN, and no sign mismatch\n      print \"0.0 == \", x, \": \", equal, \"\\n\";\n    }\n  }\n\n  // Simpler: just use fp64.Equal when unsure about values\n  var maybeNaN := if !x.IsNaN && x.IsNegative then fp64.NaN else x;\n  // var bad := maybeNaN == x;  // ERROR: cannot prove maybeNaN is not NaN\n  var safe := fp64.Equal(maybeNaN, x);  // Always works, no preconditions\n\n  // fp64.Equal always uses IEEE 754 semantics\n  assert !fp64.Equal(nan, nan);        // NaN != NaN\n  assert fp64.Equal(posZero, negZero); // ±0 are equal\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method EqualityExample(x: fp64, y: fp64) {\n  var nan := fp64.NaN;\n  var posZero: fp64 := 0.0;\n  var negZero: fp64 := -0.0;\n\n  // In ghost context - no well-formedness restrictions\n  assert nan == nan;           // true (bitwise comparison)\n  assert posZero != negZero;   // true (different bit patterns)\n\n  // In compiled context - well-formedness restrictions verified statically\n  // var b1 := x == y;              // ERROR: verifier cannot prove x and y are not NaN\n  // var b2 := posZero == negZero;  // ERROR: verifier knows they have different signs\n\n  // Valid use of == when preconditions can be verified\n  if !x.IsNaN {\n    // Can compare posZero with x since we know posZero is not NaN,\n    // and if x is also zero, we'd need to check signs match\n    if !x.IsZero || !x.IsNegative {\n      var equal := posZero == x;  // OK: not NaN, and no sign mismatch\n      print \"0.0 == \", x, \": \", equal, \"\\n\";\n    }\n  }\n\n  // Simpler: just use fp64.Equal when unsure about values\n  var maybeNaN := if !x.IsNaN && x.IsNegative then fp64.NaN else x;\n  // var bad := maybeNaN == x;  // ERROR: cannot prove maybeNaN is not NaN\n  var safe := fp64.Equal(maybeNaN, x);  // Always works, no preconditions\n\n  // fp64.Equal always uses IEEE 754 semantics\n  assert !fp64.Equal(nan, nan);        // NaN != NaN\n  assert fp64.Equal(posZero, negZero); // ±0 are equal\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method EdgeCaseTesting() {\n  var nan := fp64.NaN;\n  var inf := fp64.PositiveInfinity;\n\n  // These would fail with operators due to wellformedness checks:\n  // var bad1 := nan + 1.0;      // ERROR: fp64 arithmetic requires that operands are not NaN\n  // var bad2 := inf - inf;      // ERROR: fp64 subtraction has invalid operand combination\n  // var bad3 := nan < 1.0;      // ERROR: fp64 comparison requires that operands are not NaN\n\n  // But work with unchecked static methods:\n  var result1 := fp64.Add(nan, 1.0);\n  var result2 := fp64.Sub(inf, inf);\n  var result3 := fp64.Less(nan, 1.0);\n\n  assert result1.IsNaN;  // NaN propagates\n  assert result2.IsNaN;  // ∞ - ∞ = NaN\n  assert !result3;       // NaN < anything = false\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method EdgeCaseTesting() {\n  var nan := fp64.NaN;\n  var inf := fp64.PositiveInfinity;\n\n  // These would fail with operators due to wellformedness checks:\n  // var bad1 := nan + 1.0;      // ERROR: fp64 arithmetic requires that operands are not NaN\n  // var bad2 := inf - inf;      // ERROR: fp64 subtraction has invalid operand combination\n  // var bad3 := nan < 1.0;      // ERROR: fp64 comparison requires that operands are not NaN\n\n  // But work with unchecked static methods:\n  var result1 := fp64.Add(nan, 1.0);\n  var result2 := fp64.Sub(inf, inf);\n  var result3 := fp64.Less(nan, 1.0);\n\n  assert result1.IsNaN;  // NaN propagates\n  assert result2.IsNaN;  // ∞ - ∞ = NaN\n  assert !result3;       // NaN < anything = false\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method MathFunctions() {\n  var x: fp64 := -3.5;\n  var y: fp64 := 2.0;\n\n  var absX := fp64.Abs(x);\n  var sqrtY := fp64.Sqrt(y);\n  var minimum := fp64.Min(x, y);\n  var floored := fp64.Floor(x);\n  var ceiled := fp64.Ceiling(x);\n  var rounded := fp64.Round(2.5);  // Rounds to 2.0 (nearest even)\n\n  assert absX == 3.5;\n  assert sqrtY == ~1.4142135623730951;  // Approximate √2\n  assert minimum == x;\n  assert floored == -4.0;\n  assert ceiled == -3.0;\n  assert rounded == 2.0;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method MathFunctions() {\n  var x: fp64 := -3.5;\n  var y: fp64 := 2.0;\n\n  var absX := fp64.Abs(x);\n  var sqrtY := fp64.Sqrt(y);\n  var minimum := fp64.Min(x, y);\n  var floored := fp64.Floor(x);\n  var ceiled := fp64.Ceiling(x);\n  var rounded := fp64.Round(2.5);  // Rounds to 2.0 (nearest even)\n\n  assert absX == 3.5;\n  assert sqrtY == ~1.4142135623730951;  // Approximate √2\n  assert minimum == x;\n  assert floored == -4.0;\n  assert ceiled == -3.0;\n  assert rounded == 2.0;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method SpecialValueBehavior() {\n  var inf := fp64.PositiveInfinity;\n  var negInf := fp64.NegativeInfinity;\n\n  // Math functions work with infinity when preconditions are met\n  var sqrtInf := fp64.Sqrt(inf);        // Returns positive infinity\n  var absNegInf := fp64.Abs(negInf);    // Returns positive infinity\n  var minInf := fp64.Min(inf, negInf);  // Returns negative infinity\n\n  assert sqrtInf == fp64.PositiveInfinity;\n  assert absNegInf == fp64.PositiveInfinity;\n  assert minInf == fp64.NegativeInfinity;\n\n  // Well-formedness checks prevent invalid operations\n  // var sqrtNeg := fp64.Sqrt(-1.0);   // ERROR: negative input not allowed\n  // var floorNaN := fp64.Floor(fp64.NaN); // ERROR: NaN not allowed\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method SpecialValueBehavior() {\n  var inf := fp64.PositiveInfinity;\n  var negInf := fp64.NegativeInfinity;\n\n  // Math functions work with infinity when preconditions are met\n  var sqrtInf := fp64.Sqrt(inf);        // Returns positive infinity\n  var absNegInf := fp64.Abs(negInf);    // Returns positive infinity\n  var minInf := fp64.Min(inf, negInf);  // Returns negative infinity\n\n  assert sqrtInf == fp64.PositiveInfinity;\n  assert absNegInf == fp64.PositiveInfinity;\n  assert minInf == fp64.NegativeInfinity;\n\n  // Well-formedness checks prevent invalid operations\n  // var sqrtNeg := fp64.Sqrt(-1.0);   // ERROR: negative input not allowed\n  // var floorNaN := fp64.Floor(fp64.NaN); // ERROR: NaN not allowed\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method ConversionExamples() {\n  // Real to fp64\n  var r1: real := 0.5;\n  // var f1: fp64 := r1 as fp64;  // OK: 0.5 is exactly representable, but times out\n\n  var r2: real := 0.1;\n  // var f2: fp64 := r2 as fp64;  // ERROR: 0.1 is not exactly representable\n\n  // fp64 to real\n  var f3: fp64 := 42.5;\n  var r3: real := f3 as real;  // OK: finite value\n\n  // int to fp64\n  var i1: int := 42;\n  // var f4: fp64 := i1 as fp64;  // OK: 42 is exactly representable, but times out\n  var i2: int := 9007199254740992;  // 2^53\n  // var f5: fp64 := i2 as fp64;  // OK: 2^53 is exactly representable, but times out\n  var i3: int := 9007199254740993;  // 2^53 + 1\n  // var f6: fp64 := i3 as fp64;  // ERROR: 2^53 + 1 is not exactly representable\n\n  // fp64 to int\n  var f7: fp64 := 3.0;\n  var i4: int := f7 as int;  // OK: 3 is an integer\n\n  var f8: fp64 := ~3.14;\n  // var i5: int := f8 as int;  // ERROR: 3.14 is not an integer\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method ConversionExamples() {\n  // Real to fp64\n  var r1: real := 0.5;\n  // var f1: fp64 := r1 as fp64;  // OK: 0.5 is exactly representable, but times out\n\n  var r2: real := 0.1;\n  // var f2: fp64 := r2 as fp64;  // ERROR: 0.1 is not exactly representable\n\n  // fp64 to real\n  var f3: fp64 := 42.5;\n  var r3: real := f3 as real;  // OK: finite value\n\n  // int to fp64\n  var i1: int := 42;\n  // var f4: fp64 := i1 as fp64;  // OK: 42 is exactly representable, but times out\n  var i2: int := 9007199254740992;  // 2^53\n  // var f5: fp64 := i2 as fp64;  // OK: 2^53 is exactly representable, but times out\n  var i3: int := 9007199254740993;  // 2^53 + 1\n  // var f6: fp64 := i3 as fp64;  // ERROR: 2^53 + 1 is not exactly representable\n\n  // fp64 to int\n  var f7: fp64 := 3.0;\n  var i4: int := f7 as int;  // OK: 3 is an integer\n\n  var f8: fp64 := ~3.14;\n  // var i5: int := f8 as int;  // ERROR: 3.14 is not an integer\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method InexactConversions() {\n  // FromReal allows any real value and rounds as needed\n  var r1: real := 0.1;\n  var f1 := fp64.FromReal(r1);  // OK: rounds to nearest representable value\n\n  // Verification times out here\n  // var huge: real := 1e400;\n  // var f2 := fp64.FromReal(huge);  // Becomes positive infinity\n  // assert f2 == fp64.PositiveInfinity;\n\n  // ToInt truncates towards zero (Round Toward Zero - RTZ)\n  var f3: fp64 := 3.75;  // Exactly representable\n  var i1 := fp64.ToInt(f3);  // Returns 3\n  assert i1 == 3;\n\n  var f4: fp64 := -3.75;  // Exactly representable\n  var i2 := fp64.ToInt(f4);  // Returns -3 (truncates toward zero, not -4)\n  assert i2 == -3;\n}\n\n// This method demonstrates the precondition check\nmethod ToIntWellformednessExamples() {\n  var finite: fp64 := 42.5;\n  var i := fp64.ToInt(finite);  // OK: finite value\n  assert i == 42;\n\n  // The following would fail verification:\n  // var inf := fp64.PositiveInfinity;\n  // var i_inf := fp64.ToInt(inf);  // Error: requires finite argument\n\n  // var nan := fp64.NaN;\n  // var i_nan := fp64.ToInt(nan);  // Error: requires finite argument\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method InexactConversions() {\n  // FromReal allows any real value and rounds as needed\n  var r1: real := 0.1;\n  var f1 := fp64.FromReal(r1);  // OK: rounds to nearest representable value\n\n  // Verification times out here\n  // var huge: real := 1e400;\n  // var f2 := fp64.FromReal(huge);  // Becomes positive infinity\n  // assert f2 == fp64.PositiveInfinity;\n\n  // ToInt truncates towards zero (Round Toward Zero - RTZ)\n  var f3: fp64 := 3.75;  // Exactly representable\n  var i1 := fp64.ToInt(f3);  // Returns 3\n  assert i1 == 3;\n\n  var f4: fp64 := -3.75;  // Exactly representable\n  var i2 := fp64.ToInt(f4);  // Returns -3 (truncates toward zero, not -4)\n  assert i2 == -3;\n}\n\n// This method demonstrates the precondition check\nmethod ToIntWellformednessExamples() {\n  var finite: fp64 := 42.5;\n  var i := fp64.ToInt(finite);  // OK: finite value\n  assert i == 42;\n\n  // The following would fail verification:\n  // var inf := fp64.PositiveInfinity;\n  // var i_inf := fp64.ToInt(inf);  // Error: requires finite argument\n\n  // var nan := fp64.NaN;\n  // var i_nan := fp64.ToInt(nan);  // Error: requires finite argument\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const i: bv1 := 1\nconst j: bv8 := 195\nconst k: bv2 := 5 // error - out of range\nconst m := (194 as bv8) | (7 as bv8)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const i: bv1 := 1\nconst j: bv8 := 195\nconst k: bv2 := 5 // error - out of range\nconst m := (194 as bv8) | (7 as bv8)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const i: bv4 := 9\nconst j: bv4 := 3\n\nmethod m() {\n  assert (i & j) == (1 as bv4);\n  assert (i | j) == (11 as bv4);\n  assert (i ^ j) == (10 as bv4);\n  assert !i == (6 as bv4);\n  assert -i == (7 as bv4);\n  assert (i + i) == (2 as bv4);\n  assert (j - i) == (10 as bv4);\n  assert (i * j) == (11 as bv4);\n  assert (i as int) / (j as int) == 3;\n  assert (j << 1) == (6 as bv4);\n  assert (i << 1) == (2 as bv4);\n  assert (i >> 1) == (4 as bv4);\n  assert i == 9; // auto conversion of literal to bv4\n  assert i * 4 == j + 8 + 9; // arithmetic is modulo 16\n  assert i + j >> 1 == (i + j) >> 1; // + - bind tigher than << >>\n  assert i + j ^ 2 == i + (j^2);\n  assert i * j & 1 == i * (j&1); // & | ^ bind tighter than + - *\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const i: bv4 := 9\nconst j: bv4 := 3\n\nmethod m() {\n  assert (i & j) == (1 as bv4);\n  assert (i | j) == (11 as bv4);\n  assert (i ^ j) == (10 as bv4);\n  assert !i == (6 as bv4);\n  assert -i == (7 as bv4);\n  assert (i + i) == (2 as bv4);\n  assert (j - i) == (10 as bv4);\n  assert (i * j) == (11 as bv4);\n  assert (i as int) / (j as int) == 3;\n  assert (j << 1) == (6 as bv4);\n  assert (i << 1) == (2 as bv4);\n  assert (i >> 1) == (4 as bv4);\n  assert i == 9; // auto conversion of literal to bv4\n  assert i * 4 == j + 8 + 9; // arithmetic is modulo 16\n  assert i + j >> 1 == (i + j) >> 1; // + - bind tigher than << >>\n  assert i + j ^ 2 == i + (j^2);\n  assert i * j & 1 == i * (j&1); // & | ^ bind tighter than + - *\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const i: bv4 := 9\nconst j: bv4 := 3\n\nmethod m() {\n  assert i & 4 | j == 0 ; // parentheses required\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const i: bv4 := 9\nconst j: bv4 := 3\n\nmethod m() {\n  assert i & 4 | j == 0 ; // parentheses required\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const k: bv4 := 9\n\nmethod p() {\n  assert k as bv5 == 9 as bv6; // error: mismatched types\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const k: bv4 := 9\n\nmethod p() {\n  assert k as bv5 == 9 as bv6; // error: mismatched types\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const i: bv4 := 9\n\nmethod m() {\n  assert i as bv3 == 1; // error: i is out of range for bv3\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const i: bv4 := 9\n\nmethod m() {\n  assert i as bv3 == 1; // error: i is out of range for bv3\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const j: bv4 := 9\n\nmethod n() {\n  assert j == 25; // error: 25 is out of range for bv4\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const j: bv4 := 9\n\nmethod n() {\n  assert j == 25; // error: 25 is out of range for bv4\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const a: bv3 := -1\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const a: bv3 := -1\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const b: bv3 := 6 & 11\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const b: bv3 := 6 & 11\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type G1<T>\ntype G2<T(0)>\ntype G3<+T(==),-U>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type G1<T>\ntype G2<T(0)>\ntype G3<+T(==),-U>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A<T(00)> {}\ntype Q\nconst a: A<Q>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A<T(00)> {}\ntype Q\nconst a: A<Q>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A<T(00)> {}\ntype Q(00)\nconst a: A?<Q> := null\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A<T(00)> {}\ntype Q(00)\nconst a: A?<Q> := null\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Compare<T(==)>(a: T, b: T) returns (eq: bool)\n{\n  if a == b { eq := true; } else { eq := false; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Compare<T(==)>(a: T, b: T) returns (eq: bool)\n{\n  if a == b { eq := true; } else { eq := false; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Example<A(0), X> {\n  var n: nat\n  var i: int\n  var a: A\n  var x: X\n\n  constructor () {\n    new; // error: field 'x' has not been given a value`\n    assert n >= 0; // true, regardless of the value of 'n'\n    assert i >= 0; // possibly false, since an arbitrary 'int' may be negative\n    // 'a' does not require an explicit initialization, since 'A' is auto-init\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Example<A(0), X> {\n  var n: nat\n  var i: int\n  var a: A\n  var x: X\n\n  constructor () {\n    new; // error: field 'x' has not been given a value`\n    assert n >= 0; // true, regardless of the value of 'n'\n    assert i >= 0; // possibly false, since an arbitrary 'int' may be negative\n    // 'a' does not require an explicit initialization, since 'A' is auto-init\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  var n: nat; // Auto-initialized to an arbitrary value of type `nat`\n  assert n >= 0; // true, regardless of the value of n\n  var i: int;\n  assert i >= 0; // possibly false, arbitrary ints may be negative\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  var n: nat; // Auto-initialized to an arbitrary value of type `nat`\n  assert n >= 0; // true, regardless of the value of n\n  var i: int;\n  assert i >= 0; // possibly false, arbitrary ints may be negative\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method AutoInitExamples<A(0), X>() returns (a: A, x: X)\n{\n  // 'a' does not require an explicit initialization, since A is auto-init\n  // error: out-parameter 'x' has not been given a value\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method AutoInitExamples<A(0), X>() returns (a: A, x: X)\n{\n  // 'a' does not require an explicit initialization, since A is auto-init\n  // error: out-parameter 'x' has not been given a value\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NonemptyExamples<B(00), X>() returns (b: B, ghost g: B, ghost h: X)\n{\n  // error: non-ghost out-parameter 'b' has not been given a value\n  // ghost out-parameter 'g' is fine, since its type is nonempty\n  // error: 'h' has not been given a value\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NonemptyExamples<B(00), X>() returns (b: B, ghost g: B, ghost h: X)\n{\n  // error: non-ghost out-parameter 'b' has not been given a value\n  // ghost out-parameter 'g' is fine, since its type is nonempty\n  // error: 'h' has not been given a value\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Result<T> = Failure(error: string) | Success(value: T)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Result<T> = Failure(error: string) | Success(value: T)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Result<T> = Failure(error: string) | Success(v: T)\ndatatype ResultN<T(!new)> = Failure(error: string) | Success(v: T)\n\nclass C {}\n\nmethod m() {\n  var x1: Result<int>;\n  var x2: ResultN<int>;\n  var x3: Result<C>;\n  var x4: ResultN<C>; // error\n  var x5: Result<array<int>>;\n  var x6: ResultN<array<int>>; // error\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Result<T> = Failure(error: string) | Success(v: T)\ndatatype ResultN<T(!new)> = Failure(error: string) | Success(v: T)\n\nclass C {}\n\nmethod m() {\n  var x1: Result<int>;\n  var x2: ResultN<int>;\n  var x3: Result<C>;\n  var x4: ResultN<C>; // error\n  var x5: Result<array<int>>;\n  var x6: ResultN<array<int>>; // error\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type T<!X> = X -> bool\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type T<!X> = X -> bool\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{}        {2, 7, 5, 3}        {4+2, 1+5, a*b}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{}        {2, 7, 5, 3}        {4+2, 1+5, a*b}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A * B == {}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A * B == {}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A * B == {} && (A + B) * C == {} && (A + B + C) * D == {}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A * B == {} && (A + B) * C == {} && (A + B + C) * D == {}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "multiset{}   multiset{0, 1, 1, 2, 3, 5}   multiset{4+2, 1+5, a*b}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "multiset{}   multiset{0, 1, 1, 2, 3, 5}   multiset{4+2, 1+5, a*b}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A * B == multiset{}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A * B == multiset{}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if e in s then s[e := s[e] - 1] else s\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if e in s then s[e := s[e] - 1] else s\n",
        "description": null
      },
      {
        "language": "text",
        "code": "[]        [3, 1, 4, 1, 5, 9, 3]        [4+2, 1+5, a*b]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "[]        [3, 1, 4, 1, 5, 9, 3]        [4+2, 1+5, a*b]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "seq(5, i => i*i)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "seq(5, i => i*i)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(s: seq<int>) {\n  var t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3];\n  assert |t| == 3 && t[0] == [3.14] && t[1] == [];\n  assert t[2] == [2.7, 1.41, 1985.44];\n  var u := [true, false, false, true][1:1:];\n  assert |u| == 3 && u[0][0] && !u[1][0] && u[2] == [false, true];\n  assume |s| > 10;\n  assert s[10:][0] == s[..10];\n  assert s[10:][1] == s[10..];\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(s: seq<int>) {\n  var t := [3.14, 2.7, 1.41, 1985.44, 100.0, 37.2][1:0:3];\n  assert |t| == 3 && t[0] == [3.14] && t[1] == [];\n  assert t[2] == [2.7, 1.41, 1985.44];\n  var u := [true, false, false, true][1:1:];\n  assert |u| == 3 && u[0][0] && !u[1][0] && u[2] == [false, true];\n  assume |s| > 10;\n  assert s[10:][0] == s[..10];\n  assert s[10:][1] == s[10..];\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "\"C:\\\\tmp.txt\"\n@\"C:\\tmp.txt\"\n['C', ':', '\\\\', 't', 'm', 'p', '.', 't', 'x', 't']\n",
        "description": null
      },
      {
        "language": "text",
        "code": "\"C:\\\\tmp.txt\"\n@\"C:\\tmp.txt\"\n['C', ':', '\\\\', 't', 'm', 'p', '.', 't', 'x', 't']\n",
        "description": null
      },
      {
        "language": "text",
        "code": "map[]\nmap[20 := true, 3 := false, 20 := false]\nmap[a+b := c+d]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "map[]\nmap[20 := true, 3 := false, 20 := false]\nmap[a+b := c+d]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if K in cache {  // check if temperature is in domain of cache\n  coeff := cache[K];  // read result in cache\n} else {\n  coeff := ComputeJTCoefficient(K); // do expensive computation\n  cache := cache[K := coeff];  // update the cache\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if K in cache {  // check if temperature is in domain of cache\n  coeff := cache[K];  // read result in cache\n} else {\n  coeff := ComputeJTCoefficient(K); // do expensive computation\n  cache := cache[K := coeff];  // update the cache\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method mmm<K(==),V(==)>(m: map<K,V>, k: K, v: V) {\n    var mm := m[k := v];\n    assert v in mm.Values;\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method mmm<K(==),V(==)>(m: map<K,V>, k: K, v: V) {\n    var mm := m[k := v];\n    assert v in mm.Values;\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method mmm<K(==),V(==)>(m: map<K,V>, k: K, v: V) {\n    var mm := m[k := v];\n    assert k in mm.Keys;\n    assert v in mm.Values;\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method mmm<K(==),V(==)>(m: map<K,V>, k: K, v: V) {\n    var mm := m[k := v];\n    assert k in mm.Keys;\n    assert v in mm.Values;\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(a: array<int>) {\n  var i := 0;\n  var sum := 0;\n  while i < a.Length {\n    sum := sum + a[i];\n    i := i + 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(a: array<int>) {\n  var i := 0;\n  var sum := 0;\n  while i < a.Length {\n    sum := sum + a[i];\n    i := i + 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(s: seq<int>) {\n  var i := 0;\n  var sum := 0;\n  while i < |s| {\n    sum := sum + s[i];\n    i := i + 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(s: seq<int>) {\n  var i := 0;\n  var sum := 0;\n  while i < |s| {\n    sum := sum + s[i];\n    i := i + 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(s: array<int>) {\n  var rev := new int[s.Length];\n  forall i | 0 <= i < s.Length {\n    rev[i] := s[s.Length-i-1];\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(s: array<int>) {\n  var rev := new int[s.Length];\n  forall i | 0 <= i < s.Length {\n    rev[i] := s[s.Length-i-1];\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(s: set<int>) {\n  var ss := s;\n  while ss != {}\n    decreases |ss|\n  {\n    var i: int :| i in ss;\n    ss := ss - {i};\n    print i, \"\\n\";\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(s: set<int>) {\n  var ss := s;\n  while ss != {}\n    decreases |ss|\n  {\n    var i: int :| i in ss;\n    ss := ss - {i};\n    print i, \"\\n\";\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m<T(==),U(==)> (m: map<T,U>) {\n  var items := m.Items;\n  while items != {}\n    decreases |items|\n  {\n    var item :| item in items;\n    items := items - { item };\n    print item.0, \" \", item.1, \"\\n\";\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m<T(==),U(==)> (m: map<T,U>) {\n  var items := m.Items;\n  while items != {}\n    decreases |items|\n  {\n    var item :| item in items;\n    items := items - { item };\n    print item.0, \" \", item.1, \"\\n\";\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type T = int\ntype SS<T> = set<set<T>>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type T = int\ntype SS<T> = set<set<T>>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Y<T> = G\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Y<T> = G\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Replacements<T> = map<T,T>\ntype Vertex = int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Replacements<T> = map<T,T>\ntype Vertex = int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Z(==)<T(0)>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Z(==)<T(0)>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type string_(==,0,!new) = seq<char>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type string_(==,0,!new) = seq<char>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Pair<T> = Pair(first: T, second: T)\ntype IntPair = Pair<int>\n\nconst p: IntPair := Pair(1,2) // OK\nconst q: IntPair := IntPair(3,4) // Error\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Pair<T> = Pair(first: T, second: T)\ntype IntPair = Pair<int>\n\nconst p: IntPair := Pair(1,2) // OK\nconst q: IntPair := IntPair(3,4) // Error\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type T\ntype Q { function toString(t: T): string }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type T\ntype Q { function toString(t: T): string }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Y<T>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Y<T>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type T\nfunction F(t: T): T\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type T\nfunction F(t: T): T\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Monad<T>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Monad<T>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module P {\n  type T {\n    function ToString(): string\n  }\n}\n\nmodule X refines P {\n  newtype T = i | 0 <= i < 10 {\n    function ToString(): string {  \"\" }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module P {\n  type T {\n    function ToString(): string\n  }\n}\n\nmodule X refines P {\n  newtype T = i | 0 <= i < 10 {\n    function ToString(): string {  \"\" }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Pos = i: int | i > 0 witness 1\ntype PosReal = r | r > 0.0 witness 1.0\ntype Empty = n: nat | n < 0 witness *\ntype Big = n: nat | n > 1000 ghost witness 10000\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type Pos = i: int | i > 0 witness 1\ntype PosReal = r | r > 0.0 witness 1.0\ntype Empty = n: nat | n < 0 witness *\ntype Big = n: nat | n > 1000 ghost witness 10000\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type nat = n: int | 0 <= n\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type nat = n: int | 0 <= n\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Fib(n: nat): nat\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Fib(n: nat): nat\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Fib(n: int): int\n  requires 0 <= n  // the function argument must be non-negative\n  ensures 0 <= Fib(n)  // the function result is non-negative\n{\n  if n < 2 then n else Fib(n - 2) + Fib(n - 1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Fib(n: int): int\n  requires 0 <= n  // the function argument must be non-negative\n  ensures 0 <= Fib(n)  // the function result is non-negative\n{\n  if n < 2 then n else Fib(n - 2) + Fib(n - 1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type C = c: C? | c != null\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type C = c: C? | c != null\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type A --> B = f: A ~> B | forall a :: f.reads(a) == {}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type A --> B = f: A ~> B | forall a :: f.reads(a) == {}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type -A --> +B = f: A ~> B | forall a :: f.reads(a) == {}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type -A --> +B = f: A ~> B | forall a :: f.reads(a) == {}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type -A -> +B = f: A --> B | forall a :: f.requires(a)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type -A -> +B = f: A --> B | forall a :: f.requires(a)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type OddInt = x: int | x % 2 == 1\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type OddInt = x: int | x % 2 == 1\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type OddInt = x: int | x % 2 == 1 witness 73\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type OddInt = x: int | x % 2 == 1 witness 73\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type NonEmptySeq = x: seq<int> | |x| > 0 witness [0]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type NonEmptySeq = x: seq<int> | |x| > 0 witness [0]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type BaseType\npredicate RHS(x: BaseType)\ntype MySubset = x: BaseType | RHS(x) ghost witness MySubsetWitness()\n\nfunction {:axiom} MySubsetWitness(): BaseType\n  ensures RHS(MySubsetWitness())\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type BaseType\npredicate RHS(x: BaseType)\ntype MySubset = x: BaseType | RHS(x) ghost witness MySubsetWitness()\n\nfunction {:axiom} MySubsetWitness(): BaseType\n  ensures RHS(MySubsetWitness())\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type ReallyEmpty = x: int | false witness *\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type ReallyEmpty = x: int | false witness *\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method M(x: ReallyEmpty) returns (seven: int)\n  ensures seven == 7\n{\n  seven := 10;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method M(x: ReallyEmpty) returns (seven: int)\n  ensures seven == 7\n{\n  seven := 10;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method P() returns (seven: int)\n  ensures seven == 7\n{\n  var x: ReallyEmpty;\n  seven := 10;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method P() returns (seven: int)\n  ensures seven == 7\n{\n  var x: ReallyEmpty;\n  seven := 10;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype I = int\nnewtype D = i: int | 0 <= i < 10\nnewtype uint8 = i | 0 <= i < 256\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype I = int\nnewtype D = i: int | 0 <= i < 10\nnewtype uint8 = i | 0 <= i < 256\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype N = x: M | Q\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype N = x: M | Q\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype N = M\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype N = M\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var mid := (lo + hi) / 2;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var mid := (lo + hi) / 2;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype int32 = x | -0x8000_0000 <= x < 0x8000_0000\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype int32 = x | -0x8000_0000 <= x < 0x8000_0000\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var mid := lo + (hi - lo) / 2;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var mid := lo + (hi - lo) / 2;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var mid := lo + (hi/2 - lo/2);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var mid := lo + (hi/2 - lo/2);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype int8 = x: int | -128 <= x < 128\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype int8 = x: int | -128 <= x < 128\n",
        "description": null
      },
      {
        "language": "text",
        "code": "-128 <= c < 128\n",
        "description": null
      },
      {
        "language": "text",
        "code": "-128 <= c < 128\n",
        "description": null
      },
      {
        "language": "text",
        "code": "-128 <= c as int < 128\n",
        "description": null
      },
      {
        "language": "text",
        "code": "-128 <= c as int < 128\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var mid := (lo as int + hi as int) / 2;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var mid := (lo as int + hi as int) / 2;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var mid := ((lo as int + hi as int) / 2) as int32;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var mid := ((lo as int + hi as int) / 2) as int32;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "trait T {}\nclass A {}\nclass B extends T {\n  const b: B?\n  var v: int\n  constructor (vv: int) { v := vv; b := null; }\n  function toString(): string { \"a B\" }\n  method m(i: int) { var x := new B(0); }\n  static method q() {}\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "trait T {}\nclass A {}\nclass B extends T {\n  const b: B?\n  var v: int\n  constructor (vv: int) { v := vv; b := null; }\n  function toString(): string { \"a B\" }\n  method m(i: int) { var x := new B(0); }\n  static method q() {}\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C<T> extends J1, ..., Jn\n{\n  _members_\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C<T> extends J1, ..., Jn\n{\n  _members_\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C {\n  var f: int\n  var x: int\n  method Example() returns (b: bool)\n  {\n    var x: int;\n    b := f == this.f;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C {\n  var f: int\n  var x: int\n  method Example() returns (b: bool)\n  {\n    var x: int;\n    b := f == this.f;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c := new C;\nc := new C.Init(args);\nc := new C(args);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c := new C;\nc := new C.Init(args);\nc := new C(args);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c := new C;\nc.Init(args);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c := new C;\nc.Init(args);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "trait J\n{\n  _members_\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "trait J\n{\n  _members_\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "trait Shape extends object\n{\n  function Width(): real\n    reads this\n    decreases 1\n  method Move(dx: real, dy: real)\n    modifies this\n  method MoveH(dx: real)\n    modifies this\n  {\n    Move(dx, 0.0);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "trait Shape extends object\n{\n  function Width(): real\n    reads this\n    decreases 1\n  method Move(dx: real, dy: real)\n    modifies this\n  method MoveH(dx: real)\n    modifies this\n  {\n    Move(dx, 0.0);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class UnitSquare extends Shape\n{\n  var x: real, y: real\n  function Width(): real\n    decreases 0\n  {  // note the empty reads clause\n    1.0\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    x, y := x + dx, y + dy;\n  }\n}\n\nclass LowerRightTriangle extends Shape\n{\n  var xNW: real, yNW: real, xSE: real, ySE: real\n  function Width(): real\n    reads this\n    decreases 0\n  {\n    xSE - xNW\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    xNW, yNW, xSE, ySE := xNW + dx, yNW + dy, xSE + dx, ySE + dy;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class UnitSquare extends Shape\n{\n  var x: real, y: real\n  function Width(): real\n    decreases 0\n  {  // note the empty reads clause\n    1.0\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    x, y := x + dx, y + dy;\n  }\n}\n\nclass LowerRightTriangle extends Shape\n{\n  var xNW: real, yNW: real, xSE: real, ySE: real\n  function Width(): real\n    reads this\n    decreases 0\n  {\n    xSE - xNW\n  }\n  method Move(dx: real, dy: real)\n    modifies this\n  {\n    xNW, yNW, xSE, ySE := xNW + dx, yNW + dy, xSE + dx, ySE + dy;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  var myShapes: seq<Shape>;\n  var A := new UnitSquare;\n  myShapes := [A];\n  var tri := new LowerRightTriangle;\n  // myShapes contains two Shape values, of different classes\n  myShapes := myShapes + [tri];\n  // move shape 1 to the right by the width of shape 0\n  myShapes[1].MoveH(myShapes[0].Width());\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  var myShapes: seq<Shape>;\n  var A := new UnitSquare;\n  myShapes := [A];\n  var tri := new LowerRightTriangle;\n  // myShapes contains two Shape values, of different classes\n  myShapes := myShapes + [tri];\n  // move shape 1 to the right by the width of shape 0\n  myShapes[1].MoveH(myShapes[0].Width());\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type T(0)\nmethod m(n: nat) {\n  var a := new T[n];\n  var b: array<int> := new int[8];\n  var c: array := new T[9];\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type T(0)\nmethod m(n: nat) {\n  var a := new T[n];\n  var b: array<int> := new int[8];\n  var c: array := new T[9];\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a := new T[] [t1, t2, t3, t4];\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a := new T[] [t1, t2, t3, t4];\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a := new int[5](i => i*i);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a := new int[5](i => i*i);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a := new int[5](Square);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a := new int[5](Square);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a.Length == n\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a.Length == n\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a[i] := t;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a[i] := t;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type T(0)\nmethod m(n: nat) {\n  var a := new array<T>;\n  var b := new array<T>[n];\n  var c := new array<T>(n);  // resolution error\n  var d := new array(n);  // resolution error\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type T(0)\nmethod m(n: nat) {\n  var a := new array<T>;\n  var b := new array<T>[n];\n  var c := new array<T>(n);  // resolution error\n  var d := new array(n);  // resolution error\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "key !in a[..lo] && key !in a[hi..]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "key !in a[..lo] && key !in a[hi..]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a[lo..hi] == old(a[lo..hi])\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a[lo..hi] == old(a[lo..hi])\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost var prevElements := a[..];\nwhile // ...\n  invariant a[lo..hi] == prevElements[lo..hi]\n{\n  // ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost var prevElements := a[..];\nwhile // ...\n  invariant a[lo..hi] == prevElements[lo..hi]\n{\n  // ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "multiset(a[..]) == multiset(old(a[..]))\n",
        "description": null
      },
      {
        "language": "text",
        "code": "multiset(a[..]) == multiset(old(a[..]))\n",
        "description": null
      },
      {
        "language": "text",
        "code": "matrix := new T[m, n];\nmatrix[i, j], matrix[x, y] := matrix[x, y], matrix[i, j];\n",
        "description": null
      },
      {
        "language": "text",
        "code": "matrix := new T[m, n];\nmatrix[i, j], matrix[x, y] := matrix[x, y], matrix[i, j];\n",
        "description": null
      },
      {
        "language": "text",
        "code": "matrix.Length0 == m && matrix.Length1 == n\n",
        "description": null
      },
      {
        "language": "text",
        "code": "matrix.Length0 == m && matrix.Length1 == n\n",
        "description": null
      },
      {
        "language": "text",
        "code": "0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 &&\n0 <= x < matrix.Length0 && 0 <= y < matrix.Length1\n",
        "description": null
      },
      {
        "language": "text",
        "code": "0 <= i < matrix.Length0 && 0 <= j < matrix.Length1 &&\n0 <= x < matrix.Length0 && 0 <= y < matrix.Length1\n",
        "description": null
      },
      {
        "language": "text",
        "code": "iterator Iter<T>(_in-params_) yields (_yield-params_)\n  _specification_\n{\n  _body_\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "iterator Iter<T>(_in-params_) yields (_yield-params_)\n  _specification_\n{\n  _body_\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate Valid()\nconstructor (_in-params_)\n  modifies this\n  ensures Valid()\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate Valid()\nconstructor (_in-params_)\n  modifies this\n  ensures Valid()\n",
        "description": null
      },
      {
        "language": "text",
        "code": "iterator Gen(start: int) yields (x: int)\n  yield ensures |xs| <= 10 && x == start + |xs| - 1\n{\n  var i := 0;\n  while i < 10 invariant |xs| == i {\n    x := start + i;\n    yield;\n    i := i + 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "iterator Gen(start: int) yields (x: int)\n  yield ensures |xs| <= 10 && x == start + |xs| - 1\n{\n  var i := 0;\n  while i < 10 invariant |xs| == i {\n    x := start + i;\n    yield;\n    i := i + 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "iter := new Gen(30);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "iter := new Gen(30);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Main() {\n  var i := new Gen(30);\n  while true\n    invariant i.Valid() && fresh(i._new)\n    decreases 10 - |i.xs|\n  {\n    var m := i.MoveNext();\n    if (!m) {break; }\n    print i.x;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Main() {\n  var i := new Gen(30);\n  while true\n    invariant i.Valid() && fresh(i._new)\n    decreases 10 - |i.xs|\n  {\n    var m := i.MoveNext();\n    if (!m) {break; }\n    print i.x;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method MoveNext() returns (more: bool)\n  requires Valid()\n  modifies this\n  ensures more ==> Valid()\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method MoveNext() returns (more: bool)\n  requires Valid()\n  modifies this\n  ensures more ==> Valid()\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const start: int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const start: int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var x: int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var x: int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost var xs: seq<int>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost var xs: seq<int>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost var _reads: set<object>\nghost var _modifies: set<object>\nghost var _decreases0: T0\nghost var _decreases1: T1\n// ...\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost var _reads: set<object>\nghost var _modifies: set<object>\nghost var _decreases0: T0\nghost var _decreases1: T1\n// ...\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost var _new: set<object>;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost var _new: set<object>;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "iterator Iter<T(0)>(s: set<T>) yields (x: T)\n  yield ensures x in s && x !in xs[..|xs|-1]\n  ensures s == set z | z in xs\n{\n  var r := s;\n  while (r != {})\n    invariant r !! set z | z in xs\n    invariant s == r + set z | z in xs\n  {\n    var y :| y in r;\n    assert y !in xs;\n    r, x := r - {y}, y;\n    assert y !in xs;\n    yield;\n    assert y == xs[|xs|-1]; // a lemma to help prove loop invariant\n  }\n}\n\nmethod UseIterToCopy<T(0)>(s: set<T>) returns (t: set<T>)\n  ensures s == t\n{\n  t := {};\n  var m := new Iter(s);\n  while (true)\n    invariant m.Valid() && fresh(m._new)\n    invariant t == set z | z in m.xs\n    decreases s - t\n  {\n    var more := m.MoveNext();\n    if (!more) { break; }\n    t := t + {m.x};\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "iterator Iter<T(0)>(s: set<T>) yields (x: T)\n  yield ensures x in s && x !in xs[..|xs|-1]\n  ensures s == set z | z in xs\n{\n  var r := s;\n  while (r != {})\n    invariant r !! set z | z in xs\n    invariant s == r + set z | z in xs\n  {\n    var y :| y in r;\n    assert y !in xs;\n    r, x := r - {y}, y;\n    assert y !in xs;\n    yield;\n    assert y == xs[|xs|-1]; // a lemma to help prove loop invariant\n  }\n}\n\nmethod UseIterToCopy<T(0)>(s: set<T>) returns (t: set<T>)\n  ensures s == t\n{\n  t := {};\n  var m := new Iter(s);\n  while (true)\n    invariant m.Valid() && fresh(m._new)\n    invariant t == set z | z in m.xs\n    decreases s - t\n  {\n    var more := m.MoveNext();\n    if (!more) { break; }\n    t := t + {m.x};\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "(int) -> int\n(bool,int) ~> bool\n() --> object?\n",
        "description": null
      },
      {
        "language": "text",
        "code": "(int) -> int\n(bool,int) ~> bool\n() --> object?\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function F(x: int, arr: array<bool>): real\n  requires x < 1000\n  reads arr\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function F(x: int, arr: array<bool>): real\n  requires x < 1000\n  reads arr\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function F(x: int, b: bool): real\n  requires x < 1000\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function F(x: int, b: bool): real\n  requires x < 1000\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function F(x: int, b: bool): real\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function F(x: int, b: bool): real\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function G(pair: (int, bool)): real\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function G(pair: (int, bool)): real\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function NoArgs(): real\nfunction Z(unit: ()): real\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function NoArgs(): real\nfunction Z(unit: ()): real\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var f: (int, bool) -> real := c.F;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var f: (int, bool) -> real := c.F;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var f': (C, int, bool) -> real := F;  // not correct\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var f': (C, int, bool) -> real := F;  // not correct\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function F(x: int, ghost y: int): int\n{\n  x\n}\n\nmethod Example() {\n  ghost var f: (int, int) -> int;\n  var g: (int, int) -> int;\n  var h: (int) -> int;\n  var x: int;\n  f := F;\n  x := F(20, 30);\n  g := F; // error: tries to assign ghost to non-ghost\n  h := F; // error: wrong arity (and also tries to assign ghost to non-ghost)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function F(x: int, ghost y: int): int\n{\n  x\n}\n\nmethod Example() {\n  ghost var f: (int, int) -> int;\n  var g: (int, int) -> int;\n  var h: (int) -> int;\n  var x: int;\n  f := F;\n  x := F(20, 30);\n  g := F; // error: tries to assign ghost to non-ghost\n  h := F; // error: wrong arity (and also tries to assign ghost to non-ghost)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function f<T,U>(x: T): U\n  reads R(x)\n  requires P(x)\n{\n  body(x)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function f<T,U>(x: T): U\n  reads R(x)\n  requires P(x)\n{\n  body(x)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate P<T>(x: T)\nfunction R<T>(x: T): set<object>\nfunction body<T,U>(x: T): U\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate P<T>(x: T)\nfunction R<T>(x: T): set<object>\nfunction body<T,U>(x: T): U\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function f.reads<T>(x: T): set<object>\n  reads R(x)\n  requires P(x)\n{\n  R(x)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function f.reads<T>(x: T): set<object>\n  reads R(x)\n  requires P(x)\n{\n  R(x)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate f_requires<T>(x: T)\n  requires true\n  reads if P(x) then R(x) else *\n{\n  P(x)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate f_requires<T>(x: T)\n  requires true\n  reads if P(x) then R(x) else *\n{\n  P(x)\n}\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "TupleType = \"(\" [ [ \"ghost\" ] Type { \",\" [ \"ghost\" ] Type } ] \")\"\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Pair<T,U> = Pair(0: T, 1: U)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Pair<T,U> = Pair(0: T, 1: U)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(){\n  assert (5, true).1 == true;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(){\n  assert (5, true).1 == true;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const pair: (int, ghost int) := (1, ghost 2)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const pair: (int, ghost int) := (1, ghost 2)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype D<T> = _Ctors_\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype D<T> = _Ctors_\n",
        "description": null
      },
      {
        "language": "text",
        "code": "C(_params_)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "C(_params_)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Friends = Agnes | Agatha | Jermaine | Jack\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Friends = Agnes | Agatha | Jermaine | Jack\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype List<T> = Nil | Cons(head: T, tail: List<T>)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  assert Cons(5, Nil).Cons? && Cons(5, Nil).head == 5;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  assert Cons(5, Nil).Cons? && Cons(5, Nil).head == 5;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "Cons(5, Nil).tail.head\n",
        "description": null
      },
      {
        "language": "text",
        "code": "Cons(5, Nil).tail.head\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Pixel = Pixel(x: int, y: int, on: bool)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Pixel = Pixel(x: int, y: int, on: bool)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "List.Cons(5, List.Nil)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "List.Cons(5, List.Nil)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "d.(f := t)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "d.(f := t)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(){\n  assert Cons(4, Nil).(tail := Cons(3, Nil)) == Cons(4, Cons(3, Nil));\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(){\n  assert Cons(4, Nil).(tail := Cons(3, Nil)) == Cons(4, Cons(3, Nil));\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "node.(left := L, right := R)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "node.(left := L, right := R)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype X = T(t: X) | I(i: int)\nmethod comp() {\n  var x := T(I(0));\n  var y := I(0);\n  var z := I(1);\n  assert x.t < x;\n  assert y < x;\n  assert !(x < x);\n  assert z < x; // FAILS\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype X = T(t: X) | I(i: int)\nmethod comp() {\n  var x := T(I(0));\n  var y := I(0);\n  var z := I(1);\n  assert x.t < x;\n  assert y < x;\n  assert !(x < x);\n  assert z < x; // FAILS\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "codatatype IList<T> = Nil | Cons(head: T, tail: IList<T>)\ncodatatype Stream<T> = More(head: T, tail: Stream<T>)\ncodatatype Tree<T> = Node(left: Tree<T>, value: T, right: Tree<T>)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "codatatype IList<T> = Nil | Cons(head: T, tail: IList<T>)\ncodatatype Stream<T> = More(head: T, tail: Stream<T>)\ncodatatype Tree<T> = Node(left: Tree<T>, value: T, right: Tree<T>)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "// infinite streams\ncodatatype IStream<T> = ICons(head: T, tail: IStream<T>)\n\n// pointwise product of streams\nfunction Mult(a: IStream<int>, b: IStream<int>): IStream<int>\n{ ICons(a.head * b.head, Mult(a.tail, b.tail)) }\n\n// lexicographic order on streams\ngreatest predicate Below(a: IStream<int>, b: IStream<int>)\n{ a.head <= b.head &&\n  ((a.head == b.head) ==> Below(a.tail, b.tail))\n}\n\n// a stream is Below its Square\ngreatest lemma Theorem_BelowSquare(a: IStream<int>)\n  ensures Below(a, Mult(a, a))\n{ assert a.head <= Mult(a, a).head;\n  if a.head == Mult(a, a).head {\n    Theorem_BelowSquare(a.tail);\n  }\n}\n\n// an incorrect property and a bogus proof attempt\ngreatest lemma NotATheorem_SquareBelow(a: IStream<int>)\n  ensures Below(Mult(a, a), a) // ERROR\n{\n  NotATheorem_SquareBelow(a);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "// infinite streams\ncodatatype IStream<T> = ICons(head: T, tail: IStream<T>)\n\n// pointwise product of streams\nfunction Mult(a: IStream<int>, b: IStream<int>): IStream<int>\n{ ICons(a.head * b.head, Mult(a.tail, b.tail)) }\n\n// lexicographic order on streams\ngreatest predicate Below(a: IStream<int>, b: IStream<int>)\n{ a.head <= b.head &&\n  ((a.head == b.head) ==> Below(a.tail, b.tail))\n}\n\n// a stream is Below its Square\ngreatest lemma Theorem_BelowSquare(a: IStream<int>)\n  ensures Below(a, Mult(a, a))\n{ assert a.head <= Mult(a, a).head;\n  if a.head == Mult(a, a).head {\n    Theorem_BelowSquare(a.tail);\n  }\n}\n\n// an incorrect property and a bogus proof attempt\ngreatest lemma NotATheorem_SquareBelow(a: IStream<int>)\n  ensures Below(Mult(a, a), a) // ERROR\n{\n  NotATheorem_SquareBelow(a);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x | P(x) { Lemma(x); }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x | P(x) { Lemma(x); }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x :: P(x) ==> Q(x).\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x :: P(x) ==> Q(x).\n",
        "description": null
      },
      {
        "language": "text",
        "code": "codatatype Stream<T> = SNil | SCons(head: T, tail: Stream)\nfunction Up(n: int): Stream<int> { SCons(n, Up(n+1)) }\nfunction FivesUp(n: int): Stream<int>\n  decreases 4 - (n - 1) % 5\n{\n  if (n % 5 == 0) then\n    SCons(n, FivesUp(n+1))\n  else\n    FivesUp(n+1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "codatatype Stream<T> = SNil | SCons(head: T, tail: Stream)\nfunction Up(n: int): Stream<int> { SCons(n, Up(n+1)) }\nfunction FivesUp(n: int): Stream<int>\n  decreases 4 - (n - 1) % 5\n{\n  if (n % 5 == 0) then\n    SCons(n, FivesUp(n+1))\n  else\n    FivesUp(n+1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "greatest predicate Pos[nat](s: Stream<int>)\n{\n  match s\n  case SNil => true\n  case SCons(x, rest) => x > 0 && Pos(rest)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "greatest predicate Pos[nat](s: Stream<int>)\n{\n  match s\n  case SNil => true\n  case SCons(x, rest) => x > 0 && Pos(rest)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate Pos#[_k: nat](s: Stream<int>)\n  decreases _k\n{ if _k == 0 then true else\n  match s\n  case SNil => true\n  case SCons(x, rest) => x > 0 && Pos#[_k-1](rest)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate Pos#[_k: nat](s: Stream<int>)\n  decreases _k\n{ if _k == 0 then true else\n  match s\n  case SNil => true\n  case SCons(x, rest) => x > 0 && Pos#[_k-1](rest)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "D(P) = forall x • P(x) <==> forall k • P#[k](x)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "D(P) = forall x • P(x) <==> forall k • P#[k](x)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "lemma UpPosLemma(n: int)\n  requires n > 0\n  ensures Pos(Up(n))\n{\n  forall k | 0 <= k { UpPosLemmaK(k, n); }\n}\n\nlemma UpPosLemmaK(k: nat, n: int)\n  requires n > 0\n  ensures Pos#[k](Up(n))\n  decreases k\n{\n  if k != 0 {\n    // this establishes Pos#[k-1](Up(n).tail)\n    UpPosLemmaK(k-1, n+1);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "lemma UpPosLemma(n: int)\n  requires n > 0\n  ensures Pos(Up(n))\n{\n  forall k | 0 <= k { UpPosLemmaK(k, n); }\n}\n\nlemma UpPosLemmaK(k: nat, n: int)\n  requires n > 0\n  ensures Pos#[k](Up(n))\n  decreases k\n{\n  if k != 0 {\n    // this establishes Pos#[k-1](Up(n).tail)\n    UpPosLemmaK(k-1, n+1);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "greatest lemma UpPosLemma(n: int)\n  requires n > 0\n  ensures Pos(Up(n))\n{\n  UpPosLemma(n+1);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "greatest lemma UpPosLemma(n: int)\n  requires n > 0\n  ensures Pos(Up(n))\n{\n  UpPosLemma(n+1);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C {\n  var c: int  // no initialization\n  ghost var 123: bv10  // name may be a sequence of digits\n  var d: nat, e: real  // type is required\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C {\n  var c: int  // no initialization\n  ghost var 123: bv10  // name may be a sequence of digits\n  var d: nat, e: real  // type is required\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var x: T\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var x: T\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const c: int\nghost const d := 5\nclass A {\n  const e: bool\n  static const f: int\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const c: int\nghost const d := 5\nclass A {\n  const e: bool\n  static const f: int\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) requires i > 0 {}\nmethod p() returns (r: int) { r := 0; }\nmethod q() returns (r: int, s: int, t: nat) ensures r < s < t { r := 0; s := 1; t := 2; }\nghost method g() {}\nclass A {\n  method f() {}\n  constructor Init() {}\n  static method g<T>(t: T) {}\n}\nlemma L(p: bool) ensures p || !p {}\ntwostate lemma TL(p: bool) ensures p || !p {}\nleast lemma LL[nat](p: bool) ensures p || !p {}\ngreatest lemma GL(p: bool) ensures p || !p {}\nabstract module M { method m(i: int) }\nmodule N refines M { method m ... {} }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) requires i > 0 {}\nmethod p() returns (r: int) { r := 0; }\nmethod q() returns (r: int, s: int, t: nat) ensures r < s < t { r := 0; s := 1; t := 2; }\nghost method g() {}\nclass A {\n  method f() {}\n  constructor Init() {}\n  static method g<T>(t: T) {}\n}\nlemma L(p: bool) ensures p || !p {}\ntwostate lemma TL(p: bool) ensures p || !p {}\nleast lemma LL[nat](p: bool) ensures p || !p {}\ngreatest lemma GL(p: bool) ensures p || !p {}\nabstract module M { method m(i: int) }\nmodule N refines M { method m ... {} }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:att1}{:att2} M<T1, T2>(a: A, b: B, c: C)\n                                        returns (x: X, y: Y, z: Z)\n  requires Pre\n  modifies Frame\n  ensures Post\n  decreases Rank\n{\n  Body\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:att1}{:att2} M<T1, T2>(a: A, b: B, c: C)\n                                        returns (x: X, y: Y, z: Z)\n  requires Pre\n  modifies Frame\n  ensures Post\n  decreases Rank\n{\n  Body\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "modifies {c, d}\nmodifies {c} + {d}\nmodifies c, {d}\nmodifies c, d\n",
        "description": null
      },
      {
        "language": "text",
        "code": "modifies {c, d}\nmodifies {c} + {d}\nmodifies c, {d}\nmodifies c, d\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c := new C;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c := new C;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c, d, e := new C, new C, 15;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c, d, e := new C, new C, 15;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c := new C;\nc.Init(args);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c := new C;\nc.Init(args);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c := new C.Init(args);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c := new C.Init(args);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Item {\n  constructor I(xy: int) // ...\n  constructor (x: int, y: int)\n  // ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Item {\n  constructor I(xy: int) // ...\n  constructor (x: int, y: int)\n  // ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  i := new Item.I(42);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  i := new Item.I(42);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  m := new Item(45, 29);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  m := new Item(45, 29);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Cell { var data: int  constructor(i: int) { data := i; } }\ntwostate predicate Increasing(c: Cell)\n  reads c\n{\n  old(c.data) <= c.data\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Cell { var data: int  constructor(i: int) { data := i; } }\ntwostate predicate Increasing(c: Cell)\n  reads c\n{\n  old(c.data) <= c.data\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Caller(c: Cell)\n  modifies c\n{\n  c.data := c.data + 10;\n  label L:\n  assert Increasing(c);\n  c.data := c.data - 2;\n  assert Increasing(c);\n  assert !Increasing@L(c);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Caller(c: Cell)\n  modifies c\n{\n  c.data := c.data + 10;\n  label L:\n  assert Increasing(c);\n  c.data := c.data - 2;\n  assert Increasing(c);\n  assert !Increasing@L(c);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "twostate function Diff(c: Cell, d: Cell): int\n  reads d\n{\n  d.data - old(c.data)\n}\n\nmethod M(c: Cell) {\n  var d := new Cell(10);\n  label L:\n  ghost var x := Diff@L(c, d);\n  ghost var y := Diff(c, d); // error: d is not allocated in old state\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "twostate function Diff(c: Cell, d: Cell): int\n  reads d\n{\n  d.data - old(c.data)\n}\n\nmethod M(c: Cell) {\n  var d := new Cell(10);\n  label L:\n  ghost var x := Diff@L(c, d);\n  ghost var y := Diff(c, d); // error: d is not allocated in old state\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "twostate function DiffAgain(c: Cell, new d: Cell): int\n  reads d\n{\n  d.data - old(c.data)\n}\n\nmethod P(c: Cell) {\n  var d := new Cell(10);\n  ghost var x := DiffAgain(c, d);\n  ghost var y := DiffAgain(d, c); // error: d is not allocated in old state\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "twostate function DiffAgain(c: Cell, new d: Cell): int\n  reads d\n{\n  d.data - old(c.data)\n}\n\nmethod P(c: Cell) {\n  var d := new Cell(10);\n  ghost var x := DiffAgain(c, d);\n  ghost var y := DiffAgain(d, c); // error: d is not allocated in old state\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function SeqSum(s: seq<Cell>): int\n  reads s\n{\n  if s == [] then 0 else s[0].data + SeqSum(s[1..])\n}\n\ntwostate lemma IncSumDiff(s: seq<Cell>)\n  requires forall c :: c in s ==> Increasing(c)\n  ensures old(SeqSum(s)) <= SeqSum(s)\n{\n  if s == [] {\n  } else {\n    calc {\n      old(SeqSum(s));\n    ==  // def. SeqSum\n      old(s[0].data + SeqSum(s[1..]));\n    ==  // distribute old\n      old(s[0].data) + old(SeqSum(s[1..]));\n    <=  { assert Increasing(s[0]); }\n      s[0].data + old(SeqSum(s[1..]));\n    <=  { IncSumDiff(s[1..]); }\n      s[0].data + SeqSum(s[1..]);\n    ==  // def. SeqSum\n      SeqSum(s);\n    }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function SeqSum(s: seq<Cell>): int\n  reads s\n{\n  if s == [] then 0 else s[0].data + SeqSum(s[1..])\n}\n\ntwostate lemma IncSumDiff(s: seq<Cell>)\n  requires forall c :: c in s ==> Increasing(c)\n  ensures old(SeqSum(s)) <= SeqSum(s)\n{\n  if s == [] {\n  } else {\n    calc {\n      old(SeqSum(s));\n    ==  // def. SeqSum\n      old(s[0].data + SeqSum(s[1..]));\n    ==  // distribute old\n      old(s[0].data) + old(SeqSum(s[1..]));\n    <=  { assert Increasing(s[0]); }\n      s[0].data + old(SeqSum(s[1..]));\n    <=  { IncSumDiff(s[1..]); }\n      s[0].data + SeqSum(s[1..]);\n    ==  // def. SeqSum\n      SeqSum(s);\n    }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class P {\n  twostate function F<X>(x: X): X\n}\n\nmethod EtaExample(p: P) returns (ghost f: int -> int) {\n  label L:\n  f := x => p.F<int>@L(x);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class P {\n  twostate function F<X>(x: X): X\n}\n\nmethod EtaExample(p: P) returns (ghost f: int -> int) {\n  label L:\n  f := x => p.F<int>@L(x);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function f(i: int): real { i as real }\nfunction g(): (int, int) { (2,3) }\nfunction h(i: int, k: int): int requires i >= 0 { if i == 0 then 0 else 1 }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function f(i: int): real { i as real }\nfunction g(): (int, int) { (2,3) }\nfunction h(i: int, k: int): int requires i >= 0 { if i == 0 then 0 else 1 }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function {:att1}{:att2} F<T1, T2>(a: A, b: B, c: C): T\n  requires Pre\n  reads Frame\n  ensures Post\n  decreases Rank\n{\n  Body\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function {:att1}{:att2} F<T1, T2>(a: A, b: B, c: C): T\n  requires Pre\n  reads Frame\n  ensures Post\n  decreases Rank\n{\n  Body\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Factorial(n: int): int\n  requires 0 <= n\n  ensures 1 <= Factorial(n)\n{\n  if n == 0 then 1 else Factorial(n-1) * n\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Factorial(n: int): int\n  requires 0 <= n\n  ensures 1 <= Factorial(n)\n{\n  if n == 0 then 1 else Factorial(n-1) * n\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Factorial(n: int): (f: int)\n  requires 0 <= n\n  ensures 1 <= f\n{\n  if n == 0 then 1 else Factorial(n-1) * n\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Factorial(n: int): (f: int)\n  requires 0 <= n\n  ensures 1 <= f\n{\n  if n == 0 then 1 else Factorial(n-1) * n\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Fib(n: nat): nat {\n  if n < 2 then n else Fib(n - 2) + Fib(n - 1)\n} by method {\n  var x, y := 0, 1;\n  for i := 0 to n\n    invariant x == Fib(i) && y == Fib(i + 1)\n  {\n    x, y := y, x + y;\n  }\n  return x;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Fib(n: nat): nat {\n  if n < 2 then n else Fib(n - 2) + Fib(n - 1)\n} by method {\n  var x, y := 0, 1;\n  for i := 0 to n\n    invariant x == Fib(i) && y == Fib(i + 1)\n  {\n    x, y := y, x + y;\n  }\n  return x;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Node {\n  var children: seq<Node>\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Node {\n  var children: seq<Node>\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Path = Empty | Extend(Path, Node)\n\npredicate ReachableVia(source: Node, p: Path, sink: Node, S: set<Node>)\n  reads S\n  decreases p\n{\n  match p\n  case Empty =>\n    source == sink\n  case Extend(prefix, n) =>\n    n in S && sink in n.children && ReachableVia(source, prefix, n, S)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Path = Empty | Extend(Path, Node)\n\npredicate ReachableVia(source: Node, p: Path, sink: Node, S: set<Node>)\n  reads S\n  decreases p\n{\n  match p\n  case Empty =>\n    source == sink\n  case Extend(prefix, n) =>\n    n in S && sink in n.children && ReachableVia(source, prefix, n, S)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate Reachable(source: Node, sink: Node, S: set<Node>)\n  reads S\n{\n  exists p :: ReachableVia(source, p, sink, S)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate Reachable(source: Node, sink: Node, S: set<Node>)\n  reads S\n{\n  exists p :: ReachableVia(source, p, sink, S)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x: int :: x <= Square(x)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x: int :: x <= Square(x)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate IsCommutative<X>(r: (X, X) -> bool)\n{\n  forall x, y :: r(x, y) == r(y, x) // error: open-ended quantifier\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate IsCommutative<X>(r: (X, X) -> bool)\n{\n  forall x, y :: r(x, y) == r(y, x) // error: open-ended quantifier\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost predicate IsCommutative<X(!new)>(r: (X, X) -> bool) // X is restricted to non-heap types\n{\n  forall x, y :: r(x, y) == r(y, x) // allowed\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost predicate IsCommutative<X(!new)>(r: (X, X) -> bool) // X is restricted to non-heap types\n{\n  forall x, y :: r(x, y) == r(y, x) // allowed\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate IsCommutativeInS<X>(r: (X, X) -> bool, S: set<X>)\n{\n  forall x, y :: x in S && y in S ==> r(x, y) == r(y, x) // close-ended\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate IsCommutativeInS<X>(r: (X, X) -> bool, S: set<X>)\n{\n  forall x, y :: x in S && y in S ==> r(x, y) == r(y, x) // close-ended\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate Reachable(source: Node, sink: Node, S: set<Node>)\n  reads S\n{\n  exists p :: p in S && ReachableVia(source, p, sink, S) // type error: p\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate Reachable(source: Node, sink: Node, S: set<Node>)\n  reads S\n{\n  exists p :: p in S && ReachableVia(source, p, sink, S) // type error: p\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate In<X>(x: X, S: set<X>) {\n  x in S\n}\n\npredicate IsCommutativeInS<X>(r: (X, X) -> bool, S: set<X>)\n{\n  forall x, y :: In(x, S) && In(y, S) ==> r(x, y) == r(y, x) // error: open-ended?\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate In<X>(x: X, S: set<X>) {\n  x in S\n}\n\npredicate IsCommutativeInS<X>(r: (X, X) -> bool, S: set<X>)\n{\n  forall x, y :: In(x, S) && In(y, S) ==> r(x, y) == r(y, x) // error: open-ended?\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate In<X>(older x: X, S: set<X>) {\n  x in S\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate In<X>(older x: X, S: set<X>) {\n  x in S\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Node {\n  var children: seq<Node>\n}\n\ndatatype Path = Empty | Extend(Path, Node)\n\nghost predicate Reachable(source: Node, sink: Node, S: set<Node>)\n  reads S\n{\n  exists p :: ReachableVia(source, p, sink, S) // allowed because of 'older p' on ReachableVia\n}\n\nghost predicate ReachableVia(source: Node, older p: Path, sink: Node, S: set<Node>)\n  reads S\n  decreases p\n{\n  match p\n  case Empty =>\n    source == sink\n  case Extend(prefix, n) =>\n    n in S && sink in n.children && ReachableVia(source, prefix, n, S)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Node {\n  var children: seq<Node>\n}\n\ndatatype Path = Empty | Extend(Path, Node)\n\nghost predicate Reachable(source: Node, sink: Node, S: set<Node>)\n  reads S\n{\n  exists p :: ReachableVia(source, p, sink, S) // allowed because of 'older p' on ReachableVia\n}\n\nghost predicate ReachableVia(source: Node, older p: Path, sink: Node, S: set<Node>)\n  reads S\n  decreases p\n{\n  match p\n  case Empty =>\n    source == sink\n  case Extend(prefix, n) =>\n    n in S && sink in n.children && ReachableVia(source, prefix, n, S)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function f(x: int, y: int := 10): int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function f(x: int, y: int := 10): int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const i := f(1, 2)\nconst j := f(1)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const i := f(1, 2)\nconst j := f(1)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var k := f(y := 10, x := 2);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var k := f(y := 10, x := 2);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function ff(x: int, nameonly y: int): int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function ff(x: int, nameonly y: int): int\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int)\n  requires true\n  requires i > 0\n  requires L: 0 < i < 10\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int)\n  requires true\n  requires i > 0\n  requires L: 0 < i < 10\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:axiom} m(i: int) returns (r: int)\n  ensures r > 0\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:axiom} m(i: int) returns (r: int)\n  ensures r > 0\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int, j: int) returns (r: int)\n  decreases i, j\nmethod n(i: int) returns (r: int)\n  decreases *\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int, j: int) returns (r: int)\n  decreases i, j\nmethod n(i: int) returns (r: int)\n  decreases *\n",
        "description": null
      },
      {
        "language": "text",
        "code": "decreases A, B\ndecreases C, D\n",
        "description": null
      },
      {
        "language": "text",
        "code": "decreases A, B\ndecreases C, D\n",
        "description": null
      },
      {
        "language": "text",
        "code": "decreases A, B, C, D\n",
        "description": null
      },
      {
        "language": "text",
        "code": "decreases A, B, C, D\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Fib(n: nat) : nat\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Fib(n: nat) : nat\n{\n  if n < 2 then n else Fib(n-2) + Fib(n-1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method A(x: nat)\n{\n  B(x);\n}\n\nmethod B(x: nat)\n{\n  if x != 0 { A(x-1); }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method A(x: nat)\n{\n  B(x);\n}\n\nmethod B(x: nat)\n{\n  if x != 0 { A(x-1); }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method A(x: nat)\n  decreases x, 1\n{\n  B(x);\n}\n\nmethod B(x: nat)\n  decreases x, 0\n{\n  if x != 0 { A(x-1); }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method A(x: nat)\n  decreases x, 1\n{\n  B(x);\n}\n\nmethod B(x: nat)\n  decreases x, 0\n{\n  if x != 0 { A(x-1); }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method A(x: nat)\n   decreases x\n{\n  B(x);\n}\n\nmethod B(x: nat)\n  decreases x, 0\n{\n  if x != 0 { A(x-1); }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method A(x: nat)\n   decreases x\n{\n  B(x);\n}\n\nmethod B(x: nat)\n  decreases x, 0\n{\n  if x != 0 { A(x-1); }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Outer(x: nat)\n{\n  // set y to an arbitrary non-negative integer\n  var y :| 0 <= y;\n  Inner(x, y);\n}\n\nmethod Inner(x: nat, y: nat)\n{\n  if y != 0 {\n    Inner(x, y-1);\n  } else if x != 0 {\n    Outer(x-1);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Outer(x: nat)\n{\n  // set y to an arbitrary non-negative integer\n  var y :| 0 <= y;\n  Inner(x, y);\n}\n\nmethod Inner(x: nat, y: nat)\n{\n  if y != 0 {\n    Inner(x, y-1);\n  } else if x != 0 {\n    Outer(x-1);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Outer(x: nat)\n  decreases x\n{\n  // set y to an arbitrary non-negative integer\n  var y :| 0 <= y;\n  Inner(x, y);\n}\n\nmethod Inner(x: nat, y: nat)\n  decreases x,y\n{\n  if y != 0 {\n    Inner(x, y-1);\n  } else if x != 0 {\n    Outer(x-1);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Outer(x: nat)\n  decreases x\n{\n  // set y to an arbitrary non-negative integer\n  var y :| 0 <= y;\n  Inner(x, y);\n}\n\nmethod Inner(x: nat, y: nat)\n  decreases x,y\n{\n  if y != 0 {\n    Inner(x, y-1);\n  } else if x != 0 {\n    Outer(x-1);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Outer(x: nat)\n{\n  var y :| 0 <= y;\n  Inner(x, y);\n}\n\nmethod Inner(x: nat, y: nat)\n{\n  if y != 0 {\n    Inner(x, y-1);\n  } else if x != 0 {\n    Outer(x-1);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Outer(x: nat)\n{\n  var y :| 0 <= y;\n  Inner(x, y);\n}\n\nmethod Inner(x: nat, y: nat)\n{\n  if y != 0 {\n    Inner(x, y-1);\n  } else if x != 0 {\n    Outer(x-1);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "*\no\no`a\n`a\n{ o, p, q }\n{}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "*\no\no`a\n`a\n{ o, p, q }\n{}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A {\n  var i: int\n  var x0: int\n  var x1: int\n  var x2: int\n  var x3: int\n  var x4: int\n  method M()\n    modifies this\n    ensures unchanged(`x0) && unchanged(`x1) && unchanged(`x2) && unchanged(`x3) && unchanged(`x4)\n  { i := i + 1; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A {\n  var i: int\n  var x0: int\n  var x1: int\n  var x2: int\n  var x3: int\n  var x4: int\n  method M()\n    modifies this\n    ensures unchanged(`x0) && unchanged(`x1) && unchanged(`x2) && unchanged(`x3) && unchanged(`x4)\n  { i := i + 1; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A {\n  var i: int\n  var x0: int\n  var x1: int\n  var x2: int\n  var x3: int\n  var x4: int\n  method M()\n    modifies `i\n  { i := i + 1; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A {\n  var i: int\n  var x0: int\n  var x1: int\n  var x2: int\n  var x3: int\n  var x4: int\n  method M()\n    modifies `i\n  { i := i + 1; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const o: object\nconst o, oo: object\nfunction f()\n  reads *\nfunction g()\n  reads o, oo\nfunction h()\n  reads { o }\nmethod f()\n  reads *\nmethod g()\n  reads o, oo\nmethod h()\n  reads { o }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const o: object\nconst o, oo: object\nfunction f()\n  reads *\nfunction g()\n  reads o, oo\nfunction h()\n  reads { o }\nmethod f()\n  reads *\nmethod g()\n  reads o, oo\nmethod h()\n  reads { o }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C {\n  var x: int\n  var y: int\n\n  predicate f(c: C) \n    reads this, c`x\n  {\n    this.x == c.x\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C {\n  var x: int\n  var y: int\n\n  predicate f(c: C) \n    reads this, c`x\n  {\n    this.x == c.x\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "set x: int, o: object | o in F(x) :: o\n",
        "description": null
      },
      {
        "language": "text",
        "code": "set x: int, o: object | o in F(x) :: o\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Sum(f: int ~> real, lo: int, hi: int): real\n  requires lo <= hi\n  requires forall i :: f.requires(i)\n  reads f.reads\n  decreases hi - lo\n{\n  if lo == hi then 0.0 else\n    f(lo) + Sum(f, lo + 1, hi)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Sum(f: int ~> real, lo: int, hi: int): real\n  requires lo <= hi\n  requires forall i :: f.requires(i)\n  reads f.reads\n  decreases hi - lo\n{\n  if lo == hi then 0.0 else\n    f(lo) + Sum(f, lo + 1, hi)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Sum(f: int ~> real, lo: int, hi: int): real\n  requires lo <= hi\n  requires forall i :: lo <= i < hi ==> f.requires(i)\n  reads set i, o | lo <= i < hi && o in f.reads(i) :: o\n  decreases hi - lo\n{\n  if lo == hi then 0.0 else\n    f(lo) + Sum(f, lo + 1, hi)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Sum(f: int ~> real, lo: int, hi: int): real\n  requires lo <= hi\n  requires forall i :: lo <= i < hi ==> f.requires(i)\n  reads set i, o | lo <= i < hi && o in f.reads(i) :: o\n  decreases hi - lo\n{\n  if lo == hi then 0.0 else\n    f(lo) + Sum(f, lo + 1, hi)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A { var f: int }\nconst o: object?\nconst p: A?\nmethod M()\n  modifies { o, p }\nmethod N()\n  modifies { }\nmethod Q()\n  modifies o, p`f\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A { var f: int }\nconst o: object?\nconst p: A?\nmethod M()\n  modifies { o, p }\nmethod N()\n  modifies { }\nmethod Q()\n  modifies o, p`f\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C {\n  var next: C?\n  var value: int\n\n  method M() \n    modifies next\n  { \n    ... \n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C {\n  var next: C?\n  var value: int\n\n  method M() \n    modifies next\n  { \n    ... \n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m()\n{\n  var i := 10;\n  while 0 < i\n    invariant 0 <= i < 10\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m()\n{\n  var i := 10;\n  while 0 < i\n    invariant 0 <= i < 10\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C {\n  var next: C?\n  var value: int\n\n  method M(i: int) returns (r: int)\n    requires i >= 0\n    modifies next\n    decreases i\n    ensures r >= 0\n  { \n    ... \n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C {\n  var next: C?\n  var value: int\n\n  method M(i: int) returns (r: int)\n    requires i >= 0\n    modifies next\n    decreases i\n    ensures r >= 0\n  { \n    ... \n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C {\n  var next: C?\n  var value: int\n\n  function M(i: int): (r: int)\n    requires i >= 0\n    reads this\n    decreases i\n    ensures r >= 0\n  { \n    0 \n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C {\n  var next: C?\n  var value: int\n\n  function M(i: int): (r: int)\n    requires i >= 0\n    reads this\n    decreases i\n    ensures r >= 0\n  { \n    0 \n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost var Repr: set(object)\npredicate Valid()\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost var Repr: set(object)\npredicate Valid()\n",
        "description": null
      },
      {
        "language": "text",
        "code": "reads this, Repr\nensures Valid() ==> this in Repr\n",
        "description": null
      },
      {
        "language": "text",
        "code": "reads this, Repr\nensures Valid() ==> this in Repr\n",
        "description": null
      },
      {
        "language": "text",
        "code": "this in Repr && null !in Repr\n",
        "description": null
      },
      {
        "language": "text",
        "code": "this in Repr && null !in Repr\n",
        "description": null
      },
      {
        "language": "text",
        "code": "(A != null ==> A in Repr) &&\n",
        "description": null
      },
      {
        "language": "text",
        "code": "(A != null ==> A in Repr) &&\n",
        "description": null
      },
      {
        "language": "text",
        "code": "(F != null ==> F in Repr && F.Repr SUBSET Repr && this !in Repr && F.Valid())\n",
        "description": null
      },
      {
        "language": "text",
        "code": "(F != null ==> F in Repr && F.Repr SUBSET Repr && this !in Repr && F.Valid())\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ensures Valid() && fresh(Repr)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ensures Valid() && fresh(Repr)\n",
        "description": null
      },
      {
        "language": "text",
        "code": " Repr := {this};\n if (A != null) { Repr := Repr + {A}; }\n if (F != null) { Repr := Repr + {F} + F.Repr; }\n",
        "description": null
      },
      {
        "language": "text",
        "code": " Repr := {this};\n if (A != null) { Repr := Repr + {A}; }\n if (F != null) { Repr := Repr + {F} + F.Repr; }\n",
        "description": null
      },
      {
        "language": "text",
        "code": " requires Valid()\n modifies Repr\n ensures Valid() && fresh(Repr - old(Repr))\n",
        "description": null
      },
      {
        "language": "text",
        "code": " requires Valid()\n modifies Repr\n ensures Valid() && fresh(Repr - old(Repr))\n",
        "description": null
      },
      {
        "language": "text",
        "code": " if (A != null && !(A in Repr)) { Repr := Repr + {A}; }\n if (F != null && !(F in Repr && F.Repr SUBSET Repr)) { Repr := Repr + {F} + F.Repr; }\n",
        "description": null
      },
      {
        "language": "text",
        "code": " if (A != null && !(A in Repr)) { Repr := Repr + {A}; }\n if (F != null && !(F in Repr && F.Repr SUBSET Repr)) { Repr := Repr + {F} + F.Repr; }\n",
        "description": null
      },
      {
        "language": "text",
        "code": " requires Valid()\n",
        "description": null
      },
      {
        "language": "text",
        "code": " requires Valid()\n",
        "description": null
      },
      {
        "language": "text",
        "code": " requires old(Valid())\n",
        "description": null
      },
      {
        "language": "text",
        "code": " requires old(Valid())\n",
        "description": null
      },
      {
        "language": "text",
        "code": " requires Valid()\n reads Repr\n",
        "description": null
      },
      {
        "language": "text",
        "code": " requires Valid()\n reads Repr\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Test(a: array<int>) returns (j: int)\n  requires a.Length >= 1\n  ensures a.Length % 2 == 0 ==> j >= 10 / a.Length\n{\n  j := 20;\n  var divisor := a.Length;\n  if divisor % 2 == 0 {\n    j := j / divisor;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Test(a: array<int>) returns (j: int)\n  requires a.Length >= 1\n  ensures a.Length % 2 == 0 ==> j >= 10 / a.Length\n{\n  j := 20;\n  var divisor := a.Length;\n  if divisor % 2 == 0 {\n    j := j / divisor;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "lemma Test_WellFormed(a: array?<int>)\n{\n  assume a != null;       // From the definition of a\n  assert a != null;       // for the `requires a.Length >= 1`\n  assume a.Length >= 1;   // After well-formedness, we assume the requires\n  assert a != null;       // Again for the `a.Length % 2`\n  if a.Length % 2 == 0 {\n    assert a != null;     // Again for the final `a.Length`\n    assert a.Length != 0; // Because of the 10 / a.Length\n  }\n}\n\nmethod Test_Correctness(a: array?<int>)\n{ // Here we assume the well-formedness of the condition\n  assume a != null;       // for the `requires a.Length >= 1`\n  assume a != null;       // Again for the `a.Length % 2`\n  if a.Length % 2 == 0 {\n    assume a != null;     // Again for the final `a.Length`\n    assume a.Length != 0; // Because of the 10 / a.Length\n  }\n\n  // Now the body is translated\n  var j := 20;\n  assert a != null;          // For `var divisor := a.Length;`\n  var divisor := a.Length;\n  if * {\n    assume divisor % 2 == 0;\n    assert divisor != 0;\n    j := j / divisor;\n  }\n  assume divisor % 2 == 0 ==> divisor != 0;\n  assert a.Length % 2 == 0 ==> j >= 10 / a.Length;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "lemma Test_WellFormed(a: array?<int>)\n{\n  assume a != null;       // From the definition of a\n  assert a != null;       // for the `requires a.Length >= 1`\n  assume a.Length >= 1;   // After well-formedness, we assume the requires\n  assert a != null;       // Again for the `a.Length % 2`\n  if a.Length % 2 == 0 {\n    assert a != null;     // Again for the final `a.Length`\n    assert a.Length != 0; // Because of the 10 / a.Length\n  }\n}\n\nmethod Test_Correctness(a: array?<int>)\n{ // Here we assume the well-formedness of the condition\n  assume a != null;       // for the `requires a.Length >= 1`\n  assume a != null;       // Again for the `a.Length % 2`\n  if a.Length % 2 == 0 {\n    assume a != null;     // Again for the final `a.Length`\n    assume a.Length != 0; // Because of the 10 / a.Length\n  }\n\n  // Now the body is translated\n  var j := 20;\n  assert a != null;          // For `var divisor := a.Length;`\n  var divisor := a.Length;\n  if * {\n    assume divisor % 2 == 0;\n    assert divisor != 0;\n    j := j / divisor;\n  }\n  assume divisor % 2 == 0 ==> divisor != 0;\n  assert a.Length % 2 == 0 ==> j >= 10 / a.Length;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A { var f: int }\nmethod m(a: A) {\n  label x:\n  while true {\n     if (*) { break x; }\n  }\n  a.f := 0;\n  label y:\n  a.f := 1;\n  assert old@y(a.f) == 1;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A { var f: int }\nmethod m(a: A) {\n  label x:\n  while true {\n     if (*) { break x; }\n  }\n  a.f := 0;\n  label y:\n  a.f := 1;\n  assert old@y(a.f) == 1;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{\n  print 0;\n  var x := 0;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{\n  print 0;\n  var x := 0;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) returns (r: int) {\n  return i+1;\n}\nmethod n(i: int) returns (r: int, q: int) {\n  return i+1, i + 2;\n}\nmethod p() returns (i: int) {\n  i := 1;\n  return;\n}\nmethod q() {\n  return;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) returns (r: int) {\n  return i+1;\n}\nmethod n(i: int) returns (r: int, q: int) {\n  return i+1, i + 2;\n}\nmethod p() returns (i: int) {\n  i := 1;\n  return;\n}\nmethod q() {\n  return;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C { var f: int }\nclass D {\n  var i: int\n  constructor(i: int) {\n    this.i := i;\n  }\n}\nmethod q(i: int, j: int) {}\nmethod r() returns (s: int, t: int) { return 2,3; }\nmethod m() {\n  var ss: int, tt: int, c: C?, a: array<int>, d: D?;\n  q(0,1);\n  ss, c.f := r();\n  c := new C;\n  d := new D(2);\n  a := new int[10];\n  ss, tt := 212, 33;\n  ss :| ss > 7;\n  ss := *;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C { var f: int }\nclass D {\n  var i: int\n  constructor(i: int) {\n    this.i := i;\n  }\n}\nmethod q(i: int, j: int) {}\nmethod r() returns (s: int, t: int) { return 2,3; }\nmethod m() {\n  var ss: int, tt: int, c: C?, a: array<int>, d: D?;\n  q(0,1);\n  ss, c.f := r();\n  c := new C;\n  d := new D(2);\n  a := new int[10];\n  ss, tt := 212, 33;\n  ss :| ss > 7;\n  ss := *;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "m();\nm(1,2,3) {:attr} ;\ne.f().g.m(45);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "m();\nm(1,2,3) {:attr} ;\ne.f().g.m(45);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a, b.e().f := m() {:attr};\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a, b.e().f := m() {:attr};\n",
        "description": null
      },
      {
        "language": "text",
        "code": "    x, y := y, x;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "    x, y := y, x;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a := *;\na, b, c := 4, *, 5;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a := *;\na, b, c := 4, *, 5;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x, y :| 0 < x+y < 10;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x, y :| 0 < x+y < 10;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Sum(X: set<int>) returns (s: int)\n{\n  s := 0; var Y := X;\n  while Y != {}\n    decreases Y\n  {\n    var y: int;\n    y :| y in Y;\n    s, Y := s + y, Y - {y};\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Sum(X: set<int>) returns (s: int)\n{\n  s := 0; var Y := X;\n  while Y != {}\n    decreases Y\n  {\n    var y: int;\n    y :| y in Y;\n    s, Y := s + y, Y - {y};\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "    y :| assume y in Y;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "    y :| assume y in Y;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "    Lhs \":\"\n",
        "description": null
      },
      {
        "language": "text",
        "code": "    Lhs \":\"\n",
        "description": null
      },
      {
        "language": "text",
        "code": "opaque predicate P() { true }\n\nlemma ProveP() ensures P() {\n  reveal P();\n}\n\nmethod M(i: int) returns (r: int)\n  requires P()\n  ensures r == i\n{ r := i; }\n\nmethod C() {\n  var v := M(1/3) by { // We prove 3 != 0 outside of the by proof\n    ProveP();          // Prove precondtion  \n  }\n  assert v == 0;       // Use postcondition\n  assert P();          // Fails\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "opaque predicate P() { true }\n\nlemma ProveP() ensures P() {\n  reveal P();\n}\n\nmethod M(i: int) returns (r: int)\n  requires P()\n  ensures r == i\n{ r := i; }\n\nmethod C() {\n  var v := M(1/3) by { // We prove 3 != 0 outside of the by proof\n    ProveP();          // Prove precondtion  \n  }\n  assert v == 0;       // Use postcondition\n  assert P();          // Fails\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Status =\n| Success\n| Failure(error: string)\n{\n  predicate IsFailure() { this.Failure?  }\n  function PropagateFailure(): Status\n    requires IsFailure()\n  {\n    Failure(this.error)\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Status =\n| Success\n| Failure(error: string)\n{\n  predicate IsFailure() { this.Failure?  }\n  function PropagateFailure(): Status\n    requires IsFailure()\n  {\n    Failure(this.error)\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Outcome<T> =\n| Success(value: T)\n| Failure(error: string)\n{\n  predicate IsFailure() {\n    this.Failure?\n  }\n  function PropagateFailure<U>(): Outcome<U>\n    requires IsFailure()\n  {\n    Failure(this.error) // this is Outcome<U>.Failure(...)\n  }\n  function Extract(): T\n    requires !IsFailure()\n  {\n    this.value\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Outcome<T> =\n| Success(value: T)\n| Failure(error: string)\n{\n  predicate IsFailure() {\n    this.Failure?\n  }\n  function PropagateFailure<U>(): Outcome<U>\n    requires IsFailure()\n  {\n    Failure(this.error) // this is Outcome<U>.Failure(...)\n  }\n  function Extract(): T\n    requires !IsFailure()\n  {\n    this.value\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Callee(i: int) returns (r: Status)\n{\n  if i < 0 { return Failure(\"negative\"); }\n  return Success;\n}\n\nmethod Caller(i: int) returns (rr: Status)\n{\n  :- Callee(i);\n  ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Callee(i: int) returns (r: Status)\n{\n  if i < 0 { return Failure(\"negative\"); }\n  return Success;\n}\n\nmethod Caller(i: int) returns (rr: Status)\n{\n  :- Callee(i);\n  ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var tmp;\ntmp := Callee(i);\nif tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var tmp;\ntmp := Callee(i);\nif tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Callee(i: int) returns (r: Status, v: int, w: int)\n{\n  if i < 0 { return Failure(\"negative\"), 0, 0; }\n  return Success, i+i, i*i;\n}\n\nmethod Caller(i: int) returns (rr: Status, k: int)\n{\n  var j: int;\n  j, k :- Callee(i);\n  k := k + k;\n  ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Callee(i: int) returns (r: Status, v: int, w: int)\n{\n  if i < 0 { return Failure(\"negative\"), 0, 0; }\n  return Success, i+i, i*i;\n}\n\nmethod Caller(i: int) returns (rr: Status, k: int)\n{\n  var j: int;\n  j, k :- Callee(i);\n  k := k + k;\n  ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var tmp;\ntmp, j, k := Callee(i);\nif tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var tmp;\ntmp, j, k := Callee(i);\nif tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Callee(i: int) returns (r: Outcome<nat>, v: int)\n{\n  if i < 0 { return Failure(\"negative\"), i+i; }\n  return Success(i), i+i;\n}\n\nmethod Caller(i: int) returns (rr: Outcome<int>, k: int)\n{\n  var j: int;\n  j, k :- Callee(i);\n  k := k + k;\n  ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Callee(i: int) returns (r: Outcome<nat>, v: int)\n{\n  if i < 0 { return Failure(\"negative\"), i+i; }\n  return Success(i), i+i;\n}\n\nmethod Caller(i: int) returns (rr: Outcome<int>, k: int)\n{\n  var j: int;\n  j, k :- Callee(i);\n  k := k + k;\n  ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var tmp;\ntmp, k := Callee(i);\nif tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\nj := tmp.Extract();\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var tmp;\ntmp, k := Callee(i);\nif tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\nj := tmp.Extract();\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(r: Status) returns (rr: Status) {\n  var k;\n  k :- r, 7;\n  ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(r: Status) returns (rr: Status) {\n  var k;\n  k :- r, 7;\n  ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var k;\nvar tmp;\ntmp, k := r, 7;\nif tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var k;\nvar tmp;\ntmp, k := r, 7;\nif tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var s, t :- M();\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var s, t :- M();\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var s, t;\ns, t :- M();\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var s, t;\ns, t :- M();\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if tmp.IsFailure() {\n  rr := tmp.PropagateFailure();\n  return;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "expect !tmp.IsFailure(), tmp;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "expect !tmp.IsFailure(), tmp;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assert !tmp.IsFailure();\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assert !tmp.IsFailure();\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assume !tmp.IsFailure();\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assume !tmp.IsFailure();\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  var x, y: int; // x's type is inferred, not necessarily 'int'\n  var b: bool, k: int;\n  x := 1; // settles x's type\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  var x, y: int; // x's type is inferred, not necessarily 'int'\n  var b: bool, k: int;\n  x := 1; // settles x's type\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var x, y : int;\nvar x, y := 5, 6;\nvar x, y :- m();\nvar x, y :| 0 < x + y < 10;\nvar (x, y) := makePair();\nvar Cons(x, y) = ConsMaker();\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var x, y : int;\nvar x, y := 5, 6;\nvar x, y :- m();\nvar x, y :| 0 < x + y < 10;\nvar (x, y) := makePair();\nvar Cons(x, y) = ConsMaker();\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function returnsTuple() : (int, int)\n{\n    (5, 10)\n}\n\nfunction usesTuple() : int\n{\n    var (x, y) := returnsTuple();\n    x + y\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function returnsTuple() : (int, int)\n{\n    (5, 10)\n}\n\nfunction usesTuple() : int\n{\n    var (x, y) := returnsTuple();\n    x + y\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) {\n  if (*) { print i; }\n  if i > 0 { print i; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) {\n  if (*) { print i; }\n  if i > 0 { print i; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) {\n  ghost var k: int;\n  if i, j :| 0 < i+j < 10 {\n    k := 0;\n  } else {\n    k := 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) {\n  ghost var k: int;\n  if i, j :| 0 < i+j < 10 {\n    k := 0;\n  } else {\n    k := 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if x :| P { S } else { T }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if x :| P { S } else { T }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if exists x :: P { var x :| P; S } else { T }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if exists x :: P { var x :| P; S } else { T }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate P(n: int)\n{\n  n % 2 == 0\n}\n\nmethod M1() returns (ghost y: int)\n    requires exists x :: P(x)\n    ensures P(y)\n{\n  if x : int :| P(x) {\n      y := x;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate P(n: int)\n{\n  n % 2 == 0\n}\n\nmethod M1() returns (ghost y: int)\n    requires exists x :: P(x)\n    ensures P(y)\n{\n  if x : int :| P(x) {\n      y := x;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) {\n  var x: int;\n  if i > 0 {\n    x := i;\n  } else {\n    x := -i;\n  }\n  if * {\n    x := i;\n  } else {\n    x := -i;\n  }\n  if i: nat, j: nat :| i+j<10 {\n    assert i < 10;\n  }\n  if i == 0 {\n    x := 0;\n  } else if i > 0 {\n    x := 1;\n  } else {\n    x := -1;\n  }\n  if \n    case i == 0 => x := 0;\n    case i > 0 => x := 1;\n    case i < 0 => x := -1;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) {\n  var x: int;\n  if i > 0 {\n    x := i;\n  } else {\n    x := -i;\n  }\n  if * {\n    x := i;\n  } else {\n    x := -i;\n  }\n  if i: nat, j: nat :| i+j<10 {\n    assert i < 10;\n  }\n  if i == 0 {\n    x := 0;\n  } else if i > 0 {\n    x := 1;\n  } else {\n    x := -1;\n  }\n  if \n    case i == 0 => x := 0;\n    case i > 0 => x := 1;\n    case i < 0 => x := -1;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  if x < 0 {\n    x := -x;\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  if x < 0 {\n    x := -x;\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  if * {\n    print \"True\";\n  } else {\n    print \"False\";\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  if * {\n    print \"True\";\n  } else {\n    print \"False\";\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(x: int, y: int) returns (max: int) \n{\n  if {\n    case x <= y => max := y;\n    case y <= x => max := x;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(x: int, y: int) returns (max: int) \n{\n  if {\n    case x <= y => max := y;\n    case y <= x => max := x;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "\nmatch list {\n  case Nil => {}\n  case Cons(head,tail) => print head;\n}\nmatch x\ncase 1 =>\n  print x;\ncase 2 =>\n  var y := x*x;\n  print y;\ncase _ =>\n  print \"Other\";\n  // Any statement after is captured in this case.\n",
        "description": null
      },
      {
        "language": "text",
        "code": "\nmatch list {\n  case Nil => {}\n  case Cons(head,tail) => print head;\n}\nmatch x\ncase 1 =>\n  print x;\ncase 2 =>\n  var y := x*x;\n  print y;\ncase _ =>\n  print \"Other\";\n  // Any statement after is captured in this case.\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Tree = Empty | Node(left: Tree, data: int, right: Tree)\n\n// Return the sum of the data in a tree.\nmethod Sum(x: Tree) returns (r: int)\n{\n  match x {\n    case Empty => r := 0;\n    case Node(t1, d, t2) =>\n      var v1 := Sum(t1);\n      var v2 := Sum(t2);\n      r := v1 + d + v2;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Tree = Empty | Node(left: Tree, data: int, right: Tree)\n\n// Return the sum of the data in a tree.\nmethod Sum(x: Tree) returns (r: int)\n{\n  match x {\n    case Empty => r := 0;\n    case Node(t1, d, t2) =>\n      var v1 := Sum(t1);\n      var v2 := Sum(t2);\n      r := v1 + d + v2;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  var i := 10;\n  while 0 < i\n    invariant 0 <= i <= 10\n    decreases i\n  {\n    i := i-1;\n  }\n  while * {}\n  i := *;\n  while \n     decreases if i < 0 then -i else i\n  {\n     case i < 0 => i := i + 1;\n     case i > 0 => i := i - 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  var i := 10;\n  while 0 < i\n    invariant 0 <= i <= 10\n    decreases i\n  {\n    i := i-1;\n  }\n  while * {}\n  i := *;\n  while \n     decreases if i < 0 then -i else i\n  {\n     case i < 0 => i := i + 1;\n     case i > 0 => i := i - 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(){\n  var i := 0;\n  while i < 5 {\n    i := i + 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(){\n  var i := 0;\n  while i < 5 {\n    i := i + 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(n: int){\n  var r := n;\n  while\n    decreases if 0 <= r then r else -r\n  {\n    case r < 0 =>\n      r := r + 1;\n    case 0 < r =>\n      r := r - 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(n: int){\n  var r := n;\n  while\n    decreases if 0 <= r then r else -r\n  {\n    case r < 0 =>\n      r := r + 1;\n    case 0 < r =>\n      r := r - 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() decreases * {\n  for i := 0 to 10 {}\n  for _ := 0 to 10 {}\n  for i := 0 to * invariant i >= 0 decreases * {}\n  for i: int := 10 downto 0 {}\n  for i: int := 10 downto 0 \n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() decreases * {\n  for i := 0 to 10 {}\n  for _ := 0 to 10 {}\n  for i := 0 to * invariant i >= 0 decreases * {}\n  for i: int := 10 downto 0 {}\n  for i: int := 10 downto 0 \n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "for _ := 0 to 20 {\n  Body\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "for _ := 0 to 20 {\n  Body\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "for i: T := lo to hi\n  LoopSpec\n{ Body }\n\nfor i: T := hi downto lo\n  LoopSpec\n{ Body }\n\nfor i: T := lo to *\n  LoopSpec\n{ Body }\n\nfor i: T := hi downto *\n  LoopSpec\n{ Body }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "for i: T := lo to hi\n  LoopSpec\n{ Body }\n\nfor i: T := hi downto lo\n  LoopSpec\n{ Body }\n\nfor i: T := lo to *\n  LoopSpec\n{ Body }\n\nfor i: T := hi downto *\n  LoopSpec\n{ Body }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{\n  var _lo, _hi := lo, hi;\n  assert _lo <= _hi && forall _i: int :: _lo <= _i <= _hi ==> _i is T;\n  var i := _lo;\n  while i != _hi\n    invariant _lo <= i <= _hi\n    LoopSpec\n    decreases _hi - i\n  {\n    Body\n    i := i + 1;\n  }\n}\n\n{\n  var _lo, _hi := lo, hi;\n  assert _lo <= _hi && forall _i: int :: _lo <= _i <= _hi ==> _i is T;\n  var i := _hi;\n  while i != lo\n    invariant _lo <= i <= _hi\n    LoopSpec\n    decreases i - _lo\n  {\n    i := i - 1;\n    Body\n  }\n}\n\n{\n  var _lo := lo;\n  assert forall _i: int :: _lo <= _i ==> _i is T;\n  var i := _lo;\n  while true\n    invariant _lo <= i\n    LoopSpec\n  {\n    Body\n    i := i + 1;\n  }\n}\n\n{\n  var _hi := hi;\n  assert forall _i: int :: _i <= _hi ==> _i is T;\n  var i := _hi;\n  while true\n    invariant i <= _hi\n    LoopSpec\n  {\n    i := i - 1;\n    Body\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{\n  var _lo, _hi := lo, hi;\n  assert _lo <= _hi && forall _i: int :: _lo <= _i <= _hi ==> _i is T;\n  var i := _lo;\n  while i != _hi\n    invariant _lo <= i <= _hi\n    LoopSpec\n    decreases _hi - i\n  {\n    Body\n    i := i + 1;\n  }\n}\n\n{\n  var _lo, _hi := lo, hi;\n  assert _lo <= _hi && forall _i: int :: _lo <= _i <= _hi ==> _i is T;\n  var i := _hi;\n  while i != lo\n    invariant _lo <= i <= _hi\n    LoopSpec\n    decreases i - _lo\n  {\n    i := i - 1;\n    Body\n  }\n}\n\n{\n  var _lo := lo;\n  assert forall _i: int :: _lo <= _i ==> _i is T;\n  var i := _lo;\n  while true\n    invariant _lo <= i\n    LoopSpec\n  {\n    Body\n    i := i + 1;\n  }\n}\n\n{\n  var _hi := hi;\n  assert forall _i: int :: _i <= _hi ==> _i is T;\n  var i := _hi;\n  while true\n    invariant i <= _hi\n    LoopSpec\n  {\n    i := i - 1;\n    Body\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "for i := 0 to a.Length {\n  Process(a[i]);\n}\nfor i := a.Length downto 0 {\n  Process(a[i]);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "for i := 0 to a.Length {\n  Process(a[i]);\n}\nfor i := a.Length downto 0 {\n  Process(a[i]);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A { var f: int }\nmethod m(a: A) {\n  label x:\n  while true {\n    if (*) { break; }\n  }\n  label y: {\n    var z := 1;\n    if * { break y; }\n    z := 2;\n  }\n\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A { var f: int }\nmethod m(a: A) {\n  label x:\n  while true {\n    if (*) { break; }\n  }\n  label y: {\n    var z := 1;\n    if * { break y; }\n    z := 2;\n  }\n\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "label L: {\n  var n := ReadNext();\n  if n < 0 {\n    break L;\n  }\n  DoSomething(n);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "label L: {\n  var n := ReadNext();\n  if n < 0 {\n    break L;\n  }\n  DoSomething(n);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{\n  var n := ReadNext();\n  if 0 <= n {\n    DoSomething(n);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{\n  var n := ReadNext();\n  if 0 <= n {\n    DoSomething(n);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  for i := 0 to 10 {\n    for j := 0 to 10 {\n      label X: {\n        for k := 0 to 10 {\n          if j + k == 15 {\n            break break;\n          }\n        }\n      }\n    }\n    // control continues here after the \"break break\", exiting two loops\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  for i := 0 to 10 {\n    for j := 0 to 10 {\n      label X: {\n        for k := 0 to 10 {\n          if j + k == 15 {\n            break break;\n          }\n        }\n      }\n    }\n    // control continues here after the \"break break\", exiting two loops\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  for i := 0 to 100 {\n    if i == 17 {\n      continue;\n    }\n    DoSomething(i);\n  }\n}\nmethod DoSomething(i:int){}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  for i := 0 to 100 {\n    if i == 17 {\n      continue;\n    }\n    DoSomething(i);\n  }\n}\nmethod DoSomething(i:int){}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  for i := 0 to 100 {\n    if i != 17 {\n      DoSomething(i);\n    }\n  }\n}\nmethod DoSomething(i:int){}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  for i := 0 to 100 {\n    if i != 17 {\n      DoSomething(i);\n    }\n  }\n}\nmethod DoSomething(i:int){}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  for i := 0 to 100 {\n    label LoopBody: {\n      if i == 17 {\n        break LoopBody;\n      }\n      DoSomething(i);\n    }\n  }\n}\nmethod DoSomething(i:int){}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  for i := 0 to 100 {\n    label LoopBody: {\n      if i == 17 {\n        break LoopBody;\n      }\n      DoSomething(i);\n    }\n  }\n}\nmethod DoSomething(i:int){}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  var i := 0;\n  while i < 100 {\n    if i == 17 {\n      continue; // error: this would cause an infinite loop\n    }\n    DoSomething(i);\n    i := i + 1;\n  }\n}\nmethod DoSomething(i:int){}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  var i := 0;\n  while i < 100 {\n    if i == 17 {\n      continue; // error: this would cause an infinite loop\n    }\n    DoSomething(i);\n    i := i + 1;\n  }\n}\nmethod DoSomething(i:int){}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  label Outer:\n  for i := 0 to 100 {\n    for j := 0 to 100 {\n      if i + j == 19 {\n        continue Outer;\n      }\n      WorkIt(i, j);\n    }\n    PostProcess(i);\n    // the \"continue Outer\" statement above transfers control to here\n  }\n}\nmethod WorkIt(i:int, j:int){}\nmethod PostProcess(i:int){}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  label Outer:\n  for i := 0 to 100 {\n    for j := 0 to 100 {\n      if i + j == 19 {\n        continue Outer;\n      }\n      WorkIt(i, j);\n    }\n    PostProcess(i);\n    // the \"continue Outer\" statement above transfers control to here\n  }\n}\nmethod WorkIt(i:int, j:int){}\nmethod PostProcess(i:int){}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  for i := 0 to 100 {\n    for j := 0 to 100 {\n      if i + j == 19 {\n        break continue;\n      }\n      WorkIt(i, j);\n    }\n    PostProcess(i);\n    // the \"break continue\" statement above transfers control to here\n  }\n}\nmethod WorkIt(i:int, j:int){}\nmethod PostProcess(i:int){}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  for i := 0 to 100 {\n    for j := 0 to 100 {\n      if i + j == 19 {\n        break continue;\n      }\n      WorkIt(i, j);\n    }\n    PostProcess(i);\n    // the \"break continue\" statement above transfers control to here\n  }\n}\nmethod WorkIt(i:int, j:int){}\nmethod PostProcess(i:int){}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  var i := 0;\n  while i < 10\n    invariant 0 <= i <= 10\n  {\n    if P(i) {\n      i := i + 200;\n      break;\n    }\n    i := i + 1;\n  }\n  assert i == 10 || 200 <= i < 210;\n}\npredicate P(i:int)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  var i := 0;\n  while i < 10\n    invariant 0 <= i <= 10\n  {\n    if P(i) {\n      i := i + 200;\n      break;\n    }\n    i := i + 1;\n  }\n  assert i == 10 || 200 <= i < 210;\n}\npredicate P(i:int)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var i := 0;\nwhile i < n\n  invariant 0 <= i\n{\n  i := i + 1;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var i := 0;\nwhile i < n\n  invariant 0 <= i\n{\n  i := i + 1;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(n: nat){\n  var i := n;\n  while 0 < i\n    invariant 0 <= i\n    decreases i\n  {\n    i := i - 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(n: nat){\n  var i := n;\n  while 0 < i\n    invariant 0 <= i\n    decreases i\n  {\n    i := i - 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(m: nat, n: int) \n  requires m <= n \n{\n  var i := m;\n  while i < n\n    invariant 0 <= i <= n\n    decreases n - i\n  {\n    i := i + 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(m: nat, n: int) \n  requires m <= n \n{\n  var i := m;\n  while i < n\n    invariant 0 <= i <= n\n    decreases n - i\n  {\n    i := i + 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Cell {\n  var data: int\n}\n\nmethod M0(c: Cell, d: Cell)\n  requires c != d\n  modifies c, d\n  ensures c.data == d.data == 100\n{\n  c.data, d.data := 100, 0;\n  var i := 0;\n  while i < 100\n    invariant d.data == i\n    // Needs \"invariant c.data == 100\" or \"modifies d\" to verify\n  {\n    d.data := d.data + 1;\n    i := i + 1;\n  }\n}\n\nmethod M1(c: Cell)\n  modifies c\n  ensures c.data == 100\n{\n  c.data := 100;\n  var i := 0;\n  while i < 100\n    // Needs \"invariant c.data == 100\" or \"modifies {}\" to verify\n  {\n    var tmp := new Cell;\n    tmp.data := i;\n    i := i + 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Cell {\n  var data: int\n}\n\nmethod M0(c: Cell, d: Cell)\n  requires c != d\n  modifies c, d\n  ensures c.data == d.data == 100\n{\n  c.data, d.data := 100, 0;\n  var i := 0;\n  while i < 100\n    invariant d.data == i\n    // Needs \"invariant c.data == 100\" or \"modifies d\" to verify\n  {\n    d.data := d.data + 1;\n    i := i + 1;\n  }\n}\n\nmethod M1(c: Cell)\n  modifies c\n  ensures c.data == 100\n{\n  c.data := 100;\n  var i := 0;\n  while i < 100\n    // Needs \"invariant c.data == 100\" or \"modifies {}\" to verify\n  {\n    var tmp := new Cell;\n    tmp.data := i;\n    i := i + 1;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Cell {\n  var data: int\n  const K: int\n}\n\nmethod BodylessLoop(n: nat, c: Cell)\n  requires c.K == 8\n  modifies c\n{\n  c.data := 5;\n  var a, b := n, n;\n  for i := 0 to n\n    invariant c.K < 10\n    invariant a <= n\n    invariant c.data < 10\n  assert a == n;\n  assert b == n;\n  assert c.data == 5;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class Cell {\n  var data: int\n  const K: int\n}\n\nmethod BodylessLoop(n: nat, c: Cell)\n  requires c.K == 8\n  modifies c\n{\n  c.data := 5;\n  var a, b := n, n;\n  for i := 0 to n\n    invariant c.K < 10\n    invariant a <= n\n    invariant c.data < 10\n  assert a == n;\n  assert b == n;\n  assert c.data == 5;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "print 0, x, list, array;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "print 0, x, list, array;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Tree = Empty | Node(left: Tree, data: int, right: Tree)\nmethod Main()\n{\n  var x : Tree := Node(Node(Empty, 1, Empty), 2, Empty);\n  print \"x=\", x, \"\\n\";\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Tree = Empty | Node(left: Tree, data: int, right: Tree)\nmethod Main()\n{\n  var x : Tree := Node(Node(Empty, 1, Empty), 2, Empty);\n  print \"x=\", x, \"\\n\";\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x=Tree.Node(Tree.Node(Tree.Empty, 1, Tree.Empty), 2, Tree.Empty)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x=Tree.Node(Tree.Node(Tree.Empty, 1, Tree.Empty), 2, Tree.Empty)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assert i > 0;\nassert IsPositive: i > 0;\nassert i > 0 by {\n ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assert i > 0;\nassert IsPositive: i > 0;\nassert i > 0 by {\n ...\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assume i > 0;\nassume {:axiom} i > 0 ==> -i < 0;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assume i > 0;\nassume {:axiom} i > 0 ==> -i < 0;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "expect i > 0;\nexpect i > 0, \"i is positive\";\n",
        "description": null
      },
      {
        "language": "text",
        "code": "expect i > 0;\nexpect i > 0, \"i is positive\";\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:extern} Random(n: nat) returns (r: nat)\n  ensures r < n\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:extern} Random(n: nat) returns (r: nat)\n  ensures r < n\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:extern} Random(n: nat) returns (r: nat)\n\nmethod Random'(n: nat) returns (r: nat)\n  ensures r < n\n{\n  r := Random(n);\n  expect r < n;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:extern} Random(n: nat) returns (r: nat)\n\nmethod Random'(n: nat) returns (r: nat)\n  ensures r < n\n{\n  r := Random(n);\n  expect r < n;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assert _P_;\nexpect _P_;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assert _P_;\nexpect _P_;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assert _P_;\nexpect _P_;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assert _P_;\nexpect _P_;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "reveal f(), L;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "reveal f(), L;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) {\n  assert x: i == 0; // Fails\n  assert i == 0; // Fails also because the label 'x:' hides the first assertion\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) {\n  assert x: i == 0; // Fails\n  assert i == 0; // Fails also because the label 'x:' hides the first assertion\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) {\n  assert x: i == 0; // Fails\n  reveal x;\n  assert i == 0; // Now succeeds\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) {\n  assert x: i == 0; // Fails\n  reveal x;\n  assert i == 0; // Now succeeds\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) {\n  assert x: i == 0; // Fails\n  assert i == 0 by { reveal x; } // Now succeeds\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(i: int) {\n  assert x: i == 0; // Fails\n  assert i == 0 by { reveal x; } // Now succeeds\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(x: int, y: int) returns (z: int)\n  requires L: 0 < y\n  ensures z == x+y\n  ensures x < z\n{\n  z := x + y;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(x: int, y: int) returns (z: int)\n  requires L: 0 < y\n  ensures z == x+y\n  ensures x < z\n{\n  z := x + y;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(x: int, y: int) returns (z: int)\n  requires L: 0 < y\n  ensures z == x+y\n  ensures x < z\n{\n  z := x + y;\n  assert x < z by { reveal L; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(x: int, y: int) returns (z: int)\n  requires L: 0 < y\n  ensures z == x+y\n  ensures x < z\n{\n  z := x + y;\n  assert x < z by { reveal L; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "// We are using the options --isolate-assertions and --type-system-refresh\nmethod Outer(x: int)\n  requires ComplicatedBody(x) \n{\n  hide ComplicatedBody; // This hides the body of ComplicatedBody for the remainder of the method.\n  \n  // The body of ComplicatedBody is not needed to prove the requires of Inner\n  var y := Inner(x);\n  \n  // We reveal ComplicatedBody inside the following expression, to prove that we are not dividing by zero\n  var z := (reveal ComplicatedBody; 10 / x);\n}\n\nmethod Inner(x: int) returns (r: int)\n  requires ComplicatedBody(x)\n\npredicate ComplicatedBody(x: int) {\n  x != 0 && true // pretend true is complicated \n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "// We are using the options --isolate-assertions and --type-system-refresh\nmethod Outer(x: int)\n  requires ComplicatedBody(x) \n{\n  hide ComplicatedBody; // This hides the body of ComplicatedBody for the remainder of the method.\n  \n  // The body of ComplicatedBody is not needed to prove the requires of Inner\n  var y := Inner(x);\n  \n  // We reveal ComplicatedBody inside the following expression, to prove that we are not dividing by zero\n  var z := (reveal ComplicatedBody; 10 / x);\n}\n\nmethod Inner(x: int) returns (r: int)\n  requires ComplicatedBody(x)\n\npredicate ComplicatedBody(x: int) {\n  x != 0 && true // pretend true is complicated \n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "// We are using the options --isolate-assertions and --type-system-refresh\npredicate P() { true }\npredicate Q(x: bool) requires x\n\nmethod Foo() {\n  var q1 := Q(hide P; P()); // error, precondition not satisfied\n  var q2 := Q(hide P; reveal P; P()); // no error\n  \n  hide *;\n  \n  var q3 := Q(P()); // error, precondition not satisfied\n  var q4 := Q(reveal P; P()); // no error\n  \n  if (*) {\n    reveal P;\n    assert P();\n  } else {\n    assert P(); // error\n  }\n  reveal P;\n  if (*) {\n    assert P();\n  } else {\n    hide *;\n    assert P(); // error\n  }\n  \n  hide *;\n  if (*) {\n    reveal P;\n  } else {\n    reveal P;\n  }\n  assert P(); // error, since the previous two reveal statements are out of scope\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "// We are using the options --isolate-assertions and --type-system-refresh\npredicate P() { true }\npredicate Q(x: bool) requires x\n\nmethod Foo() {\n  var q1 := Q(hide P; P()); // error, precondition not satisfied\n  var q2 := Q(hide P; reveal P; P()); // no error\n  \n  hide *;\n  \n  var q3 := Q(P()); // error, precondition not satisfied\n  var q4 := Q(reveal P; P()); // no error\n  \n  if (*) {\n    reveal P;\n    assert P();\n  } else {\n    assert P(); // error\n  }\n  reveal P;\n  if (*) {\n    assert P();\n  } else {\n    hide *;\n    assert P(); // error\n  }\n  \n  hide *;\n  if (*) {\n    reveal P;\n  } else {\n    reveal P;\n  }\n  assert P(); // error, since the previous two reveal statements are out of scope\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall i | 0 <= i < a.Length {\n  a[i] := 0;\n}\nforall i | 0 <= i < 100 {\n  P(i); // P a lemma\n}\nforall i | 0 <= i < 100\n  ensures i < 1000 {\n} \n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall i | 0 <= i < a.Length {\n  a[i] := 0;\n}\nforall i | 0 <= i < 100 {\n  P(i); // P a lemma\n}\nforall i | 0 <= i < 100\n  ensures i < 1000 {\n} \n",
        "description": null
      },
      {
        "language": "text",
        "code": "class SimpleQueue<Data(0)>\n{\n  ghost var Contents: seq<Data>\n  var a: array<Data>  // Buffer holding contents of queue.\n  var m: int          // Index head of queue.\n  var n: int          // Index just past end of queue\n   \n  method Enqueue(d: Data)\n    requires a.Length > 0\n    requires 0 <= m <= n <= a.Length\n    modifies this, this.a\n    ensures Contents == old(Contents) + [d]\n  {\n    if n == a.Length {\n      var b := a;\n      if m == 0 { b := new Data[2 * a.Length]; }\n      forall i | 0 <= i < n - m {\n      \tb[i] := a[m + i];\n      }\n      a, m, n := b, 0, n - m;\n    }\n    a[n], n, Contents := d, n + 1, Contents + [d];\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class SimpleQueue<Data(0)>\n{\n  ghost var Contents: seq<Data>\n  var a: array<Data>  // Buffer holding contents of queue.\n  var m: int          // Index head of queue.\n  var n: int          // Index just past end of queue\n   \n  method Enqueue(d: Data)\n    requires a.Length > 0\n    requires 0 <= m <= n <= a.Length\n    modifies this, this.a\n    ensures Contents == old(Contents) + [d]\n  {\n    if n == a.Length {\n      var b := a;\n      if m == 0 { b := new Data[2 * a.Length]; }\n      forall i | 0 <= i < n - m {\n      \tb[i] := a[m + i];\n      }\n      a, m, n := b, 0, n - m;\n    }\n    a[n], n, Contents := d, n + 1, Contents + [d];\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  forall cmd', deps', e' |\n       Hash(Loc(cmd', deps', e')) == Hash(Loc(cmd, deps, e)) {\n    HashProperty(cmd', deps', e', cmd, deps, e);\n  }\n}\n\nlemma HashProperty(cmd: Expression, deps: Expression, ext: string,\n    cmd': Expression, deps': Expression, ext': string)\n  requires Hash(Loc(cmd, deps, ext)) == Hash(Loc(cmd', deps', ext'))\n  ensures cmd == cmd' && deps == deps' && ext == ext'\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m() {\n  forall cmd', deps', e' |\n       Hash(Loc(cmd', deps', e')) == Hash(Loc(cmd, deps, e)) {\n    HashProperty(cmd', deps', e', cmd, deps, e);\n  }\n}\n\nlemma HashProperty(cmd: Expression, deps: Expression, ext: string,\n    cmd': Expression, deps': Expression, ext': string)\n  requires Hash(Loc(cmd, deps, ext)) == Hash(Loc(cmd', deps', ext'))\n  ensures cmd == cmd' && deps == deps' && ext == ext'\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall p | p in DomSt(stCombinedC.st) && p in DomSt(stExecC.st)\n  ensures GetSt(p, stCombinedC.st) == GetSt(p, stExecC.st)\n{\n  assert DomSt(stCombinedC.st) <= DomSt(stExecC.st);\n  assert stCombinedC.st == Restrict(DomSt(stCombinedC.st),\n                                               stExecC.st);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall p | p in DomSt(stCombinedC.st) && p in DomSt(stExecC.st)\n  ensures GetSt(p, stCombinedC.st) == GetSt(p, stExecC.st)\n{\n  assert DomSt(stCombinedC.st) <= DomSt(stExecC.st);\n  assert stCombinedC.st == Restrict(DomSt(stCombinedC.st),\n                                               stExecC.st);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x | P(x) { Lemma(x); }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x | P(x) { Lemma(x); }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x :: P(x) ==> Q(x).\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x :: P(x) ==> Q(x).\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class MyClass {\n  var x: int\n  method N()\n    modifies this\n  {\n    x := 18;\n    modify this;\n    assert x == 18;  // error: cannot conclude this here\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class MyClass {\n  var x: int\n  method N()\n    modifies this\n  {\n    x := 18;\n    modify this;\n    assert x == 18;  // error: cannot conclude this here\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "lemma docalc(x : int, y: int)\n  ensures (x + y) * (x + y) == x * x + 2 * x * y + y * y\n{\n  calc {\n    (x + y) * (x + y);\n    ==\n    // distributive law: (a + b) * c == a * c + b * c\n    x * (x + y) + y * (x + y);\n    ==\n    // distributive law: a * (b + c) == a * b + a * c\n    x * x + x * y + y * x + y * y;\n    ==\n    calc {\n\t    y * x;\n      ==\n\t    x * y;\n    }\n    x * x + x * y + x * y + y * y;\n    ==\n    calc {\n      x * y + x * y;\n      ==\n      // a = 1 * a\n      1 * x * y + 1 * x * y;\n      ==\n      // Distributive law\n      (1 + 1) * x * y;\n      ==\n      2 * x * y;\n    }\n    x * x + 2 * x * y + y * y;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "lemma docalc(x : int, y: int)\n  ensures (x + y) * (x + y) == x * x + 2 * x * y + y * y\n{\n  calc {\n    (x + y) * (x + y);\n    ==\n    // distributive law: (a + b) * c == a * c + b * c\n    x * (x + y) + y * (x + y);\n    ==\n    // distributive law: a * (b + c) == a * b + a * c\n    x * x + x * y + y * x + y * y;\n    ==\n    calc {\n\t    y * x;\n      ==\n\t    x * y;\n    }\n    x * x + x * y + x * y + y * y;\n    ==\n    calc {\n      x * y + x * y;\n      ==\n      // a = 1 * a\n      1 * x * y + 1 * x * y;\n      ==\n      // Distributive law\n      (1 + 1) * x * y;\n      ==\n      2 * x * y;\n    }\n    x * x + 2 * x * y + y * y;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "lemma docalc(x : int, y: int)\n  ensures (x + y) * (x + y) == x * x + 2 * x * y + y * y\n{\n  calc == {\n    (x + y) * (x + y);\n    x * (x + y) + y * (x + y);\n    x * x + x * y + y * x + y * y;\n    x * x + x * y + x * y + y * y;\n    x * x + 2 * x * y + y * y;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "lemma docalc(x : int, y: int)\n  ensures (x + y) * (x + y) == x * x + 2 * x * y + y * y\n{\n  calc == {\n    (x + y) * (x + y);\n    x * (x + y) + y * (x + y);\n    x * x + x * y + y * x + y * y;\n    x * x + x * y + x * y + y * y;\n    x * x + 2 * x * y + y * y;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method OpaqueBlockUser() returns (x: int)\n  ensures x > 4 \n{\n  x := 1;\n  var y := 1;\n  opaque\n    ensures x > 3 \n  {\n    x := x + y;\n    x := x + 2;\n  }\n  assert x == 4; // error\n  x := x + 1;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method OpaqueBlockUser() returns (x: int)\n  ensures x > 4 \n{\n  x := 1;\n  var y := 1;\n  opaque\n    ensures x > 3 \n  {\n    x := x + y;\n    x := x + 2;\n  }\n  assert x == 4; // error\n  x := x + 1;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var a := L(a,b); a*b\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var a := L(a,b); a*b\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Fact(n: nat): nat\n{\n  if n == 0 then 1 else n * Fact(n-1)\n}\n\nlemma L(n: nat)\n  ensures 1 <= Fact(n)\n{\n}\n\nfunction F_Fails(n: nat): int\n{\n  50 / Fact(n)  // error: possible division by zero\n}\n\nfunction F_Succeeds(n: nat): int\n{\n  L(n); // note, this is a lemma call in an expression\n  50 / Fact(n)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function Fact(n: nat): nat\n{\n  if n == 0 then 1 else n * Fact(n-1)\n}\n\nlemma L(n: nat)\n  ensures 1 <= Fact(n)\n{\n}\n\nfunction F_Fails(n: nat): int\n{\n  50 / Fact(n)  // error: possible division by zero\n}\n\nfunction F_Succeeds(n: nat): int\n{\n  L(n); // note, this is a lemma call in an expression\n  50 / Fact(n)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A\nA <==> B\nA <==> C ==> D <==> B \n",
        "description": null
      },
      {
        "language": "text",
        "code": "A\nA <==> B\nA <==> C ==> D <==> B \n",
        "description": null
      },
      {
        "language": "text",
        "code": "A ==> B\nA ==> B ==> C ==> D\nB <== A\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A ==> B\nA ==> B ==> C ==> D\nB <== A\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A && B\nA || B\n&& A && B && C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "A && B\nA || B\n&& A && B && C\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(x: object?, y:object?, z: object?) {\n  var b: bool :=\n    && x != null\n    && y != null\n    && z != null\n    ;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method m(x: object?, y:object?, z: object?) {\n  var b: bool :=\n    && x != null\n    && y != null\n    && z != null\n    ;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x == y\nx != y\nx < y\nx >= y\nx in y\nx ! in y\nx !! y\nx ==#[k] y\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x == y\nx != y\nx < y\nx >= y\nx in y\nx ! in y\nx !! y\nx ==#[k] y\n",
        "description": null
      },
      {
        "language": "text",
        "code": "k << 5\nj >> i\n",
        "description": null
      },
      {
        "language": "text",
        "code": "k << 5\nj >> i\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x + y - z\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x + y - z\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x * y\nx / y\nx % y\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x * y\nx / y\nx % y\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x | y\nx & y\nx ^ y\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x | y\nx & y\nx ^ y\n",
        "description": null
      },
      {
        "language": "text",
        "code": "e as MyClass\ni as bv8\ne is MyClass\n",
        "description": null
      },
      {
        "language": "text",
        "code": "e as MyClass\ni as bv8\ne is MyClass\n",
        "description": null
      },
      {
        "language": "text",
        "code": "trait A { }\ntrait B<X> { }\nclass C<Y> extends B<Y> { }\nclass D<Y(==)> extends B<set<Y>> { }\nclass E extends B<int> { }\nclass F<Z> extends A { }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "trait A { }\ntrait B<X> { }\nclass C<Y> extends B<Y> { }\nclass D<Y(==)> extends B<set<Y>> { }\nclass E extends B<int> { }\nclass F<Z> extends A { }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "-x\n- - x\n! x\n",
        "description": null
      },
      {
        "language": "text",
        "code": "-x\n- - x\n! x\n",
        "description": null
      },
      {
        "language": "text",
        "code": "true\n34\nM(i,j)\nb.c.d\n[1,2,3]\n{2,3,4}\nmap[1 => 2, 3 => 4]\n(i:int,j:int)=>i+j\nif b then 4 else 5\n",
        "description": null
      },
      {
        "language": "text",
        "code": "true\n34\nM(i,j)\nb.c.d\n[1,2,3]\n{2,3,4}\nmap[1 => 2, 3 => 4]\n(i:int,j:int)=>i+j\nif b then 4 else 5\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x => -x\n_ => true\n(x,y) => x*y\n(x:int, b:bool) => if b then x else -x\nx requires x > 0 => x-1\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x => -x\n_ => true\n(x,y) => x*y\n(x:int, b:bool) => if b then x else -x\nx requires x > 0 => x-1\n",
        "description": null
      },
      {
        "language": "text",
        "code": "( _params_ ) _specification_ => _body_\n",
        "description": null
      },
      {
        "language": "text",
        "code": "( _params_ ) _specification_ => _body_\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x => x + 1\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x => x + 1\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x requires x != 0 => 100 / x\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x requires x != 0 => 100 / x\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x requires F.requires(x) reads F.reads(x) => F(x)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x requires F.requires(x) reads F.reads(x) => F(x)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x\na[k]\nLibraryModule.F().x\nold(o.f).x\n",
        "description": null
      },
      {
        "language": "text",
        "code": "x\na[k]\nLibraryModule.F().x\nold(o.f).x\n",
        "description": null
      },
      {
        "language": "text",
        "code": "new int[6]\nnew MyClass\nnew MyClass(x,y,z)\nx+y+z\n*\n",
        "description": null
      },
      {
        "language": "text",
        "code": "new int[6]\nnew MyClass\nnew MyClass(x,y,z)\nx+y+z\n*\n",
        "description": null
      },
      {
        "language": "text",
        "code": "new int[5,6]\nnew int[5][2,3,5,7,11]\nnew int[][2,3,5,7,11]\nnew int[5](i => i*i)\nnew int[2,3]((i,j) => i*j)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "new int[5,6]\nnew int[5][2,3,5,7,11]\nnew int[][2,3,5,7,11]\nnew int[5](i => i*i)\nnew int[2,3]((i,j) => i*j)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var a := new int[5];\nvar b := new int[5][2,3,5,7,11];\nvar c := new int[][2,3,5,7,11];\nvar d := new int[3][4,5,6,7]; // error\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var a := new int[5];\nvar b := new int[5][2,3,5,7,11];\nvar c := new int[][2,3,5,7,11];\nvar d := new int[3][4,5,6,7]; // error\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var a := new int[5](i => i*i);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var a := new int[5](i => i*i);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var m := new real[640, 480];\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var m := new real[640, 480];\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var diag := new int[30, 30]((i, j) => if i == j then 1 else 0);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var diag := new int[30, 30]((i, j) => if i == j then 1 else 0);\n",
        "description": null
      },
      {
        "language": "text",
        "code": "new MyClass\nnew MyClass.Init\nnew MyClass.Init(1,2,3)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "new MyClass\nnew MyClass.Init\nnew MyClass.Init(1,2,3)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "*\n",
        "description": null
      },
      {
        "language": "text",
        "code": "*\n",
        "description": null
      },
      {
        "language": "text",
        "code": "this\nnull\n5\n5.5\ntrue\n'a'\n\"dafny\"\n( e )\n| s |\nold(x)\nallocated(x)\nunchanged(x)\nfresh(e)\nassigned(x)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "this\nnull\n5\n5.5\ntrue\n'a'\n\"dafny\"\n( e )\n| s |\nold(x)\nallocated(x)\nunchanged(x)\nfresh(e)\nassigned(x)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "5\n5.5\ntrue\n'a'\n\"dafny\"\n",
        "description": null
      },
      {
        "language": "text",
        "code": "5\n5.5\ntrue\n'a'\n\"dafny\"\n",
        "description": null
      },
      {
        "language": "text",
        "code": "this\n",
        "description": null
      },
      {
        "language": "text",
        "code": "this\n",
        "description": null
      },
      {
        "language": "text",
        "code": "old(c)\nold@L(c)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "old(c)\nold@L(c)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A {\n\n  var value: int\n\n  method m(i: int)\n    requires i == 6\n    requires value == 42\n    modifies this\n  {\n    var j: int := 17;\n    value := 43;\n    label L:\n    j := 18;\n    value := 44;\n    label M:\n    assert old(i) == 6; // i is local, but can't be changed anyway\n    assert old(j) == 18; // j is local and not affected by old\n    assert old@L(j) == 18; // j is local and not affected by old\n    assert old(value) == 42;\n    assert old@L(value) == 43;\n    assert old@M(value) == 44 && this.value == 44;\n    // value is this.value; 'this' is the same\n    // same reference in current and pre state but the\n    // values stored in the heap as its fields are different;\n    // '.value' evaluates to 42 in the pre-state, 43 at L,\n    // and 44 in the current state\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A {\n\n  var value: int\n\n  method m(i: int)\n    requires i == 6\n    requires value == 42\n    modifies this\n  {\n    var j: int := 17;\n    value := 43;\n    label L:\n    j := 18;\n    value := 44;\n    label M:\n    assert old(i) == 6; // i is local, but can't be changed anyway\n    assert old(j) == 18; // j is local and not affected by old\n    assert old@L(j) == 18; // j is local and not affected by old\n    assert old(value) == 42;\n    assert old@L(value) == 43;\n    assert old@M(value) == 44 && this.value == 44;\n    // value is this.value; 'this' is the same\n    // same reference in current and pre state but the\n    // values stored in the heap as its fields are different;\n    // '.value' evaluates to 42 in the pre-state, 43 at L,\n    // and 44 in the current state\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A {\n  var value: int\n  constructor ()\n     ensures value == 10\n  {\n     value := 10;\n  }\n}\n\nclass B {\n   var a: A\n   constructor () { a := new A(); }\n\n   method m()\n     requires a.value == 11\n     modifies this, this.a\n   {\n     label L:\n     a.value := 12;\n     label M:\n     a := new A(); // Line X\n     label N:\n     a.value := 20;\n     label P:\n\n     assert old(a.value) == 11;\n     assert old(a).value == 12; // this.a is from pre-state,\n                                // but .value in current state\n     assert old@L(a.value) == 11;\n     assert old@L(a).value == 12; // same as above\n     assert old@M(a.value) == 12; // .value in M state is 12\n     assert old@M(a).value == 12;\n     assert old@N(a.value) == 10; // this.a in N is the heap\n                                  // reference at Line X\n     assert old@N(a).value == 20; // .value in current state is 20\n     assert old@P(a.value) == 20;\n     assert old@P(a).value == 20;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A {\n  var value: int\n  constructor ()\n     ensures value == 10\n  {\n     value := 10;\n  }\n}\n\nclass B {\n   var a: A\n   constructor () { a := new A(); }\n\n   method m()\n     requires a.value == 11\n     modifies this, this.a\n   {\n     label L:\n     a.value := 12;\n     label M:\n     a := new A(); // Line X\n     label N:\n     a.value := 20;\n     label P:\n\n     assert old(a.value) == 11;\n     assert old(a).value == 12; // this.a is from pre-state,\n                                // but .value in current state\n     assert old@L(a.value) == 11;\n     assert old@L(a).value == 12; // same as above\n     assert old@M(a.value) == 12; // .value in M state is 12\n     assert old@M(a).value == 12;\n     assert old@N(a.value) == 10; // this.a in N is the heap\n                                  // reference at Line X\n     assert old@N(a).value == 20; // .value in current state is 20\n     assert old@P(a.value) == 20;\n     assert old@P(a).value == 20;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A {\n  var value: int\n  constructor ()\n     ensures value == 10\n  {\n     value := 10;\n  }\n}\n\nclass B {\n   var a: A\n   constructor () { a := new A(); }\n\n   method m()\n     requires a.value == 11\n     modifies this, this.a\n   {\n     label L:\n     a.value := 12;\n     label M:\n     a := new A(); // Line X\n     label N:\n     a.value := 20;\n     label P:\n\n     assert old(a.value) == 11;\n     assert old(a).value == 12; // this.a is from pre-state,\n                                // but .value in current state\n     assert old@L(a.value) == 11;\n     assert old@L(a).value == 12; // same as above\n     assert old@M(a.value) == 12; // .value in M state is 12\n     assert old@M(a).value == 12;\n     assert old@N(a.value) == 10; // this.a in N is the heap\n                                  // reference at Line X\n     assert old@N(a).value == 20; // .value in current state is 20\n     assert old@P(a.value) == 20;\n     assert old@P(a).value == 20;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A {\n  var value: int\n  constructor ()\n     ensures value == 10\n  {\n     value := 10;\n  }\n}\n\nclass B {\n   var a: A\n   constructor () { a := new A(); }\n\n   method m()\n     requires a.value == 11\n     modifies this, this.a\n   {\n     label L:\n     a.value := 12;\n     label M:\n     a := new A(); // Line X\n     label N:\n     a.value := 20;\n     label P:\n\n     assert old(a.value) == 11;\n     assert old(a).value == 12; // this.a is from pre-state,\n                                // but .value in current state\n     assert old@L(a.value) == 11;\n     assert old@L(a).value == 12; // same as above\n     assert old@M(a.value) == 12; // .value in M state is 12\n     assert old@M(a).value == 12;\n     assert old@N(a.value) == 10; // this.a in N is the heap\n                                  // reference at Line X\n     assert old@N(a).value == 20; // .value in current state is 20\n     assert old@P(a.value) == 20;\n     assert old@P(a).value == 20;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A {\n  var z1: array<nat>\n  var z2: array<nat>\n\n  method mm()\n    requires z1.Length > 10 && z1[0] == 7\n    requires z2.Length > 10 && z2[0] == 17\n    modifies z2\n  {\n    var a: array<nat> := z1;\n    assert a[0] == 7;\n    a := z2;\n    assert a[0] == 17;\n    assert old(a[0]) == 17; // a is local with value z2\n    z2[0] := 27;\n    assert old(a[0]) == 17; // a is local, with current value of\n                            // z2; in pre-state z2[0] == 17\n    assert old(a)[0] == 27; // a is local, so old(a) has no effect\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class A {\n  var z1: array<nat>\n  var z2: array<nat>\n\n  method mm()\n    requires z1.Length > 10 && z1[0] == 7\n    requires z2.Length > 10 && z2[0] == 17\n    modifies z2\n  {\n    var a: array<nat> := z1;\n    assert a[0] == 7;\n    a := z2;\n    assert a[0] == 17;\n    assert old(a[0]) == 17; // a is local with value z2\n    z2[0] := 27;\n    assert old(a[0]) == 17; // a is local, with current value of\n                            // z2; in pre-state z2[0] == 17\n    assert old(a)[0] == 27; // a is local, so old(a) has no effect\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "fresh(e)\nfresh@L(e)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "fresh(e)\nfresh@L(e)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C { constructor() {} }\nmethod f(c1: C) returns (r: C)\n  ensures fresh(r)\n{\n  assert !fresh(c1);\n  var c2 := new C();\n  label AfterC2:\n  var c3 := new C();\n  assert fresh(c2) && fresh(c3);\n  assert fresh({c2, c3});\n  assert !fresh@AfterC2(c2) && fresh@AfterC2(c3);\n  r := c2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C { constructor() {} }\nmethod f(c1: C) returns (r: C)\n  ensures fresh(r)\n{\n  assert !fresh(c1);\n  var c2 := new C();\n  label AfterC2:\n  var c3 := new C();\n  assert fresh(c2) && fresh(c3);\n  assert fresh({c2, c3});\n  assert !fresh@AfterC2(c2) && fresh@AfterC2(c3);\n  r := c2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "allocated(c)\nallocated({c1,c2})\n",
        "description": null
      },
      {
        "language": "text",
        "code": "allocated(c)\nallocated({c1,c2})\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C { constructor() {} }\ndatatype D = Nil | Cons(C, D)\nmethod f() {\n  var d1, d2 := Nil, Nil;\n  var c1 := new C();\n  label L1:\n  var c2 := new C();\n  label L2:\n  assert old(allocated(d1) && allocated(d2));\n  d1 := Cons(c1, Nil);\n  assert old(!allocated(d1) && allocated(d2));\n  d2 := Cons(c2, Nil);\n  assert old(!allocated(d1) && !allocated(d2));\n  assert allocated(d1) && allocated(d2);\n  assert old@L1(allocated(d1) && !allocated(d2));\n  assert old@L2(allocated(d1) && allocated(d2));\n  d1 := Nil;\n  assert old(allocated(d1) && !allocated(d2));\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class C { constructor() {} }\ndatatype D = Nil | Cons(C, D)\nmethod f() {\n  var d1, d2 := Nil, Nil;\n  var c1 := new C();\n  label L1:\n  var c2 := new C();\n  label L2:\n  assert old(allocated(d1) && allocated(d2));\n  d1 := Cons(c1, Nil);\n  assert old(!allocated(d1) && allocated(d2));\n  d2 := Cons(c2, Nil);\n  assert old(!allocated(d1) && !allocated(d2));\n  assert allocated(d1) && allocated(d2);\n  assert old@L1(allocated(d1) && !allocated(d2));\n  assert old@L2(allocated(d1) && allocated(d2));\n  d1 := Nil;\n  assert old(allocated(d1) && !allocated(d2));\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "unchanged(c)\nunchanged([c1,c2])\nunchanged@L(c)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "unchanged(c)\nunchanged([c1,c2])\nunchanged@L(c)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c.x == old(c.x) && c.y == old(c.y)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c.x == old(c.x) && c.y == old(c.y)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c.x == old@Lbl(c.x) && c.y == old@Lbl(c.y)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "c.x == old@Lbl(c.x) && c.y == old@Lbl(c.y)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "|s|\n|s[1..i]|\n",
        "description": null
      },
      {
        "language": "text",
        "code": "|s|\n|s[1..i]|\n",
        "description": null
      },
      {
        "language": "text",
        "code": "[1, 2, 3]\n[1]\n[]\nseq(k, n => n+1)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "[1, 2, 3]\n[1]\n[]\nseq(k, n => n+1)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "[1, 2, 3]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "[1, 2, 3]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "seq(k, n => n+1)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "seq(k, n => n+1)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{}\n{1,2,3}\niset{1,2,3,4}\nmultiset{1,2,2,3,3,3}\nmultiset(s)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{}\n{1,2,3}\niset{1,2,3,4}\nmultiset{1,2,2,3,3,3}\nmultiset(s)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{1, 2, 3}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{1, 2, 3}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "multiset{1, 1, 2, 3}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "multiset{1, 1, 2, 3}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var s : set<int> := {1, 2, 3};\nvar ms : multiset<int> := multiset(s);\nms := ms + multiset{1};\nvar sq : seq<int> := [1, 1, 2, 3];\nvar ms2 : multiset<int> := multiset(sq);\nassert ms == ms2;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var s : set<int> := {1, 2, 3};\nvar ms : multiset<int> := multiset(s);\nms := ms + multiset{1};\nvar sq : seq<int> := [1, 1, 2, 3];\nvar ms2 : multiset<int> := multiset(sq);\nassert ms == ms2;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "map[]\nmap[1 := \"a\", 2 := \"b\"]\nimap[1 := \"a\", 2 := \"b\"]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "map[]\nmap[1 := \"a\", 2 := \"b\"]\nimap[1 := \"a\", 2 := \"b\"]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const m := map[1 := \"a\", 2 := \"b\"]\nghost const im := imap[1 := \"a\", 2 := \"b\"]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const m := map[1 := \"a\", 2 := \"b\"]\nghost const im := imap[1 := \"a\", 2 := \"b\"]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if c then e1 else e2\nif x: int :| P(x) then x else 0\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if c then e1 else e2\nif x: int :| P(x) then x else 0\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var k := 10 / x; // error, may divide by 0.\nvar m := if x != 0 then 10 / x else 1; // ok, guarded\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var k := 10 / x; // error, may divide by 0.\nvar m := if x != 0 then 10 / x else 1; // ok, guarded\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate P(x: int) {\n  x == 5 || x == -5\n}\nmethod main() {\n  assert P(5);\n  var y := if x: int :| P(x) then x else 0;\n  assert y == 5 || y == -5;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate P(x: int) {\n  x == 5 || x == -5\n}\nmethod main() {\n  assert P(5);\n  var y := if x: int :| P(x) then x else 0;\n  assert y == 5 || y == -5;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x: int :: x > 0\nforall x: nat | x < 10 :: x*x < 100\nexists x: int :: x * x == 25\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x: int :: x > 0\nforall x: nat | x < 10 :: x*x < 100\nexists x: int :: x * x == 25\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assert forall x : nat | x <= 5 :: x * x <= 25;\n(forall n :: 2 <= n ==> (exists d :: n < d < 2*n))\nassert forall x: nat | 0 <= x < |s|, y <- s[x] :: y < x;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assert forall x : nat | x <= 5 :: x * x <= 25;\n(forall n :: 2 <= n ==> (exists d :: n < d < 2*n))\nassert forall x: nat | 0 <= x < |s|, y <- s[x] :: y < x;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const c1 := set x: nat | x < 100\nconst c2 := set x: nat | x < 100 :: x * x\nconst c3 := set x: nat, y: nat | x < y < 100 :: x * y\nghost const c4 := iset x: nat | x > 100\nghost const c5: iset<int> := iset s\nconst c6 := set x <- c3 :: x + 1\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const c1 := set x: nat | x < 100\nconst c2 := set x: nat | x < 100 :: x * x\nconst c3 := set x: nat, y: nat | x < y < 100 :: x * y\nghost const c4 := iset x: nat | x > 100\nghost const c5: iset<int> := iset s\nconst c6 := set x <- c3 :: x + 1\n",
        "description": null
      },
      {
        "language": "text",
        "code": "set x : T | P(x)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "set x : T | P(x)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "set x : T | P(x) :: x\n",
        "description": null
      },
      {
        "language": "text",
        "code": "set x : T | P(x) :: x\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var S := set x1: T1 <- C1 | P1(x1),\n             x2: T2 <- C2 | P2(x1, x2),\n             ... \n             :: Q(x1, x2, ...)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var S := set x1: T1 <- C1 | P1(x1),\n             x2: T2 <- C2 | P2(x1, x2),\n             ... \n             :: Q(x1, x2, ...)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var S := set x:nat, y:nat | x < y < 3 :: (x, y)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var S := set x:nat, y:nat | x < y < 3 :: (x, y)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "set o: object\n",
        "description": null
      },
      {
        "language": "text",
        "code": "set o: object\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class I {\n  var i: int\n}\n\nmethod test() {\n  ghost var m := set x: I :: 0 <= x.i <= 10;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "class I {\n  var i: int\n}\n\nmethod test() {\n  ghost var m := set x: I :: 0 <= x.i <= 10;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assert x != 0; 10/x\nassert x != 0; assert y > 0; y/x\nassume x != 0; 10/x\nexpect x != 0; 10/x\nreveal M.f; M.f(x)\ncalc { x * 0; == 0; } x/1;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assert x != 0; 10/x\nassert x != 0; assert y > 0; y/x\nassume x != 0; 10/x\nexpect x != 0; 10/x\nreveal M.f; M.f(x)\ncalc { x * 0; == 0; } x/1;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assume x != 0; 10/x\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assume x != 0; 10/x\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var x := f(y); x*x\nvar x :- f(y); x*x\nvar x :| P(x); x*x\nvar (x, y) := T(); x + y   // T returns a tuple\nvar R(x,y) := T(); x + y   // T returns a datatype value R\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var x := f(y); x*x\nvar x :- f(y); x*x\nvar x :| P(x); x*x\nvar (x, y) := T(); x + y   // T returns a tuple\nvar R(x,y) := T(); x + y   // T returns a datatype value R\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var sum := x + y; sum * sum\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var sum := x + y; sum * sum\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Stuff = SCons(x: int, y: int) | Other\nfunction GhostF(z: Stuff): int\n  requires z.SCons?\n{\n  var SCons(u, v) := z; var sum := u + v; sum * sum\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Stuff = SCons(x: int, y: int) | Other\nfunction GhostF(z: Stuff): int\n  requires z.SCons?\n{\n  var SCons(u, v) := z; var sum := u + v; sum * sum\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var tmp := V;\nif tmp.IsFailure()\nthen tmp.PropagateFailure()\nelse E\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var tmp := V;\nif tmp.IsFailure()\nthen tmp.PropagateFailure()\nelse E\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var tmp := V;\nif tmp.IsFailure()\nthen tmp.PropagateFailure()\nelse var v := tmp.Extract(); E\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var tmp := V;\nif tmp.IsFailure()\nthen tmp.PropagateFailure()\nelse var v := tmp.Extract(); E\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var tmp := V;\nif tmp.IsFailure()\nthen tmp.PropagateFailure()\nelse var v, v1 := tmp.Extract(), V1; E\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var tmp := V;\nif tmp.IsFailure()\nthen tmp.PropagateFailure()\nelse var v, v1 := tmp.Extract(), V1; E\n",
        "description": null
      },
      {
        "language": "text",
        "code": "map x : int | 0 <= x <= 10 :: x * x;\nmap x : int | 0 <= x <= 10 :: -x := x * x;\nimap x : int | 10 < x :: x * x;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "map x : int | 0 <= x <= 10 :: x * x;\nmap x : int | 0 <= x <= 10 :: -x := x * x;\nimap x : int | 10 < x :: x * x;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function square(x : int) : int { x * x }\nmethod test()\n{\n  var m := map x : int | 0 <= x <= 10 :: x * x;\n  ghost var im := imap x : int :: x * x;\n  ghost var im2 := imap x : int :: square(x);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function square(x : int) : int { x * x }\nmethod test()\n{\n  var m := map x : int | 0 <= x <= 10 :: x * x;\n  ghost var im := imap x : int :: x * x;\n  ghost var im2 := imap x : int :: square(x);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method test()\n{\n  var m := map x : int | 1 <= x <= 10 :: 2*x := 3*x;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method test()\n{\n  var m := map x : int | 1 <= x <= 10 :: 2*x := 3*x;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "I\nI<int,C>\nI#[k]\nI#<int>[k]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "I\nI<int,C>\nI#[k]\nI#<int>[k]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "codatatype Stream<T> = Nil | Cons(head: int, stuff: T,\n                                  tail: Stream<T>)\n\nfunction append(M: Stream, N: Stream): Stream\n{\n  match M\n  case Nil => N\n  case Cons(t, s, M') => Cons(t, s, append(M', N))\n}\n\nfunction zeros<T>(s : T): Stream<T>\n{\n  Cons(0, s, zeros(s))\n}\n\nfunction ones<T>(s: T): Stream<T>\n{\n  Cons(1, s, ones(s))\n}\n\ngreatest predicate atmost(a: Stream, b: Stream)\n{\n  match a\n  case Nil => true\n  case Cons(h,s,t) => b.Cons? && h <= b.head && atmost(t, b.tail)\n}\n\ngreatest lemma {:induction false} Theorem0<T>(s: T)\n  ensures atmost(zeros(s), ones(s))\n{\n  // the following shows two equivalent ways to state the\n  // coinductive hypothesis\n  if (*) {\n    Theorem0#<T>[_k-1](s);\n  } else {\n    Theorem0(s);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "codatatype Stream<T> = Nil | Cons(head: int, stuff: T,\n                                  tail: Stream<T>)\n\nfunction append(M: Stream, N: Stream): Stream\n{\n  match M\n  case Nil => N\n  case Cons(t, s, M') => Cons(t, s, append(M', N))\n}\n\nfunction zeros<T>(s : T): Stream<T>\n{\n  Cons(0, s, zeros(s))\n}\n\nfunction ones<T>(s: T): Stream<T>\n{\n  Cons(1, s, ones(s))\n}\n\ngreatest predicate atmost(a: Stream, b: Stream)\n{\n  match a\n  case Nil => true\n  case Cons(h,s,t) => b.Cons? && h <= b.head && atmost(t, b.tail)\n}\n\ngreatest lemma {:induction false} Theorem0<T>(s: T)\n  ensures atmost(zeros(s), ones(s))\n{\n  // the following shows two equivalent ways to state the\n  // coinductive hypothesis\n  if (*) {\n    Theorem0#<T>[_k-1](s);\n  } else {\n    Theorem0(s);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a.b\n(a).b<int>\na.b#[k]\na.b#<int>[k]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a.b\n(a).b<int>\na.b#[k]\na.b#<int>[k]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a.(f := e1, g:= e2)\na.(0 := e1)\n(e).(f := e1, g:= e2)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a.(f := e1, g:= e2)\na.(0 := e1)\n(e).(f := e1, g:= e2)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module NewSyntax {\n  datatype MyDataType = MyConstructor(myint:int, mybool:bool)\n                    | MyOtherConstructor(otherbool:bool)\n                    | MyNumericConstructor(42:int)\n\n  method test(datum:MyDataType, x:int)\n    returns (abc:MyDataType, def:MyDataType,\n             ghi:MyDataType, jkl:MyDataType)\n    requires datum.MyConstructor?\n    ensures abc == datum.(myint := x + 2)\n    ensures def == datum.(otherbool := !datum.mybool)  // error\n    ensures ghi == datum.(myint := 2).(mybool := false)\n    // Resolution error: no non_destructor in MyDataType\n    //ensures jkl == datum.(non_destructor := 5) // error\n    ensures jkl == datum.(42 := 7)\n  {\n    abc := MyConstructor(x + 2, datum.mybool);\n    abc := datum.(myint := x + 2);\n    def := MyOtherConstructor(!datum.mybool);\n    ghi := MyConstructor(2, false);\n    jkl := datum.(42 := 7); // error\n\n    assert abc.(myint := abc.myint - 2) == datum.(myint := x);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module NewSyntax {\n  datatype MyDataType = MyConstructor(myint:int, mybool:bool)\n                    | MyOtherConstructor(otherbool:bool)\n                    | MyNumericConstructor(42:int)\n\n  method test(datum:MyDataType, x:int)\n    returns (abc:MyDataType, def:MyDataType,\n             ghi:MyDataType, jkl:MyDataType)\n    requires datum.MyConstructor?\n    ensures abc == datum.(myint := x + 2)\n    ensures def == datum.(otherbool := !datum.mybool)  // error\n    ensures ghi == datum.(myint := 2).(mybool := false)\n    // Resolution error: no non_destructor in MyDataType\n    //ensures jkl == datum.(non_destructor := 5) // error\n    ensures jkl == datum.(42 := 7)\n  {\n    abc := MyConstructor(x + 2, datum.mybool);\n    abc := datum.(myint := x + 2);\n    def := MyOtherConstructor(!datum.mybool);\n    ghi := MyConstructor(2, false);\n    jkl := datum.(42 := 7); // error\n\n    assert abc.(myint := abc.myint - 2) == datum.(myint := x);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a[lo .. hi ]\n(e)[ lo .. ]\ne[ .. hi ]\ne[ .. ]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a[lo .. hi ]\n(e)[ lo .. ]\ne[ .. hi ]\ne[ .. ]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a[ 0 : 2 : 3 ]\na[ e1 : e2 : e3 ]\na[ 0 : 2 : ]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a[ 0 : 2 : 3 ]\na[ e1 : e2 : e3 ]\na[ 0 : 2 : ]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "s[1 := 2, 3 := 4]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "s[1 := 2, 3 := 4]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a[9]\na[i.j.k]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a[9]\na[i.j.k]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "()\n(a)\n(a, b)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "()\n(a)\n(a, b)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "                // empty list\na\na, b\n",
        "description": null
      },
      {
        "language": "text",
        "code": "                // empty list\na\na, b\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a\na, b\na, optimize := b\n",
        "description": null
      },
      {
        "language": "text",
        "code": "a\na, b\na, optimize := b\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assigned(x)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "assigned(x)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method M(x: int, y: int) {\n  assert 1 decreases to 0;\n  assert (true, false decreases to false, true);\n  assert (x, y decreases to x - 1, y);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method M(x: int, y: int) {\n  assert 1 decreases to 0;\n  assert (true, false decreases to false, true);\n  assert (x, y decreases to x - 1, y);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method M(x: int, y: int) {\n  assert x decreases to x + 1;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method M(x: int, y: int) {\n  assert x decreases to x + 1;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const MAX := 47\nnewtype mytype = x | 0 <= x < MAX*4\n",
        "description": null
      },
      {
        "language": "text",
        "code": "const MAX := 47\nnewtype mytype = x | 0 <= x < MAX*4\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module P { // refinement parent\n}\nmodule M refines P { // refining module\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module P { // refinement parent\n}\nmodule M refines P { // refining module\n}\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "\"export\" Ident ellipsis\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module P {\n  module A { const i := 5 }\n  abstract module B { type T }\n}\n\nmodule X refines P {\n  module B' refines P.B { type T = int }\n  module C { const k := 6}\n}\n\nmodule M {\n  import X\n  method m() {\n    var z: X.B'.T := X.A.i + X.C.k;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module P {\n  module A { const i := 5 }\n  abstract module B { type T }\n}\n\nmodule X refines P {\n  module B' refines P.B { type T = int }\n  module C { const k := 6}\n}\n\nmodule M {\n  import X\n  method m() {\n    var z: X.B'.T := X.A.i + X.C.k;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n  const ToDefine: int\n  const ToDefineWithoutType: int\n  const ToGhost: int := 1\n}\n\nmodule B refines A {\n  const ToDefine: int := 2\n  const ToDefineWithoutType ... := 3\n  ghost const ToGhost: int\n  const NewConst: int\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module A {\n  const ToDefine: int\n  const ToDefineWithoutType: int\n  const ToGhost: int := 1\n}\n\nmodule B refines A {\n  const ToDefine: int := 2\n  const ToDefineWithoutType ... := 3\n  ghost const ToGhost: int\n  const NewConst: int\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module A {\n  method ToImplement(x: int) returns (r: int)\n    ensures r > x\n\n  method ToStrengthen(x: int) returns (r: int)\n\n  method ToDeterminize(x: int) returns (r: int)\n    ensures r >= x\n  {\n    var y :| y >= x;\n    return y;\n  }\n\n}\n\nmodule B refines A {\n  method ToImplement(x: int) returns (r: int)\n  {\n    return x + 2;\n  }\n\n  method ToStrengthen ...\n    ensures r == x*2\n  {\n    return x*2;\n  }\n\n  method ToDeterminize(x: int) returns (r: int)\n  {\n    return x;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module A {\n  method ToImplement(x: int) returns (r: int)\n    ensures r > x\n\n  method ToStrengthen(x: int) returns (r: int)\n\n  method ToDeterminize(x: int) returns (r: int)\n    ensures r >= x\n  {\n    var y :| y >= x;\n    return y;\n  }\n\n}\n\nmodule B refines A {\n  method ToImplement(x: int) returns (r: int)\n  {\n    return x + 2;\n  }\n\n  method ToStrengthen ...\n    ensures r == x*2\n  {\n    return x*2;\n  }\n\n  method ToDeterminize(x: int) returns (r: int)\n  {\n    return x;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module A {\n  function F(x: int): (r: int)\n    ensures r > x\n\n  function G(x: int): (r: int)\n    ensures r > x\n  { x + 1 }\n}\n\nmodule B refines A {\n  function F ...\n  { x + 1 }\n\n  function G ...\n    ensures r == x + 1\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module A {\n  function F(x: int): (r: int)\n    ensures r > x\n\n  function G(x: int): (r: int)\n    ensures r > x\n  { x + 1 }\n}\n\nmodule B refines A {\n  function F ...\n  { x + 1 }\n\n  function G ...\n    ensures r == x + 1\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module P {\n  class C {\n    function F(): int\n      ensures F() > 0\n  }\n}\n\nmodule X refines P {\n  class C ... {\n    function F...\n      ensures F() > 0\n    { 1 }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module P {\n  class C {\n    function F(): int\n      ensures F() > 0\n  }\n}\n\nmodule X refines P {\n  class C ... {\n    function F...\n      ensures F() > 0\n    { 1 }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module Parent {\n  type T\n  type B = bool\n  type S = s: string | |s| > 0 witness \"!\"\n  newtype Pos = n: nat | n > 0 witness 1\n  datatype Bool = True | False\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module Parent {\n  type T\n  type B = bool\n  type S = s: string | |s| > 0 witness \"!\"\n  newtype Pos = n: nat | n > 0 witness 1\n  datatype Bool = True | False\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module ChildWithTrait refines Parent {\n  trait T {}\n}\n\nmodule ChildWithClass refines Parent {\n  class T {}\n}\n\nmodule ChildWithSynonymType refines Parent {\n  type T = bool\n}\n\nmodule ChildWithSubsetType refines Parent {\n  type T = s: seq<int> | s != [] witness [0]\n}\n\nmodule ChildWithDataType refines Parent {\n  datatype T = True | False\n}\n\nabstract module ChildWithExtraMembers refines Parent {\n  newtype Pos ... {\n    method Print() { print this; }\n  }\n\n  datatype Bool ... {\n    function AsDafnyBool() : bool { this.True? }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module ChildWithTrait refines Parent {\n  trait T {}\n}\n\nmodule ChildWithClass refines Parent {\n  class T {}\n}\n\nmodule ChildWithSynonymType refines Parent {\n  type T = bool\n}\n\nmodule ChildWithSubsetType refines Parent {\n  type T = s: seq<int> | s != [] witness [0]\n}\n\nmodule ChildWithDataType refines Parent {\n  datatype T = True | False\n}\n\nabstract module ChildWithExtraMembers refines Parent {\n  newtype Pos ... {\n    method Print() { print this; }\n  }\n\n  datatype Bool ... {\n    function AsDafnyBool() : bool { this.True? }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module P {\n  type T3 {\n    function ToString(): string\n  }\n}\n\nmodule X refines P {\n  newtype T3 = i | 0 <= i < 10 {\n    function ToString... { \"\" }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "abstract module P {\n  type T3 {\n    function ToString(): string\n  }\n}\n\nmodule X refines P {\n  newtype T3 = i | 0 <= i < 10 {\n    function ToString... { \"\" }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{:attributeName \"argument\", \"second\" + \"argument\", 57}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{:attributeName \"argument\", \"second\" + \"argument\", 57}\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "Attribute = \"{:\" AttributeName [ Expressions ] \"}\"\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost var Repr: set<object>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost var Repr: set<object>\n",
        "description": null
      },
      {
        "language": "text",
        "code": " reads this, Repr\n",
        "description": null
      },
      {
        "language": "text",
        "code": " reads this, Repr\n",
        "description": null
      },
      {
        "language": "text",
        "code": " this in Repr && null !in Repr\n",
        "description": null
      },
      {
        "language": "text",
        "code": " this in Repr && null !in Repr\n",
        "description": null
      },
      {
        "language": "text",
        "code": " && (A != null ==> A in Repr)\n",
        "description": null
      },
      {
        "language": "text",
        "code": " && (A != null ==> A in Repr)\n",
        "description": null
      },
      {
        "language": "text",
        "code": " (F != null ==> F in Repr && F.Repr <= Repr && this !in F.Repr)\n",
        "description": null
      },
      {
        "language": "text",
        "code": " (F != null ==> F in Repr && F.Repr <= Repr && this !in F.Repr)\n",
        "description": null
      },
      {
        "language": "text",
        "code": " modifies this\n ensures Valid() && fresh(Repr - {this})\n",
        "description": null
      },
      {
        "language": "text",
        "code": " modifies this\n ensures Valid() && fresh(Repr - {this})\n",
        "description": null
      },
      {
        "language": "text",
        "code": " Repr := {this};\n if (A != null) { Repr := Repr + {A}; }\n if (F != null) { Repr := Repr + {F} + F.Repr; }\n",
        "description": null
      },
      {
        "language": "text",
        "code": " Repr := {this};\n if (A != null) { Repr := Repr + {A}; }\n if (F != null) { Repr := Repr + {F} + F.Repr; }\n",
        "description": null
      },
      {
        "language": "text",
        "code": " requires Valid()\n modifies Repr\n ensures Valid() && fresh(Repr - old(Repr))\n",
        "description": null
      },
      {
        "language": "text",
        "code": " requires Valid()\n modifies Repr\n ensures Valid() && fresh(Repr - old(Repr))\n",
        "description": null
      },
      {
        "language": "text",
        "code": " if (A != null) { Repr := Repr + {A}; }\n if (F != null) { Repr := Repr + {F} + F.Repr; }\n",
        "description": null
      },
      {
        "language": "text",
        "code": " if (A != null) { Repr := Repr + {A}; }\n if (F != null) { Repr := Repr + {F} + F.Repr; }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype {:nativeType \"byte\"} ubyte = x : int | 0 <= x < 256\nnewtype {:nativeType \"byte\"} bad_ubyte = x : int | 0 <= x < 257 // Fails\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype {:nativeType \"byte\"} ubyte = x : int | 0 <= x < 256\nnewtype {:nativeType \"byte\"} bad_ubyte = x : int | 0 <= x < 257 // Fails\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function f(x:int) : bool\n  requires x > 3\n{\n  x > 7\n}\n\n// Should succeed thanks to auto_reqs\nfunction {:autoReq} g(y:int, b:bool) : bool\n{\n  if b then f(y + 2) else f(2*y)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function f(x:int) : bool\n  requires x > 3\n{\n  x > 7\n}\n\n// Should succeed thanks to auto_reqs\nfunction {:autoReq} g(y:int, b:bool) : bool\n{\n  if b then f(y + 2) else f(2*y)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function f(x:int) : bool\n  requires x > 3\n{\n  x > 7\n}\nfunction g(y:int, b:bool) : bool\n  requires if b then y + 2 > 3 else 2 * y > 3\n{\n  if b then f(y + 2) else f(2*y)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function f(x:int) : bool\n  requires x > 3\n{\n  x > 7\n}\nfunction g(y:int, b:bool) : bool\n  requires if b then y + 2 > 3 else 2 * y > 3\n{\n  if b then f(y + 2) else f(2*y)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "   function t1() : bool { true }\n   \n   function t2() : bool { t1() }\n\n   function {:autoRevealDependencies 1} p() : (r: bool) \n     ensures r\n   { t1() }\n   \n   function {:autoRevealDependencies 1} q() : (r: bool) \n     ensures r\n   { t2() }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "   function t1() : bool { true }\n   \n   function t2() : bool { t1() }\n\n   function {:autoRevealDependencies 1} p() : (r: bool) \n     ensures r\n   { t1() }\n   \n   function {:autoRevealDependencies 1} q() : (r: bool) \n     ensures r\n   { t2() }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{:fuel functionName,lowFuel,highFuel}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{:fuel functionName,lowFuel,highFuel}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Unary = Zero | Succ(Unary)\n\nfunction UnaryToNat(n: Unary): nat {\n  match n\n  case Zero => 0\n  case Succ(p) => 1 + UnaryToNat(p)\n}\n\nfunction NatToUnary(n: nat): Unary {\n  if n == 0 then Zero else Succ(NatToUnary(n - 1))\n}\n\nlemma Correspondence()\n  ensures forall n: nat {:induction n} :: UnaryToNat(NatToUnary(n)) == n\n{\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Unary = Zero | Succ(Unary)\n\nfunction UnaryToNat(n: Unary): nat {\n  match n\n  case Zero => 0\n  case Succ(p) => 1 + UnaryToNat(p)\n}\n\nfunction NatToUnary(n: nat): Unary {\n  if n == 0 then Zero else Succ(NatToUnary(n - 1))\n}\n\nlemma Correspondence()\n  ensures forall n: nat {:induction n} :: UnaryToNat(NatToUnary(n)) == n\n{\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:only} TestVerified() {\n  assert true;                  // Unchecked\n  assert {:only} true by {      // Checked\n    assert true;                // Checked\n  }\n  assert true;                  // Unchecked\n}\n\nmethod TestUnverified() {\n  assert true;                  // Unchecked\n  assert {:only} true by {      // Unchecked because of {:only} Test()\n    assert true;                // Unchecked\n  }\n  assert true;                  // Unchecked\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:only} TestVerified() {\n  assert true;                  // Unchecked\n  assert {:only} true by {      // Checked\n    assert true;                // Checked\n  }\n  assert true;                  // Unchecked\n}\n\nmethod TestUnverified() {\n  assert true;                  // Unchecked\n  assert {:only} true by {      // Unchecked because of {:only} Test()\n    assert true;                // Unchecked\n  }\n  assert true;                  // Unchecked\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method f() {\n  assert true;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method f() {\n  assert true;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method f(a: bool, b: bool) {\n  assert a: (a ==> b) <==> (!b ==> !a);\n  assert b: (a ==> b) <==> (!b ==> !a);\n  assert c: (a ==> b) <==> (!b ==> !a);\n  assert d: (a ==> b) <==> (!b ==> !a);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method f(a: bool, b: bool) {\n  assert a: (a ==> b) <==> (!b ==> !a);\n  assert b: (a ==> b) <==> (!b ==> !a);\n  assert c: (a ==> b) <==> (!b ==> !a);\n  assert d: (a ==> b) <==> (!b ==> !a);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:isolate_assertions} f(a: bool, b: bool) {\n  assert a: (a ==> b) <==> (!b ==> !a);\n  assert b: (a ==> b) <==> (!b ==> !a);\n  assert c: (a ==> b) <==> (!b ==> !a);\n  assert d: (a ==> b) <==> (!b ==> !a);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:isolate_assertions} f(a: bool, b: bool) {\n  assert a: (a ==> b) <==> (!b ==> !a);\n  assert b: (a ==> b) <==> (!b ==> !a);\n  assert c: (a ==> b) <==> (!b ==> !a);\n  assert d: (a ==> b) <==> (!b ==> !a);\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:rlimit 30} f(a: int, b: int, c: int) {\n  assert ((1 + a*a)*c) / (1 + a*a) == c;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:rlimit 30} f(a: int, b: int, c: int) {\n  assert ((1 + a*a)*c) / (1 + a*a) == c;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Result<V,E> = Success(value: V) | Failure(error: E)\n\nfunction f(x: int): Result<int, string>\n\n//  {:tailrecursion true}  Not possible here\nfunction MakeTailRec(\n  obj: seq<int>\n): Result<seq<int>, string>\n{\n  if |obj| == 0 then Success([])\n  else\n    var tail := MakeTailRec(obj[1..]);\n    var r := f(obj[0]);\n    if r.Failure? then\n      Failure(r.error)\n    else if tail.Failure? then\n      tail\n    else\n      Success([r.value] + tail.value)\n} by method {\n  var i: nat := |obj|;\n  var tail := Success([]); // Base case\n  while i != 0\n    decreases i\n    invariant tail == MakeTailRec(obj[i..])\n  {\n    i := i - 1;\n    var r := f(obj[i]);\n    if r.Failure? {\n      tail := Failure(r.error);\n    } else if tail.Success? {\n      tail := Success([r.value] + tail.value);\n    } else {\n    }\n  }\n  return tail;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Result<V,E> = Success(value: V) | Failure(error: E)\n\nfunction f(x: int): Result<int, string>\n\n//  {:tailrecursion true}  Not possible here\nfunction MakeTailRec(\n  obj: seq<int>\n): Result<seq<int>, string>\n{\n  if |obj| == 0 then Success([])\n  else\n    var tail := MakeTailRec(obj[1..]);\n    var r := f(obj[0]);\n    if r.Failure? then\n      Failure(r.error)\n    else if tail.Failure? then\n      tail\n    else\n      Success([r.value] + tail.value)\n} by method {\n  var i: nat := |obj|;\n  var tail := Success([]); // Base case\n  while i != 0\n    decreases i\n    invariant tail == MakeTailRec(obj[i..])\n  {\n    i := i - 1;\n    var r := f(obj[i]);\n    if r.Failure? {\n      tail := Failure(r.error);\n    } else if tail.Success? {\n      tail := Success([r.value] + tail.value);\n    } else {\n    }\n  }\n  return tail;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "S         = FORALL\n          | EQUALS\n          | S && S\nEQUALS    = ID.ID (ARGLIST) == EXPR // stubs a function call\n          | ID.ID           == EXPR // stubs field access\n          | EQUALS && EQUALS\nFORALL    = forall BOUNDVARS :: EXPR ==> EQUALS\nARGLIST   = ID   // this can be one of the bound variables\n          | EXPR // this expr may not reference any of the bound variables\n          | ARGLIST, ARGLIST\nBOUNDVARS = ID : ID\n          | BOUNDVARS, BOUNDVARS\n",
        "description": null
      },
      {
        "language": "text",
        "code": "S         = FORALL\n          | EQUALS\n          | S && S\nEQUALS    = ID.ID (ARGLIST) == EXPR // stubs a function call\n          | ID.ID           == EXPR // stubs field access\n          | EQUALS && EQUALS\nFORALL    = forall BOUNDVARS :: EXPR ==> EQUALS\nARGLIST   = ID   // this can be one of the bound variables\n          | EXPR // this expr may not reference any of the bound variables\n          | ARGLIST, ARGLIST\nBOUNDVARS = ID : ID\n          | BOUNDVARS, BOUNDVARS\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Test() {\n  assert true;                  // Unchecked\n  assert {:only} true by {      // Checked\n    assert true;                // Checked\n  }\n  assert true;                  // Unchecked\n  assert {:only \"after\"} true;  // Checked\n  assert true;                  // Checked\n  assert {:only \"before\"} true; // Checked\n  assert true;                  // Unchecked\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Test() {\n  assert true;                  // Unchecked\n  assert {:only} true by {      // Checked\n    assert true;                // Checked\n  }\n  assert true;                  // Unchecked\n  assert {:only \"after\"} true;  // Checked\n  assert true;                  // Checked\n  assert {:only \"before\"} true; // Checked\n  assert true;                  // Unchecked\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method doFocus1(x: bool) returns (y: int) {\n  y := 1;                     // Batch 1    Batch 2\n  assert y == 1;              // Assertion  --\n  if x {\n    if false {\n      assert y >= 0;          // --         Assertion\n      assert {:focus} y <= 2; // --         Assertion\n      y := 2;\n      assert y == 2;          // --         Assertion\n    }\n  } else {\n    assert y == 1;            // Assertion  --\n  }\n  assert y == 1;              // Assertion  Assertion\n  if !x {\n    assert y >= 1;            // Assertion  Assertion\n  } else {\n    assert y <= 1;            // Assertion  Assertion\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method doFocus1(x: bool) returns (y: int) {\n  y := 1;                     // Batch 1    Batch 2\n  assert y == 1;              // Assertion  --\n  if x {\n    if false {\n      assert y >= 0;          // --         Assertion\n      assert {:focus} y <= 2; // --         Assertion\n      y := 2;\n      assert y == 2;          // --         Assertion\n    }\n  } else {\n    assert y == 1;            // Assertion  --\n  }\n  assert y == 1;              // Assertion  Assertion\n  if !x {\n    assert y >= 1;            // Assertion  Assertion\n  } else {\n    assert y <= 1;            // Assertion  Assertion\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method doFocus2(x: bool) returns (y: int) {\n  y := 1;                     // Batch 1    Batch 2\n  assert y == 1;              // Assertion  --\n  if x {\n    while false {\n      assert y >= 0;          // --         Assertion\n      assert {:focus} y <= 2; // --         Assertion\n      y := 2;\n      assert y == 2;          // --         Assertion\n    }\n  } else {\n    assert y == 1;            // Assertion  --\n  }\n  assert y == 1;              // Assertion  --\n  if !x {\n    assert y >= 1;            // Assertion  --\n  } else {\n    assert y <= 1;            // Assertion  --\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method doFocus2(x: bool) returns (y: int) {\n  y := 1;                     // Batch 1    Batch 2\n  assert y == 1;              // Assertion  --\n  if x {\n    while false {\n      assert y >= 0;          // --         Assertion\n      assert {:focus} y <= 2; // --         Assertion\n      y := 2;\n      assert y == 2;          // --         Assertion\n    }\n  } else {\n    assert y == 1;            // Assertion  --\n  }\n  assert y == 1;              // Assertion  --\n  if !x {\n    assert y >= 1;            // Assertion  --\n  } else {\n    assert y <= 1;            // Assertion  --\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method doSplitHere(x: bool) returns (y: int) {\n  y := 1;                      // Batch 1    Batch 2     Batch 3\n  assert y >= 0;               // Assertion  --          --\n  if x {\n    assert y <= 1;             // Assertion  --          --\n    assert {:split_here} true; // --         Assertion   --\n    assert y <= 2;             // --         Assertion   --\n    assert {:split_here} true; // --         --          Assertion\n    if x {\n      assert y == 1;           // --         --          Assertion\n    } else {\n      assert y >= 1;           // --         --          Assertion\n    }\n  } else {\n    assert y <= 3;             // Assertion  --          --\n  }\n  assert y >= -1;              // Assertion  --          --\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method doSplitHere(x: bool) returns (y: int) {\n  y := 1;                      // Batch 1    Batch 2     Batch 3\n  assert y >= 0;               // Assertion  --          --\n  if x {\n    assert y <= 1;             // Assertion  --          --\n    assert {:split_here} true; // --         Assertion   --\n    assert y <= 2;             // --         Assertion   --\n    assert {:split_here} true; // --         --          Assertion\n    if x {\n      assert y == 1;           // --         --          Assertion\n    } else {\n      assert y >= 1;           // --         --          Assertion\n    }\n  } else {\n    assert y <= 3;             // Assertion  --          --\n  }\n  assert y >= -1;              // Assertion  --          --\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Process(instances: int, price: int)\n  requires {:error \"There should be an even number of instances\", \"The number of instances is always even\"} instances % 2 == 0\n  requires {:error \"Could not prove that the price is positive\", \"The price is always positive\"} price >= 0\n{\n}\nmethod Test()\n{\n  if * {\n    Process(1, 0); // Error: There should be an even number of instances\n  }\n  if * {\n    Process(2, -1); // Error: Could not prove that the price is positive\n  }\n  if * {\n    Process(2, 5); // Success: The number of instances is always even\n                   // Success: The price is always positive\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Process(instances: int, price: int)\n  requires {:error \"There should be an even number of instances\", \"The number of instances is always even\"} instances % 2 == 0\n  requires {:error \"Could not prove that the price is positive\", \"The price is always positive\"} price >= 0\n{\n}\nmethod Test()\n{\n  if * {\n    Process(1, 0); // Error: There should be an even number of instances\n  }\n  if * {\n    Process(2, -1); // Error: Could not prove that the price is positive\n  }\n  if * {\n    Process(2, 5); // Success: The number of instances is always even\n                   // Success: The price is always positive\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate P(i: int)\npredicate Q(i: int)\n\nlemma {:axiom} PHoldEvenly()\n  ensures  forall i {:trigger Q(i)} :: P(i) ==> P(i + 2) && Q(i)\n\nlemma PHoldsForTwo()\n  ensures forall i :: P(i) ==> P(i + 4)\n{\n  forall j: int\n    ensures P(j) ==> P(j + 4)\n  {\n    if P(j) {\n      assert P(j); // Trivial assertion\n      \n      PHoldEvenly();\n      // Invoking the lemma assumes `forall i :: P(i) ==> P(i + 4)`,\n      // but it's not instantiated yet\n      \n      // The verifier sees `Q(j)`, so it instantiates\n      // `forall i :: P(i) ==> P(i + 4)` with `j`\n      // and we get the axiom `P(j) ==> P(j + 2) && Q(j)`\n      assert Q(j);     // hence it can prove `Q(j)`\n      assert P(j + 2); //   and it can prove `P(j + 2)`\n      assert P(j + 4); // But it cannot prove this\n      // because it did not instantiate `forall i :: P(i) ==> P(i + 4)` with `j+2`\n    }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate P(i: int)\npredicate Q(i: int)\n\nlemma {:axiom} PHoldEvenly()\n  ensures  forall i {:trigger Q(i)} :: P(i) ==> P(i + 2) && Q(i)\n\nlemma PHoldsForTwo()\n  ensures forall i :: P(i) ==> P(i + 4)\n{\n  forall j: int\n    ensures P(j) ==> P(j + 4)\n  {\n    if P(j) {\n      assert P(j); // Trivial assertion\n      \n      PHoldEvenly();\n      // Invoking the lemma assumes `forall i :: P(i) ==> P(i + 4)`,\n      // but it's not instantiated yet\n      \n      // The verifier sees `Q(j)`, so it instantiates\n      // `forall i :: P(i) ==> P(i + 4)` with `j`\n      // and we get the axiom `P(j) ==> P(j + 2) && Q(j)`\n      assert Q(j);     // hence it can prove `Q(j)`\n      assert P(j + 2); //   and it can prove `P(j + 2)`\n      assert P(j + 4); // But it cannot prove this\n      // because it did not instantiate `forall i :: P(i) ==> P(i + 4)` with `j+2`\n    }\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "@IsolateAssertions\nmethod Test() {\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "@IsolateAssertions\nmethod Test() {\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:isolate_assertions} Test() {\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:isolate_assertions} Test() {\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Attribute =\n  | AutoContracts\n  | AutoRequires\n  | AutoRevealDependenciesAll\n  | AutoRevealDependencies\n  | Axiom\n  | Compile(bool)\n  | Concurrent\n  | DisableNonlinearArithmetic\n  | Fuel(low: int, high: int := low + 1, functionName: string := \"\")\n  | IsolateAssertions\n  | NativeUInt8 | NativeInt8 ... | NativeUInt128 | NativeInt128 | NativeInt | NativeNone | NativeIntOrReal\n  | Options(string)\n  | Print\n  | Priority(weight: int)\n  | ResourceLimit(value: string)\n  | Synthesize\n  | TimeLimit(amount: int)\n  | TimeLimitMultiplier(multiplier: int)\n  | TailRecursion\n  | Test\n  | TestEntry\n  | TestInline(amount: int)\n  | Transparent\n  | VcsMaxCost\n  | VcsMaxKeepGoingSplits\n  | VcsMaxSplits\n  | Verify(verify: bool)\n  | VerifyOnly\n  \n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype Attribute =\n  | AutoContracts\n  | AutoRequires\n  | AutoRevealDependenciesAll\n  | AutoRevealDependencies\n  | Axiom\n  | Compile(bool)\n  | Concurrent\n  | DisableNonlinearArithmetic\n  | Fuel(low: int, high: int := low + 1, functionName: string := \"\")\n  | IsolateAssertions\n  | NativeUInt8 | NativeInt8 ... | NativeUInt128 | NativeInt128 | NativeInt | NativeNone | NativeIntOrReal\n  | Options(string)\n  | Print\n  | Priority(weight: int)\n  | ResourceLimit(value: string)\n  | Synthesize\n  | TimeLimit(amount: int)\n  | TimeLimitMultiplier(multiplier: int)\n  | TailRecursion\n  | Test\n  | TestEntry\n  | TestInline(amount: int)\n  | Transparent\n  | VcsMaxCost\n  | VcsMaxKeepGoingSplits\n  | VcsMaxSplits\n  | Verify(verify: bool)\n  | VerifyOnly\n  \n",
        "description": null
      },
      {
        "language": "text",
        "code": "type List<T>\nfunction Elements<T>(list: List<T>): set<T>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type List<T>\nfunction Elements<T>(list: List<T>): set<T>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type List<T>\nfunction Elements(list: List): set\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type List<T>\nfunction Elements(list: List): set\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type List<T>\nfunction Elements<T>(list: List): set\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type List<T>\nfunction Elements<T>(list: List): set\n",
        "description": null
      },
      {
        "language": "text",
        "code": "```dafny\nmethod M(n: nat) returns (y: int)\n{\n  var a, b;\n  for i := 0 to n {\n    if i % 2 == 0 {\n      a := a + b;\n    }\n  }\n  y := a;\n}\n```\n",
        "description": null
      },
      {
        "language": "text",
        "code": "```dafny\nmethod M(n: nat) returns (y: int)\n{\n  var a, b;\n  for i := 0 to n {\n    if i % 2 == 0 {\n      a := a + b;\n    }\n  }\n  y := a;\n}\n```\n",
        "description": null
      },
      {
        "language": "text",
        "code": "```dafny\nclass Cell {\n  var data: int\n}\n\nmethod LastFive(a: array<int>) returns (r: int)\n{\n  var u := null;\n  for i := 0 to a.Length {\n    if a[i] == 5 {\n      u := new Cell;\n      u.data := i;\n    }\n  }\n  r := if u == null then a.Length else u.data;\n}\n```\n",
        "description": null
      },
      {
        "language": "text",
        "code": "```dafny\nclass Cell {\n  var data: int\n}\n\nmethod LastFive(a: array<int>) returns (r: int)\n{\n  var u := null;\n  for i := 0 to a.Length {\n    if a[i] == 5 {\n      u := new Cell;\n      u.data := i;\n    }\n  }\n  r := if u == null then a.Length else u.data;\n}\n```\n",
        "description": null
      },
      {
        "language": "text",
        "code": "```dafny\ndatatype List<T> = Nil | Cons(T, List<T>)\n\nmethod Tutone() {\n  assert forall pair :: pair.0 == 867 && pair.1 == 5309 ==> pair == (867, 5309); // error: members .0 and .1 not found\n  assert forall pair: (int, int) :: pair.0 == 867 && pair.1 == 5309 ==> pair == (867, 5309);\n}\n```\n",
        "description": null
      },
      {
        "language": "text",
        "code": "```dafny\ndatatype List<T> = Nil | Cons(T, List<T>)\n\nmethod Tutone() {\n  assert forall pair :: pair.0 == 867 && pair.1 == 5309 ==> pair == (867, 5309); // error: members .0 and .1 not found\n  assert forall pair: (int, int) :: pair.0 == 867 && pair.1 == 5309 ==> pair == (867, 5309);\n}\n```\n",
        "description": null
      },
      {
        "language": "text",
        "code": "```dafny\ndatatype Option<T> = None | Some(T)\n\nmethod M() {\n  var a: Option<int> := None;\n  var b := None; // error: type is underspecified\n  var c := Option<int>.None;\n  var d := None;\n  d := Some(400);\n}\n```\n",
        "description": null
      },
      {
        "language": "text",
        "code": "```dafny\ndatatype Option<T> = None | Some(T)\n\nmethod M() {\n  var a: Option<int> := None;\n  var b := None; // error: type is underspecified\n  var c := Option<int>.None;\n  var d := None;\n  d := Some(400);\n}\n```\n",
        "description": null
      },
      {
        "language": "text",
        "code": "```dafny\nfunction EmptySet<T>(): set<T> {\n  {}\n}\n\nmethod M() {\n  var a := EmptySet(); // error: type is underspecified\n  var b := EmptySet();\n  b := b + {2, 3, 5};\n  var c := EmptySet<int>();\n}\n```\n",
        "description": null
      },
      {
        "language": "text",
        "code": "```dafny\nfunction EmptySet<T>(): set<T> {\n  {}\n}\n\nmethod M() {\n  var a := EmptySet(); // error: type is underspecified\n  var b := EmptySet();\n  b := b + {2, 3, 5};\n  var c := EmptySet<int>();\n}\n```\n",
        "description": null
      },
      {
        "language": "text",
        "code": "```dafny\nmethod NewArrays()\n{\n  var a := new int[3];\n  var b: array<int> := new [3];\n  var c := new [3];\n  c[0] := 200;\n  var d := new [3] [200, 800, 77];\n  var e := new [] [200, 800, 77];\n  var f := new [3](_ => 990);\n}\n```\n",
        "description": null
      },
      {
        "language": "text",
        "code": "```dafny\nmethod NewArrays()\n{\n  var a := new int[3];\n  var b: array<int> := new [3];\n  var c := new [3];\n  c[0] := 200;\n  var d := new [3] [200, 800, 77];\n  var e := new [] [200, 800, 77];\n  var f := new [3](_ => 990);\n}\n```\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var x := 1;\nif(f(x)) {\n  x := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var x := 1;\nif(f(x)) {\n  x := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function fib(n: nat): nat\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "function fib(n: nat): nat\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "lemma FibProperty(n: nat)\n  ensures fib(n) % 2 == 0 <==> n % 3 == 0\n{\n  if n < 2 {\n  } else {\n    FibProperty(n-2); FibProperty(n-1);\n  }\n}\nfunction fib(n: nat): nat\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "lemma FibProperty(n: nat)\n  ensures fib(n) % 2 == 0 <==> n % 3 == 0\n{\n  if n < 2 {\n  } else {\n    FibProperty(n-2); FibProperty(n-1);\n  }\n}\nfunction fib(n: nat): nat\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall n' | 0 <= n' < n {\n  FibProperty(n');\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall n' | 0 <= n' < n {\n  FibProperty(n');\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall k | P(k)\n  ensures Q(k)\n{ Statements; }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall k | P(k)\n  ensures Q(k)\n{ Statements; }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "lemma FibProperty(n: nat)\n  ensures fib(n) % 2 == 0 <==> n % 3 == 0\n{ }\nfunction fib(n: nat): nat\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "lemma FibProperty(n: nat)\n  ensures fib(n) % 2 == 0 <==> n % 3 == 0\n{ }\nfunction fib(n: nat): nat\n{\n  if n < 2 then n else fib(n-2) + fib(n-1)\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "least predicate g[nat](x: int) { x == 0 || g(x-2) }\ngreatest predicate G[nat](x: int) { x == 0 || G(x-2) }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "least predicate g[nat](x: int) { x == 0 || g(x-2) }\ngreatest predicate G[nat](x: int) { x == 0 || G(x-2) }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate g#[_k: nat](x: int) { _k != 0 && (x == 0 || g#[_k-1](x-2)) }\npredicate G#[_k: nat](x: int) { _k != 0 ==> (x == 0 || G#[_k-1](x-2)) }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "predicate g#[_k: nat](x: int) { _k != 0 && (x == 0 || g#[_k-1](x-2)) }\npredicate G#[_k: nat](x: int) { _k != 0 ==> (x == 0 || G#[_k-1](x-2)) }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "least predicate g[nat](x: int) { x == 0 || g(x-2) }\ngreatest predicate G[nat](x: int) { x == 0 || G(x-2) }\nlemma EvenNat(x: int)\n  requires g(x)\n  ensures 0 <= x && x % 2 == 0\n{\n  var k: nat :| g#[k](x);\n  EvenNatAux(k, x);\n}\nlemma EvenNatAux(k: nat, x: int)\n  requires g#[k](x)\n  ensures 0 <= x && x % 2 == 0\n{\n  if x == 0 { } else { EvenNatAux(k-1, x-2); }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "least predicate g[nat](x: int) { x == 0 || g(x-2) }\ngreatest predicate G[nat](x: int) { x == 0 || G(x-2) }\nlemma EvenNat(x: int)\n  requires g(x)\n  ensures 0 <= x && x % 2 == 0\n{\n  var k: nat :| g#[k](x);\n  EvenNatAux(k, x);\n}\nlemma EvenNatAux(k: nat, x: int)\n  requires g#[k](x)\n  ensures 0 <= x && x % 2 == 0\n{\n  if x == 0 { } else { EvenNatAux(k-1, x-2); }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall k', x' | 0 <= k' < k && g#[k'](x') {\n  EvenNatAux(k', x');\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall k', x' | 0 <= k' < k && g#[k'](x') {\n  EvenNatAux(k', x');\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "least predicate g[nat](x: int) { x == 0 || g(x-2) }\ngreatest predicate G[nat](x: int) { x == 0 || G(x-2) }\nlemma Always(x: int)\n  ensures G(x)\n{ forall k: nat { AlwaysAux(k, x); } }\nlemma AlwaysAux(k: nat, x: int)\n  ensures G#[k](x)\n{ }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "least predicate g[nat](x: int) { x == 0 || g(x-2) }\ngreatest predicate G[nat](x: int) { x == 0 || G(x-2) }\nlemma Always(x: int)\n  ensures G(x)\n{ forall k: nat { AlwaysAux(k, x); } }\nlemma AlwaysAux(k: nat, x: int)\n  ensures G#[k](x)\n{ }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "least predicate g(x: int) { x == 0 || g(x-2) }\ngreatest predicate G(x: int) { x == 0 || G(x-2) }\nleast lemma EvenNat(x: int)\n  requires g(x)\n  ensures 0 <= x && x % 2 == 0\n{ if x == 0 { } else { EvenNat(x-2); } }\ngreatest lemma Always(x: int)\n  ensures G(x)\n{ Always(x-2); }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "least predicate g(x: int) { x == 0 || g(x-2) }\ngreatest predicate G(x: int) { x == 0 || G(x-2) }\nleast lemma EvenNat(x: int)\n  requires g(x)\n  ensures 0 <= x && x % 2 == 0\n{ if x == 0 { } else { EvenNat(x-2); } }\ngreatest lemma Always(x: int)\n  ensures G(x)\n{ Always(x-2); }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype D = D(s: set<D>)\n\nmethod TestD(dd: D) {\n  var d := dd;\n  while d != D({})\n    decreases d\n  {\n    var x :| x in d.s;\n    d := x;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "datatype D = D(s: set<D>)\n\nmethod TestD(dd: D) {\n  var d := dd;\n  while d != D({})\n    decreases d\n  {\n    var x :| x in d.s;\n    d := x;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x {P(x)} {Q(x)} :: P(x) &&\nforall x {(Q(x)} :: Q(x) =⇒ P(x+1)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "forall x {P(x)} {Q(x)} :: P(x) &&\nforall x {(Q(x)} :: Q(x) =⇒ P(x+1)\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny build -t:lib A.dfy B.dfy C.dfy --output:MyLib.doo\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny build -t:lib A.dfy B.dfy C.dfy --output:MyLib.doo\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:test} m() {\n  mm();\n  print \"Hi!\\n\";\n}\n\nmethod mm() {\n  print \"mm\\n\";\n}\n\nmodule M {\n  method {:test} q() {\n    print 42, \"\\n\";\n  }\n}\n\nclass A {\n  static method {:test} t() { print \"T\\n\"; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method {:test} m() {\n  mm();\n  print \"Hi!\\n\";\n}\n\nmethod mm() {\n  print \"mm\\n\";\n}\n\nmodule M {\n  method {:test} q() {\n    print 42, \"\\n\";\n  }\n}\n\nclass A {\n  static method {:test} t() { print \"T\\n\"; }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny test --no-verify t.dfy\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny test --no-verify t.dfy\n",
        "description": null
      },
      {
        "language": "text",
        "code": "M.q: 42\nPASSED\nA.t: T\nPASSED\nm: mm\nHi!\nPASSED\n",
        "description": null
      },
      {
        "language": "text",
        "code": "M.q: 42\nPASSED\nA.t: T\nPASSED\nm: mm\nHi!\nPASSED\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny test --no-verify --methods-to-test='m' t.dfy\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny test --no-verify --methods-to-test='m' t.dfy\n",
        "description": null
      },
      {
        "language": "text",
        "code": "m: mm\nHi!\nPASSED\n",
        "description": null
      },
      {
        "language": "text",
        "code": "m: mm\nHi!\nPASSED\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\n  function {:testEntry} Min(a: int, b: int): int {\n    if a < b then a else b\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\n  function {:testEntry} Min(a: int, b: int): int {\n    if a < b then a else b\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny generate-tests Block program.dfy\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny generate-tests Block program.dfy\n",
        "description": null
      },
      {
        "language": "text",
        "code": "include \"program.dfy\"\nmodule UnitTests {\n  import M\n  method {:test} Test0() {\n    var r0 := M.Min(0, 0);\n  }\n  method {:test} Test1() {\n    var r0 := M.Min(0, 1);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "include \"program.dfy\"\nmodule UnitTests {\n  import M\n  method {:test} Test0() {\n    var r0 := M.Min(0, 0);\n  }\n  method {:test} Test1() {\n    var r0 := M.Min(0, 1);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\n  function {:testInline} Min(a: int, b: int): int {\n    if a < b then a else b\n  }\n  method {:testEntry} Max(a: int, b: int) returns (c: int)\n    // the tests convert the postcondition below into runtime check:\n    ensures c == if a > b then a else b\n  {\n    return -Min(-a, -b);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\n  function {:testInline} Min(a: int, b: int): int {\n    if a < b then a else b\n  }\n  method {:testEntry} Max(a: int, b: int) returns (c: int)\n    // the tests convert the postcondition below into runtime check:\n    ensures c == if a > b then a else b\n  {\n    return -Min(-a, -b);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny generate-tests Block program.dfy\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny generate-tests Block program.dfy\n",
        "description": null
      },
      {
        "language": "text",
        "code": "include \"program.dfy\"\nmodule UnitTests {\n  import M\n  method {:test} Test0() {\n    var r0 := M.Max(7719, 7720);\n    expect r0 == if 7719 > 7720 then 7719 else 7720;\n  }\n  method {:test} Test1() {\n    var r0 := M.Max(1, 0);\n    expect r0 == if 1 > 0 then 1 else 0;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "include \"program.dfy\"\nmodule UnitTests {\n  import M\n  method {:test} Test0() {\n    var r0 := M.Max(7719, 7720);\n    expect r0 == if 7719 > 7720 then 7719 else 7720;\n  }\n  method {:test} Test1() {\n    var r0 := M.Max(1, 0);\n    expect r0 == if 1 > 0 then 1 else 0;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\n  function {:testInline 2} Mod3 (n: nat): nat\n    decreases n\n  {\n    if n == 0 then 0 else\n    if n == 1 then 1 else\n    if n == 2 then 2 else\n    Mod3(n-3)\n  }\n  method {:testEntry} TestEntry(n: nat) returns (r: nat)\n    requires n >= 3\n  {\n    r := Mod3(n);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\n  function {:testInline 2} Mod3 (n: nat): nat\n    decreases n\n  {\n    if n == 0 then 0 else\n    if n == 1 then 1 else\n    if n == 2 then 2 else\n    Mod3(n-3)\n  }\n  method {:testEntry} TestEntry(n: nat) returns (r: nat)\n    requires n >= 3\n  {\n    r := Mod3(n);\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\n  function {:testEntry} DescribeProduct(a: int): string {\n    if a * a < 0 \n    then \"Product is negative\"\n    else \"Product is nonnegative\"\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "module M {\n  function {:testEntry} DescribeProduct(a: int): string {\n    if a * a < 0 \n    then \"Product is negative\"\n    else \"Product is nonnegative\"\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny find-dead-code program.dfy\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny find-dead-code program.dfy\n",
        "description": null
      },
      {
        "language": "text",
        "code": "program.dfy(5,9) is reachable.\nprogram.dfy(3,4):initialstate is reachable.\nprogram.dfy.dfy(5,9)#elseBranch is reachable.\nprogram.dfy.dfy(4,9)#thenBranch is potentially unreachable.\nOut of 4 basic blocks, 3 are reachable.\n",
        "description": null
      },
      {
        "language": "text",
        "code": "program.dfy(5,9) is reachable.\nprogram.dfy(3,4):initialstate is reachable.\nprogram.dfy.dfy(5,9)#elseBranch is reachable.\nprogram.dfy.dfy(4,9)#thenBranch is potentially unreachable.\nOut of 4 basic blocks, 3 are reachable.\n",
        "description": null
      },
      {
        "language": "text",
        "code": "includes = [\"src/**/*.dfy\"]\nexcludes = [\"**/ignore.dfy\"]\n\nbase = [\"../commonOptions.dfyconfig.toml\"]\n\n[options]\nenforce-determinism = true\nwarn-shadowing = true\n",
        "description": null
      },
      {
        "language": "text",
        "code": "includes = [\"src/**/*.dfy\"]\nexcludes = [\"**/ignore.dfy\"]\n\nbase = [\"../commonOptions.dfyconfig.toml\"]\n\n[options]\nenforce-determinism = true\nwarn-shadowing = true\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    return j;\n  }//^^^^^^^ a postcondition could not be proved on this return path\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    return j;\n  }//^^^^^^^ a postcondition could not be proved on this return path\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    i := j;\n    return;\n  }//^^^^^^^ a postcondition could not be proved on this return path\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    i := j;\n    return;\n  }//^^^^^^^ a postcondition could not be proved on this return path\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    i := j;\n    assert 2 <= i; // could not prove this assertion\n    return;\n  }\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    i := j;\n    assert 2 <= i; // could not prove this assertion\n    return;\n  }\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    i := j;\n    assert 2 <= i; // could not prove this assertion\n    return;\n  }\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    i := j;\n    assert 2 <= i; // could not prove this assertion\n    return;\n  }\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    assert 2 <= j; // could not prove this assertion\n    i := j;\n    assert 2 <= i;\n    return;\n  }\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  if b {\n    assert 2 <= j; // could not prove this assertion\n    i := j;\n    assert 2 <= i;\n    return;\n  }\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  assert b  ==>  2 <= j;  // could not prove this assertion\n  if b {\n    assert 2 <= j;\n    i := j;\n    assert 2 <= i;\n    return;\n  }\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  var j := if !b then 3 else 1;\n  assert b  ==>  2 <= j;  // could not prove this assertion\n  if b {\n    assert 2 <= j;\n    i := j;\n    assert 2 <= i;\n    return;\n  }\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  assert b  ==>  2 <= (if !b then 3 else 1);  // could not prove this assertion\n  var j := if !b then 3 else 1;\n  assert b  ==>  2 <= j;\n  if b {\n    assert 2 <= j;\n    i := j;\n    assert 2 <= i;\n    return;\n  }\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method FailingPostcondition(b: bool) returns (i: int)\n  ensures 2 <= i\n{\n  assert b  ==>  2 <= (if !b then 3 else 1);  // could not prove this assertion\n  var j := if !b then 3 else 1;\n  assert b  ==>  2 <= j;\n  if b {\n    assert 2 <= j;\n    i := j;\n    assert 2 <= i;\n    return;\n  }\n  i := 2;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "b ==>  2 <= (if !b then 3 else 1)\n!b ||  (if !b then 2 <= 3 else 2 <= 1)\n!b ||  (if !b then true else false)\n!b || !b;\n!b;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "b ==>  2 <= (if !b then 3 else 1)\n!b ||  (if !b then 2 <= 3 else 2 <= 1)\n!b ||  (if !b then true else false)\n!b || !b;\n!b;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NotTerminating(b: bool) {\n   assert X;\n   if b {\n     assert Y;\n   } else {\n     assert Z;\n     assert P;\n   }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NotTerminating(b: bool) {\n   assert X;\n   if b {\n     assert Y;\n   } else {\n     assert Z;\n     assert P;\n   }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NotTerminating() {\n   assume false; // Will never compile, but everything verifies instantly\n   assert X;\n   if b {\n     assert Y;\n   } else {\n     assert Z;\n     assert P;\n   }\n   assert W;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NotTerminating() {\n   assume false; // Will never compile, but everything verifies instantly\n   assert X;\n   if b {\n     assert Y;\n   } else {\n     assert Z;\n     assert P;\n   }\n   assert W;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NotTerminating() {\n   assert X;\n   assume false;\n   if b {\n     assert Y;\n   } else {\n     assert Z;\n     assert P;\n   }\n   assert W;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NotTerminating() {\n   assert X;\n   assume false;\n   if b {\n     assert Y;\n   } else {\n     assert Z;\n     assert P;\n   }\n   assert W;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NotTerminating() {\n   assert X;\n   if b {\n     assert Y;\n   } else {\n     assert Z;\n     assert P;\n   }\n   assume false;\n   assert W;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NotTerminating() {\n   assert X;\n   if b {\n     assert Y;\n   } else {\n     assert Z;\n     assert P;\n   }\n   assume false;\n   assert W;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NotTerminating() {\n   assert X;\n   if b {\n     assert Y;\n     assume false;\n   } else {\n     assume false;\n     assert Z;\n     assert P;\n   }\n   assert W;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NotTerminating() {\n   assert X;\n   if b {\n     assert Y;\n     assume false;\n   } else {\n     assume false;\n     assert Z;\n     assert P;\n   }\n   assert W;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NotTerminating() {\n   assert X;\n   if b {\n     assume false; // Short-circuit because this branch is verified anyway\n     assert Y;\n   } else {\n     assert Z;\n     assume false;\n     assert P;\n   }\n   assert W;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method NotTerminating() {\n   assert X;\n   if b {\n     assume false; // Short-circuit because this branch is verified anyway\n     assert Y;\n   } else {\n     assert Z;\n     assume false;\n     assert P;\n   }\n   assert W;\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  assert SOMETHING_HELPING_TO_PROVE_LEMMA_PRECONDITION;\n  LEMMA();\n  assert X;\n...\nlemma () \n  requires LEMMA_PRECONDITION\n  ensures X { ... }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  assert SOMETHING_HELPING_TO_PROVE_LEMMA_PRECONDITION;\n  LEMMA();\n  assert X;\n...\nlemma () \n  requires LEMMA_PRECONDITION\n  ensures X { ... }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  assert X by {\n    assert SOMETHING_HELPING_TO_PROVE_LEMMA_PRECONDITION;\n    LEMMA();\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  assert X by {\n    assert SOMETHING_HELPING_TO_PROVE_LEMMA_PRECONDITION;\n    LEMMA();\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  assert p: SOMETHING_HELPING_TO_PROVE_LEMMA_PRECONDITION;\n  // p is not available here.\n  assert X by {\n    reveal p;\n    LEMMA();\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  assert p: SOMETHING_HELPING_TO_PROVE_LEMMA_PRECONDITION;\n  // p is not available here.\n  assert X by {\n    reveal p;\n    LEMMA();\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Slow(i: int, j: int)\n  requires greater: i > j {\n  \n  assert i >= j by {\n    reveal greater;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "method Slow(i: int, j: int)\n  requires greater: i > j {\n  \n  assert i >= j by {\n    reveal greater;\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost predicate P(i: int)\n\nmethod TestMethod(x: bool)\n  requires r: x <==> P(1)\n{\n  if x {\n    assert a: P(1) by { reveal r; }\n  }\n  assert x ==> P(1) by { reveal a; } // Error, a is not accessible\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost predicate P(i: int)\n\nmethod TestMethod(x: bool)\n  requires r: x <==> P(1)\n{\n  if x {\n    assert a: P(1) by { reveal r; }\n  }\n  assert x ==> P(1) by { reveal a; } // Error, a is not accessible\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost predicate P(i: int)\n\nmethod TestMethod(x: bool)\n  requires r: x <==> P(1)\n{\n  assert a: x ==> P(1) by {\n    if x {\n      assert P(1) by { reveal r; } // Proved without revealing the precondition\n    }\n  }\n  assert x ==> P(1) by { reveal a; } // Now a is accessible\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "ghost predicate P(i: int)\n\nmethod TestMethod(x: bool)\n  requires r: x <==> P(1)\n{\n  assert a: x ==> P(1) by {\n    if x {\n      assert P(1) by { reveal r; } // Proved without revealing the precondition\n    }\n  }\n  assert x ==> P(1) by { reveal a; } // Now a is accessible\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type byte = x | 0 <= x < 256\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type byte = x | 0 <= x < 256\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type byte = x | 0 <= x < 256\nmethod m() {\n  var a: byte := 250;\n  var b: byte := 200;\n  var c := b - a;               // inferred to be an 'int', its value will be 50.\n  var d := a + b;               // inferred to be an 'int', its value will be 450.\n  var e := (a + b) % 256;       // still inferred to be an 'int'...\n  var f: byte := (a + b) % 256; // OK\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "type byte = x | 0 <= x < 256\nmethod m() {\n  var a: byte := 250;\n  var b: byte := 200;\n  var c := b - a;               // inferred to be an 'int', its value will be 50.\n  var d := a + b;               // inferred to be an 'int', its value will be 450.\n  var e := (a + b) % 256;       // still inferred to be an 'int'...\n  var f: byte := (a + b) % 256; // OK\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype {:nativeType \"short\"} byte = x | 0 <= x < 256\nmethod m() {\n  var a: byte := 250;\n  var b: byte := 200;\n  var c := b - a; // OK, inferred to be a byte\n  var d := a + b; // Error: cannot prove that the result of a + b is of type `byte`.\n  var f := ((a as int + b as int) % 256) as byte; // OK\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "newtype {:nativeType \"short\"} byte = x | 0 <= x < 256\nmethod m() {\n  var a: byte := 250;\n  var b: byte := 200;\n  var c := b - a; // OK, inferred to be a byte\n  var d := a + b; // Error: cannot prove that the result of a + b is of type `byte`.\n  var f := ((a as int + b as int) % 256) as byte; // OK\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "while X\n   invariant Y\n {\n   while X'\n     invariant Y'\n   {\n \n   }\n }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "while X\n   invariant Y\n {\n   while X'\n     invariant Y'\n   {\n \n   }\n }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "`while X\n   invariant Y\n {\n   innerLoop();\n }\n...\nmethod innerLoop()\n  require Y'\n  ensures Y'\n",
        "description": null
      },
      {
        "language": "text",
        "code": "`while X\n   invariant Y\n {\n   innerLoop();\n }\n...\nmethod innerLoop()\n  require Y'\n  ensures Y'\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if b {\n  assert a*a != 0;\n}\nc := (assert b ==> a != 0; if b then 3/a else f(a));\nassert c != 5/a;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "if b {\n  assert a*a != 0;\n}\nc := (assert b ==> a != 0; if b then 3/a else f(a));\nassert c != 5/a;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var c: int;\nif b {\n  assert a*a != 0;   // Correctness\n}\nassert b ==> a != 0; // Well-formedness\nif b {\n  assert a != 0;     // Well-formedness\n} else {\n  assert f.requires(a); // Well-formedness\n}\nc := if b then 3/a else f(a);\nassert a != 0;       // Well-formedness\nassert c != 5/a;     // Correctness\n",
        "description": null
      },
      {
        "language": "text",
        "code": "var c: int;\nif b {\n  assert a*a != 0;   // Correctness\n}\nassert b ==> a != 0; // Well-formedness\nif b {\n  assert a != 0;     // Well-formedness\n} else {\n  assert f.requires(a); // Well-formedness\n}\nc := if b then 3/a else f(a);\nassert a != 0;       // Well-formedness\nassert c != 5/a;     // Correctness\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny-reportgenerator --max-resource-cv-pct 10 TestResults/*.csv\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dafny-reportgenerator --max-resource-cv-pct 10 TestResults/*.csv\n",
        "description": null
      },
      {
        "language": "text",
        "code": "using icharseq = Dafny.ISequence<char>;\nusing charseq = Dafny.Sequence<char>;\n\nnamespace Externs_Compile {\n  public partial class __default {\n    public static Dafny.ISequence<icharseq> GetCommandLineArgs() {\n      var dafnyArgs = Environment\n                      .GetCommandLineArgs()\n                      .Select(charseq.FromString);\n      return Dafny.Sequence<icharseq>.FromArray(dafnyArgs.ToArray());\n    }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "using icharseq = Dafny.ISequence<char>;\nusing charseq = Dafny.Sequence<char>;\n\nnamespace Externs_Compile {\n  public partial class __default {\n    public static Dafny.ISequence<icharseq> GetCommandLineArgs() {\n      var dafnyArgs = Environment\n                      .GetCommandLineArgs()\n                      .Select(charseq.FromString);\n      return Dafny.Sequence<icharseq>.FromArray(dafnyArgs.ToArray());\n    }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "replaceable module Foo {\n  method Bar() returns (i: int) \n    ensures i >= 2\n}\n\nmethod Main() {\n  var x := Foo.Bar();\n  print x;\n}\n// At this point, the program can be verified but not run.\n\nmodule ConcreteFoo replaces Foo {\n  method Bar() returns (i: int) {\n    return 3; // Main will print 3.\n  }\n}\n// ConcreteFoo can be swapped out for different replacements of Foo, to customize runtime behavior.\n",
        "description": null
      },
      {
        "language": "text",
        "code": "replaceable module Foo {\n  method Bar() returns (i: int) \n    ensures i >= 2\n}\n\nmethod Main() {\n  var x := Foo.Bar();\n  print x;\n}\n// At this point, the program can be verified but not run.\n\nmodule ConcreteFoo replaces Foo {\n  method Bar() returns (i: int) {\n    return 3; // Main will print 3.\n  }\n}\n// ConcreteFoo can be swapped out for different replacements of Foo, to customize runtime behavior.\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  -verificationLogger:trx;LogFileName=<...>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  -verificationLogger:trx;LogFileName=<...>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{\n  \"location\": {\n    \"filename\": \"xyz.dfy\",\n    \"range\": { // Start and (optional) end of diagnostic\n      \"start\": {\n        \"pos\": 83, // 0-based character offset in input\n        \"line\": 6, // 1-based line number\n        \"character\": 0 // 0-based column number\n      },\n      \"end\": { \"pos\": 86, \"line\": 6, \"character\": 3 }\n    }\n  },\n  \"severity\": 2, // 1: error; 2: warning; 4: info\n  \"message\": \"module-level const declarations are always non-instance ...\",\n  \"source\": \"Parser\",\n  \"relatedInformation\": [ // Additional messages, if any\n    {\n      \"location\": { ... }, // Like above\n      \"message\": \"...\",\n    }\n  ]\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "{\n  \"location\": {\n    \"filename\": \"xyz.dfy\",\n    \"range\": { // Start and (optional) end of diagnostic\n      \"start\": {\n        \"pos\": 83, // 0-based character offset in input\n        \"line\": 6, // 1-based line number\n        \"character\": 0 // 0-based column number\n      },\n      \"end\": { \"pos\": 86, \"line\": 6, \"character\": 3 }\n    }\n  },\n  \"severity\": 2, // 1: error; 2: warning; 4: info\n  \"message\": \"module-level const declarations are always non-instance ...\",\n  \"source\": \"Parser\",\n  \"relatedInformation\": [ // Additional messages, if any\n    {\n      \"location\": { ... }, // Like above\n      \"message\": \"...\",\n    }\n  ]\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  module {:options \"--function-syntax:4\"} M {\n    predicate CompiledPredicate() { true }\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  module {:options \"--function-syntax:4\"} M {\n    predicate CompiledPredicate() { true }\n  }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "DOTNET=$(which dotnet)\n\nBOOGIE_ROOT=\"path/to/boogie/Source\"\nBOOGIE=\"$BOOGIE_ROOT/BoogieDriver/bin/Debug/net8.0/BoogieDriver.dll\"\n\nif [[ ! -x \"$DOTNET\" ]]; then\n    echo \"Error: Dafny requires .NET Core to run on non-Windows systems.\"\n    exit 1\nfi\n\n#Uncomment if you prefer to use the executable instead of the DLL\n#BOOGIE=$(which boogie)\n\nBOOGIE_OPTIONS=\"/infer:j\"\nPROVER_OPTIONS=\"\\\n  /proverOpt:O:auto_config=false \\\n  /proverOpt:O:type_check=true \\\n  /proverOpt:O:smt.case_split=3 \\\n  /proverOpt:O:smt.qi.eager_threshold=100 \\\n  /proverOpt:O:smt.delay_units=true \\\n  /proverOpt:O:smt.arith.solver=2 \\\n  \"\n\n\"$DOTNET\" \"$BOOGIE\" $BOOGIE_OPTIONS $PROVER_OPTIONS \"$@\"\n#Uncomment if you want to use the executable instead of the DLL\n#\"$BOOGIE\" $BOOGIE_OPTIONS $PROVER_OPTIONS \"$@\"\n",
        "description": null
      },
      {
        "language": "text",
        "code": "DOTNET=$(which dotnet)\n\nBOOGIE_ROOT=\"path/to/boogie/Source\"\nBOOGIE=\"$BOOGIE_ROOT/BoogieDriver/bin/Debug/net8.0/BoogieDriver.dll\"\n\nif [[ ! -x \"$DOTNET\" ]]; then\n    echo \"Error: Dafny requires .NET Core to run on non-Windows systems.\"\n    exit 1\nfi\n\n#Uncomment if you prefer to use the executable instead of the DLL\n#BOOGIE=$(which boogie)\n\nBOOGIE_OPTIONS=\"/infer:j\"\nPROVER_OPTIONS=\"\\\n  /proverOpt:O:auto_config=false \\\n  /proverOpt:O:type_check=true \\\n  /proverOpt:O:smt.case_split=3 \\\n  /proverOpt:O:smt.qi.eager_threshold=100 \\\n  /proverOpt:O:smt.delay_units=true \\\n  /proverOpt:O:smt.arith.solver=2 \\\n  \"\n\n\"$DOTNET\" \"$BOOGIE\" $BOOGIE_OPTIONS $PROVER_OPTIONS \"$@\"\n#Uncomment if you want to use the executable instead of the DLL\n#\"$BOOGIE\" $BOOGIE_OPTIONS $PROVER_OPTIONS \"$@\"\n",
        "description": null
      },
      {
        "language": "text",
        "code": " verify\n <base64 encoded JSON payload>\n [[DAFNY-CLIENT: EOM]]\n",
        "description": null
      },
      {
        "language": "text",
        "code": " verify\n <base64 encoded JSON payload>\n [[DAFNY-CLIENT: EOM]]\n",
        "description": null
      },
      {
        "language": "text",
        "code": " <list of errors and usual output, as produced by the Dafny CLI>\n [SUCCESS] [[DAFNY-SERVER: EOM]]\n",
        "description": null
      },
      {
        "language": "text",
        "code": " <list of errors and usual output, as produced by the Dafny CLI>\n [SUCCESS] [[DAFNY-SERVER: EOM]]\n",
        "description": null
      },
      {
        "language": "text",
        "code": " <error message>\n [FAILURE] [[DAFNY-SERVER: EOM]]\n",
        "description": null
      },
      {
        "language": "text",
        "code": " <error message>\n [FAILURE] [[DAFNY-SERVER: EOM]]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "verify\neyJhcmdzIjpbIi9jb21waWxlOjAiLCIvcHJpbnRUb29sdGlwcyIsIi90aW1lTGltaXQ6MjAiXSwi\nZmlsZW5hbWUiOiJ0cmFuc2NyaXB0Iiwic291cmNlIjoibWV0aG9kIEEoYTppbnQpIHJldHVybnMg\nKGI6IGludCkge1xuICBiIDo9IGE7XG4gIGFzc2VydCBmYWxzZTtcbn1cbiIsInNvdXJjZUlzRmls\nZSI6ZmFsc2V9\n[[DAFNY-CLIENT: EOM]]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "verify\neyJhcmdzIjpbIi9jb21waWxlOjAiLCIvcHJpbnRUb29sdGlwcyIsIi90aW1lTGltaXQ6MjAiXSwi\nZmlsZW5hbWUiOiJ0cmFuc2NyaXB0Iiwic291cmNlIjoibWV0aG9kIEEoYTppbnQpIHJldHVybnMg\nKGI6IGludCkge1xuICBiIDo9IGE7XG4gIGFzc2VydCBmYWxzZTtcbn1cbiIsInNvdXJjZUlzRmls\nZSI6ZmFsc2V9\n[[DAFNY-CLIENT: EOM]]\n",
        "description": null
      },
      {
        "language": "text",
        "code": "btoa(JSON.stringify({\n  \"args\": [\n    \"/compile:0\",\n    \"/printTooltips\",\n    \"/timeLimit:20\"\n   ],\n   \"filename\":\"transcript\",\n   \"source\":\n`method A(a:int) returns (b: int) {\n   b := a;\n   assert false;\n}\n`,\"sourceIsFile\": false}))\n=== \"eyJhcmdzIjpbIi9jb21waWxlOjAiLCIvcHJpbnRUb29sdGlwcyIsIi90aW1lTGltaXQ6MjAiXSwiZmlsZW5hbWUiOiJ0cmFuc2NyaXB0Iiwic291cmNlIjoibWV0aG9kIEEoYTppbnQpIHJldHVybnMgKGI6IGludCkge1xuICBiIDo9IGE7XG4gIGFzc2VydCBmYWxzZTtcbn1cbiIsInNvdXJjZUlzRmlsZSI6ZmFsc2V9\"\n",
        "description": null
      },
      {
        "language": "text",
        "code": "btoa(JSON.stringify({\n  \"args\": [\n    \"/compile:0\",\n    \"/printTooltips\",\n    \"/timeLimit:20\"\n   ],\n   \"filename\":\"transcript\",\n   \"source\":\n`method A(a:int) returns (b: int) {\n   b := a;\n   assert false;\n}\n`,\"sourceIsFile\": false}))\n=== \"eyJhcmdzIjpbIi9jb21waWxlOjAiLCIvcHJpbnRUb29sdGlwcyIsIi90aW1lTGltaXQ6MjAiXSwiZmlsZW5hbWUiOiJ0cmFuc2NyaXB0Iiwic291cmNlIjoibWV0aG9kIEEoYTppbnQpIHJldHVybnMgKGI6IGludCkge1xuICBiIDo9IGE7XG4gIGFzc2VydCBmYWxzZTtcbn1cbiIsInNvdXJjZUlzRmlsZSI6ZmFsc2V9\"\n",
        "description": null
      },
      {
        "language": "text",
        "code": "mkdir PluginTutorial\ncd PluginTutorial\n",
        "description": null
      },
      {
        "language": "text",
        "code": "mkdir PluginTutorial\ncd PluginTutorial\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dotnet new classlib\n",
        "description": null
      },
      {
        "language": "text",
        "code": "dotnet new classlib\n",
        "description": null
      },
      {
        "language": "text",
        "code": "mv Class1.cs MyPlugin.cs\n",
        "description": null
      },
      {
        "language": "text",
        "code": "mv Class1.cs MyPlugin.cs\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  <ItemGroup>\n    <ProjectReference Include=\"../dafny/source/DafnyLanguageServer/DafnyLanguageServer.csproj\" />\n  </ItemGroup>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  <ItemGroup>\n    <ProjectReference Include=\"../dafny/source/DafnyLanguageServer/DafnyLanguageServer.csproj\" />\n  </ItemGroup>\n",
        "description": null
      },
      {
        "language": "text",
        "code": "using Microsoft.Dafny;\nusing Microsoft.Dafny.LanguageServer.Plugins;\nusing Microsoft.Boogie;\nusing Microsoft.Dafny.LanguageServer.Language;\nusing System.Linq;\nusing Range = OmniSharp.Extensions.LanguageServer.Protocol.Models.Range;\n\nnamespace MyPlugin;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "using Microsoft.Dafny;\nusing Microsoft.Dafny.LanguageServer.Plugins;\nusing Microsoft.Boogie;\nusing Microsoft.Dafny.LanguageServer.Language;\nusing System.Linq;\nusing Range = OmniSharp.Extensions.LanguageServer.Protocol.Models.Range;\n\nnamespace MyPlugin;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "public class TestConfiguration : PluginConfiguration {\n  public override DafnyCodeActionProvider[] GetDafnyCodeActionProviders() {\n    return new DafnyCodeActionProvider[] { new AddCommentDafnyCodeActionProvider() };\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "public class TestConfiguration : PluginConfiguration {\n  public override DafnyCodeActionProvider[] GetDafnyCodeActionProviders() {\n    return new DafnyCodeActionProvider[] { new AddCommentDafnyCodeActionProvider() };\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "public class AddCommentDafnyCodeActionProvider : DafnyCodeActionProvider {\n  public override IEnumerable<DafnyCodeAction> GetDafnyCodeActions(IDafnyCodeActionInput input, Range selection) {\n    return new DafnyCodeAction[] { };\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "public class AddCommentDafnyCodeActionProvider : DafnyCodeActionProvider {\n  public override IEnumerable<DafnyCodeAction> GetDafnyCodeActions(IDafnyCodeActionInput input, Range selection) {\n    return new DafnyCodeAction[] { };\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "    var firstTokenRange = input.Program?.GetFirstTopLevelToken()?.GetLspRange();\n    if(firstTokenRange != null && firstTokenRange.Start.Line == selection.Start.Line) {\n      return new DafnyCodeAction[] {\n        // TODO\n      };\n    } else {\n      return new DafnyCodeAction[] { };\n    }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "    var firstTokenRange = input.Program?.GetFirstTopLevelToken()?.GetLspRange();\n    if(firstTokenRange != null && firstTokenRange.Start.Line == selection.Start.Line) {\n      return new DafnyCodeAction[] {\n        // TODO\n      };\n    } else {\n      return new DafnyCodeAction[] { };\n    }\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  return new DafnyCodeAction[] {\n    new InstantDafnyCodeAction(\"Insert comment\", new DafnyCodeActionEdit[] {\n      new DafnyCodeActionEdit(firstTokenRange.GetStartRange(), \"/*First comment*/\")\n    })\n  };\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  return new DafnyCodeAction[] {\n    new InstantDafnyCodeAction(\"Insert comment\", new DafnyCodeActionEdit[] {\n      new DafnyCodeActionEdit(firstTokenRange.GetStartRange(), \"/*First comment*/\")\n    })\n  };\n",
        "description": null
      },
      {
        "language": "text",
        "code": "public class CustomDafnyCodeAction: DafnyCodeAction {\n  public Range whereToInsert;\n  \n  public CustomDafnyCodeAction(Range whereToInsert): base(\"Insert comment\") {\n    this.whereToInsert = whereToInsert;\n  }\n  public override DafnyCodeActionEdit[] GetEdits() {\n    return new DafnyCodeActionEdit[] {\n      new DafnyCodeActionEdit(whereToInsert.GetStartRange(), \"/*A comment*/\")\n    };\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "public class CustomDafnyCodeAction: DafnyCodeAction {\n  public Range whereToInsert;\n  \n  public CustomDafnyCodeAction(Range whereToInsert): base(\"Insert comment\") {\n    this.whereToInsert = whereToInsert;\n  }\n  public override DafnyCodeActionEdit[] GetEdits() {\n    return new DafnyCodeActionEdit[] {\n      new DafnyCodeActionEdit(whereToInsert.GetStartRange(), \"/*A comment*/\")\n    };\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  return new DafnyCodeAction[] {\n    new CustomDafnyCodeAction(firstTokenRange)\n  };\n",
        "description": null
      },
      {
        "language": "text",
        "code": "  return new DafnyCodeAction[] {\n    new CustomDafnyCodeAction(firstTokenRange)\n  };\n",
        "description": null
      },
      {
        "language": "text",
        "code": "using OmniSharp.Extensions.JsonRpc;\nusing OmniSharp.Extensions.LanguageServer.Server;\nusing OmniSharp.Extensions.LanguageServer.Protocol.Models;\nusing Microsoft.Dafny.LanguageServer.Plugins;\nusing Microsoft.Dafny.LanguageServer.Workspace;\nusing MediatR;\nusing Microsoft.Dafny;\n\nnamespace MyPlugin;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "using OmniSharp.Extensions.JsonRpc;\nusing OmniSharp.Extensions.LanguageServer.Server;\nusing OmniSharp.Extensions.LanguageServer.Protocol.Models;\nusing Microsoft.Dafny.LanguageServer.Plugins;\nusing Microsoft.Dafny.LanguageServer.Workspace;\nusing MediatR;\nusing Microsoft.Dafny;\n\nnamespace MyPlugin;\n",
        "description": null
      },
      {
        "language": "text",
        "code": "public class TestConfiguration : PluginConfiguration {\n  public override LanguageServerOptions WithPluginHandlers(LanguageServerOptions options) {\n    return options.WithHandler<DummyHandler>();\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "public class TestConfiguration : PluginConfiguration {\n  public override LanguageServerOptions WithPluginHandlers(LanguageServerOptions options) {\n    return options.WithHandler<DummyHandler>();\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "[Parallel]\n[Method(\"dafny/request/dummy\", Direction.ClientToServer)]\npublic record DummyParams : TextDocumentIdentifier, IRequest<bool>;\n\npublic class DummyHandler : IJsonRpcRequestHandler<DummyParams, bool> {\n  private readonly IProjectDatabase projects;\n  public DummyHandler(IProjectDatabase projects) {\n    this.projects = projects;\n  }\n  public async Task<bool> Handle(DummyParams request, CancellationToken cancellationToken) {\n    var state = await projects.GetParsedDocumentNormalizeUri(request);\n    if (state == null) {\n      return false;\n    }\n    return state.Program.Descendants().OfType<LoopStmt>().Any();\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "[Parallel]\n[Method(\"dafny/request/dummy\", Direction.ClientToServer)]\npublic record DummyParams : TextDocumentIdentifier, IRequest<bool>;\n\npublic class DummyHandler : IJsonRpcRequestHandler<DummyParams, bool> {\n  private readonly IProjectDatabase projects;\n  public DummyHandler(IProjectDatabase projects) {\n    this.projects = projects;\n  }\n  public async Task<bool> Handle(DummyParams request, CancellationToken cancellationToken) {\n    var state = await projects.GetParsedDocumentNormalizeUri(request);\n    if (state == null) {\n      return false;\n    }\n    return state.Program.Descendants().OfType<LoopStmt>().Any();\n  }\n}\n",
        "description": null
      },
      {
        "language": "text",
        "code": "> dotnet build\n",
        "description": null
      },
      {
        "language": "text",
        "code": "> dotnet build\n",
        "description": null
      },
      {
        "language": "text",
        "code": "Use 'dafny --help' to see help for the new Dafny CLI format.\nUsage: dafny [ option ... ] [ filename ... ]\n\n  ---- General options -------------------------------------------------------\n\n  /version      print the dafny version number\n  /help         print this message\n  /attrHelp     print a message about supported declaration attributes\n  /env:<n>      print command line arguments\n                  0 - never, 1 (default) - during BPL print and prover log,\n                  2 - like 1 and also to standard output\n  /printVerifiedProceduresCount:<n>\n                0 - no\n                1 (default) - yes\n  /wait         await Enter from keyboard before terminating program\n  /xml:<file>   also produce output in XML format to <file>\n\n  All the .dfy files supplied on the command line along with files recursively\n  included by 'include' directives are considered a single Dafny program;\n  however only those files listed on the command line are verified.\n  \n  Exit code: 0 -- success; 1 -- invalid command-line; 2 -- parse or type errors;\n             3 -- compilation errors; 4 -- verification errors\n  \n  ---- Input configuration ---------------------------------------------------\n  \n  /dprelude:<file>\n      Choose the Dafny prelude file.\n\n  /stdin\n      Read standard input and treat it as an input .dfy file.\n  \n  ---- Plugins ---------------------------------------------------------------\n  \n  ---- Overall reporting and printing ----------------------------------------\n  \n  /showSnippets:<value>\n      0 (default) - Don't show source code snippets for Dafny messages.\n      1 - Show a source code snippet for each Dafny message.\n\n  /stats\n      Print interesting statistics about the Dafny files supplied.\n  \n  /printIncludes:<None|Immediate|Transitive>\n      None (default) - Print nothing.\n      Immediate - Print files included by files listed on the command line.\n      Transitive - Recurses on the files printed by Immediate.\n  \n      Immediate and Transitive will exit after printing.\n  \n  /view:<view1, view2>\n      Print the filtered views of a module after it is resolved (/rprint).\n      If print before the module is resolved (/dprint), then everything in\n      the module is printed. If no view is specified, then everything in\n      the module is printed.\n  /funcCallGraph\n      Print out the function call graph. Format is: func,mod=callee*\n  \n  /pmtrace\n      Print pattern-match compiler debug info.\n  \n  /printTooltips\n      Dump additional positional information (displayed as mouse-over\n      tooltips by the VS Code plugin) to stdout as 'Info' messages.\n  \n  /diagnosticsFormat:<text|json>\n      Choose how to report errors, warnings, and info messages.\n      text (default) - Use human readable output\n      json - Print each message as a JSON object, one per line.\n  \n  ---- Language feature selection --------------------------------------------\n  \n  /defaultFunctionOpacity:<value>\n      Change the default opacity of functions. \n      `transparent` (default) means functions are transparent, can be manually made opaque and then revealed. \n      `autoRevealDependencies` makes all functions not explicitly labelled as opaque to be opaque but reveals them automatically in scopes which do not have `{:autoRevealDependencies false}`. \n      `opaque` means functions are always opaque so the opaque keyword is not needed, and functions must be revealed everywhere needed for a proof.\n\n  /readsClausesOnMethods:<value>\n      0 (default) - Reads clauses on methods are forbidden.\n      1 - Reads clauses on methods are permitted (with a default of 'reads *').\n\n  /standardLibraries:<value>\n      0 (default) - Do not allow Dafny code to depend on the standard libraries included with the Dafny distribution.\n      1 - Allow Dafny code to depend on the standard libraries included with the Dafny distribution.\n      See https://github.com/dafny-lang/dafny/blob/master/Source/DafnyStandardLibraries/README.md for more information.\n      Not compatible with the /unicodeChar:0 option.\n\n  /noIncludes\n      Ignore include directives.\n  \n  /noExterns\n      Ignore extern attributes.\n  \n  /functionSyntax:<version>\n      The syntax for functions is changing from Dafny version 3 to version\n      4. This switch gives early access to the new syntax, and also\n      provides a mode to help with migration.\n  \n      3 - Compiled functions are written `function method` and\n          `predicate method`. Ghost functions are written `function` and\n          `predicate`.\n      4 (default) - Compiled functions are written `function` and `predicate`. Ghost\n          functions are written `ghost function` and `ghost predicate`.\n      migration3to4 - Compiled functions are written `function method` and\n          `predicate method`. Ghost functions are written `ghost function`\n          and `ghost predicate`. To migrate from version 3 to version 4,\n          use this flag on your version 3 program. This will give flag all\n          occurrences of `function` and `predicate` as parsing errors.\n          These are ghost functions, so change those into the new syntax\n          `ghost function` and `ghost predicate`. Then, start using\n          /functionSyntax:4. This will flag all occurrences of `function\n          method` and `predicate method` as parsing errors. So, change\n          those to just `function` and `predicate`. Now, your program uses\n          version 4 syntax and has the exact same meaning as your previous\n          version 3 program.\n      experimentalDefaultGhost - Like migration3to4, but allow `function`\n          and `predicate` as alternatives to declaring ghost functions and\n          predicates, respectively.\n      experimentalDefaultCompiled - Like migration3to4, but allow\n          `function` and `predicate` as alternatives to declaring compiled\n          functions and predicates, respectively.\n      experimentalPredicateAlwaysGhost - Compiled functions are written\n          `function`. Ghost functions are written `ghost function`.\n          Predicates are always ghost and are written `predicate`.\n  \n  /quantifierSyntax:<version>\n      The syntax for quantification domains is changing from Dafny version\n      3 to version 4, more specifically where quantifier ranges (|\n      <Range>) are allowed. This switch gives early access to the new\n      syntax.\n  \n      3 - Ranges are only allowed after all quantified variables\n          are declared. (e.g. set x, y | 0 <= x < |s| && y in s[x] && 0 <=\n          y :: y)\n      4 (default) - Ranges are allowed after each quantified variable declaration.\n          (e.g. set x | 0 <= x < |s|, y <- s[x] | 0 <= y :: y)\n  \n      Note that quantifier variable domains (<- <Domain>) are available in\n      both syntax versions.\n  \n  /disableScopes\n      Treat all export sets as 'export reveal *'. i.e. don't hide function\n      bodies or type definitions during translation.\n  \n  ---- Warning selection -----------------------------------------------------\n  \n  /warnShadowing\n      Emits a warning if the name of a declared variable caused another\n      variable to be shadowed.\n  \n  /warnMissingConstructorParenthesis\n      Emits a warning when a constructor name in a case pattern is not\n      followed by parentheses.\n  \n  /deprecation:<n>\n      0 - Don't give any warnings about deprecated features.\n      1 (default) - Show warnings about deprecated features.\n  \n  /warningsAsErrors\n      Treat warnings as errors.\n  \n  ---- Verification options -------------------------------------------------\n  \n  /allowAxioms:<value>\n      Prevents a warning from being generated for axioms, such as assume statements and functions or methods without a body, that don't have an {:axiom} attribute.\n\n  /verificationLogger:<configuration>\n      Logs verification results using the given test result format. The currently supported formats are `trx`, `csv`, and `text`. These are: the XML-based format commonly used for test results for .NET languages, a custom CSV schema, and a textual format meant for human consumption. You can provide configuration using the same string format as when using the --logger option for dotnet test, such as: --format \"trx;LogFileName=<...>\");\n      \n      The `trx` and `csv` formats automatically choose an output file name by default, and print the name of this file to the console. The `text` format prints its output to the console by default, but can send output to a file given the `LogFileName` option.\n      \n      The `text` format also includes a more detailed breakdown of what assertions appear in each assertion batch. When combined with the isolate-assertions option, it will provide approximate time and resource use costs for each assertion, allowing identification of especially expensive assertions.\n\n  /dafnyVerify:<n>\n      0 - Stop after resolution and typechecking.\n      1 - Continue on to verification and compilation.\n  \n  /verifyAllModules\n      Verify modules that come from an include directive.\n  \n  /emitUncompilableCode\n      Allow compilers to emit uncompilable code that usually contain useful\n      information about what feature is missing, rather than\n      stopping on the first problem\n  \n  /separateModuleOutput\n      Output verification results for each module separately, rather than\n      aggregating them after they are all finished.\n  \n  /noCheating:<n>\n      0 (default) - Allow assume statements and free invariants.\n      1 - Treat all assumptions as asserts, and drop free.\n  \n  /induction:<n>\n      0 - Never do induction, not even when attributes request it.\n      1 - Only apply induction when attributes request it.\n      2 - Apply induction as requested (by attributes) and also for\n          heuristically chosen quantifiers.\n      3 - Apply induction as requested, and for heuristically chosen\n          quantifiers and lemmas.\n      4 (default) - Apply induction as requested, and for lemmas.\n  \n  /inductionHeuristic:<n>\n      0 - Least discriminating induction heuristic (that is, lean toward\n          applying induction more often).\n      1,2,3,4,5 - Levels in between, ordered as follows as far as how\n          discriminating they are: 0 < 1 < 2 < (3,4) < 5 < 6.\n      6 (default) - Most discriminating.\n  \n  /trackPrintEffects:<n>\n      0 (default) - Every compiled method, constructor, and iterator,\n         whether or not it bears a {:print} attribute, may have print\n         effects.\n      1 - A compiled method, constructor, or iterator is allowed to have\n         print effects only if it is marked with {:print}.\n  \n  /definiteAssignment:<n>\n      0 - Ignores definite-assignment rules. This mode is for testing\n          only--it is not sound.\n      1 (default) - Enforces definite-assignment rules for compiled\n          variables and fields whose types do not support\n          auto-initialization, and for ghost variables and fields whose\n          type is possibly empty.\n      2 - Enforces definite-assignment for all non-yield-parameter\n          variables and fields, regardless of their types.\n      3 - Like 2, but also performs checks in the compiler that no\n          nondeterministic statements are used; thus, a program that\n          passes at this level 3 is one that the language guarantees that\n          values seen during execution will be the same in every run of\n          the program.\n      4 - Like 1, but enforces definite assignment for all local variables\n          and out-parameters, regardless of their types. (Whether or not\n          fields and new arrays are subject to definite assignments depends\n          on their types.)\n  \n  /noAutoReq\n      Ignore autoReq attributes.\n  \n  /autoReqPrint:<file>\n      Print out requirements that were automatically generated by autoReq.\n  \n  /noNLarith\n      Reduce Z3's knowledge of non-linear arithmetic (*,/,%).\n  \n      Results in more manual work, but also produces more predictable\n      behavior. (This switch will perhaps be replaced by /arith in the\n      future. For now, it takes precedence of /arith.)\n  \n  /arith:<n>\n      (experimental) Adjust how Dafny interprets arithmetic operations.\n  \n      0 - Use Boogie/Z3 built-ins for all arithmetic operations.\n      1 (default) - Like 0, but introduce symbolic synonyms for *,/,%, and\n          allow these operators to be used in triggers.\n      2 - Like 1, but introduce symbolic synonyms also for +,-.\n      3 - Turn off non-linear arithmetic in the SMT solver. Still, use\n          Boogie/Z3 built-in symbols for all arithmetic operations.\n      4 - Like 3, but introduce symbolic synonyms for *,/,%, and allow\n          these operators to be used in triggers.\n      5 - Like 4, but introduce symbolic synonyms also for +,-.\n      6 - Like 5, and introduce axioms that distribute + over *.\n      7 - like 6, and introduce facts that associate literals arguments of *.\n      8 - Like 7, and introduce axiom for the connection between *,/,%.\n      9 - Like 8, and introduce axioms for sign of multiplication.\n      10 - Like 9, and introduce axioms for commutativity and\n          associativity of *.\n  \n  /autoTriggers:<n>\n      0 - Do not generate {:trigger} annotations for user-level\n          quantifiers.\n      1 (default) - Add a {:trigger} to each user-level quantifier.\n          Existing annotations are preserved.\n  \n  /rewriteFocalPredicates:<n>\n      0 - Don't rewrite predicates in the body of prefix lemmas.\n      1 (default) - In the body of prefix lemmas, rewrite any use of a\n          focal predicate P to P#[_k-1].\n  \n  /extractCounterexample\n      If verification fails, report a detailed counterexample for the\n      first failing assertion (experimental).\n  \n  ---- Compilation options ---------------------------------------------------\n  \n  /compileTarget:<language>\n      cs (default) - Compile to .NET via C#.\n      go - Compile to Go.\n      js - Compile to JavaScript.\n      java - Compile to Java.\n      py - Compile to Python.\n      cpp - Compile to C++.\n      dfy - Compile to Dafny.\n      \n      Note that the C++ backend has various limitations (see\n      Docs/Compilation/Cpp.md). This includes lack of support for\n      BigIntegers (aka int), most higher order functions, and advanced\n      features like traits or co-inductive types.\n\n  /library:<value>\n      The contents of this file and any files it includes can be referenced from other files as if they were included. \n      However, these contents are skipped during code generation and verification.\n      This option is useful in a diamond dependency situation, \n      to prevent code from the bottom dependency from being generated more than once.\n      The value may be a comma-separated list of files and folders.\n\n  /optimizeErasableDatatypeWrapper:<value>\n      0 - Include all non-ghost datatype constructors in the compiled code\n      1 (default) - In the compiled target code, transform any non-extern\n          datatype with a single non-ghost constructor that has a single\n          non-ghost parameter into just that parameter. For example, the type\n              datatype Record = Record(x: int)\n          is transformed into just 'int' in the target code.\n\n  /out:<file>\n      Specify the filename and location for the generated target language files.\n\n  /runAllTests:<n>\n      0 (default) - Annotates compiled methods with the {:test}\n              attribute such that they can be tested using a testing framework\n              in the target language (e.g. xUnit for C#).\n          1 - Emits a main method in the target language that will execute\n              every method in the program with the {:test} attribute. Cannot\n              be used if the program already contains a main method. Note that\n              /compile:3 or 4 must be provided as well to actually execute\n              this main method!\n\n  /compile:<n>\n      0 - Do not compile Dafny program.\n      1 (default) - Upon successful verification of the Dafny program,\n          compile it to the designated target language. (/noVerify\n          automatically counts as a failed verification.)\n      2 - Always attempt to compile Dafny program to the target language,\n          regardless of verification outcome.\n      3 - If there is a Main method and there are no verification errors\n          and /noVerify is not used, compiles program in memory (i.e.,\n          does not write an output file) and runs it.\n      4 - Like (3), but attempts to compile and run regardless of\n          verification outcome.\n  /Main:<name>\n      Specify the (fully-qualified) name of the method to use as the executable entry point.\n      Default is the method with the {:main} attribute, or else the method named 'Main'.\n      A Main method can have at most one (non-ghost) argument of type `seq<string>`\n  --args <arg1> <arg2> ...\n      When running a Dafny file through /compile:3 or /compile:4, '--args' provides\n      all arguments after it to the Main function, at index starting at 1.\n      Index 0 is used to store the executable's name if it exists.\n  \n  /compileVerbose:<n>\n      0 - Don't print status of compilation to the console.\n      1 (default) - Print information such as files being written by the\n          compiler to the console.\n  \n  /spillTargetCode:<n>\n      Explicitly writes the code in the target language to one or more files.\n      This is not necessary to run a Dafny program, but may be of interest when\n      building multi-language programs or for debugging.\n  \n      0 (default) - Don't make any extra effort to write the textual\n          target program (but still compile it, if /compile indicates to\n          do so).\n      1 - Write the textual target program, if it is being compiled.\n      2 - Write the textual target program, provided it passes the\n          verifier (and /noVerify is NOT used), regardless of /compile\n          setting.\n      3 - Write the textual target program, regardless of verification\n          outcome and /compile setting.\n      Note, some compiler targets may (always or in some situations) write\n      out the textual target program as part of compilation, in which case\n      /spillTargetCode:0 behaves the same way as /spillTargetCode:1.\n  /coverage:<file>\n      The compiler emits branch-coverage calls and outputs into <file> a\n      legend that gives a description of each source-location identifier\n      used in the branch-coverage calls. (Use - as <file> to print to the\n      console.)\n  \n  /optimize\n      Produce optimized C# code by passing the /optimize flag to csc.exe.\n  \n  /optimizeResolution:<n>\n      0 - Resolve and translate all methods.\n      1 - Translate methods only in the call graph of current verification\n          target.\n      2 (default) - As in 1, but only resolve method bodies in\n          non-included Dafny sources.\n  /useRuntimeLib\n      Refer to a pre-built DafnyRuntime.dll in the compiled assembly\n      rather than including DafnyRuntime.cs verbatim.\n  \n  /testContracts:<Externs|TestedExterns>\n      Enable run-time testing of the compilable portions of certain function\n      or method contracts, at their call sites. The current implementation\n      focuses on {:extern} code but may support other code in the future.\n  \n      Externs - Check contracts on every call to a function or method marked\n          with the {:extern} attribute, regardless of where it occurs.\n      TestedExterns - Check contracts on every call to a function or method\n          marked with the {:extern} attribute when it occurs in a method\n          with the {:test} attribute, and warn if no corresponding test\n          exists for a given external declaration.\n  \n  ----------------------------------------------------------------------------\n  \n  Dafny generally accepts Boogie options and passes these on to Boogie.\n  However, some Boogie options, like /loopUnroll, may not be sound for\n  Dafny or may not have the same meaning for a Dafny program as it would\n  for a similar Boogie program.\n  \n  ---- Boogie options --------------------------------------------------------\n\n  Multiple .bpl files supplied on the command line are concatenated into one\n  Boogie program.\n\n  /lib:<name>   Include definitions in library <name>. The file <name>.bpl\n                must be an included resource in Core.dll. Currently, the\n                following libraries are supported---base, node.\n  /proc:<p>     Only check procedures matched by pattern <p>. This option\n                may be specified multiple times to match multiple patterns.\n                The pattern <p> matches the whole procedure name and may\n                contain * wildcards which match any character zero or more\n                times.\n  /noProc:<p>   Do not check procedures matched by pattern <p>. Exclusions\n                with /noProc are applied after inclusions with /proc.\n  /noResolve    parse only\n  /noTypecheck  parse and resolve only\n  /print:<file>\n                print Boogie program after parsing it\n                (use - as <file> to print to console)\n  /pretty:<n>   0 - print each Boogie statement on one line (faster).\n                1 (default) - pretty-print with some line breaks.\n  /printWithUniqueIds\n                print augmented information that uniquely identifies variables\n  /printUnstructured\n                with /print option, desugars all structured statements\n  /printPassive\n                with /print option, prints passive version of program\n  /printDesugared\n                with /print option, desugars calls\n  /printLambdaLifting\n                with /print option, desugars lambda lifting\n  /freeVarLambdaLifting\n                Boogie's lambda lifting transforms the bodies of lambda\n                expressions into templates with holes. By default, holes\n                are maximally large subexpressions that do not contain\n                bound variables. This option performs a form of lambda\n                lifting in which holes are the lambda's free variables.\n  /overlookTypeErrors\n                skip any implementation with resolution or type checking errors\n  /loopUnroll:<n>\n                unroll loops, following up to n back edges (and then some)\n                default is -1, which means loops are not unrolled\n  /extractLoops\n                convert all irreducible loops to reducible forms by node splitting\n                and extract all loops into recursive procedures\n  /soundLoopUnrolling\n                sound loop unrolling\n  /kInductionDepth:<k>\n                uses combined-case k-induction to soundly eliminate loops,\n                by unwinding proportional to the supplied parameter\n  /inferModifies\n                automatically infer modifies clauses\n  /printModel:<n>\n                0 (default) - do not print Z3's error model\n                1 - print Z3's error model\n  /printModelToFile:<file>\n                print model to <file> instead of console\n  /mv:<file>    Specify file to save the model with captured states\n                (see documentation for :captureState attribute)\n  /enhancedErrorMessages:<n>\n                0 (default) - no enhanced error messages\n                1 - Z3 error model enhanced error messages\n  /printCFG:<prefix> : print control flow graph of each implementation in\n                       Graphviz format to files named:\n                         <prefix>.<procedure name>.dot\n  /useBaseNameForFileName : When parsing use basename of file for tokens instead\n                            of the path supplied on the command line\n  /emitDebugInformation:<n>\n                0 - do not emit debug information\n                1 (default) - emit the debug information :qid, :skolemid and set-info :boogie-vc-id\n  /normalizeNames:<n>\n                0 (default) - Keep Boogie program names when generating SMT commands\n                1 - Normalize Boogie program names when generating SMT commands. \n                  This keeps SMT solver input, and thus output, \n                  constant when renaming declarations in the input program.\n  /normalizeDeclarationOrder:<n>\n                0 - Keep order of top-level declarations when generating SMT commands.\n                1 (default) - Normalize order of top-level declarations when generating SMT commands.\n                  This keeps SMT solver input, and thus output, \n                  constant when reordering declarations in the input program.\n\n  ---- Inference options -----------------------------------------------------\n\n  /infer:<flags>\n                use abstract interpretation to infer invariants\n                <flags> must specify exactly one of the following domains:\n                   t = trivial bottom/top lattice\n                   j = stronger intervals\n                together with any of the following options:\n                   s = debug statistics\n                0..9 = number of iterations before applying a widen (default=0)\n  /checkInfer   instrument inferred invariants as asserts to be checked by\n                theorem prover\n  /contractInfer\n                perform procedure contract inference\n  /instrumentInfer\n                h - instrument inferred invariants only at beginning of\n                    loop headers (default)\n                e - instrument inferred invariants at beginning and end\n                    of every block (this mode is intended for use in\n                    debugging of abstract domains)\n  /printInstrumented\n                print Boogie program after it has been instrumented with\n                invariants\n\n  ---- Debugging and general tracing options ---------------------------------\n\n  /silent       print nothing at all\n  /quiet        print nothing but warnings and errors\n  /trace        blurt out various debug trace information\n  /traceTimes   output timing information at certain points in the pipeline\n  /tracePOs     output information about the number of proof obligations\n                (also included in the /trace output)\n  /forceBplErrors\n                show boogie errors even if {:msg ...} attribute is present\n  /break        launch and break into debugger\n\n  ---- Civl options ----------------------------------------------------------\n\n  /trustMoverTypes\n                do not verify mover type annotations on atomic action declarations\n  /trustNoninterference\n                do not perform noninterference checks\n  /trustRefinement\n                do not perform refinement checks\n  /trustLayersUpto:<n>\n                do not verify layers <n> and below\n  /trustLayersDownto:<n>\n                do not verify layers <n> and above\n  /trustSequentialization\n                do not perform sequentialization checks\n  /civlDesugaredFile:<file>\n                print plain Boogie program to <file>\n\n  ---- Verification-condition generation options -----------------------------\n\n  /liveVariableAnalysis:<c>\n                0 = do not perform live variable analysis\n                1 = perform live variable analysis (default)\n                2 = perform interprocedural live variable analysis\n  /noVerify     skip VC generation and invocation of the theorem prover\n  /verifySnapshots:<n>\n                verify several program snapshots (named <filename>.v0.bpl\n                to <filename>.vN.bpl) using verification result caching:\n                0 - do not use any verification result caching (default)\n                1 - use the basic verification result caching\n                2 - use the more advanced verification result caching\n                3 - use the more advanced caching and report errors according\n                    to the new source locations for errors and their\n                    related locations (but not /errorTrace and CaptureState\n                    locations)\n  /traceCaching:<n>\n                0 (default) - none\n                1 - for testing\n                2 - for benchmarking\n                3 - for testing, benchmarking, and debugging\n  /verifySeparately\n                verify each input program separately\n  /removeEmptyBlocks:<c>\n                0 - do not remove empty blocks during VC generation\n                1 - remove empty blocks (default)\n  /coalesceBlocks:<c>\n                0 = do not coalesce blocks\n                1 = coalesce blocks (default)\n  /traceverify  print debug output during verification condition generation\n  /subsumption:<c>\n                apply subsumption to asserted conditions:\n                0 - never, 1 - not for quantifiers, 2 (default) - always\n  /alwaysAssumeFreeLoopInvariants\n                usually, a free loop invariant (or assume\n                statement in that position) is ignored in checking contexts\n                (like other free things); this option includes these free\n                loop invariants as assumes in both contexts\n  /inline:<i>   use inlining strategy <i> for procedures with the :inline\n                attribute, see /attrHelp for details:\n                  none\n                  assume (default)\n                  assert\n                  spec\n  /printInlined\n                print the implementation after inlining calls to\n                procedures with the :inline attribute (works with /inline)\n  /recursionBound:<n>\n                Set the recursion bound for stratified inlining to\n                be n (default 500)\n  /smoke        Soundness Smoke Test: try to stick assert false; in some\n                places in the BPL and see if we can still prove it\n  /smokeTimeout:<n>\n                Timeout, in seconds, for a single theorem prover\n                invocation during smoke test, defaults to 10.\n  /typeEncoding:<t>\n                Encoding of types when generating VC of a polymorphic program:\n                   m = monomorphic (default)\n                   p = predicates\n                   a = arguments\n                Boogie automatically detects monomorphic programs and enables\n                monomorphic VC generation, thereby overriding the above option.\n                If the latter two options are used, then arrays are handled via axioms.\n  /useArrayAxioms\n                If monomorphic type encoding is used, arrays are handled by default with\n                the SMT theory of arrays. This option allows the use of axioms instead.\n  /reflectAdd   In the VC, generate an auxiliary symbol, elsewhere defined\n                to be +, instead of +.\n  /prune:<n>\n                0 - Turn off pruning.\n                1 - Turn on pruning (default). Pruning will remove any top-level\n                Boogie declarations that are not accessible by the implementation\n                that is about to be verified. Without pruning, due to the unstable\n                nature of SMT solvers, a change to any part of a Boogie program\n                has the potential to affect the verification of any other part of\n                the program.\n\n                Only use this if your program contains uses clauses\n                where required, otherwise pruning will break your program.\n                More information can be found here: https://github.com/boogie-org/boogie/blob/afe8eb0ffbb48d593de1ae3bf89712246444daa8/Source/ExecutionEngine/CommandLineOptions.cs#L160\n  /printPruned:<file>\n                After pruning, print the Boogie program to the specified file.\n  /relaxFocus   Process foci in a bottom-up fashion. This way only generates\n                a linear number of splits. The default way (top-down) is more\n                aggressive and it may create an exponential number of splits.\n  /randomSeed:<s>\n                Supply the random seed for /randomizeVcIterations option.\n  /randomizeVcIterations:<n>\n                Turn on randomization of the input that Boogie passes to the\n                SMT solver and turn on randomization in the SMT solver itself.\n                Attempt to randomize and prove each VC n times using the random\n                seed s provided by the option /randomSeed:<s>. If /randomSeed option\n                is not provided, s is chosen to be zero.\n\n                Certain Boogie inputs are unstable in the sense that changes to \n                the input that preserve its meaning may cause the output to change.\n                This option simulates meaning-preserving changes to the input\n                without requiring the user to actually make those changes.\n                This option is implemented by renaming variables and reordering\n                declarations in the input, and by setting solver options that have\n                similar effects.\n  /trackVerificationCoverage\n                Track and report which program elements labeled with an\n                `{:id ...}` attribute were necessary to complete verification.\n                Assumptions, assertions, requires clauses, ensures clauses,\n                assignments, and calls can be labeled for inclusion in this\n                report. This generalizes and replaces the previous\n                (undocumented) `/printNecessaryAssertions` option.\n  /warnVacuousProofs\n                Automatically add missing `{:id ...}` attributes to assumptions,\n                assertions, requires clauses, ensures clauses, and calls; enable the\n                `/trackVerificationCoverage` option; and warn when proof goals are\n                not covered by a proof.\n  /keepQuantifier\n                If pool-based quantifier instantiation creates instances of a quantifier\n                then keep the quantifier along with the instances. By default, the quantifier\n                is dropped if any instances are created.\n\n  ---- Verification-condition splitting --------------------------------------\n\n  /vcsMaxCost:<f>\n                VC will not be split unless the cost of a VC exceeds this\n                number, defaults to 2000.0. This does NOT apply in the\n                keep-going mode after first round of splitting.\n  /vcsMaxSplits:<n>\n                Maximal number of VC generated per method. In keep\n                going mode only applies to the first round.\n                Defaults to 1.\n  /vcsMaxKeepGoingSplits:<n>\n                If set to more than 1, activates the keep\n                going mode, where after the first round of splitting,\n                VCs that timed out are split into <n> pieces and retried\n                until we succeed proving them, or there is only one\n                assertion on a single path and it timeouts (in which\n                case error is reported for that assertion).\n                Defaults to 1.\n  /vcsKeepGoingTimeout:<n>\n                Timeout in seconds for a single theorem prover\n                invocation in keep going mode, except for the final\n                single-assertion case. Defaults to 1s.\n  /vcsFinalAssertTimeout:<n>\n                Timeout in seconds for the single last\n                assertion in the keep going mode. Defaults to 30s.\n  /vcsPathJoinMult:<f>\n                If more than one path join at a block, by how much\n                multiply the number of paths in that block, to accomodate\n                for the fact that the prover will learn something on one\n                paths, before proceeding to another. Defaults to 0.8.\n  /vcsPathCostMult:<f1>\n  /vcsAssumeMult:<f2>\n                The cost of a block is\n                    (<assert-cost> + <f2>*<assume-cost>) *\n                    (1.0 + <f1>*<entering-paths>)\n                <f1> defaults to 1.0, <f2> defaults to 0.01.\n                The cost of a single assertion or assumption is\n                currently always 1.0.\n  /vcsPathSplitMult:<f>\n                If the best path split of a VC of cost A is into\n                VCs of cost B and C, then the split is applied if\n                A >= <f>*(B+C), otherwise assertion splitting will be\n                applied. Defaults to 0.5 (always do path splitting if\n                possible), set to more to do less path splitting\n                and more assertion splitting.\n  /vcsSplitOnEveryAssert\n                Splits every VC so that each assertion is isolated\n                into its own VC. May result in VCs without any assertions.\n  /vcsDumpSplits\n                For split #n dump split.n.dot and split.n.bpl.\n                Warning: Affects error reporting.\n  /vcsCores:<n>\n                Try to verify <n> VCs at once. Defaults to 1.\n  /vcsLoad:<f>  Sets vcsCores to the machine's ProcessorCount * f,\n                rounded to the nearest integer (where 0.0 <= f <= 3.0),\n                but never to less than 1.\n\n  ---- Prover options --------------------------------------------------------\n\n  /errorLimit:<num>\n                Limit the number of errors produced for each procedure\n                (default is 5, some provers may support only 1).\n                Set num to 0 to find as many assertion failures as possible.\n  /timeLimit:<num>\n                Limit the number of seconds spent trying to verify\n                each procedure\n  /rlimit:<num>\n                Limit the Z3 resource spent trying to verify each procedure.\n  /errorTrace:<n>\n                0 - no Trace labels in the error output,\n                1 (default) - include useful Trace labels in error output,\n                2 - include all Trace labels in the error output\n  /vcBrackets:<b>\n                bracket odd-charactered identifier names with |'s.  <b> is:\n                   0 - no (default),\n                   1 - yes\n  /proverDll:<tp>\n                use theorem prover <tp>, where <tp> is either the name of\n                a DLL containing the prover interface located in the\n                Boogie directory, or a full path to a DLL containing such\n                an interface. The default interface shipped is:\n                    SMTLib (uses the SMTLib2 format and calls an SMT solver)\n  /proverOpt:KEY[=VALUE]\n                Provide a prover-specific option (short form /p).\n  /proverHelp   Print prover-specific options supported by /proverOpt.\n  /proverLog:<file>\n                Log input for the theorem prover.  Like filenames\n                supplied as arguments to other options, <file> can use the\n                following macros:\n                    @TIME@    expands to the current time\n                    @PREFIX@  expands to the concatenation of strings given\n                              by /logPrefix options\n                    @FILE@    expands to the last filename specified on the\n                              command line\n                In addition, /proverLog can also use the macro '@PROC@',\n                which causes there to be one prover log file per\n                verification condition, and the macro then expands to the\n                name of the procedure that the verification condition is for.\n  /logPrefix:<str>\n                Defines the expansion of the macro '@PREFIX@', which can\n                be used in various filenames specified by other options.\n  /proverLogAppend\n                Append (not overwrite) the specified prover log file\n  /proverWarnings\n                0 (default) - don't print, 1 - print to stdout,\n                2 - print to stderr\n  /restartProver\n                Restart the prover after each query\n",
        "description": null
      },
      {
        "language": "text",
        "code": "Use 'dafny --help' to see help for the new Dafny CLI format.\nUsage: dafny [ option ... ] [ filename ... ]\n\n  ---- General options -------------------------------------------------------\n\n  /version      print the dafny version number\n  /help         print this message\n  /attrHelp     print a message about supported declaration attributes\n  /env:<n>      print command line arguments\n                  0 - never, 1 (default) - during BPL print and prover log,\n                  2 - like 1 and also to standard output\n  /printVerifiedProceduresCount:<n>\n                0 - no\n                1 (default) - yes\n  /wait         await Enter from keyboard before terminating program\n  /xml:<file>   also produce output in XML format to <file>\n\n  All the .dfy files supplied on the command line along with files recursively\n  included by 'include' directives are considered a single Dafny program;\n  however only those files listed on the command line are verified.\n  \n  Exit code: 0 -- success; 1 -- invalid command-line; 2 -- parse or type errors;\n             3 -- compilation errors; 4 -- verification errors\n  \n  ---- Input configuration ---------------------------------------------------\n  \n  /dprelude:<file>\n      Choose the Dafny prelude file.\n\n  /stdin\n      Read standard input and treat it as an input .dfy file.\n  \n  ---- Plugins ---------------------------------------------------------------\n  \n  ---- Overall reporting and printing ----------------------------------------\n  \n  /showSnippets:<value>\n      0 (default) - Don't show source code snippets for Dafny messages.\n      1 - Show a source code snippet for each Dafny message.\n\n  /stats\n      Print interesting statistics about the Dafny files supplied.\n  \n  /printIncludes:<None|Immediate|Transitive>\n      None (default) - Print nothing.\n      Immediate - Print files included by files listed on the command line.\n      Transitive - Recurses on the files printed by Immediate.\n  \n      Immediate and Transitive will exit after printing.\n  \n  /view:<view1, view2>\n      Print the filtered views of a module after it is resolved (/rprint).\n      If print before the module is resolved (/dprint), then everything in\n      the module is printed. If no view is specified, then everything in\n      the module is printed.\n  /funcCallGraph\n      Print out the function call graph. Format is: func,mod=callee*\n  \n  /pmtrace\n      Print pattern-match compiler debug info.\n  \n  /printTooltips\n      Dump additional positional information (displayed as mouse-over\n      tooltips by the VS Code plugin) to stdout as 'Info' messages.\n  \n  /diagnosticsFormat:<text|json>\n      Choose how to report errors, warnings, and info messages.\n      text (default) - Use human readable output\n      json - Print each message as a JSON object, one per line.\n  \n  ---- Language feature selection --------------------------------------------\n  \n  /defaultFunctionOpacity:<value>\n      Change the default opacity of functions. \n      `transparent` (default) means functions are transparent, can be manually made opaque and then revealed. \n      `autoRevealDependencies` makes all functions not explicitly labelled as opaque to be opaque but reveals them automatically in scopes which do not have `{:autoRevealDependencies false}`. \n      `opaque` means functions are always opaque so the opaque keyword is not needed, and functions must be revealed everywhere needed for a proof.\n\n  /readsClausesOnMethods:<value>\n      0 (default) - Reads clauses on methods are forbidden.\n      1 - Reads clauses on methods are permitted (with a default of 'reads *').\n\n  /standardLibraries:<value>\n      0 (default) - Do not allow Dafny code to depend on the standard libraries included with the Dafny distribution.\n      1 - Allow Dafny code to depend on the standard libraries included with the Dafny distribution.\n      See https://github.com/dafny-lang/dafny/blob/master/Source/DafnyStandardLibraries/README.md for more information.\n      Not compatible with the /unicodeChar:0 option.\n\n  /noIncludes\n      Ignore include directives.\n  \n  /noExterns\n      Ignore extern attributes.\n  \n  /functionSyntax:<version>\n      The syntax for functions is changing from Dafny version 3 to version\n      4. This switch gives early access to the new syntax, and also\n      provides a mode to help with migration.\n  \n      3 - Compiled functions are written `function method` and\n          `predicate method`. Ghost functions are written `function` and\n          `predicate`.\n      4 (default) - Compiled functions are written `function` and `predicate`. Ghost\n          functions are written `ghost function` and `ghost predicate`.\n      migration3to4 - Compiled functions are written `function method` and\n          `predicate method`. Ghost functions are written `ghost function`\n          and `ghost predicate`. To migrate from version 3 to version 4,\n          use this flag on your version 3 program. This will give flag all\n          occurrences of `function` and `predicate` as parsing errors.\n          These are ghost functions, so change those into the new syntax\n          `ghost function` and `ghost predicate`. Then, start using\n          /functionSyntax:4. This will flag all occurrences of `function\n          method` and `predicate method` as parsing errors. So, change\n          those to just `function` and `predicate`. Now, your program uses\n          version 4 syntax and has the exact same meaning as your previous\n          version 3 program.\n      experimentalDefaultGhost - Like migration3to4, but allow `function`\n          and `predicate` as alternatives to declaring ghost functions and\n          predicates, respectively.\n      experimentalDefaultCompiled - Like migration3to4, but allow\n          `function` and `predicate` as alternatives to declaring compiled\n          functions and predicates, respectively.\n      experimentalPredicateAlwaysGhost - Compiled functions are written\n          `function`. Ghost functions are written `ghost function`.\n          Predicates are always ghost and are written `predicate`.\n  \n  /quantifierSyntax:<version>\n      The syntax for quantification domains is changing from Dafny version\n      3 to version 4, more specifically where quantifier ranges (|\n      <Range>) are allowed. This switch gives early access to the new\n      syntax.\n  \n      3 - Ranges are only allowed after all quantified variables\n          are declared. (e.g. set x, y | 0 <= x < |s| && y in s[x] && 0 <=\n          y :: y)\n      4 (default) - Ranges are allowed after each quantified variable declaration.\n          (e.g. set x | 0 <= x < |s|, y <- s[x] | 0 <= y :: y)\n  \n      Note that quantifier variable domains (<- <Domain>) are available in\n      both syntax versions.\n  \n  /disableScopes\n      Treat all export sets as 'export reveal *'. i.e. don't hide function\n      bodies or type definitions during translation.\n  \n  ---- Warning selection -----------------------------------------------------\n  \n  /warnShadowing\n      Emits a warning if the name of a declared variable caused another\n      variable to be shadowed.\n  \n  /warnMissingConstructorParenthesis\n      Emits a warning when a constructor name in a case pattern is not\n      followed by parentheses.\n  \n  /deprecation:<n>\n      0 - Don't give any warnings about deprecated features.\n      1 (default) - Show warnings about deprecated features.\n  \n  /warningsAsErrors\n      Treat warnings as errors.\n  \n  ---- Verification options -------------------------------------------------\n  \n  /allowAxioms:<value>\n      Prevents a warning from being generated for axioms, such as assume statements and functions or methods without a body, that don't have an {:axiom} attribute.\n\n  /verificationLogger:<configuration>\n      Logs verification results using the given test result format. The currently supported formats are `trx`, `csv`, and `text`. These are: the XML-based format commonly used for test results for .NET languages, a custom CSV schema, and a textual format meant for human consumption. You can provide configuration using the same string format as when using the --logger option for dotnet test, such as: --format \"trx;LogFileName=<...>\");\n      \n      The `trx` and `csv` formats automatically choose an output file name by default, and print the name of this file to the console. The `text` format prints its output to the console by default, but can send output to a file given the `LogFileName` option.\n      \n      The `text` format also includes a more detailed breakdown of what assertions appear in each assertion batch. When combined with the isolate-assertions option, it will provide approximate time and resource use costs for each assertion, allowing identification of especially expensive assertions.\n\n  /dafnyVerify:<n>\n      0 - Stop after resolution and typechecking.\n      1 - Continue on to verification and compilation.\n  \n  /verifyAllModules\n      Verify modules that come from an include directive.\n  \n  /emitUncompilableCode\n      Allow compilers to emit uncompilable code that usually contain useful\n      information about what feature is missing, rather than\n      stopping on the first problem\n  \n  /separateModuleOutput\n      Output verification results for each module separately, rather than\n      aggregating them after they are all finished.\n  \n  /noCheating:<n>\n      0 (default) - Allow assume statements and free invariants.\n      1 - Treat all assumptions as asserts, and drop free.\n  \n  /induction:<n>\n      0 - Never do induction, not even when attributes request it.\n      1 - Only apply induction when attributes request it.\n      2 - Apply induction as requested (by attributes) and also for\n          heuristically chosen quantifiers.\n      3 - Apply induction as requested, and for heuristically chosen\n          quantifiers and lemmas.\n      4 (default) - Apply induction as requested, and for lemmas.\n  \n  /inductionHeuristic:<n>\n      0 - Least discriminating induction heuristic (that is, lean toward\n          applying induction more often).\n      1,2,3,4,5 - Levels in between, ordered as follows as far as how\n          discriminating they are: 0 < 1 < 2 < (3,4) < 5 < 6.\n      6 (default) - Most discriminating.\n  \n  /trackPrintEffects:<n>\n      0 (default) - Every compiled method, constructor, and iterator,\n         whether or not it bears a {:print} attribute, may have print\n         effects.\n      1 - A compiled method, constructor, or iterator is allowed to have\n         print effects only if it is marked with {:print}.\n  \n  /definiteAssignment:<n>\n      0 - Ignores definite-assignment rules. This mode is for testing\n          only--it is not sound.\n      1 (default) - Enforces definite-assignment rules for compiled\n          variables and fields whose types do not support\n          auto-initialization, and for ghost variables and fields whose\n          type is possibly empty.\n      2 - Enforces definite-assignment for all non-yield-parameter\n          variables and fields, regardless of their types.\n      3 - Like 2, but also performs checks in the compiler that no\n          nondeterministic statements are used; thus, a program that\n          passes at this level 3 is one that the language guarantees that\n          values seen during execution will be the same in every run of\n          the program.\n      4 - Like 1, but enforces definite assignment for all local variables\n          and out-parameters, regardless of their types. (Whether or not\n          fields and new arrays are subject to definite assignments depends\n          on their types.)\n  \n  /noAutoReq\n      Ignore autoReq attributes.\n  \n  /autoReqPrint:<file>\n      Print out requirements that were automatically generated by autoReq.\n  \n  /noNLarith\n      Reduce Z3's knowledge of non-linear arithmetic (*,/,%).\n  \n      Results in more manual work, but also produces more predictable\n      behavior. (This switch will perhaps be replaced by /arith in the\n      future. For now, it takes precedence of /arith.)\n  \n  /arith:<n>\n      (experimental) Adjust how Dafny interprets arithmetic operations.\n  \n      0 - Use Boogie/Z3 built-ins for all arithmetic operations.\n      1 (default) - Like 0, but introduce symbolic synonyms for *,/,%, and\n          allow these operators to be used in triggers.\n      2 - Like 1, but introduce symbolic synonyms also for +,-.\n      3 - Turn off non-linear arithmetic in the SMT solver. Still, use\n          Boogie/Z3 built-in symbols for all arithmetic operations.\n      4 - Like 3, but introduce symbolic synonyms for *,/,%, and allow\n          these operators to be used in triggers.\n      5 - Like 4, but introduce symbolic synonyms also for +,-.\n      6 - Like 5, and introduce axioms that distribute + over *.\n      7 - like 6, and introduce facts that associate literals arguments of *.\n      8 - Like 7, and introduce axiom for the connection between *,/,%.\n      9 - Like 8, and introduce axioms for sign of multiplication.\n      10 - Like 9, and introduce axioms for commutativity and\n          associativity of *.\n  \n  /autoTriggers:<n>\n      0 - Do not generate {:trigger} annotations for user-level\n          quantifiers.\n      1 (default) - Add a {:trigger} to each user-level quantifier.\n          Existing annotations are preserved.\n  \n  /rewriteFocalPredicates:<n>\n      0 - Don't rewrite predicates in the body of prefix lemmas.\n      1 (default) - In the body of prefix lemmas, rewrite any use of a\n          focal predicate P to P#[_k-1].\n  \n  /extractCounterexample\n      If verification fails, report a detailed counterexample for the\n      first failing assertion (experimental).\n  \n  ---- Compilation options ---------------------------------------------------\n  \n  /compileTarget:<language>\n      cs (default) - Compile to .NET via C#.\n      go - Compile to Go.\n      js - Compile to JavaScript.\n      java - Compile to Java.\n      py - Compile to Python.\n      cpp - Compile to C++.\n      dfy - Compile to Dafny.\n      \n      Note that the C++ backend has various limitations (see\n      Docs/Compilation/Cpp.md). This includes lack of support for\n      BigIntegers (aka int), most higher order functions, and advanced\n      features like traits or co-inductive types.\n\n  /library:<value>\n      The contents of this file and any files it includes can be referenced from other files as if they were included. \n      However, these contents are skipped during code generation and verification.\n      This option is useful in a diamond dependency situation, \n      to prevent code from the bottom dependency from being generated more than once.\n      The value may be a comma-separated list of files and folders.\n\n  /optimizeErasableDatatypeWrapper:<value>\n      0 - Include all non-ghost datatype constructors in the compiled code\n      1 (default) - In the compiled target code, transform any non-extern\n          datatype with a single non-ghost constructor that has a single\n          non-ghost parameter into just that parameter. For example, the type\n              datatype Record = Record(x: int)\n          is transformed into just 'int' in the target code.\n\n  /out:<file>\n      Specify the filename and location for the generated target language files.\n\n  /runAllTests:<n>\n      0 (default) - Annotates compiled methods with the {:test}\n              attribute such that they can be tested using a testing framework\n              in the target language (e.g. xUnit for C#).\n          1 - Emits a main method in the target language that will execute\n              every method in the program with the {:test} attribute. Cannot\n              be used if the program already contains a main method. Note that\n              /compile:3 or 4 must be provided as well to actually execute\n              this main method!\n\n  /compile:<n>\n      0 - Do not compile Dafny program.\n      1 (default) - Upon successful verification of the Dafny program,\n          compile it to the designated target language. (/noVerify\n          automatically counts as a failed verification.)\n      2 - Always attempt to compile Dafny program to the target language,\n          regardless of verification outcome.\n      3 - If there is a Main method and there are no verification errors\n          and /noVerify is not used, compiles program in memory (i.e.,\n          does not write an output file) and runs it.\n      4 - Like (3), but attempts to compile and run regardless of\n          verification outcome.\n  /Main:<name>\n      Specify the (fully-qualified) name of the method to use as the executable entry point.\n      Default is the method with the {:main} attribute, or else the method named 'Main'.\n      A Main method can have at most one (non-ghost) argument of type `seq<string>`\n  --args <arg1> <arg2> ...\n      When running a Dafny file through /compile:3 or /compile:4, '--args' provides\n      all arguments after it to the Main function, at index starting at 1.\n      Index 0 is used to store the executable's name if it exists.\n  \n  /compileVerbose:<n>\n      0 - Don't print status of compilation to the console.\n      1 (default) - Print information such as files being written by the\n          compiler to the console.\n  \n  /spillTargetCode:<n>\n      Explicitly writes the code in the target language to one or more files.\n      This is not necessary to run a Dafny program, but may be of interest when\n      building multi-language programs or for debugging.\n  \n      0 (default) - Don't make any extra effort to write the textual\n          target program (but still compile it, if /compile indicates to\n          do so).\n      1 - Write the textual target program, if it is being compiled.\n      2 - Write the textual target program, provided it passes the\n          verifier (and /noVerify is NOT used), regardless of /compile\n          setting.\n      3 - Write the textual target program, regardless of verification\n          outcome and /compile setting.\n      Note, some compiler targets may (always or in some situations) write\n      out the textual target program as part of compilation, in which case\n      /spillTargetCode:0 behaves the same way as /spillTargetCode:1.\n  /coverage:<file>\n      The compiler emits branch-coverage calls and outputs into <file> a\n      legend that gives a description of each source-location identifier\n      used in the branch-coverage calls. (Use - as <file> to print to the\n      console.)\n  \n  /optimize\n      Produce optimized C# code by passing the /optimize flag to csc.exe.\n  \n  /optimizeResolution:<n>\n      0 - Resolve and translate all methods.\n      1 - Translate methods only in the call graph of current verification\n          target.\n      2 (default) - As in 1, but only resolve method bodies in\n          non-included Dafny sources.\n  /useRuntimeLib\n      Refer to a pre-built DafnyRuntime.dll in the compiled assembly\n      rather than including DafnyRuntime.cs verbatim.\n  \n  /testContracts:<Externs|TestedExterns>\n      Enable run-time testing of the compilable portions of certain function\n      or method contracts, at their call sites. The current implementation\n      focuses on {:extern} code but may support other code in the future.\n  \n      Externs - Check contracts on every call to a function or method marked\n          with the {:extern} attribute, regardless of where it occurs.\n      TestedExterns - Check contracts on every call to a function or method\n          marked with the {:extern} attribute when it occurs in a method\n          with the {:test} attribute, and warn if no corresponding test\n          exists for a given external declaration.\n  \n  ----------------------------------------------------------------------------\n  \n  Dafny generally accepts Boogie options and passes these on to Boogie.\n  However, some Boogie options, like /loopUnroll, may not be sound for\n  Dafny or may not have the same meaning for a Dafny program as it would\n  for a similar Boogie program.\n  \n  ---- Boogie options --------------------------------------------------------\n\n  Multiple .bpl files supplied on the command line are concatenated into one\n  Boogie program.\n\n  /lib:<name>   Include definitions in library <name>. The file <name>.bpl\n                must be an included resource in Core.dll. Currently, the\n                following libraries are supported---base, node.\n  /proc:<p>     Only check procedures matched by pattern <p>. This option\n                may be specified multiple times to match multiple patterns.\n                The pattern <p> matches the whole procedure name and may\n                contain * wildcards which match any character zero or more\n                times.\n  /noProc:<p>   Do not check procedures matched by pattern <p>. Exclusions\n                with /noProc are applied after inclusions with /proc.\n  /noResolve    parse only\n  /noTypecheck  parse and resolve only\n  /print:<file>\n                print Boogie program after parsing it\n                (use - as <file> to print to console)\n  /pretty:<n>   0 - print each Boogie statement on one line (faster).\n                1 (default) - pretty-print with some line breaks.\n  /printWithUniqueIds\n                print augmented information that uniquely identifies variables\n  /printUnstructured\n                with /print option, desugars all structured statements\n  /printPassive\n                with /print option, prints passive version of program\n  /printDesugared\n                with /print option, desugars calls\n  /printLambdaLifting\n                with /print option, desugars lambda lifting\n  /freeVarLambdaLifting\n                Boogie's lambda lifting transforms the bodies of lambda\n                expressions into templates with holes. By default, holes\n                are maximally large subexpressions that do not contain\n                bound variables. This option performs a form of lambda\n                lifting in which holes are the lambda's free variables.\n  /overlookTypeErrors\n                skip any implementation with resolution or type checking errors\n  /loopUnroll:<n>\n                unroll loops, following up to n back edges (and then some)\n                default is -1, which means loops are not unrolled\n  /extractLoops\n                convert all irreducible loops to reducible forms by node splitting\n                and extract all loops into recursive procedures\n  /soundLoopUnrolling\n                sound loop unrolling\n  /kInductionDepth:<k>\n                uses combined-case k-induction to soundly eliminate loops,\n                by unwinding proportional to the supplied parameter\n  /inferModifies\n                automatically infer modifies clauses\n  /printModel:<n>\n                0 (default) - do not print Z3's error model\n                1 - print Z3's error model\n  /printModelToFile:<file>\n                print model to <file> instead of console\n  /mv:<file>    Specify file to save the model with captured states\n                (see documentation for :captureState attribute)\n  /enhancedErrorMessages:<n>\n                0 (default) - no enhanced error messages\n                1 - Z3 error model enhanced error messages\n  /printCFG:<prefix> : print control flow graph of each implementation in\n                       Graphviz format to files named:\n                         <prefix>.<procedure name>.dot\n  /useBaseNameForFileName : When parsing use basename of file for tokens instead\n                            of the path supplied on the command line\n  /emitDebugInformation:<n>\n                0 - do not emit debug information\n                1 (default) - emit the debug information :qid, :skolemid and set-info :boogie-vc-id\n  /normalizeNames:<n>\n                0 (default) - Keep Boogie program names when generating SMT commands\n                1 - Normalize Boogie program names when generating SMT commands. \n                  This keeps SMT solver input, and thus output, \n                  constant when renaming declarations in the input program.\n  /normalizeDeclarationOrder:<n>\n                0 - Keep order of top-level declarations when generating SMT commands.\n                1 (default) - Normalize order of top-level declarations when generating SMT commands.\n                  This keeps SMT solver input, and thus output, \n                  constant when reordering declarations in the input program.\n\n  ---- Inference options -----------------------------------------------------\n\n  /infer:<flags>\n                use abstract interpretation to infer invariants\n                <flags> must specify exactly one of the following domains:\n                   t = trivial bottom/top lattice\n                   j = stronger intervals\n                together with any of the following options:\n                   s = debug statistics\n                0..9 = number of iterations before applying a widen (default=0)\n  /checkInfer   instrument inferred invariants as asserts to be checked by\n                theorem prover\n  /contractInfer\n                perform procedure contract inference\n  /instrumentInfer\n                h - instrument inferred invariants only at beginning of\n                    loop headers (default)\n                e - instrument inferred invariants at beginning and end\n                    of every block (this mode is intended for use in\n                    debugging of abstract domains)\n  /printInstrumented\n                print Boogie program after it has been instrumented with\n                invariants\n\n  ---- Debugging and general tracing options ---------------------------------\n\n  /silent       print nothing at all\n  /quiet        print nothing but warnings and errors\n  /trace        blurt out various debug trace information\n  /traceTimes   output timing information at certain points in the pipeline\n  /tracePOs     output information about the number of proof obligations\n                (also included in the /trace output)\n  /forceBplErrors\n                show boogie errors even if {:msg ...} attribute is present\n  /break        launch and break into debugger\n\n  ---- Civl options ----------------------------------------------------------\n\n  /trustMoverTypes\n                do not verify mover type annotations on atomic action declarations\n  /trustNoninterference\n                do not perform noninterference checks\n  /trustRefinement\n                do not perform refinement checks\n  /trustLayersUpto:<n>\n                do not verify layers <n> and below\n  /trustLayersDownto:<n>\n                do not verify layers <n> and above\n  /trustSequentialization\n                do not perform sequentialization checks\n  /civlDesugaredFile:<file>\n                print plain Boogie program to <file>\n\n  ---- Verification-condition generation options -----------------------------\n\n  /liveVariableAnalysis:<c>\n                0 = do not perform live variable analysis\n                1 = perform live variable analysis (default)\n                2 = perform interprocedural live variable analysis\n  /noVerify     skip VC generation and invocation of the theorem prover\n  /verifySnapshots:<n>\n                verify several program snapshots (named <filename>.v0.bpl\n                to <filename>.vN.bpl) using verification result caching:\n                0 - do not use any verification result caching (default)\n                1 - use the basic verification result caching\n                2 - use the more advanced verification result caching\n                3 - use the more advanced caching and report errors according\n                    to the new source locations for errors and their\n                    related locations (but not /errorTrace and CaptureState\n                    locations)\n  /traceCaching:<n>\n                0 (default) - none\n                1 - for testing\n                2 - for benchmarking\n                3 - for testing, benchmarking, and debugging\n  /verifySeparately\n                verify each input program separately\n  /removeEmptyBlocks:<c>\n                0 - do not remove empty blocks during VC generation\n                1 - remove empty blocks (default)\n  /coalesceBlocks:<c>\n                0 = do not coalesce blocks\n                1 = coalesce blocks (default)\n  /traceverify  print debug output during verification condition generation\n  /subsumption:<c>\n                apply subsumption to asserted conditions:\n                0 - never, 1 - not for quantifiers, 2 (default) - always\n  /alwaysAssumeFreeLoopInvariants\n                usually, a free loop invariant (or assume\n                statement in that position) is ignored in checking contexts\n                (like other free things); this option includes these free\n                loop invariants as assumes in both contexts\n  /inline:<i>   use inlining strategy <i> for procedures with the :inline\n                attribute, see /attrHelp for details:\n                  none\n                  assume (default)\n                  assert\n                  spec\n  /printInlined\n                print the implementation after inlining calls to\n                procedures with the :inline attribute (works with /inline)\n  /recursionBound:<n>\n                Set the recursion bound for stratified inlining to\n                be n (default 500)\n  /smoke        Soundness Smoke Test: try to stick assert false; in some\n                places in the BPL and see if we can still prove it\n  /smokeTimeout:<n>\n                Timeout, in seconds, for a single theorem prover\n                invocation during smoke test, defaults to 10.\n  /typeEncoding:<t>\n                Encoding of types when generating VC of a polymorphic program:\n                   m = monomorphic (default)\n                   p = predicates\n                   a = arguments\n                Boogie automatically detects monomorphic programs and enables\n                monomorphic VC generation, thereby overriding the above option.\n                If the latter two options are used, then arrays are handled via axioms.\n  /useArrayAxioms\n                If monomorphic type encoding is used, arrays are handled by default with\n                the SMT theory of arrays. This option allows the use of axioms instead.\n  /reflectAdd   In the VC, generate an auxiliary symbol, elsewhere defined\n                to be +, instead of +.\n  /prune:<n>\n                0 - Turn off pruning.\n                1 - Turn on pruning (default). Pruning will remove any top-level\n                Boogie declarations that are not accessible by the implementation\n                that is about to be verified. Without pruning, due to the unstable\n                nature of SMT solvers, a change to any part of a Boogie program\n                has the potential to affect the verification of any other part of\n                the program.\n\n                Only use this if your program contains uses clauses\n                where required, otherwise pruning will break your program.\n                More information can be found here: https://github.com/boogie-org/boogie/blob/afe8eb0ffbb48d593de1ae3bf89712246444daa8/Source/ExecutionEngine/CommandLineOptions.cs#L160\n  /printPruned:<file>\n                After pruning, print the Boogie program to the specified file.\n  /relaxFocus   Process foci in a bottom-up fashion. This way only generates\n                a linear number of splits. The default way (top-down) is more\n                aggressive and it may create an exponential number of splits.\n  /randomSeed:<s>\n                Supply the random seed for /randomizeVcIterations option.\n  /randomizeVcIterations:<n>\n                Turn on randomization of the input that Boogie passes to the\n                SMT solver and turn on randomization in the SMT solver itself.\n                Attempt to randomize and prove each VC n times using the random\n                seed s provided by the option /randomSeed:<s>. If /randomSeed option\n                is not provided, s is chosen to be zero.\n\n                Certain Boogie inputs are unstable in the sense that changes to \n                the input that preserve its meaning may cause the output to change.\n                This option simulates meaning-preserving changes to the input\n                without requiring the user to actually make those changes.\n                This option is implemented by renaming variables and reordering\n                declarations in the input, and by setting solver options that have\n                similar effects.\n  /trackVerificationCoverage\n                Track and report which program elements labeled with an\n                `{:id ...}` attribute were necessary to complete verification.\n                Assumptions, assertions, requires clauses, ensures clauses,\n                assignments, and calls can be labeled for inclusion in this\n                report. This generalizes and replaces the previous\n                (undocumented) `/printNecessaryAssertions` option.\n  /warnVacuousProofs\n                Automatically add missing `{:id ...}` attributes to assumptions,\n                assertions, requires clauses, ensures clauses, and calls; enable the\n                `/trackVerificationCoverage` option; and warn when proof goals are\n                not covered by a proof.\n  /keepQuantifier\n                If pool-based quantifier instantiation creates instances of a quantifier\n                then keep the quantifier along with the instances. By default, the quantifier\n                is dropped if any instances are created.\n\n  ---- Verification-condition splitting --------------------------------------\n\n  /vcsMaxCost:<f>\n                VC will not be split unless the cost of a VC exceeds this\n                number, defaults to 2000.0. This does NOT apply in the\n                keep-going mode after first round of splitting.\n  /vcsMaxSplits:<n>\n                Maximal number of VC generated per method. In keep\n                going mode only applies to the first round.\n                Defaults to 1.\n  /vcsMaxKeepGoingSplits:<n>\n                If set to more than 1, activates the keep\n                going mode, where after the first round of splitting,\n                VCs that timed out are split into <n> pieces and retried\n                until we succeed proving them, or there is only one\n                assertion on a single path and it timeouts (in which\n                case error is reported for that assertion).\n                Defaults to 1.\n  /vcsKeepGoingTimeout:<n>\n                Timeout in seconds for a single theorem prover\n                invocation in keep going mode, except for the final\n                single-assertion case. Defaults to 1s.\n  /vcsFinalAssertTimeout:<n>\n                Timeout in seconds for the single last\n                assertion in the keep going mode. Defaults to 30s.\n  /vcsPathJoinMult:<f>\n                If more than one path join at a block, by how much\n                multiply the number of paths in that block, to accomodate\n                for the fact that the prover will learn something on one\n                paths, before proceeding to another. Defaults to 0.8.\n  /vcsPathCostMult:<f1>\n  /vcsAssumeMult:<f2>\n                The cost of a block is\n                    (<assert-cost> + <f2>*<assume-cost>) *\n                    (1.0 + <f1>*<entering-paths>)\n                <f1> defaults to 1.0, <f2> defaults to 0.01.\n                The cost of a single assertion or assumption is\n                currently always 1.0.\n  /vcsPathSplitMult:<f>\n                If the best path split of a VC of cost A is into\n                VCs of cost B and C, then the split is applied if\n                A >= <f>*(B+C), otherwise assertion splitting will be\n                applied. Defaults to 0.5 (always do path splitting if\n                possible), set to more to do less path splitting\n                and more assertion splitting.\n  /vcsSplitOnEveryAssert\n                Splits every VC so that each assertion is isolated\n                into its own VC. May result in VCs without any assertions.\n  /vcsDumpSplits\n                For split #n dump split.n.dot and split.n.bpl.\n                Warning: Affects error reporting.\n  /vcsCores:<n>\n                Try to verify <n> VCs at once. Defaults to 1.\n  /vcsLoad:<f>  Sets vcsCores to the machine's ProcessorCount * f,\n                rounded to the nearest integer (where 0.0 <= f <= 3.0),\n                but never to less than 1.\n\n  ---- Prover options --------------------------------------------------------\n\n  /errorLimit:<num>\n                Limit the number of errors produced for each procedure\n                (default is 5, some provers may support only 1).\n                Set num to 0 to find as many assertion failures as possible.\n  /timeLimit:<num>\n                Limit the number of seconds spent trying to verify\n                each procedure\n  /rlimit:<num>\n                Limit the Z3 resource spent trying to verify each procedure.\n  /errorTrace:<n>\n                0 - no Trace labels in the error output,\n                1 (default) - include useful Trace labels in error output,\n                2 - include all Trace labels in the error output\n  /vcBrackets:<b>\n                bracket odd-charactered identifier names with |'s.  <b> is:\n                   0 - no (default),\n                   1 - yes\n  /proverDll:<tp>\n                use theorem prover <tp>, where <tp> is either the name of\n                a DLL containing the prover interface located in the\n                Boogie directory, or a full path to a DLL containing such\n                an interface. The default interface shipped is:\n                    SMTLib (uses the SMTLib2 format and calls an SMT solver)\n  /proverOpt:KEY[=VALUE]\n                Provide a prover-specific option (short form /p).\n  /proverHelp   Print prover-specific options supported by /proverOpt.\n  /proverLog:<file>\n                Log input for the theorem prover.  Like filenames\n                supplied as arguments to other options, <file> can use the\n                following macros:\n                    @TIME@    expands to the current time\n                    @PREFIX@  expands to the concatenation of strings given\n                              by /logPrefix options\n                    @FILE@    expands to the last filename specified on the\n                              command line\n                In addition, /proverLog can also use the macro '@PROC@',\n                which causes there to be one prover log file per\n                verification condition, and the macro then expands to the\n                name of the procedure that the verification condition is for.\n  /logPrefix:<str>\n                Defines the expansion of the macro '@PREFIX@', which can\n                be used in various filenames specified by other options.\n  /proverLogAppend\n                Append (not overwrite) the specified prover log file\n  /proverWarnings\n                0 (default) - don't print, 1 - print to stdout,\n                2 - print to stderr\n  /restartProver\n                Restart the prover after each query\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "letter = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\ndigit = \"0123456789\"\nposDigit = \"123456789\"\nposDigitFrom2 = \"23456789\"\n\nhexdigit = \"0123456789ABCDEFabcdef\"\n\nspecial = \"'_?\"\n\ncr        = '\\r'\n\nlf        = '\\n'\n\ntab       = '\\t'\n\nspace     = ' '\n\nnondigitIdChar = letter + special\n\nidchar = nondigitIdChar + digit\n\nnonidchar = ANY - idchar\n\ncharChar = ANY - '\\'' - '\\\\' - cr - lf\n\nstringChar = ANY - '\"' - '\\\\' - cr - lf\n\nverbatimStringChar = ANY - '\"'\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "reservedword =\n    \"abstract\" | \"allocated\" | \"as\" | \"assert\" | \"assume\" |\n    \"bool\" | \"break\" | \"by\" |\n    \"calc\" | \"case\" | \"char\" | \"class\" | \"codatatype\" |\n    \"const\" | \"constructor\" | \"continue\" |\n    \"datatype\" | \"decreases\" |\n    \"else\" | \"ensures\" | \"exists\" | \"expect\" | \"export\" | \"extends\" |\n    \"false\" | \"for\" | \"forall\" | \"fp32\" | \"fp64\" | \"fresh\" | \"function\" | \"ghost\" |\n    \"if\" | \"imap\" | \"import\" | \"in\" | \"include\" |\n    \"int\" | \"invariant\" | \"is\" | \"iset\" | \"iterator\" |\n    \"label\" | \"lemma\" | \"map\" | \"match\" | \"method\" |\n    \"modifies\" | \"modify\" | \"module\" | \"multiset\" |\n    \"nameonly\" | \"nat\" | \"new\" | \"newtype\" | \"null\" |\n    \"object\" | \"object?\" | \"old\" | \"opaque\" | \"opened\" | \"ORDINAL\"\n    \"predicate\" | \"print\" | \"provides\" |\n    \"reads\" | \"real\" | \"refines\" | \"requires\" | \"return\" |\n    \"returns\" | \"reveal\" | \"reveals\" |\n    \"seq\" | \"set\" | \"static\" | \"string\" |\n    \"then\" | \"this\" | \"trait\" | \"true\" | \"twostate\" | \"type\" |\n    \"unchanged\" | \"var\" | \"while\" | \"witness\" |\n    \"yield\" | \"yields\" |\n    arrayToken | bvToken\n\narrayToken = \"array\" [ posDigitFrom2 | posDigit digit { digit }][\"?\"]\n\nbvToken = \"bv\" ( 0 | posDigit { digit } )\n\nident = nondigitIdChar { idchar } - charToken - reservedword\n\ndigits = digit {[\"_\"] digit}\n\nhexdigits = \"0x\" hexdigit {[\"_\"] hexdigit}\n\nrealnumber = digit {[\"_\"] digit}\n             ( '.' digit {[\"_\"] digit} ['e' ['-'] digit {[\"_\"] digit}]\n             | 'e' ['-'] digit {[\"_\"] digit}\n             )\n\nescapedChar =\n    ( \"\\'\" | \"\\\"\" | \"\\\\\" | \"\\0\" | \"\\n\" | \"\\r\" | \"\\t\"\n      | \"\\u\" hexdigit hexdigit hexdigit hexdigit\n      | \"\\U{\" hexdigit { hexdigit } \"}\"\n    )\n\ncharToken = \"'\" ( charChar | escapedChar ) \"'\"\n\nstringToken =\n    '\"' { stringChar | escapedChar }  '\"'\n  | \"@\" '\"' { verbatimStringChar | '\"' '\"' } '\"'\n\nellipsis = \"...\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "Dafny = { IncludeDirective_ } { TopDecl(isTopLevel:true, isAbstract: false) } EOF\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "IncludeDirective_ = \"include\" stringToken\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "TopDecl(isTopLevel, isAbstract) =\n  { DeclModifier }\n  ( SubModuleDecl(isTopLevel)\n  | ClassDecl\n  | DatatypeDecl\n  | NewtypeDecl\n  | SynonymTypeDecl  // includes abstract types\n  | IteratorDecl\n  | TraitDecl\n  | ClassMemberDecl(allowConstructors: false, isValueType: true, moduleLevelDecl: true)\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "DeclModifier = ( \"abstract\" | \"ghost\" | \"static\" | \"opaque\" )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "SubModuleDecl(isTopLevel) = ( ModuleDefinition | ModuleImport | ModuleExport )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ModuleDefinition(isTopLevel) = \n  \"module\" { Attribute } ModuleQualifiedName\n  [ \"refines\" ModuleQualifiedName ]\n  \"{\" { TopDecl(isTopLevel:false, isAbstract) } \"}\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ModuleImport =\n  \"import\"\n  [ \"opened\" ]\n  ( QualifiedModuleExport\n  | ModuleName \"=\" QualifiedModuleExport\n  | ModuleName \":\" QualifiedModuleExport\n  )\n\nQualifiedModuleExport =\n    ModuleQualifiedName [ \"`\" ModuleExportSuffix ]\n\nModuleExportSuffix =\n  ( ExportId\n  | \"{\" ExportId { \",\" ExportId } \"}\"\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ModuleExport =\n  \"export\"\n  [ ExportId ]\n  [ \"...\" ]\n  {\n    \"extends\"  ExportId { \",\" ExportId }\n  | \"provides\" ( ExportSignature { \",\" ExportSignature } | \"*\" )\n  | \"reveals\"  ( ExportSignature { \",\" ExportSignature } | \"*\" )\n  }\n\nExportSignature = TypeNameOrCtorSuffix [ \".\" TypeNameOrCtorSuffix ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "Type = DomainType_ | ArrowType_\n\nDomainType_ =\n  ( BoolType_ | CharType_ | IntType_ | RealType_ | FloatType_\n  | OrdinalType_ | BitVectorType_ | ObjectType_\n  | FiniteSetType_ | InfiniteSetType_\n  | MultisetType_\n  | FiniteMapType_ | InfiniteMapType_\n  | SequenceType_\n  | NatType_\n  | StringType_\n  | ArrayType_\n  | TupleType\n  | NamedType\n  )\n\nNamedType = NameSegmentForTypeName { \".\" NameSegmentForTypeName }\n\nNameSegmentForTypeName = Ident [ GenericInstantiation ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "BoolType_ = \"bool\"\nIntType_ = \"int\"\nRealType_ = \"real\"\nFloatType_ = \"fp32\" | \"fp64\"\nBitVectorType_ = bvToken\nOrdinalType_ = \"ORDINAL\"\nCharType_ = \"char\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "GenericInstantiation = \"<\" Type { \",\" Type } \">\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "GenericParameters(allowVariance) =\n  \"<\" [ Variance ] TypeVariableName { TypeParameterCharacteristics }\n  { \",\" [ Variance ] TypeVariableName { TypeParameterCharacteristics } }\n  \">\"\n\n// The optional Variance indicator is permitted only if allowVariance is true\nVariance = ( \"*\" | \"+\" | \"!\" | \"-\" )\n\nTypeParameterCharacteristics = \"(\" TPCharOption { \",\" TPCharOption } \")\"\n\nTPCharOption = ( \"==\" | \"0\" | \"00\" | \"!\" \"new\" )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "FiniteSetType_ = \"set\" [ GenericInstantiation ]\n\nInfiniteSetType_ = \"iset\" [ GenericInstantiation ]\n\nMultisetType_ = \"multiset\" [ GenericInstantiation ]\n\nSequenceType_ = \"seq\" [ GenericInstantiation ]\n\nStringType_ = \"string\"\n\nFiniteMapType_ = \"map\" [ GenericInstantiation ]\n\nInfiniteMapType_ = \"imap\" [ GenericInstantiation ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "SynonymTypeDecl =\n  SynonymTypeDecl_ | OpaqueTypeDecl_ | SubsetTypeDecl_\n\nSynonymTypeName = NoUSIdent\n\nSynonymTypeDecl_ =\n  \"type\" { Attribute } SynonymTypeName\n   { TypeParameterCharacteristics }\n   [ GenericParameters ]\n   \"=\" Type\n\nOpaqueTypeDecl_ =\n  \"type\" { Attribute } SynonymTypeName\n   { TypeParameterCharacteristics }\n   [ GenericParameters ]\n   [ TypeMembers ]\n\nTypeMembers =\n  \"{\"\n  {\n    { DeclModifier }\n    ClassMemberDecl(allowConstructors: false,\n                    isValueType: true,\n                    moduleLevelDecl: false,\n                    isWithinAbstractModule: module.IsAbstract)\n  }\n  \"}\"\n\nSubsetTypeDecl_ =\n  \"type\"\n  { Attribute }\n  SynonymTypeName [ GenericParameters ]\n  \"=\"\n  LocalIdentTypeOptional\n  \"|\"\n  Expression(allowLemma: false, allowLambda: true)\n  [ \"ghost\" \"witness\" Expression(allowLemma: false, allowLambda: true)\n  | \"witness\" Expression((allowLemma: false, allowLambda: true)\n  | \"witness\" \"*\"\n  ]\n\nNatType_ = \"nat\"\n\nNewtypeDecl = \"newtype\" { Attribute } NewtypeName \"=\"\n  [ ellipsis ]\n  ( LocalIdentTypeOptional\n    \"|\"\n    Expression(allowLemma: false, allowLambda: true)\n    [ \"ghost\" \"witness\" Expression(allowLemma: false, allowLambda: true)\n    | \"witness\" Expression((allowLemma: false, allowLambda: true)\n    | \"witness\" \"*\"\n    ]\n  | Type\n  )\n  [ TypeMembers ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ClassDecl = \"class\" { Attribute } ClassName [ GenericParameters ]\n  [\"extends\" Type {\",\" Type} | ellipsis ]\n  \"{\" { { DeclModifier }\n        ClassMemberDecl(modifiers,\n                        allowConstructors: true,\n                        isValueType: false,\n                        moduleLevelDecl: false) \n      }\n  \"}\"\n\nClassMemberDecl(modifiers, allowConstructors, isValueType, moduleLevelDecl) =\n  ( FieldDecl(isValueType) // allowed iff moduleLevelDecl is false\n  | ConstantFieldDecl(moduleLevelDecl)\n  | FunctionDecl(isWithinAbstractModule)\n  | MethodDecl(modifiers, allowConstructors)\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "TraitDecl =\n  \"trait\" { Attribute } ClassName [ GenericParameters ]\n  [ \"extends\" Type { \",\" Type } | ellipsis ]\n  \"{\"\n   { { DeclModifier } ClassMemberDecl(allowConstructors: true,\n                                      isValueType: false,\n                                      moduleLevelDecl: false,\n                                      isWithinAbstractModule: false) }\n  \"}\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ObjectType_ = \"object\" | \"object?\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ArrayType_ = arrayToken [ GenericInstantiation ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "IteratorDecl = \"iterator\" { Attribute } IteratorName\n  ( [ GenericParameters ]\n    Formals(allowGhostKeyword: true, allowNewKeyword: false, \n                                     allowOlderKeyword: false)\n    [ \"yields\" Formals(allowGhostKeyword: true, allowNewKeyword: false, \n                                                allowOlderKeyword: false) ]\n  | ellipsis\n  )\n  IteratorSpec\n  [ BlockStmt ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ArrowType_ = ( DomainType_ \"~>\" Type\n             | DomainType_ \"-->\" Type\n             | DomainType_ \"->\" Type\n             )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "DatatypeDecl =\n  ( \"datatype\" | \"codatatype\" )\n  { Attribute }\n  DatatypeName [ GenericParameters ]\n  \"=\" \n  [ ellipsis ]\n  [ \"|\" ] DatatypeMemberDecl\n  { \"|\" DatatypeMemberDecl }\n  [ TypeMembers ]\n\nDatatypeMemberDecl =\n  { Attribute } DatatypeMemberName [ FormalsOptionalIds ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "FieldDecl(isValueType) =\n  \"var\" { Attribute } FIdentType { \",\" FIdentType }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ConstantFieldDecl(moduleLevelDecl) =\n  \"const\" { Attribute } CIdentType [ ellipsis ]\n   [ \":=\" Expression(allowLemma: false, allowLambda:true) ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "MethodDecl(isGhost, allowConstructors, isWithinAbstractModule) =\n  MethodKeyword_ { Attribute } [ MethodFunctionName ]\n  ( MethodSignature_(isGhost, isExtreme: true iff this is a least\n                                   or greatest lemma declaration)\n  | ellipsis\n  )\n  MethodSpec(isConstructor: true iff this is a constructor declaration)\n  [ BlockStmt ]\n\nMethodKeyword_ = ( \"method\"\n                 | \"constructor\"\n                 | \"lemma\"\n                 | \"twostate\" \"lemma\"\n                 | \"least\" \"lemma\"\n                 | \"greatest\" \"lemma\"\n                 )\n\n\nMethodSignature_(isGhost, isExtreme) =\n  [ GenericParameters ]\n  [ KType ]    // permitted only if isExtreme == true\n  Formals(allowGhostKeyword: !isGhost, allowNewKeyword: isTwostateLemma, \n          allowOlderKeyword: false, allowDefault: true)\n  [ \"returns\" Formals(allowGhostKeyword: !isGhost, allowNewKeyword: false, \n                      allowOlderKeyword: false, allowDefault: false) ]\n\nKType = \"[\" ( \"nat\" | \"ORDINAL\" ) \"]\"\n\nFormals(allowGhostKeyword, allowNewKeyword, allowOlderKeyword, allowDefault) =\n  \"(\" [ { Attribute } GIdentType(allowGhostKeyword, allowNewKeyword, allowOlderKeyword,\n                   allowNameOnlyKeyword: true, allowDefault)\n        { \",\" { Attribute } GIdentType(allowGhostKeyword, allowNewKeyword, allowOlderKeyword,\n                         allowNameOnlyKeyword: true, allowDefault) }\n      ]\n  \")\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "FunctionDecl(isWithinAbstractModule) =\n  ( [ \"twostate\" ] \"function\" [ \"method\" ] { Attribute }\n    MethodFunctionName\n    FunctionSignatureOrEllipsis_(allowGhostKeyword:\n                                           (\"method\" present),\n                                 allowNewKeyword:\n                                           \"twostate\" present)\n  | \"predicate\" [ \"method\" ] { Attribute }\n    MethodFunctionName\n    PredicateSignatureOrEllipsis_(allowGhostKeyword:\n                                           (\"method\" present),\n                                  allowNewKeyword:\n                                           \"twostate\" present,\n                                  allowOlderKeyword: true)\n  | ( \"least\" | \"greatest\" ) \"predicate\" { Attribute }\n    MethodFunctionName\n    PredicateSignatureOrEllipsis_(allowGhostKeyword: false,\n                         allowNewKeyword: \"twostate\" present,\n                         allowOlderKeyword: false))\n  )\n  FunctionSpec\n  [ FunctionBody ]\n\nFunctionSignatureOrEllipsis_(allowGhostKeyword) =\n  FunctionSignature_(allowGhostKeyword) | ellipsis\n\nFunctionSignature_(allowGhostKeyword, allowNewKeyword) =\n  [ GenericParameters ]\n  Formals(allowGhostKeyword, allowNewKeyword, allowOlderKeyword: true, \n          allowDefault: true)\n  \":\"\n  ( Type\n  | \"(\" GIdentType(allowGhostKeyword: false,\n                   allowNewKeyword: false,\n                   allowOlderKeyword: false,\n                   allowNameOnlyKeyword: false,\n                   allowDefault: false)\n    \")\"\n  )\n\nPredicateSignatureOrEllipsis_(allowGhostKeyword, allowNewKeyword, \n                              allowOlderKeyword) =\n    PredicateSignature_(allowGhostKeyword, allowNewKeyword, allowOlderKeyword) \n  | ellipsis\n\nPredicateSignature_(allowGhostKeyword, allowNewKeyword, allowOlderKeyword) =\n  [ GenericParameters ]\n  [ KType ]\n  Formals(allowGhostKeyword, allowNewKeyword, allowOlderKeyword, \n          allowDefault: true)\n  [\n    \":\"\n    ( Type\n    | \"(\" Ident \":\" \"bool\" \")\"\n    )\n  ]\n\nFunctionBody = \"{\" Expression(allowLemma: true, allowLambda: true)\n               \"}\" [ \"by\" \"method\" BlockStmt ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "MethodSpec =\n  { ModifiesClause(allowLambda: false)\n  | RequiresClause(allowLabel: true)\n  | EnsuresClause(allowLambda: false)\n  | DecreasesClause(allowWildcard: true, allowLambda: false)\n  }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "FunctionSpec =\n  { RequiresClause(allowLabel: true)\n  | ReadsClause(allowLemma: false, allowLambda: false, allowWild: true)\n  | EnsuresClause(allowLambda: false)\n  | DecreasesClause(allowWildcard: false, allowLambda: false)\n  }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "LambdaSpec =\n  { ReadsClause(allowLemma: true, allowLambda: false, allowWild: true)\n  | \"requires\" Expression(allowLemma: false, allowLambda: false)\n  }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "IteratorSpec =\n  { ReadsClause(allowLemma: false, allowLambda: false,\n                                  allowWild: false)\n  | ModifiesClause(allowLambda: false)\n  | [ \"yield\" ] RequiresClause(allowLabel: !isYield)\n  | [ \"yield\" ] EnsuresClause(allowLambda: false)\n  | DecreasesClause(allowWildcard: false, allowLambda: false)\n  }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "LoopSpec =\n  { InvariantClause_\n  | DecreasesClause(allowWildcard: true, allowLambda: true)\n  | ModifiesClause(allowLambda: true)\n  }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "RequiresClause(allowLabel) =\n  \"requires\" { Attribute }\n  [ LabelName \":\" ]  // Label allowed only if allowLabel is true\n  Expression(allowLemma: false, allowLambda: false)\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "EnsuresClause(allowLambda) =\n  \"ensures\" { Attribute } Expression(allowLemma: false, allowLambda)\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "DecreasesClause(allowWildcard, allowLambda) =\n  \"decreases\" { Attribute } DecreasesList(allowWildcard, allowLambda)\n\nDecreasesList(allowWildcard, allowLambda) =\n  PossiblyWildExpression(allowLambda, allowWildcard)\n  { \",\" PossiblyWildExpression(allowLambda, allowWildcard) }\n\nPossiblyWildExpression(allowLambda, allowWild) =\n  ( \"*\"  // if allowWild is false, using '*' provokes an error\n  | Expression(allowLemma: false, allowLambda)\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ModifiesClause(allowLambda) =\n  \"modifies\" { Attribute }\n  FrameExpression(allowLemma: false, allowLambda)\n  { \",\" FrameExpression(allowLemma: false, allowLambda) }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "InvariantClause_ =\n  \"invariant\" { Attribute }\n  Expression(allowLemma: false, allowLambda: true)\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ReadsClause(allowLemma, allowLambda, allowWild) =\n  \"reads\" { Attribute }\n  PossiblyWildFrameExpression(allowLemma, allowLambda, allowWild)\n  { \",\" PossiblyWildFrameExpression(allowLemma, allowLambda, allowWild) }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "FrameExpression(allowLemma, allowLambda) =\n  ( Expression(allowLemma, allowLambda) [ FrameField ]\n  | FrameField\n  )\n\nFrameField = \"`\" IdentOrDigits\n\nPossiblyWildFrameExpression(allowLemma, allowLambda, allowWild) =\n  ( \"*\"  // error if !allowWild and '*'\n  | FrameExpression(allowLemma, allowLambda)\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "Stmt = { \"label\" LabelName \":\" } NonLabeledStmt\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "NonLabeledStmt =\n  ( AssertStmt | AssumeStmt | BlockStmt | BreakStmt\n  | CalcStmt | ExpectStmt | ForallStmt | IfStmt\n  | MatchStmt | ModifyStmt\n  | PrintStmt | ReturnStmt | RevealStmt\n  | UpdateStmt | UpdateFailureStmt\n  | VarDeclStatement | WhileStmt | ForLoopStmt | YieldStmt\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "BreakStmt =\n  ( \"break\" LabelName \";\"\n  | \"continue\" LabelName \";\"\n  | { \"break\" } \"break\" \";\"\n  | { \"break\" } \"continue\" \";\"\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "BlockStmt = \"{\" { Stmt } \"}\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ReturnStmt = \"return\" [ Rhs { \",\" Rhs } ] \";\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "YieldStmt = \"yield\" [ Rhs { \",\" Rhs } ] \";\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "UpdateStmt =\n  Lhs\n  ( {Attribute} \";\"\n  |\n    { \",\" Lhs }\n    ( \":=\" Rhs { \",\" Rhs }\n    | \":|\" [ \"assume\" ]\n               Expression(allowLemma: false, allowLambda: true)\n    )\n    \";\"\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "UpdateFailureStmt  =\n  [ Lhs { \",\" Lhs } ]\n  \":-\"\n  [ \"expect\"  | \"assert\" | \"assume\" ]\n  Expression(allowLemma: false, allowLambda: false)\n  { \",\" Rhs }\n  \";\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "VarDeclStatement =\n  [ \"ghost\" ] \"var\" { Attribute }\n  (\n    LocalIdentTypeOptional\n    { \",\" { Attribute } LocalIdentTypeOptional }\n    [ \":=\"\n      Rhs { \",\" Rhs }\n    | \":-\"\n      [ \"expect\" | \"assert\" | \"assume\" ]\n      Expression(allowLemma: false, allowLambda: false)\n      { \",\" Rhs }\n    | { Attribute }\n      \":|\"\n      [ \"assume\" ] Expression(allowLemma: false, allowLambda: true)\n    ]\n  |\n    CasePatternLocal\n    ( \":=\" | { Attribute } \":|\" )\n    Expression(allowLemma: false, allowLambda: true)\n  )\n  \";\"\n\nCasePatternLocal = \n  ( [ Ident ] \"(\" CasePatternLocal { \",\" CasePatternLocal } \")\"\n  | LocalIdentTypeOptional\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "Guard = ( \"*\"\n        | \"(\" \"*\" \")\"\n        | Expression(allowLemma: true, allowLambda: true)\n        )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "BindingGuard(allowLambda) =\n  IdentTypeOptional { \",\" IdentTypeOptional }\n  { Attribute }\n  \":|\"\n  Expression(allowLemma: true, allowLambda)\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "IfStmt = \"if\"\n  ( AlternativeBlock(allowBindingGuards: true)\n  |\n    ( BindingGuard(allowLambda: true)\n    | Guard\n    )\n    BlockStmt [ \"else\" ( IfStmt | BlockStmt ) ]\n  )\n\nAlternativeBlock(allowBindingGuards) =\n  ( { AlternativeBlockCase(allowBindingGuards) }\n  | \"{\" { AlternativeBlockCase(allowBindingGuards) } \"}\"\n  )\n\nAlternativeBlockCase(allowBindingGuards) =\n  { \"case\"\n    (\n    BindingGuard(allowLambda: false) //permitted iff allowBindingGuards == true\n    | Expression(allowLemma: true, allowLambda: false)\n    ) \"=>\" { Stmt }\n  }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "WhileStmt =\n  \"while\"\n  ( LoopSpec\n    AlternativeBlock(allowBindingGuards: false)\n  | Guard\n    LoopSpec\n    ( BlockStmt\n    |           // no body\n    )\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ForLoopStmt =\n  \"for\" IdentTypeOptional \":=\"\n  Expression(allowLemma: false, allowLambda: false)\n  ( \"to\" | \"downto\" )\n  ( \"*\" | Expression(allowLemma: false, allowLambda: false)\n  )\n  LoopSpec\n  ( BlockStmt\n  |           // no body\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "MatchStmt =\n  \"match\"\n  Expression(allowLemma: true, allowLambda: true)\n  ( \"{\" { CaseStmt } \"}\"\n  | { CaseStmt }\n  )\n\nCaseStmt = \"case\" ExtendedPattern \"=>\" { Stmt }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "AssertStmt =\n  \"assert\"\n  { Attribute }\n  [ LabelName \":\" ]\n  Expression(allowLemma: false, allowLambda: true)\n  ( \";\"\n  | \"by\" BlockStmt\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "AssumeStmt =\n  \"assume\"\n  { Attribute }\n  Expression(allowLemma: false, allowLambda: true)\n  \";\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ExpectStmt =\n  \"expect\"\n  { Attribute }\n  Expression(allowLemma: false, allowLambda: true)\n  [ \",\" Expression(allowLemma: false, allowLambda: true) ]\n  \";\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "PrintStmt =\n  \"print\"\n  Expression(allowLemma: false, allowLambda: true)\n  { \",\" Expression(allowLemma: false, allowLambda: true) }\n  \";\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "RevealStmt =\n  \"reveal\"\n  Expression(allowLemma: false, allowLambda: true)\n  { \",\" Expression(allowLemma: false, allowLambda: true) }\n  \";\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ForallStmt =\n  \"forall\"\n  ( \"(\" [ QuantifierDomain ] \")\"\n  | [ QuantifierDomain ]\n  )\n  { EnsuresClause(allowLambda: true) }\n  [ BlockStmt ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ModifyStmt =\n  \"modify\"\n  { Attribute }\n  FrameExpression(allowLemma: false, allowLambda: true)\n  { \",\" FrameExpression(allowLemma: false, allowLambda: true) }\n  \";\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "CalcStmt = \"calc\" { Attribute } [ CalcOp ] \"{\" CalcBody_ \"}\"\n\nCalcBody_ = { CalcLine_ [ CalcOp ] Hints_ }\n\nCalcLine_ = Expression(allowLemma: false, allowLambda: true) \";\"\n\nHints_ = { ( BlockStmt | CalcStmt ) }\n\nCalcOp =\n  ( \"==\" [ \"#\" \"[\"\n           Expression(allowLemma: true, allowLambda: true) \"]\" ]\n  | \"<\" | \">\"\n  | \"!=\" | \"<=\" | \">=\"\n  | \"<==>\" | \"==>\" | \"<==\"\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "OpaqueBlock = \"opaque\" OpaqueSpec BlockStmt\n  \nOpaqueSpec = {\n  | ModifiesClause(allowLambda: false)\n  | EnsuresClause(allowLambda: false)\n}\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "Expression(allowLemma, allowLambda, allowBitwiseOps = true) =\n  EquivExpression(allowLemma, allowLambda, allowBitwiseOps)\n  [ \";\" Expression(allowLemma, allowLambda, allowBitwiseOps) ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "EquivExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  ImpliesExpliesExpression(allowLemma, allowLambda, allowBitwiseOps)\n  { \"<==>\" ImpliesExpliesExpression(allowLemma, allowLambda, allowBitwiseOps) }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ImpliesExpliesExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  LogicalExpression(allowLemma, allowLambda)\n  [ (  \"==>\" ImpliesExpression(allowLemma, allowLambda, allowBitwiseOps)\n    | \"<==\" LogicalExpression(allowLemma, allowLambda, allowBitwiseOps)\n            { \"<==\" LogicalExpression(allowLemma, allowLambda, allowBitwiseOps) }\n    )\n  ]\n\nImpliesExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  LogicalExpression(allowLemma, allowLambda, allowBitwiseOps)\n  [  \"==>\" ImpliesExpression(allowLemma, allowLambda, allowBitwiseOps) ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "LogicalExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  [ \"&&\" | \"||\" ]\n  RelationalExpression(allowLemma, allowLambda, allowBitwiseOps)\n  { ( \"&&\" | \"||\" )\n    RelationalExpression(allowLemma, allowLambda, allowBitwiseOps)\n  }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "RelationalExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  ShiftTerm(allowLemma, allowLambda, allowBitwiseOps)\n  { RelOp ShiftTerm(allowLemma, allowLambda, allowBitwiseOps) }\n\nRelOp =\n  ( \"==\"\n    [ \"#\" \"[\" Expression(allowLemma: true, allowLambda: true) \"]\" ]\n  | \"!=\"\n    [ \"#\" \"[\" Expression(allowLemma: true, allowLambda: true) \"]\" ]\n  | \"<\" | \">\" | \"<=\" | \">=\"\n  | \"in\"\n  | \"!in\"\n  | \"!!\"\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ShiftTerm(allowLemma, allowLambda, allowBitwiseOps) =\n  Term(allowLemma, allowLambda, allowBitwiseOps)\n  { ShiftOp Term(allowLemma, allowLambda, allowBitwiseOps) }\n\nShiftOp = ( \"<<\" | \">>\" )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "Term(allowLemma, allowLambda, allowBitwiseOps) =\n  Factor(allowLemma, allowLambda, allowBitwiseOps)\n  { AddOp Factor(allowLemma, allowLambda, allowBitwiseOps) }\n\nAddOp = ( \"+\" | \"-\" )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "Factor(allowLemma, allowLambda, allowBitwiseOps) =\n  BitvectorFactor(allowLemma, allowLambda, allowBitwiseOps)\n  { MulOp BitvectorFactor(allowLemma, allowLambda, allowBitwiseOps) }\n\nMulOp = ( \"*\" | \"/\" | \"%\" )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "BitvectorFactor(allowLemma, allowLambda, allowBitwiseOps) =\n  AsExpression(allowLemma, allowLambda, allowBitwiseOps)\n  { BVOp AsExpression(allowLemma, allowLambda, allowBitwiseOps) }\n\nBVOp = ( \"|\" | \"&\" | \"^\" )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "AsExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  UnaryExpression(allowLemma, allowLambda, allowBitwiseOps)\n  { ( \"as\" | \"is\" ) Type }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "UnaryExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  ( \"-\" UnaryExpression(allowLemma, allowLambda, allowBitwiseOps)\n  | \"!\" UnaryExpression(allowLemma, allowLambda, allowBitwiseOps)\n  | PrimaryExpression(allowLemma, allowLambda, allowBitwiseOps)\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "PrimaryExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  ( NameSegment { Suffix }\n  | LambdaExpression(allowLemma, allowBitwiseOps)\n  | MapDisplayExpr { Suffix }\n  | SeqDisplayExpr { Suffix }\n  | SetDisplayExpr { Suffix }\n  | EndlessExpression(allowLemma, allowLambda, allowBitwiseOps)\n  | ConstAtomExpression { Suffix }\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "LambdaExpression(allowLemma, allowBitwiseOps) =\n  ( WildIdent\n  | \"(\" [ IdentTypeOptional { \",\" IdentTypeOptional } ] \")\"\n  )\n  LambdaSpec\n  \"=>\"\n  Expression(allowLemma, allowLambda: true, allowBitwiseOps)\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "Lhs =\n  ( NameSegment { Suffix }\n  | ConstAtomExpression Suffix { Suffix }\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "Rhs =\n    ArrayAllocation\n  | ObjectAllocation_\n  | Expression(allowLemma: false, allowLambda: true, allowBitwiseOps: true)\n  | HavocRhs_\n  )\n  { Attribute }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ArrayAllocation_ =\n  \"new\" [ Type ] \"[\" [ Expressions ] \"]\"\n  [ \"(\" Expression(allowLemma: true, allowLambda: true) \")\"\n  | \"[\" [ Expressions ] \"]\"\n  ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ObjectAllocation_ = \"new\" Type [ \".\" TypeNameOrCtorSuffix ]\n                               [ \"(\" [ Bindings ] \")\" ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "HavocRhs_ = \"*\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ConstAtomExpression =\n  ( LiteralExpression\n  | ThisExpression_\n  | FreshExpression_\n  | AllocatedExpression_\n  | UnchangedExpression_\n  | OldExpression_\n  | CardinalityExpression_\n  | ParensExpression\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "LiteralExpression =\n ( \"false\" | \"true\" | \"null\" | Nat | Dec | ApproxLiteral |\n   charToken | stringToken )\n\nApproxLiteral = \"~\" [ \"-\" ] Dec\n\nNat = ( digits | hexdigits )\n\nDec = ( realnumber | digits \".\" | \".\" ( digits | realnumber ) )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ThisExpression_ = \"this\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "OldExpression_ =\n  \"old\" [ \"@\" LabelName ]\n  \"(\" Expression(allowLemma: true, allowLambda: true) \")\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "FreshExpression_ =\n  \"fresh\" [ \"@\" LabelName ]\n  \"(\" Expression(allowLemma: true, allowLambda: true) \")\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "AllocatedExpression_ =\n  \"allocated\" \"(\" Expression(allowLemma: true, allowLambda: true) \")\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "UnchangedExpression_ =\n  \"unchanged\" [ \"@\" LabelName ]\n  \"(\" FrameExpression(allowLemma: true, allowLambda: true)\n      { \",\" FrameExpression(allowLemma: true, allowLambda: true) }\n  \")\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "CardinalityExpression_ =\n  \"|\" Expression(allowLemma: true, allowLambda: true) \"|\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ParensExpression =\n  \"(\" [ TupleArgs ] \")\"\n\nTupleArgs =\n  [ \"ghost\" ]\n  ActualBinding(isGhost) // argument is true iff the ghost modifier is present\n  { \",\"\n    [ \"ghost\" ]\n    ActualBinding(isGhost) // argument is true iff the ghost modifier is present\n  }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "SeqDisplayExpr =\n  ( \"[\" [ Expressions ] \"]\"\n  | \"seq\" [ GenericInstantiation ]\n    \"(\" Expression(allowLemma: true, allowLambda: true)\n    \",\" Expression(allowLemma: true, allowLambda: true)\n    \")\"\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "SetDisplayExpr =\n  ( [ \"iset\" | \"multiset\" ] \"{\" [ Expressions ] \"}\"\n  | \"multiset\" \"(\" Expression(allowLemma: true,\n                              allowLambda: true) \")\"\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "MapDisplayExpr =\n  (\"map\" | \"imap\" ) \"[\" [ MapLiteralExpressions ] \"]\"\n\nMapLiteralExpressions =\n  Expression(allowLemma: true, allowLambda: true)\n  \":=\" \n  Expression(allowLemma: true, allowLambda: true)\n  { \",\" \n    Expression(allowLemma: true, allowLambda: true)\n    \":=\" \n    Expression(allowLemma: true, allowLambda: true)\n  }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "EndlessExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  ( IfExpression(allowLemma, allowLambda, allowBitwiseOps)\n  | MatchExpression(allowLemma, allowLambda, allowBitwiseOps)\n  | QuantifierExpression(allowLemma, allowLambda)\n  | SetComprehensionExpr(allowLemma, allowLambda, allowBitwiseOps)\n  | StmtInExpr\n    Expression(allowLemma, allowLambda, allowBitwiseOps)\n  | LetExpression(allowLemma, allowLambda, allowBitwiseOps)\n  | MapComprehensionExpr(allowLemma, allowLambda, allowBitwiseOps)\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "IfExpression(allowLemma, allowLambda, allowBitwiseOps) =\n    \"if\" ( BindingGuard(allowLambda: true)\n         | Expression(allowLemma: true, allowLambda: true, allowBitwiseOps: true)\n         )\n    \"then\" Expression(allowLemma: true, allowLambda: true, allowBitwiseOps: true)\n    \"else\" Expression(allowLemma, allowLambda, allowBitwiseOps)\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "MatchExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  \"match\"\n  Expression(allowLemma, allowLambda, allowBitwiseOps)\n  ( \"{\" { CaseExpression(allowLemma: true, allowLambda, allowBitwiseOps: true) } \"}\"\n  | { CaseExpression(allowLemma, allowLambda, allowBitwiseOps) }\n  )\n\nCaseExpression(allowLemma, allowLambda, allowBitwiseOps) =\n  \"case\" { Attribute } ExtendedPattern \"=>\" Expression(allowLemma, allowLambda, allowBitwiseOps)\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "CasePattern =\n  ( IdentTypeOptional\n  | [Ident] \"(\" [ CasePattern { \",\" CasePattern } ] \")\"\n  )\n\nSingleExtendedPattern =\n  ( PossiblyNegatedLiteralExpression\n  | IdentTypeOptional\n  | [ Ident ] \"(\" [ SingleExtendedPattern { \",\" SingleExtendedPattern } ] \")\"\n  )\n\nExtendedPattern =\n  ( [ \"|\" ] SingleExtendedPattern { \"|\" SingleExtendedPattern } )\n\nPossiblyNegatedLiteralExpression =\n  ( \"-\" ( Nat | Dec )\n  | LiteralExpression\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "QuantifierExpression(allowLemma, allowLambda) =\n  ( \"forall\" | \"exists\" ) QuantifierDomain \"::\"\n  Expression(allowLemma, allowLambda)\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "SetComprehensionExpr(allowLemma, allowLambda) =\n  [ \"set\" | \"iset\" ]\n  QuantifierDomain(allowLemma, allowLambda)\n  [ \"::\" Expression(allowLemma, allowLambda) ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "MapComprehensionExpr(allowLemma, allowLambda) =\n  ( \"map\" | \"imap\" )\n  QuantifierDomain(allowLemma, allowLambda)\n  \"::\"\n  Expression(allowLemma, allowLambda)\n  [ \":=\" Expression(allowLemma, allowLambda) ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "StmtInExpr = ( AssertStmt | AssumeStmt | ExpectStmt\n             | RevealStmt | CalcStmt | ForallStmt\n             )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "LetExpression(allowLemma, allowLambda) =\n  (\n    [ \"ghost\" ] \"var\" CasePattern { \",\" CasePattern }\n    ( \":=\" | \":-\" | { Attribute } \":|\" )\n    Expression(allowLemma: false, allowLambda: true)\n    { \",\" Expression(allowLemma: false, allowLambda: true) }\n  |\n    \":-\"\n    Expression(allowLemma: false, allowLambda: true)\n  )\n  \";\"\n  Expression(allowLemma, allowLambda)\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "NameSegment = Ident [ GenericInstantiation | HashCall ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "HashCall = \"#\" [ GenericInstantiation ]\n  \"[\" Expression(allowLemma: true, allowLambda: true) \"]\"\n  \"(\" [ Bindings ] \")\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "Suffix =\n  ( AugmentedDotSuffix_\n  | DatatypeUpdateSuffix_\n  | SubsequenceSuffix_\n  | SlicesByLengthSuffix_\n  | SequenceUpdateSuffix_\n  | SelectionSuffix_\n  | ArgumentListSuffix_\n  )\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "AugmentedDotSuffix_ = \".\" DotSuffix\n                      [ GenericInstantiation | HashCall ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "DatatypeUpdateSuffix_ =\n  \".\" \"(\" MemberBindingUpdate { \",\" MemberBindingUpdate } \")\"\n\nMemberBindingUpdate =\n  ( ident | digits )\n  \":=\" Expression(allowLemma: true, allowLambda: true)\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "SubsequenceSuffix_ =\n  \"[\" [ Expression(allowLemma: true, allowLambda: true) ]\n      \"..\" [ Expression(allowLemma: true, allowLambda: true) ]\n  \"]\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "SlicesByLengthSuffix_ =\n  \"[\" Expression(allowLemma: true, allowLambda: true) \":\"\n      [\n        Expression(allowLemma: true, allowLambda: true)\n        { \":\" Expression(allowLemma: true, allowLambda: true) }\n        [ \":\" ]\n      ]\n  \"]\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "SequenceUpdateSuffix_ =\n  \"[\" Expression(allowLemma: true, allowLambda: true)\n      \":=\" Expression(allowLemma: true, allowLambda: true)\n  \"]\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "SelectionSuffix_ =\n  \"[\" Expression(allowLemma: true, allowLambda: true)\n      { \",\" Expression(allowLemma: true, allowLambda: true) }\n  \"]\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ArgumentListSuffix_ = \"(\" [ Expressions ] \")\"\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "Expressions =\n  Expression(allowLemma: true, allowLambda: true)\n  { \",\" Expression(allowLemma: true, allowLambda: true) }\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "ActualBindings =\n  ActualBinding\n  { \",\" ActualBinding }\n\nActualBinding(isGhost = false) =\n  [ NoUSIdentOrDigits \":=\" ]\n  Expression(allowLemma: true, allowLambda: true)\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "QuantifierDomain(allowLemma, allowLambda) =\n  QuantifierVarDecl(allowLemma, allowLambda) \n  { \",\" QuantifierVarDecl(allowLemma, allowLambda) }\n\nQuantifierVarDecl(allowLemma, allowLambda) =\n  IdentTypeOptional\n  [ \"<-\" Expression(allowLemma, allowLambda) ]\n  { Attribute }\n  [ | Expression(allowLemma, allowLambda) ]\n",
        "description": null
      },
      {
        "language": "grammar",
        "code": "Ident = ident\n\nDotSuffix = ( ident | digits | \"requires\" | \"reads\" )\n\nNoUSIdent = ident - \"_\" { idchar }\n\nWildIdent = NoUSIdent | \"_\"\n\nIdentOrDigits = Ident | digits\nNoUSIdentOrDigits = NoUSIdent | digits\nModuleName = NoUSIdent\nClassName = NoUSIdent    // also traits\nDatatypeName = NoUSIdent\nDatatypeMemberName = NoUSIdentOrDigits\nNewtypeName = NoUSIdent\nSynonymTypeName = NoUSIdent\nIteratorName = NoUSIdent\nTypeVariableName = NoUSIdent\nMethodFunctionName = NoUSIdentOrDigits\nLabelName = NoUSIdentOrDigits\nAttributeName = NoUSIdent\nExportId = NoUSIdentOrDigits\nTypeNameOrCtorSuffix = NoUSIdentOrDigits\n\nModuleQualifiedName = ModuleName { \".\" ModuleName }\n\nIdentType = WildIdent \":\" Type\n\nFIdentType = NoUSIdentOrDigits \":\" Type\n\nCIdentType = NoUSIdentOrDigits [ \":\" Type ]\n\nGIdentType(allowGhostKeyword, allowNewKeyword, allowOlderKeyword, allowNameOnlyKeyword, allowDefault) =\n  { \"ghost\" | \"new\" | \"nameonly\" | \"older\" } IdentType\n  [ \":=\" Expression(allowLemma: true, allowLambda: true) ]\n\nLocalIdentTypeOptional = WildIdent [ \":\" Type ]\n\nIdentTypeOptional = WildIdent [ \":\" Type ]\n\nTypeIdentOptional =\n  { Attribute }\n  { \"ghost\" | \"nameonly\" } [ NoUSIdentOrDigits \":\" ] Type\n  [ \":=\" Expression(allowLemma: true, allowLambda: true) ]\n\nFormalsOptionalIds = \"(\" [ TypeIdentOptional\n                           { \",\" TypeIdentOptional } ] \")\"\n\n",
        "description": null
      },
      {
        "language": "text",
        "code": "integer literal:  10\nhex literal:      0xDEAD\nreal literal:     1.1\nboolean literal:  true false\nchar literal:     'c'\nstring literal:   \"abc\"\nverbatim string:  @\"abc\"\nident:            ijk\ntype:             int\ngeneric type:     map<int,T>\noperator:         <=\npunctuation:      { }\nkeyword:          while\nspec:             requires\ncomment:          // comment\nattribute         {: name }\nerror:            $\n",
        "description": null
      },
      {
        "language": "text",
        "code": "integer literal:  10\nhex literal:      0xDEAD\nreal literal:     1.1\nboolean literal:  true false\nchar literal:     'c'\nstring literal:   \"abc\"\nverbatim string:  @\"abc\"\nident:            ijk\ntype:             int\ngeneric type:     map<int,T>\noperator:         <=\npunctuation:      { }\nkeyword:          while\nspec:             requires\ncomment:          // comment\nattribute         {: name }\nerror:            $\n",
        "description": null
      },
      {
        "language": "text",
        "code": "integer: 0 00 20 01 0_1\nfloat:   .0 1.0 1. 0_1.1_0\nbad:    0_\nhex:    0x10_abcdefABCDEF\nstring:   \"string \\n \\t \\r \\0\" \"a\\\"b\" \"'\" \"\\'\" \"\"\nstring:   \"!@#$%^&*()_-+={}[]|:;\\\\<>,.?/~`\"\nstring:   \"\\u1234 \"\nstring:   \"     \" : \"\\0\\n\\r\\t\\'\\\"\\\\\"\nnotstring: \"abcde\nnotstring: \"\\u123 \" : \"x\\Zz\" : \"x\\ux\"\nvstring:  @\"\" @\"a\" @\"\"\"\" @\"'\\\" @\"\\u\"\nvstring:  @\"xx\"\"y y\"\"zz \"\nvstring:  @\" \" @\"       \"\nvstring:  @\"x\nx\"\nbad:      @!\nchar:    'a' '\\n' '\\'' '\"' '\\\"' ' ' '\\\\'\nchar:    '\\0' '\\r' '\\t'  '\\u1234'\nbadchar:  $ `\nids:  '\\u123'   '\\Z'  '\\u'  '\\u2222Z'\nids:  '\\u123ZZZ'     '\\u2222Z'\nids: 'a : a' : 'ab' :  'a'b' : 'a''b'\nids:  a_b _ab ab? _0\nid-label:  a@label\nliteral:  true false null\nop:      - ! ~ x  -!~x\nop:      a + b - c * d / e % f a+b-c*d/e%f\nop:      <= >= < > == != b&&c || ==> <==> <==\nop:      !=# !! in !in\nop:      !in∆  !iné\nnot op:  !inx\npunc:    . , :: | :| := ( ) [ ] { }\ntypes:   int real string char bool nat ORDINAL\ntypes:   object object?\ntypes:   bv1 bv10 bv0\ntypes:   array array2 array20 array10\ntypes:   array? array2? array20? array10?\nids:     array1 array0 array02 bv02 bv_1\nids:     intx natx int0 int_ int? bv1_ bv1x array2x\ntypes:   seq<int>  set < bool >\ntypes:   map<bool,bool>  imap < bool , bool >\ntypes:   seq<Node> seq< Node >\ntypes:   seq<set< real> >\ntypes:   map<set<int>,seq<bool>>\ntypes:   G<A,int> G<G<A>,G<bool>>\ntypes:   seq map imap set iset multiset\nids:     seqx mapx\nno arg:  seq < >  seq < , >  seq <bool , , bool >  seq<bool,>\nkeywords: if while assert assume\nspec:    requires  reads modifies\nattribute:  {: MyAttribute \"asd\", 34 }\nattribute:  {: MyAttribute }\ncomment:  // comment\ncomment:  /* comment */ after\ncomment:  // comment /* asd */ dfg\ncomment:  /* comment /* embedded */ tail */ after\ncomment:  /* comment // embedded */ after\ncomment: /* comment\n   /* inner comment\n   */\n   outer comment\n   */ after\n   more after\n",
        "description": null
      },
      {
        "language": "text",
        "code": "integer: 0 00 20 01 0_1\nfloat:   .0 1.0 1. 0_1.1_0\nbad:    0_\nhex:    0x10_abcdefABCDEF\nstring:   \"string \\n \\t \\r \\0\" \"a\\\"b\" \"'\" \"\\'\" \"\"\nstring:   \"!@#$%^&*()_-+={}[]|:;\\\\<>,.?/~`\"\nstring:   \"\\u1234 \"\nstring:   \"     \" : \"\\0\\n\\r\\t\\'\\\"\\\\\"\nnotstring: \"abcde\nnotstring: \"\\u123 \" : \"x\\Zz\" : \"x\\ux\"\nvstring:  @\"\" @\"a\" @\"\"\"\" @\"'\\\" @\"\\u\"\nvstring:  @\"xx\"\"y y\"\"zz \"\nvstring:  @\" \" @\"       \"\nvstring:  @\"x\nx\"\nbad:      @!\nchar:    'a' '\\n' '\\'' '\"' '\\\"' ' ' '\\\\'\nchar:    '\\0' '\\r' '\\t'  '\\u1234'\nbadchar:  $ `\nids:  '\\u123'   '\\Z'  '\\u'  '\\u2222Z'\nids:  '\\u123ZZZ'     '\\u2222Z'\nids: 'a : a' : 'ab' :  'a'b' : 'a''b'\nids:  a_b _ab ab? _0\nid-label:  a@label\nliteral:  true false null\nop:      - ! ~ x  -!~x\nop:      a + b - c * d / e % f a+b-c*d/e%f\nop:      <= >= < > == != b&&c || ==> <==> <==\nop:      !=# !! in !in\nop:      !in∆  !iné\nnot op:  !inx\npunc:    . , :: | :| := ( ) [ ] { }\ntypes:   int real string char bool nat ORDINAL\ntypes:   object object?\ntypes:   bv1 bv10 bv0\ntypes:   array array2 array20 array10\ntypes:   array? array2? array20? array10?\nids:     array1 array0 array02 bv02 bv_1\nids:     intx natx int0 int_ int? bv1_ bv1x array2x\ntypes:   seq<int>  set < bool >\ntypes:   map<bool,bool>  imap < bool , bool >\ntypes:   seq<Node> seq< Node >\ntypes:   seq<set< real> >\ntypes:   map<set<int>,seq<bool>>\ntypes:   G<A,int> G<G<A>,G<bool>>\ntypes:   seq map imap set iset multiset\nids:     seqx mapx\nno arg:  seq < >  seq < , >  seq <bool , , bool >  seq<bool,>\nkeywords: if while assert assume\nspec:    requires  reads modifies\nattribute:  {: MyAttribute \"asd\", 34 }\nattribute:  {: MyAttribute }\ncomment:  // comment\ncomment:  /* comment */ after\ncomment:  // comment /* asd */ dfg\ncomment:  /* comment /* embedded */ tail */ after\ncomment:  /* comment // embedded */ after\ncomment: /* comment\n   /* inner comment\n   */\n   outer comment\n   */ after\n   more after\n",
        "description": null
      }
    ],
    "original_format": "html",
    "word_count": 130463
  }
}