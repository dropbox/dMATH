{
  "id": "coq-1-",
  "source": "https://softwarefoundations.cis.upenn.edu/",
  "backend": "Coq",
  "title": "Software Foundations",
  "content": "**The Software Foundations series is a broad introduction to the mathematical\nunderpinnings of reliable software.**\n\nThe principal novelty of the series is that every detail is one hundred percent\nformalized and machine-checked: the entire text of each volume, including the\nexercises, is literally a \"proof script\" for the Coq proof assistant.\n\nThe exposition is intended for a broad range of readers, from advanced\nundergraduates to PhD students and researchers. No specific background in logic\nor programming languages is assumed, though a degree of mathematical maturity is\nhelpful. A one-semester course can expect to cover *Logical Foundations* plus\nmost of *Programming Language Foundations* or *Verified Functional Algorithms*,\nor selections from both.\n\n────────────────────────────────────────────────────────────────────────────────\nVolume 1                                                                        \n────────────────────────────────────────────────────────────────────────────────\n*Logical Foundations* is the entry-point to the series. It covers functional    \nprogramming, basic concepts of logic, computer-assisted theorem proving, and    \nCoq.                                                                            \n────────────────────────────────────────────────────────────────────────────────\n\n────────────────────────────────────────────────────────────────────────────────\nVolume 2                                                                        \n────────────────────────────────────────────────────────────────────────────────\n*Programming Language Foundations* surveys the theory of programming languages, \nincluding operational semantics, Hoare logic, and static type systems.          \n────────────────────────────────────────────────────────────────────────────────\n\n────────────────────────────────────────────────────────────────────────────────\nVolume 3                                                                        \n────────────────────────────────────────────────────────────────────────────────\n*Verified Functional Algorithms* shows how a variety of fundamental data        \nstructures can be specified and mechanically verified.                          \n                                                                                \n────────────────────────────────────────────────────────────────────────────────\n\n────────────────────────────────────────────────────────────────────────────────\nVolume 4                                                                        \n────────────────────────────────────────────────────────────────────────────────\n*QuickChick: Property-Based Testing in Coq* introduces tools for combining      \nrandomized property-based testing with formal specification and proof in the Coq\necosystem.                                                                      \n────────────────────────────────────────────────────────────────────────────────\n\n────────────────────────────────────────────────────────────────────────────────\nVolume 5                                                                        \n────────────────────────────────────────────────────────────────────────────────\n*Verifiable C* is an extended hands-on tutorial on specifying and verifying     \nreal-world C programs using the Princeton Verified Software Toolchain.          \n                                                                                \n────────────────────────────────────────────────────────────────────────────────\n\n────────────────────────────────────────────────────────────────────────────────\nVolume 6                                                                        \n────────────────────────────────────────────────────────────────────────────────\n*Separation Logic Foundations* is an in-depth introduction to separation logic—a\npractical approach to modular verification of imperative programs—and how to    \nbuild program verification tools on top of it.                                  \n                                                                                \n────────────────────────────────────────────────────────────────────────────────\n",
  "content_type": "Tutorial",
  "fetched_at": "2025-12-19T17:31:38.388573Z",
  "metadata": {
    "sections": [],
    "tags": [],
    "code_blocks": [],
    "original_format": "html",
    "word_count": 265
  }
}