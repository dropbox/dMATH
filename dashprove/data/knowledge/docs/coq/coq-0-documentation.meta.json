{
  "id": "coq-0-documentation",
  "source": "https://coq.inria.fr/documentation",
  "backend": "Coq",
  "title": "Learn Rocq",
  "content": "* [ Learn ][1]\n* Overview Platform Docs Supporting tools Exercises Books Papers ▾\n[ Overview ][2] [ Platform Docs ][3] [ Supporting tools ][4] [ Exercises ][5] [\nBooks ][6] [ Papers ][7]\n\n# Explore the Rocq Documentation\n\nYou can explore the Rocq & Rocq Platform packages documentation, guides,\nexercises, and books to enhance your knowledge.\nSearch inside the Rocq documentation\n[\n\nInstall Rocq Platform 2025.01.0\n\n][8] [\n\nRocq Reference Manual\n\n][9] [\n\nRocq Corelib Theories\n\n][10] [\n\nRocq OCaml API\n\n][11] [\n\nRocq Stdlib Manual\n\n][12] [\n\nRocq Stdlib Theories\n\n][13]\n[ Jump to Beginner Section ][14] [ Jump to Intermediate Section ][15] [ Jump to\nAdvanced Section ][16]\n\n## FOUNDATIONS FOR BEGINNERS\n\nGET STARTED\n\n## Introduction To Rocq\n\nInstall Rocq and gain a high-level understanding of the language\n\n* [ Installing the Rocq Prover ][17]\n* [ A Tour of Rocq ][18]\nDocumentation\n\n## The Rocq Prover\n\nAn in-depth explanation of language features and data structures from the\nStandard Library\n\n* [ Rocq Platform Docs ][19]\nRECOMMENDED BOOK\n\n## Software Foundations: Logical Foundations (Volume 1)\n\n[\nFREE\n][20]\nBeginner\n\nFor newcomers interested in programming languages, the Software Foundations\nseries is an excellent introduction to using the Rocq Prover for formal\nverification.\n\n[Read Online ][21]\n[ See More Books ][22]\nRECOMMENDED BOOK\n\n## Mathematical Components\n\n[\nFREE\n][23]\nBeginner\n\nFor newcomers with a background in mathematics rather than computer science,\nthis book is an introduction to the Rocq Prover and to the SSReflect proof\nlanguage used in the Mathematical Components library. Accustomed Rocq users will\nfind a substantial account of the formalization style that made the Mathematical\nComponents library possible.\n\n[Read Online ][24]\n[ See More Books ][25]\nRECOMMENDED BOOK\n\n## Programs and Proofs: Mechanizing Mathematics with Dependent Types\n\n[\nFREE\n][26]\nBeginner\n\nThe primary audience of the manuscript are the readers with expertise in\nsoftware development and programming and knowledge of discrete mathematic\ndisciplines on the level of an undergraduate university program. The high-level\ngoal of the course is, therefore, to demonstrate how much the rigorous\nmathematical reasoning and development of robust and intellectually manageable\nprograms have in common, and how understanding of common programming language\nconcepts provides a solid background for building mathematical abstractions and\nproving theorems formally. The low-level goal of this course is to provide an\noverview of the Rocq Prover, taken in its both incarnations: as an expressive\nfunctional programming language with dependent types and as a proof assistant\nproviding support for mechanized interactive theorem proving.\n\n[Read Online ][27]\n[ See More Books ][28]\nRECOMMENDED BOOK\n\n## Coq'Art\n\n[\n][29]\nBeginner\n\nThis textbook is a foundational book that introduces readers to the Rocq Prover\nand its underlying formal system, the Calculus of Inductive Constructions (CIC).\nThe book provides a comprehensive guide to interactive theorem proving,\ncombining theory with practical applications. It covers key concepts such as\ninductive types, recursive functions, and proof construction, while offering\nnumerous examples and case studies, including the formalization of algorithms\nand mathematical proofs. Coq'Art serves as both an introduction for beginners\nand a reference for experts, making it an essential resource for anyone working\nwith Rocq or exploring formal methods.\n\n[Publisher's Book Website ][30] [Examples and Exercises ][31]\n[ See More Books ][32]\nPLATFORM TOOLS\n\n## The Rocq Platform\n\n[\n\n### opam\n\nOCaml's package manager for managing Rocq and libraries\n\nGet Started\n][33]\n[Go to Platform Tools Documentation][34]\n\n## EXPLORING THE INTERMEDIATE LEVEL\n\nRECOMMENDED BOOK\n\n## Software Foundations: Verified Functional Algorithms (Volume 3)\n\n[\nFREE\n][35]\nIntermediate\n\nVerified Functional Algorithms shows how a variety of fundamental data\nstructures can be specified and mechanically verified.\n\n[Read Online ][36]\n[ See More Books ][37]\nRECOMMENDED BOOK\n\n## Formal Reasoning About Programs\n\n[\nFREE\n][38]\nIntermediate\n\nFormal Reasoning About Programs (FRAP) is a book that provides a general\nintroduction to formal logical reasoning about the correctness of programs and\nto using Rocq for this purpose. The main narrative of FRAP presents standard\nprogram-proof ideas, without rigorous proofs. Matching Rocq code then show how\nto make it rigorous. Interleaved with that narrative, there are also other\nlectures' worth of material, for building up more practical background on Rocq\nitself.\n\n[Read Online ][39] [Source Code ][40]\n[ See More Books ][41]\n[\nGUIDE\n\n## Reference Manual\n\nThe reference manual is the authoritative source of documentation for the Rocq\nProver. It contains a changelog describing updates to Rocq, which we recommend\nyou read when you upgrade.\n\nTake Me There\n][42]\n\n## ADVANCED LEVEL\n\nRECOMMENDED BOOK\n\n## Certified Programming with Dependent Types\n\n[\nFREE\n][43]\nAdvanced\n\nCertified Programming with Dependent Types (CPDT) is a hands-on guide to\nadvanced programming and proving using the Rocq Prover. The book focuses on\nleveraging Roqc’s dependent type system to write certified programs, where\ncorrectness is formally verified alongside implementation. It introduces key\nconcepts such as inductive types, type theory, proof automation, and advanced\ntactics, providing a blend of theoretical foundations and practical examples.\nCPDT is particularly known for its focus on proof engineering and building\nlarge-scale verified systems efficiently. Aimed at readers with some prior\nexposure to Rocq, it serves as an invaluable resource for those looking to\nmaster the interplay between programming and formal verification.\n\n[Read Online ][44]\n[ See More Books ][45]\nRECOMMENDED BOOK\n\n## Computer Arithmetic and Formal Proofs: Verifying Floating-point Algorithms\n## with the Coq System\n\n[\n][46]\nAdvanced\n\nFloating-point arithmetic is ubiquitous in modern computing, as it is the tool\nof choice to approximate real numbers. Due to its limited range and precision,\nits use can become quite involved and potentially lead to numerous failures. One\nway to greatly increase confidence in floating-point software is by\ncomputer-assisted verification of its correctness proofs. This book provides a\ncomprehensive view of how to formally specify and verify tricky floating-point\nalgorithms with the Coq proof assistant. It describes the Flocq formalization of\nfloating-point arithmetic and some methods to automate theorem proofs. It then\npresents the specification and verification of various algorithms, from\nerror-free transformations to a numerical scheme for a partial differential\nequation. The examples cover not only mathematical algorithms but also C\nprograms as well as issues related to compilation.\n\n[Publisher's Book Website ][47]\n[ See More Books ][48]\n\n### Papers\n\nAspiring towards greater understanding of Rocq and its underlying theory? Check\nout papers written by Rocq researchers:\n[\nCorrect and Complete Type Checking and Certified Erasure for Coq, in Coq\nCoq is built around a well-delimited kernel that performs type checking for\ndefinitions in a variant of the Calculus of Inductive Constructions (CIC).\nAlthough the metatheory of CIC is very stable and reliable, the correctness of\nits implementation in Coq is less clear. Indeed, implementing an efficient type\nchecker for CIC is a rather complex task, and many parts of the code rely on\nimplicit invariants which can easily be broken by further evolution of the code.\nTherefore, on average, one critical bug has been found every year in Coq. This\npaper presents the first implementation of a type checker for the kernel of Coq\n(without the module system, template polymorphism and η-conversion), which is\nproven sound and complete in Coq with respect to its formal specification. Note\nthat because of Gödel’s second incompleteness theorem, there is no hope to prove\ncompletely the soundness of the specification of Coq inside Coq (in particular\nstrong normalization), but it is possible to prove the correctness and\ncompleteness of the implementation assuming soundness of the specification, thus\nmoving from a trusted code base (TCB) to a trusted theory base (TTB) paradigm.\nOur work is based on the MetaCoq project which provides meta-programming\nfacilities to work with terms and declarations at the level of the kernel. We\nverify a relatively efficient type checker based on the specification of the\ntyping relation of the Polymorphic, Cumulative Calculus of Inductive\nConstructions (PCUIC) at the basis of Coq. It is worth mentioning that during\nthe verification process, we have found a source of incompleteness in Coq’s\nofficial type checker, which has then been fixed in Coq 8.14 thanks to our work.\nIn addition to the kernel implementation, another essential feature of Coq is\nthe so-called extraction mechanism: the production of executable code in\nfunctional languages from Coq definitions. We present a verified version of this\nsubtle type and proof erasure step, therefore enabling the verified extraction\nof a safe type checker for Coq in the future.\nMatthieu Sozeau, Yannick Forster, Meven Lennon-Bertrand, Jakob Botsch Nielsen,\nNicolas Tabareau, Théo Winterhalter\nTheory and Implementation of Rocq\nJACM\ntype-checker\n][49] [\nThe Coq Proof Assistant Version 8.20.0\nCoq version 8.20 adds a new rewrite rule mechanism along with a few new\nfeatures, a host of improvements to the virtual machine, the notation system,\nLtac2 and the standard library.\nYves Bertot, Frédéric Besson, Ana Borges, Ali Caglayan, Tej Chajed, Cyril Cohen,\nPierre Corbineau, Pierre Courtieu, Andres Erbsen, Jim Fehrle, Julien Forest,\nEmilio Jesús Gallego Arias, Gaëtan Gilbert, Georges Gonthier, Benjamin Grégoire,\nJason Gross, Hugo Herbelin, Vincent Laporte, Olivier Laurent, Assia Mahboubi,\nKenji Maillard, Erik Martin-Dorel, Guillaume Melquiond, Pierre-Marie Pédrot,\nClément Pit-Claudel, Pierre Roux, Kazuhiko Sakaguchi, Vincent Semeria, Michael\nSoegtrop, Matthieu Sozeau, Arnaud Spiwack, Nicolas Tabareau, Enrico Tassi,\nLaurent Théry, Anton Trunov, Xia Li-yao, Théo Zimmermann\nTheory and Implementation of Rocq\nRelease\n][50] [\nTrocq: Proof Transfer for Free, With or Without Univalence\nIn interactive theorem proving, a range of different representations may be\navailable for a single mathematical concept, and some proofs may rely on several\nrepresentations. Without automated support such as proof transfer, theorems\navailable with different representations cannot be combined, without light to\nmajor manual input from the user. Tools with such a purpose exist, but in proof\nassistants based on dependent type theory, it still requires human effort to\nprove transfer, whereas it is obvious and often left implicit on paper. This\npaper presents Trocq, a new proof transfer framework, based on a generalization\nof the univalent parametricity translation, thanks to a new formulation of type\nequivalence. This translation takes care to avoid dependency on the axiom of\nunivalence for transfers in a delimited class of statements, and may be used\nwith relations that are not necessarily isomorphisms. We motivate and apply our\nframework on a set of examples designed to show that it unifies several existing\nproof transfer tools. The article also discusses an implementation of this\ntranslation for the Coq proof assistant, in the Coq-Elpi metalanguage.\nCyril Cohen, Enzo Crance, Assia Mahboubi\nTheory and Implementation of Rocq\nESOP\nProof Transfer\n][51] [\nVerified Extraction from Coq to OCaml\nOne of the central claims of fame of the Coq proof assistant is extraction,\ni.e., the ability to obtain efficient programs in industrial programming\nlanguages such as OCaml, Haskell, or Scheme from programs written in Coq's\nexpressive dependent type theory. Extraction is of great practical usefulness,\nused crucially e.g., in the CompCert project. However, for such executables\nobtained by extraction, the extraction process is part of the trusted code base\n(TCB), as are Coq's kernel and the compiler used to compile the extracted code.\nThe extraction process contains intricate semantic transformation of programs\nthat rely on subtle operational features of both the source and target language.\nIts code has also evolved since the last theoretical exposition in the seminal\nPhD thesis of Pierre Letouzey. Furthermore, while the exact correctness\nstatements for the execution of extracted code are described clearly in academic\nliterature, the interoperability with unverified code has never been\ninvestigated formally, and yet is used in virtually every project relying on\nextraction. In this paper, we describe the development of a novel extraction\npipeline from Coq to OCaml, implemented and verified in Coq itself, with a clear\ncorrectness theorem and guarantees for safe interoperability. We build our work\non the MetaCoq project, which aims at decreasing the TCB of Coq's kernel by\nreimplementing it in Coq itself and proving it correct w.r.t. a formal\nspecification of Coq's type theory in Coq. Since OCaml does not have a formal\nspecification, we make use of the Malfunction project specifying the semantics\nof the intermediate language of the OCaml compiler. Our work fills some gaps in\nthe literature and highlights important differences between the operational\nsemantics of Coq programs and their extracted variants. In particular, we focus\non the guarantees that can be provided for interoperability with unverified\ncode, identify guarantees that are infeasible to provide, and raise interesting\nopen question regarding semantic guarantees that could be provided. As central\nresult, we prove that extracted programs of first-order data type are correct\nand can safely interoperate, whereas for higher-order programs already simple\ninteroperations can lead to incorrect behaviour and even outright segfaults.\nYannick Forster, Matthieu Sozeau, Nicolas Tabareau\nTheory and Implementation of Rocq\nPLDI\nextraction\n][52]\n[ View all papers ][53]\n\n[1]: /docs\n[2]: /docs\n[3]: /docs/platform-docs\n[4]: /docs/tools\n[5]: /exercises\n[6]: /books\n[7]: /papers\n[8]: /install\n[9]: /refman\n[10]: /corelib\n[11]: /api\n[12]: /refman-stdlib\n[13]: /stdlib\n[14]: #beginner_section\n[15]: #intermediate_section\n[16]: #advanced_section\n[17]: /install\n[18]: /docs/tour-of-rocq\n[19]: /docs/platform-docs\n[20]: https://softwarefoundations.cis.upenn.edu/\n[21]: https://softwarefoundations.cis.upenn.edu/\n[22]: /books\n[23]: https://math-comp.github.io/mcb/\n[24]: https://math-comp.github.io/mcb/\n[25]: /books\n[26]: https://ilyasergey.net/pnp/\n[27]: https://ilyasergey.net/pnp/\n[28]: /books\n[29]: https://doi.org/10.1007/978-3-662-07964-5\n[30]: https://doi.org/10.1007/978-3-662-07964-5\n[31]: https://rocq-community.org/coq-art\n[32]: /books\n[33]: https://opam.ocaml.org\n[34]: /docs/platform-docs\n[35]: https://softwarefoundations.cis.upenn.edu/\n[36]: https://softwarefoundations.cis.upenn.edu/\n[37]: /books\n[38]: http://adam.chlipala.net/frap/\n[39]: http://adam.chlipala.net/frap/\n[40]: https://github.com/achlipala/frap\n[41]: /books\n[42]: /refman\n[43]: http://adam.chlipala.net/cpdt/\n[44]: http://adam.chlipala.net/cpdt/\n[45]: /books\n[46]: https://www.sciencedirect.com/book/9781785481123/computer-arithmetic-and-f\normal-proofs\n[47]: https://www.sciencedirect.com/book/9781785481123/computer-arithmetic-and-f\normal-proofs\n[48]: /books\n[49]: https://dl.acm.org/doi/10.1145/3706056\n[50]: https://zenodo.org/records/14542673\n[51]: https://inria.hal.science/hal-04177913v5\n[52]: https://dl.acm.org/doi/10.1145/3656379\n[53]: /papers\n",
  "content_type": "Reference",
  "fetched_at": "2025-12-19T17:31:37.627501Z",
  "metadata": {
    "sections": [
      "Explore the Rocq Documentation",
      "\n  FOUNDATIONS\n    FOR BEGINNERS\n  ",
      "Introduction To Rocq",
      "The Rocq Prover",
      "Software Foundations: Logical Foundations (Volume 1)",
      "Mathematical Components",
      "Programs and Proofs: Mechanizing Mathematics with Dependent Types",
      "Coq'Art",
      "The Rocq Platform",
      "\n    \n    opam\n  ",
      "\n    EXPLORING\n    THE INTERMEDIATE LEVEL\n  ",
      "Software Foundations: Verified Functional Algorithms (Volume 3) ",
      "Formal Reasoning About Programs",
      "\n        Reference Manual\n      ",
      "\n  ADVANCED\n      LEVEL\n  ",
      "Certified Programming with Dependent Types",
      "Computer Arithmetic and Formal Proofs: Verifying Floating-point Algorithms with the Coq System",
      "Papers",
      "Footer",
      "About Rocq",
      "Resources",
      "Ecosystem",
      "Policies"
    ],
    "tags": [],
    "code_blocks": [],
    "original_format": "html",
    "word_count": 2214
  }
}