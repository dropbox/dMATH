//! Coverage Statistics for Model Checking
//!
//! This module provides coverage tracking to help users understand which parts
//! of their specification were exercised during model checking.
//!
//! Coverage includes:
//! - **Action coverage**: Which disjuncts of Next generated transitions
//! - **Dead action detection**: Actions that never fired (potential spec issues)
//! - **Per-action statistics**: States and transitions per action

use std::collections::HashMap;
use tla_core::ast::{BoundVar, Expr, OperatorDef};
use tla_core::{Span, Spanned};

/// Coverage statistics for the entire model checking run
#[derive(Debug, Clone, Default)]
pub struct CoverageStats {
    /// Per-action coverage statistics (action name -> stats)
    pub actions: HashMap<String, ActionStats>,
    /// Order in which actions were detected (for display)
    pub action_order: Vec<String>,
    /// Total number of distinct states found
    pub total_states: usize,
    /// Total number of transitions explored
    pub total_transitions: usize,
}

impl CoverageStats {
    /// Create new empty coverage stats
    pub fn new() -> Self {
        Self::default()
    }

    /// Register an action (from Next analysis)
    pub fn register_action(&mut self, name: String) {
        if !self.actions.contains_key(&name) {
            self.actions
                .insert(name.clone(), ActionStats::new(name.clone()));
            self.action_order.push(name);
        }
    }

    /// Record that an action generated successors
    pub fn record_action(&mut self, action_name: &str, successor_count: usize) {
        if let Some(stats) = self.actions.get_mut(action_name) {
            stats.transitions += successor_count;
            if successor_count > 0 {
                stats.times_fired += 1;
            }
        }
    }

    /// Get list of dead actions (never fired)
    pub fn dead_actions(&self) -> Vec<&str> {
        self.action_order
            .iter()
            .filter(|name| {
                self.actions
                    .get(*name)
                    .map(|s| s.times_fired == 0)
                    .unwrap_or(false)
            })
            .map(|s| s.as_str())
            .collect()
    }

    /// Format coverage as a report string
    pub fn format_report(&self) -> String {
        let mut lines = Vec::new();
        lines.push("=== Coverage Report ===".to_string());
        lines.push(format!(
            "Total: {} distinct states, {} transitions",
            self.total_states, self.total_transitions
        ));
        lines.push(String::new());

        if self.action_order.is_empty() {
            lines.push("No actions detected.".to_string());
        } else {
            lines.push("Actions:".to_string());
            for name in &self.action_order {
                if let Some(stats) = self.actions.get(name) {
                    let status = if stats.times_fired == 0 {
                        " [DEAD]"
                    } else {
                        ""
                    };
                    lines.push(format!(
                        "  {}: {} transitions, fired {} times{}",
                        name, stats.transitions, stats.times_fired, status
                    ));
                }
            }

            let dead = self.dead_actions();
            if !dead.is_empty() {
                lines.push(String::new());
                lines.push(format!(
                    "WARNING: {} dead action(s) (never fired): {}",
                    dead.len(),
                    dead.join(", ")
                ));
            }
        }

        lines.join("\n")
    }
}

/// Statistics for a single action
#[derive(Debug, Clone)]
pub struct ActionStats {
    /// Action name (from operator name or generated)
    pub name: String,
    /// Number of transitions generated by this action
    pub transitions: usize,
    /// Number of times this action fired (had at least one successor)
    pub times_fired: usize,
}

impl ActionStats {
    /// Create new stats for an action
    pub fn new(name: String) -> Self {
        Self {
            name,
            transitions: 0,
            times_fired: 0,
        }
    }
}

/// Detected action from Next relation analysis
#[derive(Debug, Clone)]
pub struct DetectedAction {
    /// Name of the action
    pub name: String,
    /// The expression for this action (disjunct of Next)
    pub expr: Spanned<Expr>,
}

/// Analyze the Next relation to detect top-level action disjuncts
///
/// Looks for patterns like:
/// - `Action1 \/ Action2 \/ Action3`
/// - `\E p \in S : action(p)`
/// - Named operator references
///
/// Returns list of detected actions with their names and expressions.
pub fn detect_actions(next_def: &OperatorDef) -> Vec<DetectedAction> {
    let mut actions = Vec::new();
    let mut counter = 0;
    let ctx = ActionContext::default();
    detect_actions_rec(&next_def.body, &ctx, &mut actions, &mut counter);
    actions
}

#[derive(Debug, Clone, Default)]
struct ActionContext {
    exists: Vec<Vec<BoundVar>>,
    guards: Vec<Spanned<Expr>>,
}

fn detect_actions_rec(
    expr: &Spanned<Expr>,
    ctx: &ActionContext,
    actions: &mut Vec<DetectedAction>,
    counter: &mut usize,
) {
    match &expr.node {
        // Disjunction: each branch is a separate action
        Expr::Or(a, b) => {
            detect_actions_rec(a, ctx, actions, counter);
            detect_actions_rec(b, ctx, actions, counter);
        }

        Expr::Exists(_bounds, body) => {
            // Preserve the EXISTS context so each detected action remains well-scoped.
            // For: \E p \in S : action1(p) \/ action2(p)
            // we produce:
            //   \E p \in S : action1(p)
            //   \E p \in S : action2(p)
            let mut next_ctx = ctx.clone();
            next_ctx.exists.push(_bounds.clone());
            detect_actions_rec(body, &next_ctx, actions, counter);
        }

        // IF expression - each branch is a different action, guarded by the condition.
        Expr::If(cond, then_branch, else_branch) => {
            let cond_expr = (**cond).clone();

            // THEN branch: cond /\ action
            let mut then_ctx = ctx.clone();
            then_ctx.guards.push(cond_expr.clone());
            detect_actions_rec(then_branch, &then_ctx, actions, counter);

            // ELSE branch: ~cond /\ action
            let mut else_ctx = ctx.clone();
            let not_cond = Spanned::new(Expr::Not(Box::new(cond_expr.clone())), cond_expr.span);
            else_ctx.guards.push(not_cond);
            detect_actions_rec(else_branch, &else_ctx, actions, counter);
        }

        // Named operator reference - this is an action
        Expr::Ident(name) => {
            actions.push(DetectedAction {
                name: name.clone(),
                expr: apply_action_context(expr.clone(), ctx),
            });
        }

        // Applied operator - use the operator name as action name
        Expr::Apply(op, _args) => {
            let name = extract_action_name_from_expr(&op.node).unwrap_or_else(|| {
                *counter += 1;
                format!("Action_{}", counter)
            });
            actions.push(DetectedAction {
                name,
                expr: apply_action_context(expr.clone(), ctx),
            });
        }

        // Module-qualified reference
        Expr::ModuleRef(module, op, _args) => {
            actions.push(DetectedAction {
                name: format!("{}!{}", module, op),
                expr: apply_action_context(expr.clone(), ctx),
            });
        }

        // Conjunction at top level - this is a single complex action
        Expr::And(_, _) => {
            // Try to extract a name from the conjunction
            let name = try_extract_name_from_conjunction(expr).unwrap_or_else(|| {
                *counter += 1;
                format!("Action_{}", counter)
            });
            actions.push(DetectedAction {
                name,
                expr: apply_action_context(expr.clone(), ctx),
            });
        }

        // Any other expression is treated as a single action
        _ => {
            *counter += 1;
            actions.push(DetectedAction {
                name: format!("Action_{}", counter),
                expr: apply_action_context(expr.clone(), ctx),
            });
        }
    }
}

fn apply_action_context(mut expr: Spanned<Expr>, ctx: &ActionContext) -> Spanned<Expr> {
    // Conjoin guards first (so they remain inside any EXISTS wrappers).
    for guard in &ctx.guards {
        let span = merged_span(guard.span, expr.span);
        expr = Spanned::new(Expr::And(Box::new(guard.clone()), Box::new(expr)), span);
    }

    // Wrap with EXISTS from inner to outer.
    for bounds in ctx.exists.iter().rev() {
        let span = expr.span;
        expr = Spanned::new(Expr::Exists(bounds.clone(), Box::new(expr)), span);
    }

    expr
}

fn merged_span(a: Span, b: Span) -> Span {
    if a.file == b.file {
        a.merge(b)
    } else {
        // Best-effort for synthesized expressions that combine multiple files/modules.
        Span::dummy()
    }
}

/// Extract action name from an expression (for Apply nodes)
fn extract_action_name_from_expr(expr: &Expr) -> Option<String> {
    match expr {
        Expr::Ident(name) => Some(name.clone()),
        _ => None,
    }
}

/// Try to extract a meaningful name from a conjunction (e.g., name from first conjunct)
fn try_extract_name_from_conjunction(expr: &Spanned<Expr>) -> Option<String> {
    match &expr.node {
        Expr::And(a, _b) => {
            // Try the left side first
            if let Some(name) = try_extract_name_from_conjunction(a) {
                return Some(name);
            }
            // Could try right side but usually left is the "name"
            None
        }
        Expr::Ident(name) => Some(name.clone()),
        Expr::Apply(op, _) => extract_action_name_from_expr(&op.node),
        _ => None,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tla_core::Span;

    #[test]
    fn test_coverage_stats_dead_actions() {
        let mut stats = CoverageStats::new();
        stats.register_action("Action1".to_string());
        stats.register_action("Action2".to_string());
        stats.register_action("Action3".to_string());

        // Action1 and Action3 fire, Action2 is dead
        stats.record_action("Action1", 5);
        stats.record_action("Action3", 2);

        let dead = stats.dead_actions();
        assert_eq!(dead, vec!["Action2"]);
    }

    #[test]
    fn test_coverage_stats_format() {
        let mut stats = CoverageStats::new();
        stats.total_states = 100;
        stats.total_transitions = 500;
        stats.register_action("Send".to_string());
        stats.register_action("Receive".to_string());
        stats.record_action("Send", 300);
        stats.record_action("Receive", 200);

        let report = stats.format_report();
        assert!(report.contains("100 distinct states"));
        assert!(report.contains("500 transitions"));
        assert!(report.contains("Send"));
        assert!(report.contains("Receive"));
    }

    #[test]
    fn test_coverage_with_dead_action() {
        let mut stats = CoverageStats::new();
        stats.register_action("Active".to_string());
        stats.register_action("NeverUsed".to_string());
        stats.record_action("Active", 10);

        let report = stats.format_report();
        assert!(report.contains("[DEAD]"));
        assert!(report.contains("NeverUsed"));
        assert!(report.contains("WARNING"));
    }

    fn sp(expr: Expr) -> Spanned<Expr> {
        Spanned::new(expr, Span::dummy())
    }

    #[test]
    fn test_detect_actions_preserves_exists_context() {
        let bounds = vec![BoundVar {
            name: Spanned::new("p".to_string(), Span::dummy()),
            domain: Some(Box::new(sp(Expr::Ident("S".to_string())))),
            pattern: None,
        }];

        let a = sp(Expr::Apply(
            Box::new(sp(Expr::Ident("A".to_string()))),
            vec![sp(Expr::Ident("p".to_string()))],
        ));
        let b = sp(Expr::Apply(
            Box::new(sp(Expr::Ident("B".to_string()))),
            vec![sp(Expr::Ident("p".to_string()))],
        ));

        let next_body = sp(Expr::Exists(
            bounds.clone(),
            Box::new(sp(Expr::Or(Box::new(a.clone()), Box::new(b.clone())))),
        ));

        let next_def = OperatorDef {
            name: Spanned::new("Next".to_string(), Span::dummy()),
            params: Vec::new(),
            body: next_body,
            local: false,
        };

        let actions = detect_actions(&next_def);
        assert_eq!(actions.len(), 2);
        assert_eq!(actions[0].name, "A");
        assert_eq!(actions[1].name, "B");

        for act in &actions {
            match &act.expr.node {
                Expr::Exists(ex_bounds, body) => {
                    assert_eq!(ex_bounds.len(), 1);
                    assert_eq!(ex_bounds[0].name.node, "p");
                    match &body.node {
                        Expr::Apply(_, _) => {}
                        other => panic!("expected Apply body, got {other:?}"),
                    }
                }
                other => panic!("expected Exists wrapper, got {other:?}"),
            }
        }
    }

    #[test]
    fn test_detect_actions_if_branches_get_guarded() {
        let cond = sp(Expr::Ident("c".to_string()));
        let then_branch = sp(Expr::Ident("A".to_string()));
        let else_branch = sp(Expr::Ident("B".to_string()));
        let next_body = sp(Expr::If(
            Box::new(cond.clone()),
            Box::new(then_branch),
            Box::new(else_branch),
        ));

        let next_def = OperatorDef {
            name: Spanned::new("Next".to_string(), Span::dummy()),
            params: Vec::new(),
            body: next_body,
            local: false,
        };

        let actions = detect_actions(&next_def);
        assert_eq!(actions.len(), 2);
        assert_eq!(actions[0].name, "A");
        assert_eq!(actions[1].name, "B");

        match &actions[0].expr.node {
            Expr::And(g, a) => {
                assert!(matches!(&g.node, Expr::Ident(name) if name == "c"));
                assert!(matches!(&a.node, Expr::Ident(name) if name == "A"));
            }
            other => panic!("expected And guard for THEN, got {other:?}"),
        }

        match &actions[1].expr.node {
            Expr::And(g, b) => match &g.node {
                Expr::Not(inner) => {
                    assert!(matches!(&inner.node, Expr::Ident(name) if name == "c"));
                    assert!(matches!(&b.node, Expr::Ident(name) if name == "B"));
                }
                other => panic!("expected Not(c) guard for ELSE, got {other:?}"),
            },
            other => panic!("expected And guard for ELSE, got {other:?}"),
        }
    }
}
