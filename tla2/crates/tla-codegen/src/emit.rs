//! Rust code emitter for TLA+ specifications
//!
//! This module generates Rust code from TLA+ modules. The generated code:
//! - Defines a state struct from TLA+ variables
//! - Implements the StateMachine trait
//! - Generates Init and Next actions
//! - Optionally generates Kani verification harnesses

use crate::types::{TlaType, TypeContext};
use std::collections::{HashMap, HashSet};
use std::fmt::Write;
use tla_core::ast::{
    BoundVar, CaseArm, ExceptPathElement, ExceptSpec, Expr, Module, OperatorDef, Substitution, Unit,
};
use tla_core::span::Spanned;

/// Represents a value in Init predicate analysis
#[derive(Debug, Clone)]
enum InitValue {
    /// Direct expression assignment: x = value
    Expr(Expr),
    /// Non-deterministic choice: x \in Set
    InSet(Expr),
}

/// Code generation options
#[derive(Debug, Clone, Default)]
pub struct CodeGenOptions {
    /// Module name for generated code (defaults to TLA+ module name)
    pub module_name: Option<String>,
    /// Generate proptest harnesses
    pub generate_proptest: bool,
    /// Generate Kani harnesses
    pub generate_kani: bool,
}

/// Generate Rust code from a TLA+ module
pub fn generate_rust(module: &Module, options: &CodeGenOptions) -> Result<String, String> {
    let mut ctx = TypeContext::new();
    let var_types = ctx.infer_module(module);

    let errors = ctx.take_errors();
    if !errors.is_empty() {
        let msgs: Vec<_> = errors.iter().map(|e| e.to_string()).collect();
        return Err(format!("Type inference errors:\n{}", msgs.join("\n")));
    }

    let op_defs: HashMap<String, OperatorDef> = module
        .units
        .iter()
        .filter_map(|unit| match &unit.node {
            Unit::Operator(op) => Some((op.name.node.clone(), op.clone())),
            _ => None,
        })
        .collect();

    let mut out = String::new();
    let emitter = RustEmitter::new(&mut out, &var_types, &op_defs);
    emitter.emit_module(module, options)?;
    Ok(out)
}

/// Rust code emitter
struct RustEmitter<'a> {
    out: &'a mut String,
    var_types: &'a std::collections::HashMap<String, TlaType>,
    op_defs: &'a HashMap<String, OperatorDef>,
    indent: usize,
}

impl<'a> RustEmitter<'a> {
    fn new(
        out: &'a mut String,
        var_types: &'a std::collections::HashMap<String, TlaType>,
        op_defs: &'a HashMap<String, OperatorDef>,
    ) -> Self {
        RustEmitter {
            out,
            var_types,
            op_defs,
            indent: 0,
        }
    }

    /// Write indentation
    fn write_indent(&mut self) {
        for _ in 0..self.indent {
            write!(self.out, "    ").unwrap();
        }
    }

    /// Write a line with current indentation
    fn writeln_indented(&mut self, s: &str) {
        self.write_indent();
        writeln!(self.out, "{}", s).unwrap();
    }

    fn emit_module(mut self, module: &Module, options: &CodeGenOptions) -> Result<(), String> {
        let mod_name = options
            .module_name
            .as_ref()
            .unwrap_or(&module.name.node)
            .clone();

        // Header
        writeln!(
            self.out,
            "//! Generated from TLA+ module: {}",
            module.name.node
        )
        .unwrap();
        writeln!(self.out, "//!").unwrap();
        writeln!(self.out, "//! This file was auto-generated by tla-codegen.").unwrap();
        writeln!(self.out, "//! Do not edit manually.").unwrap();
        writeln!(self.out).unwrap();
        writeln!(self.out, "#![allow(unused)]").unwrap();
        writeln!(self.out).unwrap();
        writeln!(self.out, "use tla_runtime::prelude::*;").unwrap();
        writeln!(self.out).unwrap();

        // Collect variables
        let mut variables: Vec<String> = Vec::new();
        for unit in &module.units {
            if let Unit::Variable(vars) = &unit.node {
                for var in vars {
                    variables.push(var.node.clone());
                }
            }
        }

        // Collect operators
        let mut init_op: Option<&OperatorDef> = None;
        let mut next_op: Option<&OperatorDef> = None;
        let mut invariants: Vec<&OperatorDef> = Vec::new();

        for unit in &module.units {
            if let Unit::Operator(op) = &unit.node {
                match op.name.node.as_str() {
                    "Init" => init_op = Some(op),
                    "Next" => next_op = Some(op),
                    name if name.starts_with("Inv") || name.ends_with("Invariant") => {
                        invariants.push(op);
                    }
                    _ => {}
                }
            }
        }

        // Generate state struct
        self.emit_state_struct(&mod_name, &variables)?;

        // Generate state machine implementation
        self.emit_state_machine(&mod_name, &variables, init_op, next_op, &invariants)?;

        // Generate tests if requested
        if options.generate_proptest {
            self.emit_proptest(&mod_name, &invariants)?;
        }

        // Generate Kani harnesses if requested
        if options.generate_kani {
            self.emit_kani_harness(&mod_name, &invariants)?;
        }

        Ok(())
    }

    fn emit_state_struct(&mut self, name: &str, variables: &[String]) -> Result<(), String> {
        writeln!(self.out, "/// State for {}", name).unwrap();
        writeln!(self.out, "#[derive(Clone, Debug, PartialEq, Eq, Hash)]").unwrap();
        writeln!(self.out, "pub struct {}State {{", to_pascal_case(name)).unwrap();

        for var in variables {
            let ty = self.var_types.get(var).cloned().unwrap_or(TlaType::Unknown);
            let rust_ty = if ty.is_resolved() {
                ty.to_rust_type()
            } else {
                "i64".to_string() // Default to i64 for unresolved
            };
            writeln!(self.out, "    pub {}: {},", to_snake_case(var), rust_ty).unwrap();
        }

        writeln!(self.out, "}}").unwrap();
        writeln!(self.out).unwrap();

        Ok(())
    }

    fn emit_state_machine(
        &mut self,
        name: &str,
        variables: &[String],
        init_op: Option<&OperatorDef>,
        next_op: Option<&OperatorDef>,
        invariants: &[&OperatorDef],
    ) -> Result<(), String> {
        let struct_name = to_pascal_case(name);

        writeln!(self.out, "/// State machine for {}", name).unwrap();
        writeln!(self.out, "pub struct {};", struct_name).unwrap();
        writeln!(self.out).unwrap();

        writeln!(self.out, "impl StateMachine for {} {{", struct_name).unwrap();
        writeln!(self.out, "    type State = {}State;", struct_name).unwrap();
        writeln!(self.out).unwrap();

        // Init
        writeln!(self.out, "    fn init(&self) -> Vec<Self::State> {{").unwrap();
        if let Some(init) = init_op {
            self.indent = 2;
            self.emit_init_body(&init.body, variables)?;
        } else {
            writeln!(self.out, "        vec![]").unwrap();
        }
        writeln!(self.out, "    }}").unwrap();
        writeln!(self.out).unwrap();

        // Next
        writeln!(
            self.out,
            "    fn next(&self, state: &Self::State) -> Vec<Self::State> {{"
        )
        .unwrap();
        if let Some(next) = next_op {
            self.indent = 2;
            self.emit_next_body(&next.body, variables)?;
        } else {
            writeln!(self.out, "        vec![]").unwrap();
        }
        writeln!(self.out, "    }}").unwrap();

        // Check invariant
        if !invariants.is_empty() {
            writeln!(self.out).unwrap();
            writeln!(
                self.out,
                "    fn check_invariant(&self, state: &Self::State) -> Option<bool> {{"
            )
            .unwrap();
            write!(self.out, "        Some(").unwrap();
            for (i, inv) in invariants.iter().enumerate() {
                if i > 0 {
                    write!(self.out, " && ").unwrap();
                }
                write!(
                    self.out,
                    "self.check_{}(state)",
                    to_snake_case(&inv.name.node)
                )
                .unwrap();
            }
            writeln!(self.out, ")").unwrap();
            writeln!(self.out, "    }}").unwrap();
        }

        writeln!(self.out, "}}").unwrap();
        writeln!(self.out).unwrap();

        // Helper methods for invariants
        if !invariants.is_empty() {
            writeln!(self.out, "impl {} {{", struct_name).unwrap();
            for inv in invariants {
                self.emit_invariant_method(inv, &struct_name)?;
            }
            writeln!(self.out, "}}").unwrap();
        }

        Ok(())
    }

    fn emit_init_body(&mut self, expr: &Spanned<Expr>, variables: &[String]) -> Result<(), String> {
        // Analyze Init predicate to extract initial state assignments
        // Common patterns:
        // 1. x = value /\ y = value  (conjunction of assignments)
        // 2. x \in Set (non-deterministic choice)

        let mut assignments = std::collections::HashMap::<String, InitValue>::new();
        let expanded = self.expand_operators(&expr.node);
        self.collect_init_assignments(&expanded, &mut assignments);

        // Check if we have all variables assigned
        let missing: Vec<_> = variables
            .iter()
            .filter(|v| !assignments.contains_key(*v))
            .collect();

        if !missing.is_empty() {
            // Fall back to placeholder if we can't determine all variables
            self.writeln_indented("// Could not infer initial values for all variables");
            self.writeln_indented(&format!("// Missing: {:?}", missing));
            self.writeln_indented("vec![]");
            return Ok(());
        }

        // Check for non-deterministic choices
        let has_choice: Vec<_> = assignments
            .iter()
            .filter(|(_, v)| matches!(v, InitValue::InSet(_)))
            .map(|(k, _)| k.clone())
            .collect();

        if has_choice.is_empty() {
            // Deterministic init - single state
            self.writeln_indented("vec![Self::State {");
            self.indent += 1;
            for var in variables {
                let rust_var = to_snake_case(var);
                if let Some(value) = assignments.get(var) {
                    let value_str = self.init_value_to_rust(value);
                    self.writeln_indented(&format!("{}: {},", rust_var, value_str));
                }
            }
            self.indent -= 1;
            self.writeln_indented("}]");
        } else {
            // Non-deterministic init - need to enumerate
            self.writeln_indented("let mut states = Vec::new();");

            // Generate nested loops for each non-deterministic variable
            self.emit_init_loops(variables, &assignments, &has_choice, 0)?;

            self.writeln_indented("states");
        }

        Ok(())
    }

    /// Collect variable assignments from Init predicate
    fn collect_init_assignments(
        &self,
        expr: &Expr,
        assignments: &mut std::collections::HashMap<String, InitValue>,
    ) {
        match expr {
            Expr::And(left, right) => {
                self.collect_init_assignments(&left.node, assignments);
                self.collect_init_assignments(&right.node, assignments);
            }
            Expr::Eq(left, right) => {
                // x = value
                if let Expr::Ident(name) = &left.node {
                    if self.var_types.contains_key(name) {
                        assignments.insert(name.clone(), InitValue::Expr(right.node.clone()));
                    }
                }
            }
            Expr::In(elem, set) => {
                // x \in Set (non-deterministic choice)
                if let Expr::Ident(name) = &elem.node {
                    if self.var_types.contains_key(name) {
                        assignments.insert(name.clone(), InitValue::InSet(set.node.clone()));
                    }
                }
            }
            _ => {}
        }
    }

    /// Convert an InitValue to Rust code
    fn init_value_to_rust(&self, value: &InitValue) -> String {
        match value {
            InitValue::Expr(e) => self.expr_to_rust(e),
            InitValue::InSet(e) => format!("/* choose from {} */", self.expr_to_rust(e)),
        }
    }

    /// Emit nested loops for non-deterministic init
    fn emit_init_loops(
        &mut self,
        variables: &[String],
        assignments: &std::collections::HashMap<String, InitValue>,
        choices: &[String],
        choice_idx: usize,
    ) -> Result<(), String> {
        if choice_idx >= choices.len() {
            // All loops emitted, now emit the state construction
            self.writeln_indented("states.push(Self::State {");
            self.indent += 1;
            for var in variables {
                let rust_var = to_snake_case(var);
                if choices.contains(var) {
                    // Use loop variable
                    self.writeln_indented(&format!("{}: {}.clone(),", rust_var, rust_var));
                } else if let Some(value) = assignments.get(var) {
                    let value_str = self.init_value_to_rust(value);
                    self.writeln_indented(&format!("{}: {},", rust_var, value_str));
                }
            }
            self.indent -= 1;
            self.writeln_indented("});");
        } else {
            let var = &choices[choice_idx];
            let rust_var = to_snake_case(var);
            if let Some(InitValue::InSet(set_expr)) = assignments.get(var) {
                let set_str = self.expr_to_rust(set_expr);
                self.writeln_indented(&format!("for {} in {} {{", rust_var, set_str));
                self.indent += 1;
                self.emit_init_loops(variables, assignments, choices, choice_idx + 1)?;
                self.indent -= 1;
                self.writeln_indented("}");
            }
        }
        Ok(())
    }

    fn emit_next_body(&mut self, expr: &Spanned<Expr>, variables: &[String]) -> Result<(), String> {
        // Analyze Next action to extract state transitions
        // Common patterns:
        // 1. A1 \/ A2 \/ A3 (disjunction of actions)
        // 2. x' = expr /\ y' = expr (primed variable assignments)
        // 3. UNCHANGED <<vars>> (unchanged variables)

        let expanded = self.expand_operators(&expr.node);
        let actions = Self::collect_actions(&expanded);

        if actions.is_empty() {
            self.writeln_indented("// Could not parse Next action");
            self.writeln_indented("vec![]");
            return Ok(());
        }

        self.writeln_indented("let mut next_states = Vec::new();");
        writeln!(self.out).unwrap();

        for (i, action) in actions.iter().enumerate() {
            self.writeln_indented(&format!("// Action {}", i + 1));
            self.emit_action(action, variables)?;
            writeln!(self.out).unwrap();
        }

        self.writeln_indented("next_states");
        Ok(())
    }

    /// Collect individual actions from a Next disjunction
    fn collect_actions(expr: &Expr) -> Vec<Expr> {
        match expr {
            Expr::Or(left, right) => {
                let mut actions = Self::collect_actions(&left.node);
                actions.extend(Self::collect_actions(&right.node));
                actions
            }
            _ => vec![expr.clone()],
        }
    }

    /// Emit code for a single action
    fn emit_action(&mut self, action: &Expr, variables: &[String]) -> Result<(), String> {
        // Collect primed assignments and guards from the action
        let mut primed_assigns = std::collections::HashMap::<String, Expr>::new();
        let mut unchanged: HashSet<String> = HashSet::new();
        let mut guards = Vec::new();

        Self::analyze_action(action, &mut primed_assigns, &mut unchanged, &mut guards);

        // Emit guard condition
        if !guards.is_empty() {
            let guard_str = guards
                .iter()
                .map(|g| self.expr_to_rust(g))
                .collect::<Vec<_>>()
                .join(" && ");
            self.writeln_indented(&format!("if {} {{", guard_str));
            self.indent += 1;
        }

        // Check for non-deterministic choices in assignments
        let choices: Vec<(String, Expr)> = primed_assigns
            .iter()
            .filter_map(|(var, expr)| {
                if let Expr::In(elem, set) = expr {
                    if matches!(&elem.node, Expr::Prime(_)) {
                        return Some((var.clone(), set.node.clone()));
                    }
                }
                None
            })
            .collect();

        if choices.is_empty() {
            // Deterministic action
            self.writeln_indented("next_states.push(Self::State {");
            self.indent += 1;
            for var in variables {
                let rust_var = to_snake_case(var);
                if let Some(expr) = primed_assigns.get(var) {
                    let value = self.primed_expr_to_rust(expr);
                    self.writeln_indented(&format!("{}: {},", rust_var, value));
                } else if unchanged.contains(var) {
                    self.writeln_indented(&format!("{}: state.{}.clone(),", rust_var, rust_var));
                } else {
                    // Assume unchanged if not mentioned
                    self.writeln_indented(&format!("{}: state.{}.clone(),", rust_var, rust_var));
                }
            }
            self.indent -= 1;
            self.writeln_indented("});");
        } else {
            // Non-deterministic - emit loops
            for (var, set_expr) in &choices {
                let rust_var = to_snake_case(var);
                let set_str = self.expr_to_rust(set_expr);
                self.writeln_indented(&format!("for {}_next in {} {{", rust_var, set_str));
                self.indent += 1;
            }

            self.writeln_indented("next_states.push(Self::State {");
            self.indent += 1;
            for var in variables {
                let rust_var = to_snake_case(var);
                if choices.iter().any(|(v, _)| v == var) {
                    self.writeln_indented(&format!("{}: {}_next.clone(),", rust_var, rust_var));
                } else if let Some(expr) = primed_assigns.get(var) {
                    let value = self.primed_expr_to_rust(expr);
                    self.writeln_indented(&format!("{}: {},", rust_var, value));
                } else {
                    self.writeln_indented(&format!("{}: state.{}.clone(),", rust_var, rust_var));
                }
            }
            self.indent -= 1;
            self.writeln_indented("});");

            for _ in &choices {
                self.indent -= 1;
                self.writeln_indented("}");
            }
        }

        if !guards.is_empty() {
            self.indent -= 1;
            self.writeln_indented("}");
        }

        Ok(())
    }

    /// Analyze an action to extract primed assignments, unchanged vars, and guards
    fn analyze_action(
        expr: &Expr,
        primed_assigns: &mut std::collections::HashMap<String, Expr>,
        unchanged: &mut HashSet<String>,
        guards: &mut Vec<Expr>,
    ) {
        match expr {
            Expr::And(left, right) => {
                Self::analyze_action(&left.node, primed_assigns, unchanged, guards);
                Self::analyze_action(&right.node, primed_assigns, unchanged, guards);
            }
            Expr::Eq(left, right) => {
                // x' = value
                if let Expr::Prime(inner) = &left.node {
                    if let Expr::Ident(name) = &inner.node {
                        primed_assigns.insert(name.clone(), right.node.clone());
                        return;
                    }
                }
                // Otherwise it's a guard
                guards.push(expr.clone());
            }
            Expr::In(elem, _set) => {
                // x' \in Set (non-deterministic)
                if let Expr::Prime(inner) = &elem.node {
                    if let Expr::Ident(name) = &inner.node {
                        primed_assigns.insert(name.clone(), expr.clone());
                        return;
                    }
                }
                // Otherwise it's a guard
                guards.push(expr.clone());
            }
            Expr::Unchanged(vars) => {
                // UNCHANGED <<x, y>>
                Self::collect_unchanged_vars(&vars.node, unchanged);
            }
            _ => {
                // Treat as a guard
                guards.push(expr.clone());
            }
        }
    }

    /// Collect variable names from UNCHANGED expression
    fn collect_unchanged_vars(expr: &Expr, unchanged: &mut HashSet<String>) {
        match expr {
            Expr::Ident(name) => {
                unchanged.insert(name.clone());
            }
            Expr::Tuple(elems) => {
                for elem in elems {
                    Self::collect_unchanged_vars(&elem.node, unchanged);
                }
            }
            _ => {}
        }
    }

    /// Convert a primed expression to Rust (handling x' references as x_next)
    fn primed_expr_to_rust(&self, expr: &Expr) -> String {
        match expr {
            Expr::Prime(inner) => {
                if let Expr::Ident(name) = &inner.node {
                    format!("{}_next", to_snake_case(name))
                } else {
                    self.expr_to_rust(expr)
                }
            }
            // For simple state variable references, add .clone() to handle non-Copy types
            Expr::Ident(name) if self.var_types.contains_key(name) => {
                format!("state.{}.clone()", to_snake_case(name))
            }
            _ => self.expr_to_rust_with_state(expr, true),
        }
    }

    fn expand_operators(&self, expr: &Expr) -> Expr {
        let env = [self.op_defs];
        let mut expanding = HashSet::new();
        let bound = HashSet::new();
        self.expand_operators_in_env(expr, &env, &mut expanding, &bound)
    }

    fn lookup_operator<'b>(
        env: &[&'b HashMap<String, OperatorDef>],
        name: &str,
    ) -> Option<&'b OperatorDef> {
        for scope in env.iter().rev() {
            if let Some(op) = scope.get(name) {
                return Some(op);
            }
        }
        None
    }

    fn expand_operators_in_env(
        &self,
        expr: &Expr,
        env: &[&HashMap<String, OperatorDef>],
        expanding: &mut HashSet<String>,
        bound: &HashSet<String>,
    ) -> Expr {
        match expr {
            Expr::Bool(b) => Expr::Bool(*b),
            Expr::Int(n) => Expr::Int(n.clone()),
            Expr::String(s) => Expr::String(s.clone()),
            Expr::Ident(name) => {
                if bound.contains(name) || self.var_types.contains_key(name) {
                    return Expr::Ident(name.clone());
                }
                let Some(op) = Self::lookup_operator(env, name) else {
                    return Expr::Ident(name.clone());
                };
                if !op.params.is_empty() {
                    return Expr::Ident(name.clone());
                }
                if !expanding.insert(name.clone()) {
                    return Expr::Ident(name.clone());
                }
                let mut op_bound = bound.clone();
                for param in &op.params {
                    op_bound.insert(param.name.node.clone());
                }
                let expanded =
                    self.expand_operators_in_env(&op.body.node, env, expanding, &op_bound);
                expanding.remove(name);
                expanded
            }
            Expr::Apply(op_expr, args) => {
                if let Expr::Ident(name) = &op_expr.node {
                    if !bound.contains(name) && !self.var_types.contains_key(name) {
                        if let Some(op) = Self::lookup_operator(env, name) {
                            if op.params.len() == args.len()
                                && op.params.iter().all(|p| p.arity == 0)
                            {
                                if !expanding.insert(name.clone()) {
                                    return expr.clone();
                                }

                                let subst: HashMap<String, Expr> = op
                                    .params
                                    .iter()
                                    .zip(args.iter())
                                    .map(|(p, a)| (p.name.node.clone(), a.node.clone()))
                                    .collect();
                                let substituted =
                                    self.substitute_expr(&op.body.node, &subst, &HashSet::new());
                                let expanded = self.expand_operators_in_env(
                                    &substituted,
                                    env,
                                    expanding,
                                    bound,
                                );
                                expanding.remove(name);
                                return expanded;
                            }
                        }
                    }
                }

                let op_expanded =
                    self.expand_operators_in_env(&op_expr.node, env, expanding, bound);
                let args_expanded = args
                    .iter()
                    .map(|a| {
                        Spanned::dummy(self.expand_operators_in_env(&a.node, env, expanding, bound))
                    })
                    .collect();
                Expr::Apply(Box::new(Spanned::dummy(op_expanded)), args_expanded)
            }
            Expr::Lambda(params, body) => {
                let mut bound2 = bound.clone();
                for param in params {
                    bound2.insert(param.node.clone());
                }
                Expr::Lambda(
                    params.clone(),
                    Box::new(Spanned::dummy(
                        self.expand_operators_in_env(&body.node, env, expanding, &bound2),
                    )),
                )
            }
            Expr::And(a, b) => Expr::And(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Or(a, b) => Expr::Or(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Not(a) => Expr::Not(Box::new(Spanned::dummy(
                self.expand_operators_in_env(&a.node, env, expanding, bound),
            ))),
            Expr::Implies(a, b) => Expr::Implies(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Equiv(a, b) => Expr::Equiv(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Forall(bounds, body) => {
                let (new_bounds, bound2) = self.expand_bound_vars(bounds, env, expanding, bound);
                Expr::Forall(
                    new_bounds,
                    Box::new(Spanned::dummy(
                        self.expand_operators_in_env(&body.node, env, expanding, &bound2),
                    )),
                )
            }
            Expr::Exists(bounds, body) => {
                let (new_bounds, bound2) = self.expand_bound_vars(bounds, env, expanding, bound);
                Expr::Exists(
                    new_bounds,
                    Box::new(Spanned::dummy(
                        self.expand_operators_in_env(&body.node, env, expanding, &bound2),
                    )),
                )
            }
            Expr::Choose(boundvar, body) => {
                let (mut bounds, bound2) =
                    self.expand_bound_vars(std::slice::from_ref(boundvar), env, expanding, bound);
                Expr::Choose(
                    bounds.pop().unwrap(),
                    Box::new(Spanned::dummy(
                        self.expand_operators_in_env(&body.node, env, expanding, &bound2),
                    )),
                )
            }
            Expr::SetEnum(elems) => Expr::SetEnum(
                elems
                    .iter()
                    .map(|e| {
                        Spanned::dummy(self.expand_operators_in_env(&e.node, env, expanding, bound))
                    })
                    .collect(),
            ),
            Expr::SetBuilder(body, bounds) => {
                let (new_bounds, bound2) = self.expand_bound_vars(bounds, env, expanding, bound);
                Expr::SetBuilder(
                    Box::new(Spanned::dummy(
                        self.expand_operators_in_env(&body.node, env, expanding, &bound2),
                    )),
                    new_bounds,
                )
            }
            Expr::SetFilter(boundvar, pred) => {
                let (mut bounds, bound2) =
                    self.expand_bound_vars(std::slice::from_ref(boundvar), env, expanding, bound);
                Expr::SetFilter(
                    bounds.pop().unwrap(),
                    Box::new(Spanned::dummy(
                        self.expand_operators_in_env(&pred.node, env, expanding, &bound2),
                    )),
                )
            }
            Expr::In(a, b) => Expr::In(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::NotIn(a, b) => Expr::NotIn(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Subseteq(a, b) => Expr::Subseteq(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Union(a, b) => Expr::Union(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Intersect(a, b) => Expr::Intersect(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::SetMinus(a, b) => Expr::SetMinus(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Powerset(s) => Expr::Powerset(Box::new(Spanned::dummy(
                self.expand_operators_in_env(&s.node, env, expanding, bound),
            ))),
            Expr::BigUnion(s) => Expr::BigUnion(Box::new(Spanned::dummy(
                self.expand_operators_in_env(&s.node, env, expanding, bound),
            ))),
            Expr::FuncDef(bounds, body) => {
                let (new_bounds, bound2) = self.expand_bound_vars(bounds, env, expanding, bound);
                Expr::FuncDef(
                    new_bounds,
                    Box::new(Spanned::dummy(
                        self.expand_operators_in_env(&body.node, env, expanding, &bound2),
                    )),
                )
            }
            Expr::FuncApply(f, a) => Expr::FuncApply(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&f.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
            ),
            Expr::Domain(f) => Expr::Domain(Box::new(Spanned::dummy(
                self.expand_operators_in_env(&f.node, env, expanding, bound),
            ))),
            Expr::Except(f, specs) => Expr::Except(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&f.node, env, expanding, bound),
                )),
                specs
                    .iter()
                    .map(|s| ExceptSpec {
                        path: s
                            .path
                            .iter()
                            .map(|elem| match elem {
                                ExceptPathElement::Index(idx) => {
                                    ExceptPathElement::Index(Spanned::dummy(
                                        self.expand_operators_in_env(
                                            &idx.node, env, expanding, bound,
                                        ),
                                    ))
                                }
                                ExceptPathElement::Field(f) => ExceptPathElement::Field(f.clone()),
                            })
                            .collect(),
                        value: Spanned::dummy(self.expand_operators_in_env(
                            &s.value.node,
                            env,
                            expanding,
                            bound,
                        )),
                    })
                    .collect(),
            ),
            Expr::FuncSet(a, b) => Expr::FuncSet(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Record(fields) => Expr::Record(
                fields
                    .iter()
                    .map(|(k, v)| {
                        (
                            k.clone(),
                            Spanned::dummy(
                                self.expand_operators_in_env(&v.node, env, expanding, bound),
                            ),
                        )
                    })
                    .collect(),
            ),
            Expr::RecordAccess(rec, field) => Expr::RecordAccess(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&rec.node, env, expanding, bound),
                )),
                field.clone(),
            ),
            Expr::RecordSet(fields) => Expr::RecordSet(
                fields
                    .iter()
                    .map(|(k, v)| {
                        (
                            k.clone(),
                            Spanned::dummy(
                                self.expand_operators_in_env(&v.node, env, expanding, bound),
                            ),
                        )
                    })
                    .collect(),
            ),
            Expr::Tuple(elems) => Expr::Tuple(
                elems
                    .iter()
                    .map(|e| {
                        Spanned::dummy(self.expand_operators_in_env(&e.node, env, expanding, bound))
                    })
                    .collect(),
            ),
            Expr::Times(sets) => Expr::Times(
                sets.iter()
                    .map(|s| {
                        Spanned::dummy(self.expand_operators_in_env(&s.node, env, expanding, bound))
                    })
                    .collect(),
            ),
            Expr::Prime(inner) => Expr::Prime(Box::new(Spanned::dummy(
                self.expand_operators_in_env(&inner.node, env, expanding, bound),
            ))),
            Expr::Always(p) => Expr::Always(Box::new(Spanned::dummy(
                self.expand_operators_in_env(&p.node, env, expanding, bound),
            ))),
            Expr::Eventually(p) => Expr::Eventually(Box::new(Spanned::dummy(
                self.expand_operators_in_env(&p.node, env, expanding, bound),
            ))),
            Expr::LeadsTo(p, q) => Expr::LeadsTo(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&p.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&q.node, env, expanding, bound),
                )),
            ),
            Expr::WeakFair(vars, a) => Expr::WeakFair(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&vars.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
            ),
            Expr::StrongFair(vars, a) => Expr::StrongFair(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&vars.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
            ),
            Expr::Enabled(a) => Expr::Enabled(Box::new(Spanned::dummy(
                self.expand_operators_in_env(&a.node, env, expanding, bound),
            ))),
            Expr::Unchanged(e) => Expr::Unchanged(Box::new(Spanned::dummy(
                self.expand_operators_in_env(&e.node, env, expanding, bound),
            ))),
            Expr::If(cond, then_e, else_e) => Expr::If(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&cond.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(self.expand_operators_in_env(
                    &then_e.node,
                    env,
                    expanding,
                    bound,
                ))),
                Box::new(Spanned::dummy(self.expand_operators_in_env(
                    &else_e.node,
                    env,
                    expanding,
                    bound,
                ))),
            ),
            Expr::Case(arms, other) => {
                let new_arms: Vec<CaseArm> = arms
                    .iter()
                    .map(|arm| CaseArm {
                        guard: Spanned::dummy(self.expand_operators_in_env(
                            &arm.guard.node,
                            env,
                            expanding,
                            bound,
                        )),
                        body: Spanned::dummy(self.expand_operators_in_env(
                            &arm.body.node,
                            env,
                            expanding,
                            bound,
                        )),
                    })
                    .collect();
                let new_other = other.as_ref().map(|e| {
                    Box::new(Spanned::dummy(
                        self.expand_operators_in_env(&e.node, env, expanding, bound),
                    ))
                });
                Expr::Case(new_arms, new_other)
            }
            Expr::Let(defs, body) => {
                let local_ops: HashMap<String, OperatorDef> = defs
                    .iter()
                    .map(|d| (d.name.node.clone(), d.clone()))
                    .collect();
                let mut env2 = Vec::with_capacity(env.len() + 1);
                env2.extend_from_slice(env);
                env2.push(&local_ops);
                self.expand_operators_in_env(&body.node, &env2, expanding, bound)
            }
            Expr::Eq(a, b) => Expr::Eq(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Neq(a, b) => Expr::Neq(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Lt(a, b) => Expr::Lt(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Leq(a, b) => Expr::Leq(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Gt(a, b) => Expr::Gt(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Geq(a, b) => Expr::Geq(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Add(a, b) => Expr::Add(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Sub(a, b) => Expr::Sub(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Mul(a, b) => Expr::Mul(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Div(a, b) => Expr::Div(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::IntDiv(a, b) => Expr::IntDiv(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Mod(a, b) => Expr::Mod(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Pow(a, b) => Expr::Pow(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::Neg(a) => Expr::Neg(Box::new(Spanned::dummy(
                self.expand_operators_in_env(&a.node, env, expanding, bound),
            ))),
            Expr::Range(a, b) => Expr::Range(
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&a.node, env, expanding, bound),
                )),
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&b.node, env, expanding, bound),
                )),
            ),
            Expr::ModuleRef(m, op, args) => {
                // For now, keep module references as-is (they need instance info to resolve)
                let new_args: Vec<_> = args
                    .iter()
                    .map(|a| {
                        Spanned::dummy(self.expand_operators_in_env(&a.node, env, expanding, bound))
                    })
                    .collect();
                Expr::ModuleRef(m.clone(), op.clone(), new_args)
            }
            Expr::InstanceExpr(module, subs) => {
                // Expand operators in substitution expressions
                let new_subs: Vec<_> = subs
                    .iter()
                    .map(|sub| Substitution {
                        from: sub.from.clone(),
                        to: Spanned::dummy(self.expand_operators_in_env(
                            &sub.to.node,
                            env,
                            expanding,
                            bound,
                        )),
                    })
                    .collect();
                Expr::InstanceExpr(module.clone(), new_subs)
            }
            // Operator references don't need expansion
            Expr::OpRef(op) => Expr::OpRef(op.clone()),
        }
    }

    fn expand_bound_vars(
        &self,
        bounds: &[BoundVar],
        env: &[&HashMap<String, OperatorDef>],
        expanding: &mut HashSet<String>,
        bound: &HashSet<String>,
    ) -> (Vec<BoundVar>, HashSet<String>) {
        let mut new_bounds = Vec::with_capacity(bounds.len());
        let mut bound2 = bound.clone();
        for bv in bounds {
            let new_domain = bv.domain.as_ref().map(|d| {
                Box::new(Spanned::dummy(
                    self.expand_operators_in_env(&d.node, env, expanding, &bound2),
                ))
            });
            new_bounds.push(BoundVar {
                name: bv.name.clone(),
                domain: new_domain,
                pattern: bv.pattern.clone(),
            });
            bound2.insert(bv.name.node.clone());
        }
        (new_bounds, bound2)
    }

    fn substitute_expr(
        &self,
        expr: &Expr,
        subst: &HashMap<String, Expr>,
        bound: &HashSet<String>,
    ) -> Expr {
        match expr {
            Expr::Bool(b) => Expr::Bool(*b),
            Expr::Int(n) => Expr::Int(n.clone()),
            Expr::String(s) => Expr::String(s.clone()),
            Expr::Ident(name) => {
                if bound.contains(name) {
                    Expr::Ident(name.clone())
                } else {
                    subst
                        .get(name)
                        .cloned()
                        .unwrap_or_else(|| Expr::Ident(name.clone()))
                }
            }
            Expr::Apply(op, args) => Expr::Apply(
                Box::new(Spanned::dummy(self.substitute_expr(&op.node, subst, bound))),
                args.iter()
                    .map(|a| Spanned::dummy(self.substitute_expr(&a.node, subst, bound)))
                    .collect(),
            ),
            Expr::Lambda(params, body) => {
                let mut bound2 = bound.clone();
                for p in params {
                    bound2.insert(p.node.clone());
                }
                Expr::Lambda(
                    params.clone(),
                    Box::new(Spanned::dummy(
                        self.substitute_expr(&body.node, subst, &bound2),
                    )),
                )
            }
            Expr::And(a, b) => Expr::And(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Or(a, b) => Expr::Or(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Not(a) => Expr::Not(Box::new(Spanned::dummy(
                self.substitute_expr(&a.node, subst, bound),
            ))),
            Expr::Implies(a, b) => Expr::Implies(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Equiv(a, b) => Expr::Equiv(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Forall(bounds, body) => {
                let (new_bounds, bound2) = self.substitute_bound_vars(bounds, subst, bound);
                Expr::Forall(
                    new_bounds,
                    Box::new(Spanned::dummy(
                        self.substitute_expr(&body.node, subst, &bound2),
                    )),
                )
            }
            Expr::Exists(bounds, body) => {
                let (new_bounds, bound2) = self.substitute_bound_vars(bounds, subst, bound);
                Expr::Exists(
                    new_bounds,
                    Box::new(Spanned::dummy(
                        self.substitute_expr(&body.node, subst, &bound2),
                    )),
                )
            }
            Expr::Choose(boundvar, body) => {
                let (mut new_bounds, bound2) =
                    self.substitute_bound_vars(std::slice::from_ref(boundvar), subst, bound);
                Expr::Choose(
                    new_bounds.pop().unwrap(),
                    Box::new(Spanned::dummy(
                        self.substitute_expr(&body.node, subst, &bound2),
                    )),
                )
            }
            Expr::SetEnum(elems) => Expr::SetEnum(
                elems
                    .iter()
                    .map(|e| Spanned::dummy(self.substitute_expr(&e.node, subst, bound)))
                    .collect(),
            ),
            Expr::SetBuilder(body, bounds) => {
                let (new_bounds, bound2) = self.substitute_bound_vars(bounds, subst, bound);
                Expr::SetBuilder(
                    Box::new(Spanned::dummy(
                        self.substitute_expr(&body.node, subst, &bound2),
                    )),
                    new_bounds,
                )
            }
            Expr::SetFilter(boundvar, pred) => {
                let (mut new_bounds, bound2) =
                    self.substitute_bound_vars(std::slice::from_ref(boundvar), subst, bound);
                Expr::SetFilter(
                    new_bounds.pop().unwrap(),
                    Box::new(Spanned::dummy(
                        self.substitute_expr(&pred.node, subst, &bound2),
                    )),
                )
            }
            Expr::In(a, b) => Expr::In(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::NotIn(a, b) => Expr::NotIn(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Subseteq(a, b) => Expr::Subseteq(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Union(a, b) => Expr::Union(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Intersect(a, b) => Expr::Intersect(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::SetMinus(a, b) => Expr::SetMinus(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Powerset(s) => Expr::Powerset(Box::new(Spanned::dummy(
                self.substitute_expr(&s.node, subst, bound),
            ))),
            Expr::BigUnion(s) => Expr::BigUnion(Box::new(Spanned::dummy(
                self.substitute_expr(&s.node, subst, bound),
            ))),
            Expr::FuncDef(bounds, body) => {
                let (new_bounds, bound2) = self.substitute_bound_vars(bounds, subst, bound);
                Expr::FuncDef(
                    new_bounds,
                    Box::new(Spanned::dummy(
                        self.substitute_expr(&body.node, subst, &bound2),
                    )),
                )
            }
            Expr::FuncApply(f, a) => Expr::FuncApply(
                Box::new(Spanned::dummy(self.substitute_expr(&f.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
            ),
            Expr::Domain(f) => Expr::Domain(Box::new(Spanned::dummy(
                self.substitute_expr(&f.node, subst, bound),
            ))),
            Expr::Except(f, specs) => Expr::Except(
                Box::new(Spanned::dummy(self.substitute_expr(&f.node, subst, bound))),
                specs
                    .iter()
                    .map(|s| ExceptSpec {
                        path: s
                            .path
                            .iter()
                            .map(|elem| match elem {
                                ExceptPathElement::Index(idx) => ExceptPathElement::Index(
                                    Spanned::dummy(self.substitute_expr(&idx.node, subst, bound)),
                                ),
                                ExceptPathElement::Field(f) => ExceptPathElement::Field(f.clone()),
                            })
                            .collect(),
                        value: Spanned::dummy(self.substitute_expr(&s.value.node, subst, bound)),
                    })
                    .collect(),
            ),
            Expr::FuncSet(a, b) => Expr::FuncSet(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Record(fields) => Expr::Record(
                fields
                    .iter()
                    .map(|(k, v)| {
                        (
                            k.clone(),
                            Spanned::dummy(self.substitute_expr(&v.node, subst, bound)),
                        )
                    })
                    .collect(),
            ),
            Expr::RecordAccess(rec, field) => Expr::RecordAccess(
                Box::new(Spanned::dummy(
                    self.substitute_expr(&rec.node, subst, bound),
                )),
                field.clone(),
            ),
            Expr::RecordSet(fields) => Expr::RecordSet(
                fields
                    .iter()
                    .map(|(k, v)| {
                        (
                            k.clone(),
                            Spanned::dummy(self.substitute_expr(&v.node, subst, bound)),
                        )
                    })
                    .collect(),
            ),
            Expr::Tuple(elems) => Expr::Tuple(
                elems
                    .iter()
                    .map(|e| Spanned::dummy(self.substitute_expr(&e.node, subst, bound)))
                    .collect(),
            ),
            Expr::Times(sets) => Expr::Times(
                sets.iter()
                    .map(|s| Spanned::dummy(self.substitute_expr(&s.node, subst, bound)))
                    .collect(),
            ),
            Expr::Prime(inner) => Expr::Prime(Box::new(Spanned::dummy(self.substitute_expr(
                &inner.node,
                subst,
                bound,
            )))),
            Expr::Always(p) => Expr::Always(Box::new(Spanned::dummy(
                self.substitute_expr(&p.node, subst, bound),
            ))),
            Expr::Eventually(p) => Expr::Eventually(Box::new(Spanned::dummy(
                self.substitute_expr(&p.node, subst, bound),
            ))),
            Expr::LeadsTo(p, q) => Expr::LeadsTo(
                Box::new(Spanned::dummy(self.substitute_expr(&p.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&q.node, subst, bound))),
            ),
            Expr::WeakFair(vars, a) => Expr::WeakFair(
                Box::new(Spanned::dummy(
                    self.substitute_expr(&vars.node, subst, bound),
                )),
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
            ),
            Expr::StrongFair(vars, a) => Expr::StrongFair(
                Box::new(Spanned::dummy(
                    self.substitute_expr(&vars.node, subst, bound),
                )),
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
            ),
            Expr::Enabled(a) => Expr::Enabled(Box::new(Spanned::dummy(
                self.substitute_expr(&a.node, subst, bound),
            ))),
            Expr::Unchanged(e) => Expr::Unchanged(Box::new(Spanned::dummy(
                self.substitute_expr(&e.node, subst, bound),
            ))),
            Expr::If(cond, then_e, else_e) => Expr::If(
                Box::new(Spanned::dummy(
                    self.substitute_expr(&cond.node, subst, bound),
                )),
                Box::new(Spanned::dummy(self.substitute_expr(
                    &then_e.node,
                    subst,
                    bound,
                ))),
                Box::new(Spanned::dummy(self.substitute_expr(
                    &else_e.node,
                    subst,
                    bound,
                ))),
            ),
            Expr::Case(arms, other) => {
                let new_arms: Vec<CaseArm> = arms
                    .iter()
                    .map(|arm| CaseArm {
                        guard: Spanned::dummy(self.substitute_expr(&arm.guard.node, subst, bound)),
                        body: Spanned::dummy(self.substitute_expr(&arm.body.node, subst, bound)),
                    })
                    .collect();
                let new_other = other
                    .as_ref()
                    .map(|e| Box::new(Spanned::dummy(self.substitute_expr(&e.node, subst, bound))));
                Expr::Case(new_arms, new_other)
            }
            Expr::Let(defs, body) => {
                let new_defs: Vec<OperatorDef> = defs
                    .iter()
                    .map(|d| self.substitute_operator_def(d, subst, bound))
                    .collect();
                Expr::Let(
                    new_defs,
                    Box::new(Spanned::dummy(
                        self.substitute_expr(&body.node, subst, bound),
                    )),
                )
            }
            Expr::Eq(a, b) => Expr::Eq(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Neq(a, b) => Expr::Neq(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Lt(a, b) => Expr::Lt(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Leq(a, b) => Expr::Leq(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Gt(a, b) => Expr::Gt(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Geq(a, b) => Expr::Geq(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Add(a, b) => Expr::Add(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Sub(a, b) => Expr::Sub(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Mul(a, b) => Expr::Mul(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Div(a, b) => Expr::Div(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::IntDiv(a, b) => Expr::IntDiv(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Mod(a, b) => Expr::Mod(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Pow(a, b) => Expr::Pow(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::Neg(a) => Expr::Neg(Box::new(Spanned::dummy(
                self.substitute_expr(&a.node, subst, bound),
            ))),
            Expr::Range(a, b) => Expr::Range(
                Box::new(Spanned::dummy(self.substitute_expr(&a.node, subst, bound))),
                Box::new(Spanned::dummy(self.substitute_expr(&b.node, subst, bound))),
            ),
            Expr::ModuleRef(m, op, args) => {
                let new_args: Vec<_> = args
                    .iter()
                    .map(|a| Spanned::dummy(self.substitute_expr(&a.node, subst, bound)))
                    .collect();
                Expr::ModuleRef(m.clone(), op.clone(), new_args)
            }
            Expr::InstanceExpr(module, subs) => {
                let new_subs: Vec<_> = subs
                    .iter()
                    .map(|sub| Substitution {
                        from: sub.from.clone(),
                        to: Spanned::dummy(self.substitute_expr(&sub.to.node, subst, bound)),
                    })
                    .collect();
                Expr::InstanceExpr(module.clone(), new_subs)
            }
            // Operator references don't need substitution
            Expr::OpRef(op) => Expr::OpRef(op.clone()),
        }
    }

    fn substitute_bound_vars(
        &self,
        bounds: &[BoundVar],
        subst: &HashMap<String, Expr>,
        bound: &HashSet<String>,
    ) -> (Vec<BoundVar>, HashSet<String>) {
        let mut new_bounds = Vec::with_capacity(bounds.len());
        let mut bound2 = bound.clone();
        for bv in bounds {
            let new_domain = bv.domain.as_ref().map(|d| {
                Box::new(Spanned::dummy(
                    self.substitute_expr(&d.node, subst, &bound2),
                ))
            });
            new_bounds.push(BoundVar {
                name: bv.name.clone(),
                domain: new_domain,
                pattern: bv.pattern.clone(),
            });
            bound2.insert(bv.name.node.clone());
        }
        (new_bounds, bound2)
    }

    fn substitute_operator_def(
        &self,
        def: &OperatorDef,
        subst: &HashMap<String, Expr>,
        bound: &HashSet<String>,
    ) -> OperatorDef {
        let mut bound2 = bound.clone();
        for param in &def.params {
            bound2.insert(param.name.node.clone());
        }
        OperatorDef {
            name: def.name.clone(),
            params: def.params.clone(),
            body: Spanned::dummy(self.substitute_expr(&def.body.node, subst, &bound2)),
            local: def.local,
        }
    }

    /// Convert a TLA+ expression to Rust code
    fn expr_to_rust(&self, expr: &Expr) -> String {
        self.expr_to_rust_with_state(expr, false)
    }

    /// Convert expression to Rust, optionally prefixing state variable access
    fn expr_to_rust_with_state(&self, expr: &Expr, prefix_state: bool) -> String {
        match expr {
            // Literals
            Expr::Bool(b) => b.to_string(),
            Expr::Int(n) => format!("{}_i64", n),
            Expr::String(s) => format!("{:?}.to_string()", s),

            // Variables
            Expr::Ident(name) => {
                if self.var_types.contains_key(name) && prefix_state {
                    format!("state.{}", to_snake_case(name))
                } else {
                    // Check for built-in constants
                    match name.as_str() {
                        "TRUE" => "true".to_string(),
                        "FALSE" => "false".to_string(),
                        "BOOLEAN" => "boolean_set()".to_string(),
                        _ => to_snake_case(name),
                    }
                }
            }

            // Logic
            Expr::And(a, b) => format!(
                "({} && {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Or(a, b) => format!(
                "({} || {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Not(a) => format!("!{}", self.expr_to_rust_with_state(&a.node, prefix_state)),
            Expr::Implies(a, b) => format!(
                "(!{} || {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Equiv(a, b) => format!(
                "({} == {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),

            // Comparison
            Expr::Eq(a, b) => format!(
                "({} == {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Neq(a, b) => format!(
                "({} != {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Lt(a, b) => format!(
                "({} < {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Leq(a, b) => format!(
                "({} <= {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Gt(a, b) => format!(
                "({} > {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Geq(a, b) => format!(
                "({} >= {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),

            // Arithmetic
            Expr::Add(a, b) => format!(
                "({} + {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Sub(a, b) => format!(
                "({} - {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Mul(a, b) => format!(
                "({} * {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Div(a, b) => format!(
                "({} / {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::IntDiv(a, b) => format!(
                "({} / {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Mod(a, b) => format!(
                "({} % {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Pow(a, b) => format!(
                "{}.pow({} as u32)",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Neg(a) => format!("-{}", self.expr_to_rust_with_state(&a.node, prefix_state)),
            Expr::Range(a, b) => format!(
                "range_set({}, {})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),

            // Sets
            Expr::SetEnum(elems) => {
                if elems.is_empty() {
                    "TlaSet::new()".to_string()
                } else {
                    let elem_strs: Vec<_> = elems
                        .iter()
                        .map(|e| self.expr_to_rust_with_state(&e.node, prefix_state))
                        .collect();
                    format!("tla_set![{}]", elem_strs.join(", "))
                }
            }
            Expr::In(elem, set) => format!(
                "{}.contains(&{})",
                self.expr_to_rust_with_state(&set.node, prefix_state),
                self.expr_to_rust_with_state(&elem.node, prefix_state)
            ),
            Expr::NotIn(elem, set) => format!(
                "!{}.contains(&{})",
                self.expr_to_rust_with_state(&set.node, prefix_state),
                self.expr_to_rust_with_state(&elem.node, prefix_state)
            ),
            Expr::Subseteq(a, b) => format!(
                "{}.is_subset(&{})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Union(a, b) => format!(
                "{}.union(&{})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Intersect(a, b) => format!(
                "{}.intersect(&{})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::SetMinus(a, b) => format!(
                "{}.difference(&{})",
                self.expr_to_rust_with_state(&a.node, prefix_state),
                self.expr_to_rust_with_state(&b.node, prefix_state)
            ),
            Expr::Powerset(s) => format!(
                "powerset(&{})",
                self.expr_to_rust_with_state(&s.node, prefix_state)
            ),

            // Tuples
            Expr::Tuple(elems) => {
                let elem_strs: Vec<_> = elems
                    .iter()
                    .map(|e| self.expr_to_rust_with_state(&e.node, prefix_state))
                    .collect();
                format!("({})", elem_strs.join(", "))
            }

            // Functions
            Expr::FuncApply(func, arg) => format!(
                "{}.apply(&{}).cloned().unwrap()",
                self.expr_to_rust_with_state(&func.node, prefix_state),
                self.expr_to_rust_with_state(&arg.node, prefix_state)
            ),
            Expr::Domain(func) => format!(
                "{}.domain()",
                self.expr_to_rust_with_state(&func.node, prefix_state)
            ),
            Expr::FuncDef(bounds, body) => {
                // Function definition: [x \in S |-> expr]
                // Creates a TlaFunc from domain elements to body values
                if bounds.len() == 1 {
                    let bound = &bounds[0];
                    let var_name = to_snake_case(&bound.name.node);
                    let domain_str = bound
                        .domain
                        .as_ref()
                        .map(|s| self.expr_to_rust_with_state(&s.node, prefix_state))
                        .unwrap_or_else(|| "/* no domain */".to_string());
                    let body_str = self.expr_to_rust_with_state(&body.node, prefix_state);
                    format!(
                        "TlaFunc::from_iter({}.iter().map(|{}| ({}.clone(), {})))",
                        domain_str, var_name, var_name, body_str
                    )
                } else {
                    // Multi-argument function: [x \in S, y \in T |-> expr]
                    // Generate nested flat_map iterators with tuple keys
                    let body_str = self.expr_to_rust_with_state(&body.node, prefix_state);
                    let var_names: Vec<_> =
                        bounds.iter().map(|b| to_snake_case(&b.name.node)).collect();
                    let domain_strs: Vec<_> = bounds
                        .iter()
                        .map(|b| {
                            b.domain
                                .as_ref()
                                .map(|d| self.expr_to_rust_with_state(&d.node, prefix_state))
                                .unwrap_or_else(|| "/* no domain */".to_string())
                        })
                        .collect();

                    // Build the key tuple (x.clone(), y.clone(), ...)
                    let key_tuple = format!(
                        "({})",
                        var_names
                            .iter()
                            .map(|v| format!("{}.clone()", v))
                            .collect::<Vec<_>>()
                            .join(", ")
                    );

                    // Build nested iterators from inner to outer
                    // innermost: T.iter().map(|y| ((x.clone(), y.clone()), body))
                    // then: S.iter().flat_map(|x| ...)
                    let n = bounds.len();
                    let mut result = format!(
                        "{}.iter().map(|{}| ({}, {}))",
                        domain_strs[n - 1],
                        var_names[n - 1],
                        key_tuple,
                        body_str
                    );

                    // Wrap with flat_map from n-2 down to 0
                    for i in (0..n - 1).rev() {
                        result = format!(
                            "{}.iter().flat_map(|{}| {})",
                            domain_strs[i], var_names[i], result
                        );
                    }

                    format!("TlaFunc::from_iter({})", result)
                }
            }
            Expr::FuncSet(domain, range) => {
                // [S -> T] is the set of all functions from S to T
                // For finite S and T, this is |T|^|S| functions
                // Generate code that enumerates all possible functions
                let domain_str = self.expr_to_rust_with_state(&domain.node, prefix_state);
                let range_str = self.expr_to_rust_with_state(&range.node, prefix_state);
                format!(
                    r#"{{
    let __domain: Vec<_> = ({}).iter().cloned().collect();
    let __range: Vec<_> = ({}).iter().cloned().collect();
    let __dom_len = __domain.len();
    let __range_len = __range.len();
    if __dom_len > 10 || __range_len.checked_pow(__dom_len as u32).map_or(true, |n| n > 10000) {{
        panic!("FuncSet [{{}}->{{}}) too large: domain_size={{}}, range_size={{}}", __dom_len, __range_len, __dom_len, __range_len);
    }}
    let mut __result = TlaSet::new();
    let __total = __range_len.pow(__dom_len as u32);
    for __i in 0..__total {{
        let mut __f_entries = Vec::new();
        let mut __n = __i;
        for __d in &__domain {{
            __f_entries.push((__d.clone(), __range[__n % __range_len].clone()));
            __n /= __range_len;
        }}
        __result.insert(TlaFunc::from_iter(__f_entries));
    }}
    __result
}}"#,
                    domain_str, range_str
                )
            }

            // Records
            Expr::Record(fields) => {
                // [a |-> 1, b |-> 2] translates to TlaRecord::from_fields([...])
                let field_strs: Vec<_> = fields
                    .iter()
                    .map(|(k, v)| {
                        format!(
                            "(\"{}\".to_string(), {})",
                            k.node,
                            self.expr_to_rust_with_state(&v.node, prefix_state)
                        )
                    })
                    .collect();
                format!("TlaRecord::from_fields([{}])", field_strs.join(", "))
            }
            Expr::RecordAccess(rec, field) => {
                // For TlaRecord, use .get().cloned().unwrap()
                // For struct-style records (state vars), use .field
                // Heuristic: if rec is an identifier that's a state var, use struct access
                if let Expr::Ident(name) = &rec.node {
                    if self.var_types.contains_key(name) {
                        return format!(
                            "{}.{}",
                            self.expr_to_rust_with_state(&rec.node, prefix_state),
                            to_snake_case(&field.node)
                        );
                    }
                }
                // Otherwise use TlaRecord method
                format!(
                    "{}.get(\"{}\").cloned().unwrap()",
                    self.expr_to_rust_with_state(&rec.node, prefix_state),
                    field.node
                )
            }
            Expr::RecordSet(fields) => {
                // [a: S, b: T] is a set of records - Cartesian product of field values
                // For small field sets, enumerate all combinations
                if fields.is_empty() {
                    "tla_set![TlaRecord::new()]".to_string()
                } else {
                    // Generate nested loops for Cartesian product
                    let mut result = String::new();
                    result.push_str("{\n");
                    result.push_str("    let mut __records = TlaSet::new();\n");

                    // Generate nested for loops
                    let field_names: Vec<_> = fields.iter().map(|(k, _)| k.node.clone()).collect();
                    for (i, (_, v)) in fields.iter().enumerate() {
                        let var_name = format!("__f{}", i);
                        result.push_str(&format!(
                            "    for {} in {} {{\n",
                            var_name,
                            self.expr_to_rust_with_state(&v.node, prefix_state)
                        ));
                    }

                    // Build the record
                    result.push_str("    __records.insert(TlaRecord::from_fields([");
                    for (i, name) in field_names.iter().enumerate() {
                        if i > 0 {
                            result.push_str(", ");
                        }
                        result.push_str(&format!("(\"{}\".to_string(), __f{}.clone())", name, i));
                    }
                    result.push_str("]));\n");

                    // Close the loops
                    for _ in fields {
                        result.push_str("    }\n");
                    }

                    result.push_str("    __records\n}");
                    result
                }
            }

            // Control
            Expr::If(cond, then_e, else_e) => format!(
                "if {} {{ {} }} else {{ {} }}",
                self.expr_to_rust_with_state(&cond.node, prefix_state),
                self.expr_to_rust_with_state(&then_e.node, prefix_state),
                self.expr_to_rust_with_state(&else_e.node, prefix_state)
            ),

            // Prime (for Next actions)
            Expr::Prime(inner) => {
                if let Expr::Ident(name) = &inner.node {
                    format!("{}_next", to_snake_case(name))
                } else {
                    format!(
                        "/* {}' */",
                        self.expr_to_rust_with_state(&inner.node, prefix_state)
                    )
                }
            }

            // Function application - handle stdlib operators
            Expr::Apply(op_expr, args) => {
                if let Expr::Ident(name) = &op_expr.node {
                    self.translate_stdlib_apply(name, args, prefix_state)
                } else {
                    // Operator expression isn't an identifier, try translating as function call
                    let op_str = self.expr_to_rust_with_state(&op_expr.node, prefix_state);
                    let args_str: Vec<_> = args
                        .iter()
                        .map(|a| self.expr_to_rust_with_state(&a.node, prefix_state))
                        .collect();
                    format!("{}({})", op_str, args_str.join(", "))
                }
            }

            // EXCEPT - function update [f EXCEPT ![a] = b]
            Expr::Except(func, specs) => {
                let func_str = self.expr_to_rust_with_state(&func.node, prefix_state);
                let mut result = format!("{{\n    let mut __tmp = {}.clone();\n", func_str);
                for spec in specs {
                    // Build the key expression from path elements
                    // Only single-element Index paths are supported for now
                    if spec.path.len() == 1 {
                        if let ExceptPathElement::Index(idx) = &spec.path[0] {
                            let key_str = self.expr_to_rust_with_state(&idx.node, prefix_state);
                            let val_str =
                                self.expr_to_rust_with_state(&spec.value.node, prefix_state);
                            result.push_str(&format!(
                                "    __tmp.update({}, {});\n",
                                key_str, val_str
                            ));
                        } else if let ExceptPathElement::Field(f) = &spec.path[0] {
                            // Record field update
                            let val_str =
                                self.expr_to_rust_with_state(&spec.value.node, prefix_state);
                            result.push_str(&format!(
                                "    __tmp.{} = {};\n",
                                to_snake_case(&f.node),
                                val_str
                            ));
                        }
                    } else {
                        // Nested path: [f EXCEPT ![a][b] = v]
                        // For path [a, b], we need to:
                        // 1. Get inner value: f[a]
                        // 2. Update it: inner.update(b, v)
                        // 3. Update outer: f.update(a, inner)
                        let val_str = self.expr_to_rust_with_state(&spec.value.node, prefix_state);
                        let n = spec.path.len();

                        // Generate path element descriptors for code generation
                        #[derive(Clone)]
                        enum PathElem {
                            Index(String),
                            Field(String),
                        }

                        let path_elems: Vec<PathElem> = spec
                            .path
                            .iter()
                            .map(|elem| match elem {
                                ExceptPathElement::Index(idx) => PathElem::Index(
                                    self.expr_to_rust_with_state(&idx.node, prefix_state),
                                ),
                                ExceptPathElement::Field(f) => PathElem::Field(f.node.clone()),
                            })
                            .collect();

                        // Declare key variables for indices
                        for (i, elem) in path_elems.iter().enumerate() {
                            if let PathElem::Index(idx_str) = elem {
                                result.push_str(&format!("    let __key_{} = {};\n", i, idx_str));
                            }
                        }

                        // Navigate down the path, extracting intermediate values
                        // __inner_0 is the first level down from __tmp
                        for (i, elem) in path_elems.iter().enumerate().take(n - 1) {
                            let prev = if i == 0 {
                                "__tmp".to_string()
                            } else {
                                format!("__inner_{}", i - 1)
                            };

                            let accessor = match elem {
                                PathElem::Index(_) => {
                                    format!("{}.apply(&__key_{}).cloned().unwrap()", prev, i)
                                }
                                PathElem::Field(f) => {
                                    format!("{}.get(\"{}\").cloned().unwrap()", prev, f)
                                }
                            };
                            result.push_str(&format!("    let __inner_{} = {};\n", i, accessor));
                        }

                        // Update the innermost value
                        let inner_idx = n - 2;
                        let update_code =
                            match &path_elems[n - 1] {
                                PathElem::Index(_) => {
                                    format!(
                                    "{{ let mut __t = __inner_{}; __t.update(__key_{}, {}); __t }}",
                                    inner_idx, n - 1, val_str
                                )
                                }
                                PathElem::Field(f) => {
                                    format!(
                                        "{{ let mut __t = __inner_{}; __t.set(\"{}\", {}); __t }}",
                                        inner_idx, f, val_str
                                    )
                                }
                            };
                        result.push_str(&format!(
                            "    let __inner_{} = {};\n",
                            inner_idx, update_code
                        ));

                        // Propagate updates back up the chain
                        for i in (0..inner_idx).rev() {
                            let update_code = match &path_elems[i + 1] {
                                PathElem::Index(_) => {
                                    format!(
                                        "{{ let mut __t = __inner_{}; __t.update(__key_{}, __inner_{}); __t }}",
                                        i, i + 1, i + 1
                                    )
                                }
                                PathElem::Field(f) => {
                                    format!(
                                        "{{ let mut __t = __inner_{}; __t.set(\"{}\", __inner_{}); __t }}",
                                        i, f, i + 1
                                    )
                                }
                            };
                            result.push_str(&format!("    let __inner_{} = {};\n", i, update_code));
                        }

                        // Final update to __tmp
                        let final_update = match &path_elems[0] {
                            PathElem::Index(_) => {
                                "    __tmp.update(__key_0, __inner_0);\n".to_string()
                            }
                            PathElem::Field(f) => {
                                format!("    __tmp.set(\"{}\", __inner_0);\n", f)
                            }
                        };
                        result.push_str(&final_update);
                    }
                }
                result.push_str("    __tmp\n}");
                result
            }

            // Quantifiers
            // \A x \in S : P(x) -> S.iter().all(|x| P(x))
            Expr::Forall(bounds, body) => {
                if bounds.len() == 1 {
                    let bound = &bounds[0];
                    let var_name = to_snake_case(&bound.name.node);
                    let domain_str = bound
                        .domain
                        .as_ref()
                        .map(|s| self.expr_to_rust_with_state(&s.node, prefix_state))
                        .unwrap_or_else(|| "/* no domain */".to_string());
                    let body_str = self.expr_to_rust_with_state(&body.node, prefix_state);
                    format!("{}.iter().all(|{}| {})", domain_str, var_name, body_str)
                } else {
                    // Multiple bound variables: \A x \in S, y \in T : P(x, y)
                    // -> S.iter().all(|x| T.iter().all(|y| P(x, y)))
                    let mut result = String::new();
                    for bound in bounds {
                        let var_name = to_snake_case(&bound.name.node);
                        let domain_str = bound
                            .domain
                            .as_ref()
                            .map(|s| self.expr_to_rust_with_state(&s.node, prefix_state))
                            .unwrap_or_else(|| "/* no domain */".to_string());
                        result.push_str(&format!("{}.iter().all(|{}| ", domain_str, var_name));
                    }
                    result.push_str(&self.expr_to_rust_with_state(&body.node, prefix_state));
                    for _ in bounds {
                        result.push(')');
                    }
                    result
                }
            }

            // \E x \in S : P(x) -> S.iter().any(|x| P(x))
            Expr::Exists(bounds, body) => {
                if bounds.len() == 1 {
                    let bound = &bounds[0];
                    let var_name = to_snake_case(&bound.name.node);
                    let domain_str = bound
                        .domain
                        .as_ref()
                        .map(|s| self.expr_to_rust_with_state(&s.node, prefix_state))
                        .unwrap_or_else(|| "/* no domain */".to_string());
                    let body_str = self.expr_to_rust_with_state(&body.node, prefix_state);
                    format!("{}.iter().any(|{}| {})", domain_str, var_name, body_str)
                } else {
                    // Multiple bound variables: \E x \in S, y \in T : P(x, y)
                    // -> S.iter().any(|x| T.iter().any(|y| P(x, y)))
                    let mut result = String::new();
                    for bound in bounds {
                        let var_name = to_snake_case(&bound.name.node);
                        let domain_str = bound
                            .domain
                            .as_ref()
                            .map(|s| self.expr_to_rust_with_state(&s.node, prefix_state))
                            .unwrap_or_else(|| "/* no domain */".to_string());
                        result.push_str(&format!("{}.iter().any(|{}| ", domain_str, var_name));
                    }
                    result.push_str(&self.expr_to_rust_with_state(&body.node, prefix_state));
                    for _ in bounds {
                        result.push(')');
                    }
                    result
                }
            }

            // CHOOSE x \in S : P(x) -> find first x in S satisfying P
            Expr::Choose(bound, pred) => {
                let var_name = to_snake_case(&bound.name.node);
                let domain_str = bound
                    .domain
                    .as_ref()
                    .map(|s| self.expr_to_rust_with_state(&s.node, prefix_state))
                    .unwrap_or_else(|| "/* no domain */".to_string());
                let pred_str = self.expr_to_rust_with_state(&pred.node, prefix_state);
                format!(
                    "{}.iter().find(|{}| {}).cloned().expect(\"CHOOSE: no element satisfies predicate\")",
                    domain_str, var_name, pred_str
                )
            }

            // Set builder: {expr : x \in S} -> S.iter().map(|x| expr).collect()
            Expr::SetBuilder(body, bounds) => {
                if bounds.len() == 1 {
                    let bound = &bounds[0];
                    let var_name = to_snake_case(&bound.name.node);
                    let domain_str = bound
                        .domain
                        .as_ref()
                        .map(|s| self.expr_to_rust_with_state(&s.node, prefix_state))
                        .unwrap_or_else(|| "/* no domain */".to_string());
                    let body_str = self.expr_to_rust_with_state(&body.node, prefix_state);
                    format!(
                        "TlaSet::from_iter({}.iter().map(|{}| {}))",
                        domain_str, var_name, body_str
                    )
                } else {
                    // Multiple bound variables: {expr : x \in S, y \in T}
                    // -> flat_map for Cartesian product
                    let mut iter_chain = String::new();
                    let mut vars = Vec::new();
                    for (i, bound) in bounds.iter().enumerate() {
                        let var_name = to_snake_case(&bound.name.node);
                        vars.push(var_name.clone());
                        let domain_str = bound
                            .domain
                            .as_ref()
                            .map(|s| self.expr_to_rust_with_state(&s.node, prefix_state))
                            .unwrap_or_else(|| "/* no domain */".to_string());
                        if i == 0 {
                            iter_chain.push_str(&format!(
                                "{}.iter().flat_map(|{}| ",
                                domain_str, var_name
                            ));
                        } else if i == bounds.len() - 1 {
                            iter_chain
                                .push_str(&format!("{}.iter().map(|{}| ", domain_str, var_name));
                        } else {
                            iter_chain.push_str(&format!(
                                "{}.iter().flat_map(|{}| ",
                                domain_str, var_name
                            ));
                        }
                    }
                    let body_str = self.expr_to_rust_with_state(&body.node, prefix_state);
                    iter_chain.push_str(&body_str);
                    for _ in bounds {
                        iter_chain.push(')');
                    }
                    format!("TlaSet::from_iter({})", iter_chain)
                }
            }

            // Set filter: {x \in S : P(x)} -> S.iter().filter(|x| P(x)).collect()
            Expr::SetFilter(bound, pred) => {
                let var_name = to_snake_case(&bound.name.node);
                let domain_str = bound
                    .domain
                    .as_ref()
                    .map(|s| self.expr_to_rust_with_state(&s.node, prefix_state))
                    .unwrap_or_else(|| "/* no domain */".to_string());
                let pred_str = self.expr_to_rust_with_state(&pred.node, prefix_state);
                format!(
                    "TlaSet::from_iter({}.iter().filter(|{}| {}).cloned())",
                    domain_str, var_name, pred_str
                )
            }

            // LET x == e1 IN e2 -> { let x = e1; e2 }
            Expr::Let(defs, body) => {
                let mut result = "{\n".to_string();
                for def in defs {
                    let name = to_snake_case(&def.name.node);
                    if def.params.is_empty() {
                        // Simple let binding
                        let val_str = self.expr_to_rust_with_state(&def.body.node, prefix_state);
                        result.push_str(&format!("    let {} = {};\n", name, val_str));
                    } else {
                        // Function definition in LET
                        let params: Vec<_> = def
                            .params
                            .iter()
                            .map(|p| format!("{}: _", to_snake_case(&p.name.node)))
                            .collect();
                        let body_str = self.expr_to_rust_with_state(&def.body.node, prefix_state);
                        result.push_str(&format!(
                            "    let {} = |{}| {};\n",
                            name,
                            params.join(", "),
                            body_str
                        ));
                    }
                }
                let body_str = self.expr_to_rust_with_state(&body.node, prefix_state);
                result.push_str(&format!("    {}\n}}", body_str));
                result
            }

            // CASE arm1 [] arm2 [] OTHER -> expr
            // -> if cond1 { e1 } else if cond2 { e2 } else { default }
            Expr::Case(arms, other) => {
                let mut result = String::new();
                for (i, arm) in arms.iter().enumerate() {
                    let cond_str = self.expr_to_rust_with_state(&arm.guard.node, prefix_state);
                    let body_str = self.expr_to_rust_with_state(&arm.body.node, prefix_state);
                    if i == 0 {
                        result.push_str(&format!("if {} {{ {} }}", cond_str, body_str));
                    } else {
                        result.push_str(&format!(" else if {} {{ {} }}", cond_str, body_str));
                    }
                }
                if let Some(default) = other {
                    let default_str = self.expr_to_rust_with_state(&default.node, prefix_state);
                    result.push_str(&format!(" else {{ {} }}", default_str));
                } else {
                    result.push_str(" else { panic!(\"CASE: no matching arm\") }");
                }
                result
            }

            // Cartesian product: S \X T -> cross product enumeration
            Expr::Times(sets) => {
                if sets.len() == 2 {
                    let left_str = self.expr_to_rust_with_state(&sets[0].node, prefix_state);
                    let right_str = self.expr_to_rust_with_state(&sets[1].node, prefix_state);
                    format!(
                        "TlaSet::from_iter({}.iter().flat_map(|__a| {}.iter().map(move |__b| (__a.clone(), __b.clone()))))",
                        left_str, right_str
                    )
                } else {
                    // For more than 2 sets, nest the products
                    let first_str = self.expr_to_rust_with_state(&sets[0].node, prefix_state);
                    let mut result = first_str;
                    for (i, set) in sets.iter().enumerate().skip(1) {
                        let set_str = self.expr_to_rust_with_state(&set.node, prefix_state);
                        result = format!(
                            "TlaSet::from_iter({}.iter().flat_map(|__a{}| {}.iter().map(move |__b{}| (__a{}.clone(), __b{}.clone()))))",
                            result, i, set_str, i, i, i
                        );
                    }
                    result
                }
            }

            // BigUnion: UNION S -> flatten a set of sets
            Expr::BigUnion(s) => {
                format!(
                    "TlaSet::from_iter({}.iter().flat_map(|__s| __s.iter().cloned()))",
                    self.expr_to_rust_with_state(&s.node, prefix_state)
                )
            }

            // Lambda: LAMBDA x, y : body -> closure
            Expr::Lambda(params, body) => {
                let param_strs: Vec<_> = params
                    .iter()
                    .map(|p| format!("{}: _", to_snake_case(&p.node)))
                    .collect();
                let body_str = self.expr_to_rust_with_state(&body.node, prefix_state);
                format!("|{}| {}", param_strs.join(", "), body_str)
            }

            // Default - generate a placeholder
            _ => format!("/* unsupported: {:?} */", std::mem::discriminant(expr)),
        }
    }

    /// Translate a stdlib operator application to Rust
    fn translate_stdlib_apply(
        &self,
        name: &str,
        args: &[Spanned<Expr>],
        prefix_state: bool,
    ) -> String {
        let arg = |i: usize| -> String {
            args.get(i)
                .map(|a| self.expr_to_rust_with_state(&a.node, prefix_state))
                .unwrap_or_else(|| "/* missing arg */".to_string())
        };

        match name {
            // ===== Sequences (Sequences module) =====
            // Len(s) - length of sequence
            "Len" => format!("({}.len() as i64)", arg(0)),
            // Head(s) - first element
            "Head" => format!("{}.first().cloned().unwrap()", arg(0)),
            // Tail(s) - all but first element
            "Tail" => format!("{}.into_iter().skip(1).collect::<Vec<_>>()", arg(0)),
            // Append(s, e) - append element to sequence
            "Append" => {
                format!("{{ let mut v = {}.clone(); v.push({}); v }}", arg(0), arg(1))
            }
            // SubSeq(s, m, n) - subsequence from index m to n (TLA+ is 1-indexed)
            "SubSeq" => {
                format!(
                    "{}[({} - 1) as usize..{} as usize].to_vec()",
                    arg(0),
                    arg(1),
                    arg(2)
                )
            }
            // Seq(S) - set of all sequences over S (placeholder - can't enumerate infinite set)
            "Seq" => format!("/* Seq({}) - infinite set */", arg(0)),
            // SelectSeq(s, Test) - filter sequence by predicate
            "SelectSeq" => {
                format!(
                    "{}.into_iter().filter(|x| {}(x.clone())).collect::<Vec<_>>()",
                    arg(0),
                    arg(1)
                )
            }

            // ===== FiniteSets module =====
            // Cardinality(S) - number of elements in set
            "Cardinality" => format!("({}.len() as i64)", arg(0)),
            // IsFiniteSet(S) - always true for our finite sets
            "IsFiniteSet" => "true".to_string(),

            // ===== TLC module =====
            // Print(out, val) - print and return val
            "Print" => format!("{{ println!(\"{{}}\", {}); {} }}", arg(0), arg(1)),
            // PrintT(out) - print and return TRUE
            "PrintT" => format!("{{ println!(\"{{}}\", {}); true }}", arg(0)),
            // Assert(val, out) - assert val is true
            "Assert" => format!("{{ assert!({}, \"{{}}\", {}); true }}", arg(0), arg(1)),
            // ToString(v) - convert value to string
            "ToString" => format!("format!(\"{{:?}}\", {})", arg(0)),
            // JavaTime - current time in milliseconds
            "JavaTime" => {
                "std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_millis() as i64".to_string()
            }

            // ===== SequencesExt module (community) =====
            // Reverse(s) - reverse sequence
            "Reverse" => {
                format!(
                    "{{ let mut v = {}.clone(); v.reverse(); v }}",
                    arg(0)
                )
            }
            // Front(s) - all but last element
            "Front" => format!("{}[..{}.len() - 1].to_vec()", arg(0), arg(0)),
            // Last(s) - last element
            "Last" => format!("{}.last().cloned().unwrap()", arg(0)),
            // Cons(e, s) - prepend element
            "Cons" => {
                format!(
                    "{{ let mut v = vec![{}]; v.extend({}.clone()); v }}",
                    arg(0),
                    arg(1)
                )
            }
            // Contains(s, e) - check if sequence contains element
            "Contains" => format!("{}.contains(&{})", arg(0), arg(1)),
            // ToSet(s) or Range(s) - convert sequence to set
            "ToSet" | "Range" if args.len() == 1 => {
                format!("{}.iter().cloned().collect::<TlaSet<_>>()", arg(0))
            }
            // Indices(s) - 1..Len(s)
            "Indices" => format!("range_set(1, {}.len() as i64)", arg(0)),

            // ===== FiniteSetsExt module (community) =====
            // Max(S) - maximum element of set
            "Max" => format!("{}.iter().max().cloned().unwrap()", arg(0)),
            // Min(S) - minimum element of set
            "Min" => format!("{}.iter().min().cloned().unwrap()", arg(0)),
            // Sum(S) - sum of set elements
            "Sum" => format!("{}.iter().sum::<i64>()", arg(0)),
            // Product(S) - product of set elements
            "Product" => format!("{}.iter().product::<i64>()", arg(0)),
            // SymDiff(S, T) - symmetric difference
            "SymDiff" => {
                format!(
                    "{}.difference(&{}).union(&{}.difference(&{}))",
                    arg(0),
                    arg(1),
                    arg(1),
                    arg(0)
                )
            }
            // Flatten(SS) - union of sets of sets
            "Flatten" => {
                format!(
                    "{}.iter().fold(TlaSet::new(), |acc, s| acc.union(s))",
                    arg(0)
                )
            }
            // Choose(S) - arbitrary element from set (returns first in sorted order)
            "Choose" if args.len() == 1 => {
                format!("{}.iter().next().cloned().unwrap()", arg(0))
            }

            // ===== Functions module (community) =====
            // Restrict(f, S) - restrict function domain to S
            "Restrict" => {
                format!(
                    "{}.iter().filter(|(k, _)| {}.contains(k)).cloned().collect::<TlaFunc<_, _>>()",
                    arg(0),
                    arg(1)
                )
            }
            // IsInjective(f) - check if function is injective
            "IsInjective" => {
                format!(
                    "{{ let vals: Vec<_> = {}.iter().map(|(_, v)| v).collect(); vals.len() == vals.iter().collect::<std::collections::HashSet<_>>().len() }}",
                    arg(0)
                )
            }

            // ===== Bags module =====
            // EmptyBag - empty multiset
            "EmptyBag" => "TlaFunc::new()".to_string(),

            // ===== Unknown operator - generate fallback =====
            _ => {
                let args_str: Vec<_> = args
                    .iter()
                    .map(|a| self.expr_to_rust_with_state(&a.node, prefix_state))
                    .collect();
                format!("/* {}({}) */", name, args_str.join(", "))
            }
        }
    }

    fn emit_invariant_method(
        &mut self,
        inv: &OperatorDef,
        struct_name: &str,
    ) -> Result<(), String> {
        writeln!(
            self.out,
            "    fn check_{}(&self, state: &{}State) -> bool {{",
            to_snake_case(&inv.name.node),
            struct_name,
        )
        .unwrap();

        // Translate the invariant body expression
        let expanded = self.expand_operators(&inv.body.node);
        let inv_expr = self.expr_to_rust_with_state(&expanded, true);
        writeln!(self.out, "        {}", inv_expr).unwrap();
        writeln!(self.out, "    }}").unwrap();
        Ok(())
    }

    fn emit_proptest(&mut self, name: &str, invariants: &[&OperatorDef]) -> Result<(), String> {
        let struct_name = to_pascal_case(name);

        writeln!(self.out).unwrap();
        writeln!(self.out, "#[cfg(test)]").unwrap();
        writeln!(self.out, "mod tests {{").unwrap();
        writeln!(self.out, "    use super::*;").unwrap();
        writeln!(self.out, "    use std::collections::HashSet;").unwrap();
        writeln!(self.out).unwrap();

        // Test init produces at least one state
        writeln!(self.out, "    #[test]").unwrap();
        writeln!(self.out, "    fn test_init_not_empty() {{").unwrap();
        writeln!(self.out, "        let machine = {};", struct_name).unwrap();
        writeln!(self.out, "        let init_states = machine.init();").unwrap();
        writeln!(
            self.out,
            "        assert!(!init_states.is_empty(), \"Init should produce at least one state\");"
        )
        .unwrap();
        writeln!(self.out, "    }}").unwrap();
        writeln!(self.out).unwrap();

        // Test invariants hold in initial states
        if !invariants.is_empty() {
            writeln!(self.out, "    #[test]").unwrap();
            writeln!(self.out, "    fn test_init_satisfies_invariants() {{").unwrap();
            writeln!(self.out, "        let machine = {};", struct_name).unwrap();
            writeln!(self.out, "        let init_states = machine.init();").unwrap();
            writeln!(self.out, "        for state in &init_states {{").unwrap();
            writeln!(
                self.out,
                "            if let Some(ok) = machine.check_invariant(state) {{"
            )
            .unwrap();
            writeln!(self.out, "                assert!(ok, \"Invariant violated in initial state: {{:?}}\", state);").unwrap();
            writeln!(self.out, "            }}").unwrap();
            writeln!(self.out, "        }}").unwrap();
            writeln!(self.out, "    }}").unwrap();
            writeln!(self.out).unwrap();
        }

        // Test bounded BFS exploration
        writeln!(self.out, "    #[test]").unwrap();
        writeln!(self.out, "    fn test_bounded_exploration() {{").unwrap();
        writeln!(self.out, "        let machine = {};", struct_name).unwrap();
        writeln!(
            self.out,
            "        let mut seen: HashSet<{}State> = HashSet::new();",
            struct_name
        )
        .unwrap();
        writeln!(self.out, "        let mut frontier = machine.init();").unwrap();
        writeln!(self.out).unwrap();
        writeln!(self.out, "        // Explore up to 1000 states").unwrap();
        writeln!(self.out, "        let max_states = 1000;").unwrap();
        writeln!(self.out, "        let mut total_states = 0;").unwrap();
        writeln!(self.out).unwrap();
        writeln!(
            self.out,
            "        while !frontier.is_empty() && total_states < max_states {{"
        )
        .unwrap();
        writeln!(self.out, "            let state = frontier.pop().unwrap();").unwrap();
        writeln!(self.out, "            if seen.contains(&state) {{").unwrap();
        writeln!(self.out, "                continue;").unwrap();
        writeln!(self.out, "            }}").unwrap();
        writeln!(self.out, "            seen.insert(state.clone());").unwrap();
        writeln!(self.out, "            total_states += 1;").unwrap();
        writeln!(self.out).unwrap();

        if !invariants.is_empty() {
            writeln!(self.out, "            // Check invariant").unwrap();
            writeln!(
                self.out,
                "            if let Some(ok) = machine.check_invariant(&state) {{"
            )
            .unwrap();
            writeln!(
                self.out,
                "                assert!(ok, \"Invariant violated in state: {{:?}}\", state);"
            )
            .unwrap();
            writeln!(self.out, "            }}").unwrap();
            writeln!(self.out).unwrap();
        }

        writeln!(self.out, "            // Generate successors").unwrap();
        writeln!(
            self.out,
            "            let next_states = machine.next(&state);"
        )
        .unwrap();
        writeln!(self.out, "            frontier.extend(next_states);").unwrap();
        writeln!(self.out, "        }}").unwrap();
        writeln!(self.out).unwrap();
        writeln!(
            self.out,
            "        println!(\"Explored {{}} states\", total_states);"
        )
        .unwrap();
        writeln!(self.out, "    }}").unwrap();

        // Test one-step invariant preservation (for each initial state)
        if !invariants.is_empty() {
            writeln!(self.out).unwrap();
            writeln!(self.out, "    #[test]").unwrap();
            writeln!(self.out, "    fn test_next_preserves_invariants() {{").unwrap();
            writeln!(self.out, "        let machine = {};", struct_name).unwrap();
            writeln!(self.out, "        let init_states = machine.init();").unwrap();
            writeln!(self.out).unwrap();
            writeln!(self.out, "        for state in &init_states {{").unwrap();
            writeln!(
                self.out,
                "            let next_states = machine.next(state);"
            )
            .unwrap();
            writeln!(self.out, "            for next_state in &next_states {{").unwrap();
            writeln!(
                self.out,
                "                if let Some(ok) = machine.check_invariant(next_state) {{"
            )
            .unwrap();
            writeln!(self.out, "                    assert!(ok, \"Invariant violated after transition: {{:?}} -> {{:?}}\", state, next_state);").unwrap();
            writeln!(self.out, "                }}").unwrap();
            writeln!(self.out, "            }}").unwrap();
            writeln!(self.out, "        }}").unwrap();
            writeln!(self.out, "    }}").unwrap();
        }

        writeln!(self.out, "}}").unwrap();
        Ok(())
    }

    fn emit_kani_harness(&mut self, name: &str, invariants: &[&OperatorDef]) -> Result<(), String> {
        let struct_name = to_pascal_case(name);

        writeln!(self.out).unwrap();
        writeln!(self.out, "#[cfg(kani)]").unwrap();
        writeln!(self.out, "mod kani_proofs {{").unwrap();
        writeln!(self.out, "    use super::*;").unwrap();
        writeln!(self.out).unwrap();

        // Proof that all initial states satisfy invariants
        writeln!(self.out, "    #[kani::proof]").unwrap();
        writeln!(self.out, "    fn init_satisfies_invariants() {{").unwrap();
        writeln!(self.out, "        let machine = {};", struct_name).unwrap();
        writeln!(self.out, "        let init_states = machine.init();").unwrap();
        writeln!(self.out, "        for state in &init_states {{").unwrap();
        writeln!(
            self.out,
            "            if let Some(ok) = machine.check_invariant(state) {{"
        )
        .unwrap();
        writeln!(
            self.out,
            "                kani::assert(ok, \"Invariant violated in initial state\");"
        )
        .unwrap();
        writeln!(self.out, "            }}").unwrap();
        writeln!(self.out, "        }}").unwrap();
        writeln!(self.out, "    }}").unwrap();
        writeln!(self.out).unwrap();

        // Proof that invariants are preserved by Next
        writeln!(self.out, "    #[kani::proof]").unwrap();
        writeln!(self.out, "    #[kani::unwind(5)]").unwrap();
        writeln!(self.out, "    fn next_preserves_invariants() {{").unwrap();
        writeln!(self.out, "        let machine = {};", struct_name).unwrap();
        writeln!(self.out, "        let init_states = machine.init();").unwrap();
        writeln!(self.out, "        if init_states.is_empty() {{ return; }}").unwrap();
        writeln!(self.out).unwrap();
        writeln!(
            self.out,
            "        // Check that if invariant holds in state, it holds in next states"
        )
        .unwrap();
        writeln!(self.out, "        let idx: usize = kani::any();").unwrap();
        writeln!(self.out, "        kani::assume(idx < init_states.len());").unwrap();
        writeln!(self.out, "        let state = &init_states[idx];").unwrap();
        writeln!(self.out).unwrap();
        writeln!(
            self.out,
            "        // Assume invariant holds in current state"
        )
        .unwrap();
        writeln!(
            self.out,
            "        if let Some(ok) = machine.check_invariant(state) {{"
        )
        .unwrap();
        writeln!(self.out, "            kani::assume(ok);").unwrap();
        writeln!(self.out, "        }}").unwrap();
        writeln!(self.out).unwrap();
        writeln!(
            self.out,
            "        // Check invariant holds in all next states"
        )
        .unwrap();
        writeln!(self.out, "        let next_states = machine.next(state);").unwrap();
        writeln!(self.out, "        for next_state in &next_states {{").unwrap();
        writeln!(
            self.out,
            "            if let Some(ok) = machine.check_invariant(next_state) {{"
        )
        .unwrap();
        writeln!(
            self.out,
            "                kani::assert(ok, \"Invariant violated after transition\");"
        )
        .unwrap();
        writeln!(self.out, "            }}").unwrap();
        writeln!(self.out, "        }}").unwrap();
        writeln!(self.out, "    }}").unwrap();

        // Generate individual invariant proofs
        for inv in invariants {
            let inv_name = to_snake_case(&inv.name.node);
            writeln!(self.out).unwrap();
            writeln!(self.out, "    #[kani::proof]").unwrap();
            writeln!(self.out, "    fn {}_holds_initially() {{", inv_name).unwrap();
            writeln!(self.out, "        let machine = {};", struct_name).unwrap();
            writeln!(self.out, "        let init_states = machine.init();").unwrap();
            writeln!(self.out, "        for state in &init_states {{").unwrap();
            writeln!(
                self.out,
                "            kani::assert(machine.check_{}(state), \"{} violated\");",
                inv_name, inv.name.node
            )
            .unwrap();
            writeln!(self.out, "        }}").unwrap();
            writeln!(self.out, "    }}").unwrap();
        }

        writeln!(self.out, "}}").unwrap();
        Ok(())
    }
}

/// Convert to PascalCase
fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;
    for c in s.chars() {
        if c == '_' || c == '-' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }
    result
}

/// Convert to snake_case
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() && i > 0 {
            result.push('_');
        }
        result.push(c.to_ascii_lowercase());
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;
    use tla_core::span::{FileId, Span, Spanned};

    fn make_span() -> Span {
        Span::new(FileId(0), 0, 0)
    }

    fn spanned<T>(node: T) -> Spanned<T> {
        Spanned::new(node, make_span())
    }

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("hello_world"), "HelloWorld");
        assert_eq!(to_pascal_case("Counter"), "Counter");
        assert_eq!(to_pascal_case("my_spec"), "MySpec");
    }

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("HelloWorld"), "hello_world");
        assert_eq!(to_snake_case("Counter"), "counter");
        assert_eq!(to_snake_case("MySpec"), "my_spec");
    }

    #[test]
    fn test_expr_to_rust_literals() {
        let emitter = RustEmitter {
            out: &mut String::new(),
            var_types: &std::collections::HashMap::new(),
            op_defs: &std::collections::HashMap::new(),
            indent: 0,
        };

        assert_eq!(emitter.expr_to_rust(&Expr::Bool(true)), "true");
        assert_eq!(emitter.expr_to_rust(&Expr::Bool(false)), "false");
        assert_eq!(emitter.expr_to_rust(&Expr::Int(42.into())), "42_i64");
        assert_eq!(
            emitter.expr_to_rust(&Expr::String("hello".to_string())),
            "\"hello\".to_string()"
        );
    }

    #[test]
    fn test_expr_to_rust_arithmetic() {
        let emitter = RustEmitter {
            out: &mut String::new(),
            var_types: &std::collections::HashMap::new(),
            op_defs: &std::collections::HashMap::new(),
            indent: 0,
        };

        let add = Expr::Add(
            Box::new(spanned(Expr::Int(1.into()))),
            Box::new(spanned(Expr::Int(2.into()))),
        );
        assert_eq!(emitter.expr_to_rust(&add), "(1_i64 + 2_i64)");

        let mul = Expr::Mul(
            Box::new(spanned(Expr::Ident("x".to_string()))),
            Box::new(spanned(Expr::Int(3.into()))),
        );
        assert_eq!(emitter.expr_to_rust(&mul), "(x * 3_i64)");
    }

    #[test]
    fn test_expr_to_rust_logic() {
        let emitter = RustEmitter {
            out: &mut String::new(),
            var_types: &std::collections::HashMap::new(),
            op_defs: &std::collections::HashMap::new(),
            indent: 0,
        };

        let and = Expr::And(
            Box::new(spanned(Expr::Bool(true))),
            Box::new(spanned(Expr::Bool(false))),
        );
        assert_eq!(emitter.expr_to_rust(&and), "(true && false)");

        let not = Expr::Not(Box::new(spanned(Expr::Bool(true))));
        assert_eq!(emitter.expr_to_rust(&not), "!true");
    }

    #[test]
    fn test_expr_to_rust_sets() {
        let emitter = RustEmitter {
            out: &mut String::new(),
            var_types: &std::collections::HashMap::new(),
            op_defs: &std::collections::HashMap::new(),
            indent: 0,
        };

        let set = Expr::SetEnum(vec![
            spanned(Expr::Int(1.into())),
            spanned(Expr::Int(2.into())),
        ]);
        assert_eq!(emitter.expr_to_rust(&set), "tla_set![1_i64, 2_i64]");

        let range = Expr::Range(
            Box::new(spanned(Expr::Int(1.into()))),
            Box::new(spanned(Expr::Int(10.into()))),
        );
        assert_eq!(emitter.expr_to_rust(&range), "range_set(1_i64, 10_i64)");
    }

    #[test]
    fn test_expr_to_rust_with_state() {
        let mut var_types = std::collections::HashMap::new();
        var_types.insert("count".to_string(), TlaType::Int);

        let emitter = RustEmitter {
            out: &mut String::new(),
            var_types: &var_types,
            op_defs: &std::collections::HashMap::new(),
            indent: 0,
        };

        // Without state prefix
        assert_eq!(
            emitter.expr_to_rust(&Expr::Ident("count".to_string())),
            "count"
        );

        // With state prefix
        assert_eq!(
            emitter.expr_to_rust_with_state(&Expr::Ident("count".to_string()), true),
            "state.count"
        );
    }

    #[test]
    fn test_generate_simple_counter() {
        use tla_core::ast::{Module, OperatorDef, Unit};

        // Build a simple counter spec:
        // VARIABLE count
        // Init == count = 0
        // Next == count' = count + 1

        let init_body = Expr::Eq(
            Box::new(spanned(Expr::Ident("count".to_string()))),
            Box::new(spanned(Expr::Int(0.into()))),
        );

        let next_body = Expr::Eq(
            Box::new(spanned(Expr::Prime(Box::new(spanned(Expr::Ident(
                "count".to_string(),
            )))))),
            Box::new(spanned(Expr::Add(
                Box::new(spanned(Expr::Ident("count".to_string()))),
                Box::new(spanned(Expr::Int(1.into()))),
            ))),
        );

        let module = Module {
            name: spanned("Counter".to_string()),
            extends: vec![],
            units: vec![
                spanned(Unit::Variable(vec![spanned("count".to_string())])),
                spanned(Unit::Operator(OperatorDef {
                    name: spanned("Init".to_string()),
                    params: vec![],
                    body: spanned(init_body),
                    local: false,
                })),
                spanned(Unit::Operator(OperatorDef {
                    name: spanned("Next".to_string()),
                    params: vec![],
                    body: spanned(next_body),
                    local: false,
                })),
            ],
            span: make_span(),
        };

        let options = CodeGenOptions::default();
        let result = generate_rust(&module, &options).unwrap();

        // Check that the generated code contains expected elements
        assert!(result.contains("pub struct CounterState"));
        assert!(result.contains("pub count: i64"));
        assert!(result.contains("impl StateMachine for Counter"));
        assert!(result.contains("fn init(&self)"));
        assert!(result.contains("fn next(&self, state: &Self::State)"));
    }

    #[test]
    fn test_generate_with_invariant() {
        use tla_core::ast::{Module, OperatorDef, Unit};

        let inv_body = Expr::Geq(
            Box::new(spanned(Expr::Ident("count".to_string()))),
            Box::new(spanned(Expr::Int(0.into()))),
        );

        let init_body = Expr::Eq(
            Box::new(spanned(Expr::Ident("count".to_string()))),
            Box::new(spanned(Expr::Int(0.into()))),
        );

        let module = Module {
            name: spanned("Counter".to_string()),
            extends: vec![],
            units: vec![
                spanned(Unit::Variable(vec![spanned("count".to_string())])),
                spanned(Unit::Operator(OperatorDef {
                    name: spanned("Init".to_string()),
                    params: vec![],
                    body: spanned(init_body),
                    local: false,
                })),
                spanned(Unit::Operator(OperatorDef {
                    name: spanned("InvNonNegative".to_string()),
                    params: vec![],
                    body: spanned(inv_body),
                    local: false,
                })),
            ],
            span: make_span(),
        };

        let options = CodeGenOptions::default();
        let result = generate_rust(&module, &options).unwrap();

        // Check that invariant method is generated
        assert!(result.contains("fn check_inv_non_negative(&self, state: &CounterState) -> bool"));
        assert!(result.contains("(state.count >= 0_i64)"));
    }

    #[test]
    fn test_generate_with_kani() {
        use tla_core::ast::{Module, OperatorDef, Unit};

        let init_body = Expr::Eq(
            Box::new(spanned(Expr::Ident("x".to_string()))),
            Box::new(spanned(Expr::Int(0.into()))),
        );

        let module = Module {
            name: spanned("Simple".to_string()),
            extends: vec![],
            units: vec![
                spanned(Unit::Variable(vec![spanned("x".to_string())])),
                spanned(Unit::Operator(OperatorDef {
                    name: spanned("Init".to_string()),
                    params: vec![],
                    body: spanned(init_body),
                    local: false,
                })),
            ],
            span: make_span(),
        };

        let options = CodeGenOptions {
            module_name: None,
            generate_proptest: false,
            generate_kani: true,
        };
        let result = generate_rust(&module, &options).unwrap();

        // Check that Kani proofs are generated
        assert!(result.contains("#[cfg(kani)]"));
        assert!(result.contains("mod kani_proofs"));
        assert!(result.contains("#[kani::proof]"));
        assert!(result.contains("fn init_satisfies_invariants()"));
        assert!(result.contains("fn next_preserves_invariants()"));
    }

    #[test]
    fn test_init_nondeterministic() {
        use tla_core::ast::{Module, OperatorDef, Unit};

        // Init == x \in 1..3
        let init_body = Expr::In(
            Box::new(spanned(Expr::Ident("x".to_string()))),
            Box::new(spanned(Expr::Range(
                Box::new(spanned(Expr::Int(1.into()))),
                Box::new(spanned(Expr::Int(3.into()))),
            ))),
        );

        let module = Module {
            name: spanned("Nondet".to_string()),
            extends: vec![],
            units: vec![
                spanned(Unit::Variable(vec![spanned("x".to_string())])),
                spanned(Unit::Operator(OperatorDef {
                    name: spanned("Init".to_string()),
                    params: vec![],
                    body: spanned(init_body),
                    local: false,
                })),
            ],
            span: make_span(),
        };

        let options = CodeGenOptions::default();
        let result = generate_rust(&module, &options).unwrap();

        // Check that non-deterministic init generates a loop
        assert!(result.contains("for x in range_set(1_i64, 3_i64)"));
        assert!(result.contains("states.push("));
    }

    #[test]
    fn test_stdlib_apply_translation() {
        let emitter = RustEmitter {
            out: &mut String::new(),
            var_types: &std::collections::HashMap::new(),
            op_defs: &std::collections::HashMap::new(),
            indent: 0,
        };

        // Test Cardinality(s) - should translate to s.len() as i64
        let cardinality = Expr::Apply(
            Box::new(spanned(Expr::Ident("Cardinality".to_string()))),
            vec![spanned(Expr::Ident("s".to_string()))],
        );
        let result = emitter.expr_to_rust(&cardinality);
        assert!(result.contains(".len() as i64"), "Cardinality: {}", result);

        // Test Len(s) - should translate to s.len() as i64
        let len = Expr::Apply(
            Box::new(spanned(Expr::Ident("Len".to_string()))),
            vec![spanned(Expr::Ident("seq".to_string()))],
        );
        let result = emitter.expr_to_rust(&len);
        assert!(result.contains(".len() as i64"), "Len: {}", result);

        // Test Max(s) - should translate to .iter().max()
        let max = Expr::Apply(
            Box::new(spanned(Expr::Ident("Max".to_string()))),
            vec![spanned(Expr::Ident("s".to_string()))],
        );
        let result = emitter.expr_to_rust(&max);
        assert!(result.contains(".max()"), "Max: {}", result);

        // Test Head(s) - should translate to .first()
        let head = Expr::Apply(
            Box::new(spanned(Expr::Ident("Head".to_string()))),
            vec![spanned(Expr::Ident("seq".to_string()))],
        );
        let result = emitter.expr_to_rust(&head);
        assert!(result.contains(".first()"), "Head: {}", result);
    }
}
