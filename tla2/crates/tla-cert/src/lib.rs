//! TLA+ Proof Certificate Checker
//!
//! This crate provides a minimal, trusted proof certificate checker.
//! Proof certificates are generated by automated provers (Zenon, SMT solvers)
//! and can be independently verified by this checker.
//!
//! # Design Goals
//!
//! 1. **Minimal**: <2000 lines, easy to audit
//! 2. **Trusted**: Small trusted computing base
//! 3. **Independent**: Verifies proofs without trusting the prover
//!
//! # Certificate Format
//!
//! Certificates are sequences of proof steps, each justified by:
//! - Axioms (built-in logical rules)
//! - Previously proven steps (modus ponens, etc.)
//! - Definitions (from the specification)

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// A proof certificate that can be independently verified
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Certificate {
    /// Unique identifier for this proof
    pub id: String,
    /// The goal that was proven
    pub goal: Formula,
    /// Hypotheses assumed in the proof
    pub hypotheses: Vec<Formula>,
    /// The proof steps
    pub steps: Vec<CertificateStep>,
    /// Backend that generated this certificate
    pub backend: Backend,
}

/// A single step in a proof certificate
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CertificateStep {
    /// Unique ID for this step
    pub id: StepId,
    /// The formula established by this step
    pub formula: Formula,
    /// Justification for this step
    pub justification: Justification,
}

/// Identifier for a proof step
pub type StepId = u32;

/// Justification for a proof step
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Justification {
    /// An axiom (built-in logical truth)
    Axiom(Axiom),
    /// Hypothesis (assumed true)
    Hypothesis(usize),
    /// Modus ponens: from P and P => Q, derive Q
    ModusPonens {
        premise: StepId,
        implication: StepId,
    },
    /// Universal instantiation: from ∀x. P(x), derive P(t)
    UniversalInstantiation { forall: StepId, term: Term },
    /// Existential introduction: from P(t), derive ∃x. P(x)
    ExistentialIntro { witness: StepId, variable: String },
    /// Definition expansion
    Definition { name: String },
    /// Conjunction introduction: from P and Q, derive P ∧ Q
    AndIntro { left: StepId, right: StepId },
    /// Conjunction elimination (left): from P ∧ Q, derive P
    AndElimLeft { conjunction: StepId },
    /// Conjunction elimination (right): from P ∧ Q, derive Q
    AndElimRight { conjunction: StepId },
    /// Disjunction introduction (left): from P, derive P ∨ Q
    OrIntroLeft { premise: StepId, right: Formula },
    /// Disjunction introduction (right): from Q, derive P ∨ Q
    OrIntroRight { left: Formula, premise: StepId },
    /// Double negation elimination: from ¬¬P, derive P
    DoubleNegElim { premise: StepId },
    /// Rewrite using equality: from a = b and P(a), derive P(b)
    Rewrite { equality: StepId, target: StepId },
}

/// Built-in axioms
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Axiom {
    /// P ∨ ¬P (excluded middle)
    ExcludedMiddle(Formula),
    /// P → P (identity)
    Identity(Formula),
    /// P → (Q → P) (weakening)
    Weakening,
    /// a = a (reflexivity)
    EqualityRefl,
    /// a = b → b = a (symmetry)
    EqualitySym,
    /// a = b ∧ b = c → a = c (transitivity)
    EqualityTrans,
    /// Basic arithmetic axiom
    Arithmetic(ArithmeticAxiom),
    /// Set theory axiom
    SetTheory(SetAxiom),
}

/// Arithmetic axioms
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ArithmeticAxiom {
    /// 0 + a = a
    AddZero,
    /// a + b = b + a
    AddComm,
    /// (a + b) + c = a + (b + c)
    AddAssoc,
    /// a * 1 = a
    MulOne,
    /// a * 0 = 0
    MulZero,
}

/// Set theory axioms
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SetAxiom {
    /// x ∈ {} ↔ FALSE
    EmptySet,
    /// x ∈ {a} ↔ x = a
    Singleton,
    /// x ∈ S ∪ T ↔ x ∈ S ∨ x ∈ T
    Union,
    /// x ∈ S ∩ T ↔ x ∈ S ∧ x ∈ T
    Intersection,
}

/// First-order formula
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Formula {
    /// Propositional constant
    Bool(bool),
    /// Predicate application
    Predicate(String, Vec<Term>),
    /// Negation
    Not(Box<Formula>),
    /// Conjunction
    And(Box<Formula>, Box<Formula>),
    /// Disjunction
    Or(Box<Formula>, Box<Formula>),
    /// Implication
    Implies(Box<Formula>, Box<Formula>),
    /// Equivalence
    Equiv(Box<Formula>, Box<Formula>),
    /// Universal quantification
    Forall(String, Box<Formula>),
    /// Existential quantification
    Exists(String, Box<Formula>),
    /// Equality
    Eq(Term, Term),
}

/// First-order term
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum Term {
    /// Variable
    Var(String),
    /// Constant
    Const(String),
    /// Integer literal
    Int(i64),
    /// Function application
    App(String, Vec<Term>),
}

/// Backend that generated the certificate
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Backend {
    Zenon,
    Z3,
    CVC5,
    Lean4,
}

/// Result of certificate verification
#[derive(Debug, Serialize, Deserialize)]
pub enum VerificationResult {
    /// Certificate is valid
    Valid,
    /// Certificate is invalid
    Invalid(VerificationError),
}

/// Errors during certificate verification
#[derive(Debug, Serialize, Deserialize)]
pub enum VerificationError {
    /// Referenced step doesn't exist
    UnknownStep(StepId),
    /// Justification doesn't match formula
    InvalidJustification { step: StepId, reason: String },
    /// Final step doesn't match goal
    GoalMismatch,
    /// Invalid axiom application
    InvalidAxiom(String),
}

// ============================================================================
// Serialization
// ============================================================================

/// Error type for certificate I/O operations
#[derive(Debug)]
pub enum CertificateIoError {
    /// JSON serialization/deserialization error
    Json(serde_json::Error),
    /// File I/O error
    Io(std::io::Error),
}

impl std::fmt::Display for CertificateIoError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Json(e) => write!(f, "JSON error: {}", e),
            Self::Io(e) => write!(f, "I/O error: {}", e),
        }
    }
}

impl std::error::Error for CertificateIoError {}

impl From<serde_json::Error> for CertificateIoError {
    fn from(e: serde_json::Error) -> Self {
        Self::Json(e)
    }
}

impl From<std::io::Error> for CertificateIoError {
    fn from(e: std::io::Error) -> Self {
        Self::Io(e)
    }
}

impl Certificate {
    /// Serialize the certificate to JSON
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string(self)
    }

    /// Serialize the certificate to pretty-printed JSON
    pub fn to_json_pretty(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(self)
    }

    /// Deserialize a certificate from JSON
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }

    /// Save the certificate to a file as JSON
    pub fn save_to_file(
        &self,
        path: impl AsRef<std::path::Path>,
    ) -> Result<(), CertificateIoError> {
        let json = self.to_json_pretty()?;
        std::fs::write(path, json)?;
        Ok(())
    }

    /// Load a certificate from a JSON file
    pub fn load_from_file(path: impl AsRef<std::path::Path>) -> Result<Self, CertificateIoError> {
        let json = std::fs::read_to_string(path)?;
        let cert = Self::from_json(&json)?;
        Ok(cert)
    }
}

impl VerificationResult {
    /// Returns true if the verification was successful
    pub fn is_valid(&self) -> bool {
        matches!(self, Self::Valid)
    }

    /// Returns the error if verification failed
    pub fn error(&self) -> Option<&VerificationError> {
        match self {
            Self::Valid => None,
            Self::Invalid(e) => Some(e),
        }
    }
}

/// The certificate checker
pub struct CertificateChecker {
    /// Proven facts (step_id -> formula)
    facts: HashMap<StepId, Formula>,
    /// Definitions available
    definitions: HashMap<String, Formula>,
}

impl CertificateChecker {
    /// Create a new certificate checker
    pub fn new() -> Self {
        Self {
            facts: HashMap::new(),
            definitions: HashMap::new(),
        }
    }

    /// Add a definition
    pub fn add_definition(&mut self, name: String, formula: Formula) {
        self.definitions.insert(name, formula);
    }

    /// Verify a certificate
    pub fn verify(&mut self, cert: &Certificate) -> VerificationResult {
        self.facts.clear();

        // Add hypotheses as facts
        for (i, hyp) in cert.hypotheses.iter().enumerate() {
            self.facts.insert(i as StepId, hyp.clone());
        }

        // Verify each step
        for step in &cert.steps {
            match self.verify_step(step, &cert.hypotheses) {
                Ok(()) => {
                    self.facts.insert(step.id, step.formula.clone());
                }
                Err(e) => return VerificationResult::Invalid(e),
            }
        }

        // Check that the goal was proven (using alpha-equivalence for quantified formulas)
        let last_step = cert.steps.last();
        match last_step {
            Some(step) if alpha_equiv(&step.formula, &cert.goal) => VerificationResult::Valid,
            _ => VerificationResult::Invalid(VerificationError::GoalMismatch),
        }
    }

    fn verify_step(
        &self,
        step: &CertificateStep,
        hypotheses: &[Formula],
    ) -> Result<(), VerificationError> {
        match &step.justification {
            Justification::Hypothesis(idx) => {
                if *idx < hypotheses.len() && hypotheses[*idx] == step.formula {
                    Ok(())
                } else {
                    Err(VerificationError::InvalidJustification {
                        step: step.id,
                        reason: "Invalid hypothesis reference".to_string(),
                    })
                }
            }

            Justification::Axiom(axiom) => self.verify_axiom(axiom, &step.formula),

            Justification::ModusPonens {
                premise,
                implication,
            } => {
                let p = self
                    .facts
                    .get(premise)
                    .ok_or(VerificationError::UnknownStep(*premise))?;
                let imp = self
                    .facts
                    .get(implication)
                    .ok_or(VerificationError::UnknownStep(*implication))?;

                // Check that imp is P => Q and p is P and step.formula is Q
                if let Formula::Implies(ante, cons) = imp {
                    if ante.as_ref() == p && cons.as_ref() == &step.formula {
                        return Ok(());
                    }
                }

                Err(VerificationError::InvalidJustification {
                    step: step.id,
                    reason: "Modus ponens doesn't apply".to_string(),
                })
            }

            Justification::AndIntro { left, right } => {
                let l = self
                    .facts
                    .get(left)
                    .ok_or(VerificationError::UnknownStep(*left))?;
                let r = self
                    .facts
                    .get(right)
                    .ok_or(VerificationError::UnknownStep(*right))?;

                if step.formula == Formula::And(Box::new(l.clone()), Box::new(r.clone())) {
                    Ok(())
                } else {
                    Err(VerificationError::InvalidJustification {
                        step: step.id,
                        reason: "And-intro doesn't match".to_string(),
                    })
                }
            }

            Justification::AndElimLeft { conjunction } => {
                let conj = self
                    .facts
                    .get(conjunction)
                    .ok_or(VerificationError::UnknownStep(*conjunction))?;

                if let Formula::And(left, _) = conj {
                    if left.as_ref() == &step.formula {
                        return Ok(());
                    }
                }

                Err(VerificationError::InvalidJustification {
                    step: step.id,
                    reason: "And-elim-left doesn't apply".to_string(),
                })
            }

            Justification::AndElimRight { conjunction } => {
                let conj = self
                    .facts
                    .get(conjunction)
                    .ok_or(VerificationError::UnknownStep(*conjunction))?;

                if let Formula::And(_, right) = conj {
                    if right.as_ref() == &step.formula {
                        return Ok(());
                    }
                }

                Err(VerificationError::InvalidJustification {
                    step: step.id,
                    reason: "And-elim-right doesn't apply".to_string(),
                })
            }

            Justification::OrIntroLeft { premise, right } => {
                let p = self
                    .facts
                    .get(premise)
                    .ok_or(VerificationError::UnknownStep(*premise))?;

                // From P, derive P ∨ Q
                let expected = Formula::Or(Box::new(p.clone()), Box::new(right.clone()));
                if step.formula == expected {
                    Ok(())
                } else {
                    Err(VerificationError::InvalidJustification {
                        step: step.id,
                        reason: "Or-intro-left doesn't match".to_string(),
                    })
                }
            }

            Justification::OrIntroRight { left, premise } => {
                let q = self
                    .facts
                    .get(premise)
                    .ok_or(VerificationError::UnknownStep(*premise))?;

                // From Q, derive P ∨ Q
                let expected = Formula::Or(Box::new(left.clone()), Box::new(q.clone()));
                if step.formula == expected {
                    Ok(())
                } else {
                    Err(VerificationError::InvalidJustification {
                        step: step.id,
                        reason: "Or-intro-right doesn't match".to_string(),
                    })
                }
            }

            Justification::DoubleNegElim { premise } => {
                let nnp = self
                    .facts
                    .get(premise)
                    .ok_or(VerificationError::UnknownStep(*premise))?;

                // From ¬¬P, derive P
                if let Formula::Not(inner) = nnp {
                    if let Formula::Not(p) = inner.as_ref() {
                        if p.as_ref() == &step.formula {
                            return Ok(());
                        }
                    }
                }

                Err(VerificationError::InvalidJustification {
                    step: step.id,
                    reason: "Double negation elimination doesn't apply".to_string(),
                })
            }

            Justification::Rewrite { equality, target } => {
                let eq_formula = self
                    .facts
                    .get(equality)
                    .ok_or(VerificationError::UnknownStep(*equality))?;
                let target_formula = self
                    .facts
                    .get(target)
                    .ok_or(VerificationError::UnknownStep(*target))?;

                // From a = b and P(a), derive P(b)
                if let Formula::Eq(a, b) = eq_formula {
                    // Check if step.formula can be obtained by substituting a with b (or b with a)
                    // in target_formula
                    let rewritten_ab = substitute_term_in_formula(target_formula, a, b);
                    let rewritten_ba = substitute_term_in_formula(target_formula, b, a);
                    if step.formula == rewritten_ab || step.formula == rewritten_ba {
                        return Ok(());
                    }
                }

                Err(VerificationError::InvalidJustification {
                    step: step.id,
                    reason: "Rewrite doesn't apply".to_string(),
                })
            }

            Justification::Definition { name } => {
                // Check if the formula matches a definition expansion
                if let Some(def_formula) = self.definitions.get(name) {
                    if &step.formula == def_formula {
                        return Ok(());
                    }
                }

                Err(VerificationError::InvalidJustification {
                    step: step.id,
                    reason: format!("Definition '{}' not found or doesn't match", name),
                })
            }

            Justification::UniversalInstantiation { forall, term } => {
                let forall_formula = self
                    .facts
                    .get(forall)
                    .ok_or(VerificationError::UnknownStep(*forall))?;

                // From ∀x. P(x), derive P(t)
                if let Formula::Forall(var, body) = forall_formula {
                    let instantiated = substitute_var_in_formula(body, var, term);
                    if step.formula == instantiated {
                        return Ok(());
                    }
                }

                Err(VerificationError::InvalidJustification {
                    step: step.id,
                    reason: "Universal instantiation doesn't apply".to_string(),
                })
            }

            Justification::ExistentialIntro { witness, variable } => {
                let witness_formula = self
                    .facts
                    .get(witness)
                    .ok_or(VerificationError::UnknownStep(*witness))?;

                // From P(t), derive ∃x. P(x).
                //
                // This is sound iff there exists a term `t` such that:
                //   witness_formula == body[x := t]
                if let Formula::Exists(var, body) = &step.formula {
                    if var == variable && is_existential_intro_instance(body, var, witness_formula)
                    {
                        return Ok(());
                    }
                }

                Err(VerificationError::InvalidJustification {
                    step: step.id,
                    reason: "Existential introduction doesn't apply".to_string(),
                })
            }
        }
    }

    fn verify_axiom(&self, axiom: &Axiom, formula: &Formula) -> Result<(), VerificationError> {
        match axiom {
            Axiom::ExcludedMiddle(p) => {
                // Should be p ∨ ¬p
                let expected = Formula::Or(
                    Box::new(p.clone()),
                    Box::new(Formula::Not(Box::new(p.clone()))),
                );
                if formula == &expected {
                    Ok(())
                } else {
                    Err(VerificationError::InvalidAxiom(
                        "Excluded middle formula mismatch".to_string(),
                    ))
                }
            }

            Axiom::Identity(p) => {
                // Should be p → p
                let expected = Formula::Implies(Box::new(p.clone()), Box::new(p.clone()));
                if formula == &expected {
                    Ok(())
                } else {
                    Err(VerificationError::InvalidAxiom(
                        "Identity formula mismatch".to_string(),
                    ))
                }
            }

            Axiom::EqualityRefl => {
                // Should be a = a
                if let Formula::Eq(a, b) = formula {
                    if a == b {
                        return Ok(());
                    }
                }
                Err(VerificationError::InvalidAxiom(
                    "Equality reflexivity mismatch".to_string(),
                ))
            }

            Axiom::Weakening => {
                // Should be P → (Q → P) for some P, Q
                if let Formula::Implies(p, inner) = formula {
                    if let Formula::Implies(_, p2) = inner.as_ref() {
                        if p.as_ref() == p2.as_ref() {
                            return Ok(());
                        }
                    }
                }
                Err(VerificationError::InvalidAxiom(
                    "Weakening axiom mismatch".to_string(),
                ))
            }

            Axiom::EqualitySym => {
                // Should be (a = b) → (b = a)
                if let Formula::Implies(ante, cons) = formula {
                    if let (Formula::Eq(a1, b1), Formula::Eq(a2, b2)) =
                        (ante.as_ref(), cons.as_ref())
                    {
                        if a1 == b2 && b1 == a2 {
                            return Ok(());
                        }
                    }
                }
                Err(VerificationError::InvalidAxiom(
                    "Equality symmetry mismatch".to_string(),
                ))
            }

            Axiom::EqualityTrans => {
                // Should be (a = b ∧ b = c) → (a = c)
                if let Formula::Implies(ante, cons) = formula {
                    if let Formula::And(eq1, eq2) = ante.as_ref() {
                        if let (Formula::Eq(a, b1), Formula::Eq(b2, c), Formula::Eq(a2, c2)) =
                            (eq1.as_ref(), eq2.as_ref(), cons.as_ref())
                        {
                            if b1 == b2 && a == a2 && c == c2 {
                                return Ok(());
                            }
                        }
                    }
                }
                Err(VerificationError::InvalidAxiom(
                    "Equality transitivity mismatch".to_string(),
                ))
            }

            Axiom::Arithmetic(arith) => self.verify_arithmetic_axiom(arith, formula),

            Axiom::SetTheory(set) => self.verify_set_axiom(set, formula),
        }
    }

    fn verify_arithmetic_axiom(
        &self,
        axiom: &ArithmeticAxiom,
        formula: &Formula,
    ) -> Result<(), VerificationError> {
        // Arithmetic axioms are typically expressed as equalities
        // For full verification, we'd need to pattern match against specific forms
        // For now, we validate the structure is an equality
        match axiom {
            ArithmeticAxiom::AddZero => {
                // 0 + a = a : should be ∀a. (0 + a = a) or just a concrete equality
                if let Formula::Eq(Term::App(op, args), rhs) = formula {
                    if op == "+" && args.len() == 2 && args[0] == Term::Int(0) && &args[1] == rhs {
                        return Ok(());
                    }
                }
                Err(VerificationError::InvalidAxiom(
                    "AddZero axiom mismatch".to_string(),
                ))
            }
            ArithmeticAxiom::AddComm => {
                // a + b = b + a
                if let Formula::Eq(lhs, rhs) = formula {
                    if let (Term::App(op1, args1), Term::App(op2, args2)) = (lhs, rhs) {
                        if op1 == "+"
                            && op2 == "+"
                            && args1.len() == 2
                            && args2.len() == 2
                            && args1[0] == args2[1]
                            && args1[1] == args2[0]
                        {
                            return Ok(());
                        }
                    }
                }
                Err(VerificationError::InvalidAxiom(
                    "AddComm axiom mismatch".to_string(),
                ))
            }
            ArithmeticAxiom::AddAssoc => {
                // (a + b) + c = a + (b + c)
                if let Formula::Eq(lhs, rhs) = formula {
                    // Check structure: App(+, [App(+, [a, b]), c]) = App(+, [a, App(+, [b, c])])
                    if let (Term::App(op1, args1), Term::App(op2, args2)) = (lhs, rhs) {
                        if op1 == "+" && op2 == "+" && args1.len() == 2 && args2.len() == 2 {
                            if let (
                                Term::App(inner_op1, inner_args1),
                                Term::App(inner_op2, inner_args2),
                            ) = (&args1[0], &args2[1])
                            {
                                if inner_op1 == "+"
                                    && inner_op2 == "+"
                                    && inner_args1.len() == 2
                                    && inner_args2.len() == 2
                                    && inner_args1[0] == args2[0]  // a
                                    && inner_args1[1] == inner_args2[0]  // b
                                    && args1[1] == inner_args2[1]
                                // c
                                {
                                    return Ok(());
                                }
                            }
                        }
                    }
                }
                Err(VerificationError::InvalidAxiom(
                    "AddAssoc axiom mismatch".to_string(),
                ))
            }
            ArithmeticAxiom::MulOne => {
                // a * 1 = a
                if let Formula::Eq(Term::App(op, args), rhs) = formula {
                    if op == "*" && args.len() == 2 && args[1] == Term::Int(1) && &args[0] == rhs {
                        return Ok(());
                    }
                }
                Err(VerificationError::InvalidAxiom(
                    "MulOne axiom mismatch".to_string(),
                ))
            }
            ArithmeticAxiom::MulZero => {
                // a * 0 = 0
                if let Formula::Eq(Term::App(op, args), rhs) = formula {
                    if op == "*"
                        && args.len() == 2
                        && args[1] == Term::Int(0)
                        && rhs == &Term::Int(0)
                    {
                        return Ok(());
                    }
                }
                Err(VerificationError::InvalidAxiom(
                    "MulZero axiom mismatch".to_string(),
                ))
            }
        }
    }

    fn verify_set_axiom(
        &self,
        axiom: &SetAxiom,
        formula: &Formula,
    ) -> Result<(), VerificationError> {
        // Set axioms are typically expressed as equivalences
        match axiom {
            SetAxiom::EmptySet => {
                // x ∈ {} ↔ FALSE
                if let Formula::Equiv(lhs, rhs) = formula {
                    if let Formula::Predicate(pred, args) = lhs.as_ref() {
                        if pred == "∈" && args.len() == 2 {
                            if let Term::Const(set_name) = &args[1] {
                                if set_name == "{}" && rhs.as_ref() == &Formula::Bool(false) {
                                    return Ok(());
                                }
                            }
                        }
                    }
                }
                Err(VerificationError::InvalidAxiom(
                    "EmptySet axiom mismatch".to_string(),
                ))
            }
            SetAxiom::Singleton => {
                // x ∈ {a} ↔ x = a
                if let Formula::Equiv(lhs, rhs) = formula {
                    if let Formula::Predicate(pred, args) = lhs.as_ref() {
                        if pred == "∈" && args.len() == 2 {
                            if let Formula::Eq(x, a) = rhs.as_ref() {
                                if &args[0] == x {
                                    // Check that args[1] represents {a}
                                    if let Term::App(set_op, set_args) = &args[1] {
                                        if set_op == "singleton"
                                            && set_args.len() == 1
                                            && &set_args[0] == a
                                        {
                                            return Ok(());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                Err(VerificationError::InvalidAxiom(
                    "Singleton axiom mismatch".to_string(),
                ))
            }
            SetAxiom::Union => {
                // x ∈ S ∪ T ↔ x ∈ S ∨ x ∈ T
                if let Formula::Equiv(lhs, rhs) = formula {
                    if let Formula::Predicate(pred, args) = lhs.as_ref() {
                        if pred == "∈" && args.len() == 2 {
                            if let Term::App(union_op, union_args) = &args[1] {
                                if union_op == "∪" && union_args.len() == 2 {
                                    if let Formula::Or(in_s, in_t) = rhs.as_ref() {
                                        // Verify structure: x ∈ S and x ∈ T
                                        if let (
                                            Formula::Predicate(p1, args1),
                                            Formula::Predicate(p2, args2),
                                        ) = (in_s.as_ref(), in_t.as_ref())
                                        {
                                            if p1 == "∈"
                                                && p2 == "∈"
                                                && args1.len() == 2
                                                && args2.len() == 2
                                                && args1[0] == args[0]
                                                && args2[0] == args[0]
                                                && args1[1] == union_args[0]
                                                && args2[1] == union_args[1]
                                            {
                                                return Ok(());
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                Err(VerificationError::InvalidAxiom(
                    "Union axiom mismatch".to_string(),
                ))
            }
            SetAxiom::Intersection => {
                // x ∈ S ∩ T ↔ x ∈ S ∧ x ∈ T
                if let Formula::Equiv(lhs, rhs) = formula {
                    if let Formula::Predicate(pred, args) = lhs.as_ref() {
                        if pred == "∈" && args.len() == 2 {
                            if let Term::App(inter_op, inter_args) = &args[1] {
                                if inter_op == "∩" && inter_args.len() == 2 {
                                    if let Formula::And(in_s, in_t) = rhs.as_ref() {
                                        // Verify structure: x ∈ S and x ∈ T
                                        if let (
                                            Formula::Predicate(p1, args1),
                                            Formula::Predicate(p2, args2),
                                        ) = (in_s.as_ref(), in_t.as_ref())
                                        {
                                            if p1 == "∈"
                                                && p2 == "∈"
                                                && args1.len() == 2
                                                && args2.len() == 2
                                                && args1[0] == args[0]
                                                && args2[0] == args[0]
                                                && args1[1] == inter_args[0]
                                                && args2[1] == inter_args[1]
                                            {
                                                return Ok(());
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                Err(VerificationError::InvalidAxiom(
                    "Intersection axiom mismatch".to_string(),
                ))
            }
        }
    }
}

impl Default for CertificateChecker {
    fn default() -> Self {
        Self::new()
    }
}

/// Substitute all occurrences of `old` term with `new` term in a formula
fn substitute_term_in_formula(formula: &Formula, old: &Term, new: &Term) -> Formula {
    match formula {
        Formula::Bool(b) => Formula::Bool(*b),
        Formula::Predicate(name, terms) => {
            let new_terms: Vec<Term> = terms.iter().map(|t| substitute_term(t, old, new)).collect();
            Formula::Predicate(name.clone(), new_terms)
        }
        Formula::Not(f) => Formula::Not(Box::new(substitute_term_in_formula(f, old, new))),
        Formula::And(l, r) => Formula::And(
            Box::new(substitute_term_in_formula(l, old, new)),
            Box::new(substitute_term_in_formula(r, old, new)),
        ),
        Formula::Or(l, r) => Formula::Or(
            Box::new(substitute_term_in_formula(l, old, new)),
            Box::new(substitute_term_in_formula(r, old, new)),
        ),
        Formula::Implies(l, r) => Formula::Implies(
            Box::new(substitute_term_in_formula(l, old, new)),
            Box::new(substitute_term_in_formula(r, old, new)),
        ),
        Formula::Equiv(l, r) => Formula::Equiv(
            Box::new(substitute_term_in_formula(l, old, new)),
            Box::new(substitute_term_in_formula(r, old, new)),
        ),
        Formula::Forall(var, body) => {
            // Don't substitute if the variable is shadowed
            if let Term::Var(v) = old {
                if v == var {
                    return formula.clone();
                }
            }
            Formula::Forall(
                var.clone(),
                Box::new(substitute_term_in_formula(body, old, new)),
            )
        }
        Formula::Exists(var, body) => {
            // Don't substitute if the variable is shadowed
            if let Term::Var(v) = old {
                if v == var {
                    return formula.clone();
                }
            }
            Formula::Exists(
                var.clone(),
                Box::new(substitute_term_in_formula(body, old, new)),
            )
        }
        Formula::Eq(l, r) => {
            Formula::Eq(substitute_term(l, old, new), substitute_term(r, old, new))
        }
    }
}

/// Substitute all occurrences of `old` term with `new` term in a term
fn substitute_term(term: &Term, old: &Term, new: &Term) -> Term {
    if term == old {
        return new.clone();
    }
    match term {
        Term::Var(_) | Term::Const(_) | Term::Int(_) => term.clone(),
        Term::App(name, args) => {
            let new_args: Vec<Term> = args.iter().map(|a| substitute_term(a, old, new)).collect();
            Term::App(name.clone(), new_args)
        }
    }
}

/// Substitute all occurrences of variable `var` with term `replacement` in a formula
fn substitute_var_in_formula(formula: &Formula, var: &str, replacement: &Term) -> Formula {
    let var_term = Term::Var(var.to_string());
    substitute_term_in_formula(formula, &var_term, replacement)
}

// ============================================================================
// Alpha-equivalence
// ============================================================================

/// Check if two formulas are alpha-equivalent (equal up to renaming of bound variables).
///
/// For example, `∀x. P(x)` and `∀y. P(y)` are alpha-equivalent.
pub fn alpha_equiv(f1: &Formula, f2: &Formula) -> bool {
    alpha_equiv_formula(f1, f2, &mut Vec::new(), &mut Vec::new())
}

/// Check alpha-equivalence of formulas with bound variable tracking.
/// `bindings1` and `bindings2` track corresponding bound variables from f1 and f2.
fn alpha_equiv_formula(
    f1: &Formula,
    f2: &Formula,
    bindings1: &mut Vec<String>,
    bindings2: &mut Vec<String>,
) -> bool {
    match (f1, f2) {
        (Formula::Bool(a), Formula::Bool(b)) => a == b,

        (Formula::Predicate(name1, args1), Formula::Predicate(name2, args2)) => {
            name1 == name2
                && args1.len() == args2.len()
                && args1
                    .iter()
                    .zip(args2)
                    .all(|(t1, t2)| alpha_equiv_term(t1, t2, bindings1, bindings2))
        }

        (Formula::Not(a), Formula::Not(b)) => alpha_equiv_formula(a, b, bindings1, bindings2),

        (Formula::And(a1, a2), Formula::And(b1, b2))
        | (Formula::Or(a1, a2), Formula::Or(b1, b2))
        | (Formula::Implies(a1, a2), Formula::Implies(b1, b2))
        | (Formula::Equiv(a1, a2), Formula::Equiv(b1, b2)) => {
            alpha_equiv_formula(a1, b1, bindings1, bindings2)
                && alpha_equiv_formula(a2, b2, bindings1, bindings2)
        }

        (Formula::Forall(v1, body1), Formula::Forall(v2, body2))
        | (Formula::Exists(v1, body1), Formula::Exists(v2, body2)) => {
            // Push corresponding bound variables
            bindings1.push(v1.clone());
            bindings2.push(v2.clone());
            let result = alpha_equiv_formula(body1, body2, bindings1, bindings2);
            bindings1.pop();
            bindings2.pop();
            result
        }

        (Formula::Eq(t1a, t1b), Formula::Eq(t2a, t2b)) => {
            alpha_equiv_term(t1a, t2a, bindings1, bindings2)
                && alpha_equiv_term(t1b, t2b, bindings1, bindings2)
        }

        _ => false,
    }
}

/// Check alpha-equivalence of terms with bound variable tracking.
fn alpha_equiv_term(t1: &Term, t2: &Term, bindings1: &[String], bindings2: &[String]) -> bool {
    match (t1, t2) {
        (Term::Var(v1), Term::Var(v2)) => {
            // Check if both are bound at corresponding positions
            let pos1 = bindings1.iter().rposition(|b| b == v1);
            let pos2 = bindings2.iter().rposition(|b| b == v2);

            match (pos1, pos2) {
                // Both bound at the same relative position
                (Some(p1), Some(p2)) => p1 == p2,
                // Both free - must have same name
                (None, None) => v1 == v2,
                // One bound, one free - not equivalent
                _ => false,
            }
        }

        (Term::Const(c1), Term::Const(c2)) => c1 == c2,
        (Term::Int(i1), Term::Int(i2)) => i1 == i2,

        (Term::App(name1, args1), Term::App(name2, args2)) => {
            name1 == name2
                && args1.len() == args2.len()
                && args1
                    .iter()
                    .zip(args2)
                    .all(|(a1, a2)| alpha_equiv_term(a1, a2, bindings1, bindings2))
        }

        _ => false,
    }
}

/// Check if `witness` is an instance of `body` where free occurrences of `var`
/// are replaced by a single (consistent) witness term.
/// This function supports alpha-equivalence for inner quantifiers.
fn is_existential_intro_instance(body: &Formula, var: &str, witness: &Formula) -> bool {
    let mut inferred: Option<Term> = None;
    let mut bindings_body: Vec<String> = Vec::new();
    let mut bindings_witness: Vec<String> = Vec::new();

    if !unify_formula_with_witness_term(
        body,
        witness,
        var,
        &mut inferred,
        &mut bindings_body,
        &mut bindings_witness,
    ) {
        return false;
    }

    match inferred {
        Some(t) => {
            // Verify by substitution and alpha-equivalence check
            let substituted = substitute_var_in_formula(body, var, &t);
            alpha_equiv(&substituted, witness)
        }
        None => alpha_equiv(body, witness),
    }
}

/// Unify `body` against `witness` to find what term `var` was replaced with.
/// Supports alpha-equivalence for inner quantifiers by tracking bound variables.
fn unify_formula_with_witness_term(
    body: &Formula,
    witness: &Formula,
    var: &str,
    inferred: &mut Option<Term>,
    bindings_body: &mut Vec<String>,
    bindings_witness: &mut Vec<String>,
) -> bool {
    match (body, witness) {
        (Formula::Bool(a), Formula::Bool(b)) => a == b,
        (Formula::Predicate(name_a, args_a), Formula::Predicate(name_b, args_b)) => {
            name_a == name_b
                && args_a.len() == args_b.len()
                && args_a.iter().zip(args_b).all(|(t1, t2)| {
                    unify_term_with_witness_term(
                        t1,
                        t2,
                        var,
                        inferred,
                        bindings_body,
                        bindings_witness,
                    )
                })
        }
        (Formula::Not(a), Formula::Not(b)) => {
            unify_formula_with_witness_term(a, b, var, inferred, bindings_body, bindings_witness)
        }
        (Formula::And(al, ar), Formula::And(bl, br))
        | (Formula::Or(al, ar), Formula::Or(bl, br))
        | (Formula::Implies(al, ar), Formula::Implies(bl, br))
        | (Formula::Equiv(al, ar), Formula::Equiv(bl, br)) => {
            unify_formula_with_witness_term(al, bl, var, inferred, bindings_body, bindings_witness)
                && unify_formula_with_witness_term(
                    ar,
                    br,
                    var,
                    inferred,
                    bindings_body,
                    bindings_witness,
                )
        }
        (Formula::Forall(v1, a), Formula::Forall(v2, b))
        | (Formula::Exists(v1, a), Formula::Exists(v2, b)) => {
            // Track bindings for alpha-equivalence
            bindings_body.push(v1.clone());
            bindings_witness.push(v2.clone());
            let result = unify_formula_with_witness_term(
                a,
                b,
                var,
                inferred,
                bindings_body,
                bindings_witness,
            );
            bindings_body.pop();
            bindings_witness.pop();
            result
        }
        (Formula::Eq(a1, a2), Formula::Eq(b1, b2)) => {
            unify_term_with_witness_term(a1, b1, var, inferred, bindings_body, bindings_witness)
                && unify_term_with_witness_term(
                    a2,
                    b2,
                    var,
                    inferred,
                    bindings_body,
                    bindings_witness,
                )
        }
        _ => false,
    }
}

/// Check if `var` is currently shadowed by a binding in the body.
fn is_var_shadowed(var: &str, bindings_body: &[String]) -> bool {
    bindings_body.iter().any(|b| b == var)
}

fn unify_term_with_witness_term(
    body: &Term,
    witness: &Term,
    var: &str,
    inferred: &mut Option<Term>,
    bindings_body: &[String],
    bindings_witness: &[String],
) -> bool {
    // Check if we're at the existential variable (not shadowed)
    if !is_var_shadowed(var, bindings_body) {
        if let Term::Var(v) = body {
            if v == var {
                return match inferred {
                    None => {
                        *inferred = Some(witness.clone());
                        true
                    }
                    Some(existing) => existing == witness,
                };
            }
        }
    }

    // For other terms, use alpha-equivalence logic
    match (body, witness) {
        (Term::Var(v1), Term::Var(v2)) => {
            // Check if both are bound at corresponding positions
            let pos1 = bindings_body.iter().rposition(|b| b == v1);
            let pos2 = bindings_witness.iter().rposition(|b| b == v2);

            match (pos1, pos2) {
                // Both bound at the same relative position
                (Some(p1), Some(p2)) => p1 == p2,
                // Both free - must have same name
                (None, None) => v1 == v2,
                // One bound, one free - not equivalent
                _ => false,
            }
        }
        (Term::Const(a), Term::Const(b)) => a == b,
        (Term::Int(a), Term::Int(b)) => a == b,
        (Term::App(name_a, args_a), Term::App(name_b, args_b)) => {
            name_a == name_b
                && args_a.len() == args_b.len()
                && args_a.iter().zip(args_b).all(|(t1, t2)| {
                    unify_term_with_witness_term(
                        t1,
                        t2,
                        var,
                        inferred,
                        bindings_body,
                        bindings_witness,
                    )
                })
        }
        _ => false,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_proof() {
        // Prove: Given P, prove P
        let p = Formula::Predicate("P".to_string(), vec![]);

        let cert = Certificate {
            id: "test".to_string(),
            goal: p.clone(),
            hypotheses: vec![p.clone()],
            steps: vec![CertificateStep {
                id: 100,
                formula: p.clone(),
                justification: Justification::Hypothesis(0),
            }],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);

        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_modus_ponens() {
        // Prove: Given P and P => Q, prove Q
        let p = Formula::Predicate("P".to_string(), vec![]);
        let q = Formula::Predicate("Q".to_string(), vec![]);
        let p_implies_q = Formula::Implies(Box::new(p.clone()), Box::new(q.clone()));

        let cert = Certificate {
            id: "test".to_string(),
            goal: q.clone(),
            hypotheses: vec![p.clone(), p_implies_q.clone()],
            steps: vec![
                CertificateStep {
                    id: 100,
                    formula: p.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 101,
                    formula: p_implies_q.clone(),
                    justification: Justification::Hypothesis(1),
                },
                CertificateStep {
                    id: 102,
                    formula: q.clone(),
                    justification: Justification::ModusPonens {
                        premise: 100,
                        implication: 101,
                    },
                },
            ],
            backend: Backend::Z3,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);

        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_and_intro() {
        // Prove: Given P and Q, prove P ∧ Q
        let p = Formula::Predicate("P".to_string(), vec![]);
        let q = Formula::Predicate("Q".to_string(), vec![]);
        let p_and_q = Formula::And(Box::new(p.clone()), Box::new(q.clone()));

        let cert = Certificate {
            id: "test".to_string(),
            goal: p_and_q.clone(),
            hypotheses: vec![p.clone(), q.clone()],
            steps: vec![
                CertificateStep {
                    id: 100,
                    formula: p.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 101,
                    formula: q.clone(),
                    justification: Justification::Hypothesis(1),
                },
                CertificateStep {
                    id: 102,
                    formula: p_and_q.clone(),
                    justification: Justification::AndIntro {
                        left: 100,
                        right: 101,
                    },
                },
            ],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);

        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_invalid_proof() {
        // Invalid: trying to prove Q from P alone
        let p = Formula::Predicate("P".to_string(), vec![]);
        let q = Formula::Predicate("Q".to_string(), vec![]);

        let cert = Certificate {
            id: "test".to_string(),
            goal: q.clone(),
            hypotheses: vec![p.clone()],
            steps: vec![CertificateStep {
                id: 100,
                formula: p.clone(),
                justification: Justification::Hypothesis(0),
            }],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);

        assert!(matches!(
            result,
            VerificationResult::Invalid(VerificationError::GoalMismatch)
        ));
    }

    #[test]
    fn test_or_intro_left() {
        // Prove: Given P, prove P ∨ Q
        let p = Formula::Predicate("P".to_string(), vec![]);
        let q = Formula::Predicate("Q".to_string(), vec![]);
        let p_or_q = Formula::Or(Box::new(p.clone()), Box::new(q.clone()));

        let cert = Certificate {
            id: "test".to_string(),
            goal: p_or_q.clone(),
            hypotheses: vec![p.clone()],
            steps: vec![
                CertificateStep {
                    id: 100,
                    formula: p.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 101,
                    formula: p_or_q.clone(),
                    justification: Justification::OrIntroLeft {
                        premise: 100,
                        right: q.clone(),
                    },
                },
            ],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_or_intro_right() {
        // Prove: Given Q, prove P ∨ Q
        let p = Formula::Predicate("P".to_string(), vec![]);
        let q = Formula::Predicate("Q".to_string(), vec![]);
        let p_or_q = Formula::Or(Box::new(p.clone()), Box::new(q.clone()));

        let cert = Certificate {
            id: "test".to_string(),
            goal: p_or_q.clone(),
            hypotheses: vec![q.clone()],
            steps: vec![
                CertificateStep {
                    id: 100,
                    formula: q.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 101,
                    formula: p_or_q.clone(),
                    justification: Justification::OrIntroRight {
                        left: p.clone(),
                        premise: 100,
                    },
                },
            ],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_double_neg_elim() {
        // Prove: Given ¬¬P, prove P
        let p = Formula::Predicate("P".to_string(), vec![]);
        let not_p = Formula::Not(Box::new(p.clone()));
        let not_not_p = Formula::Not(Box::new(not_p));

        let cert = Certificate {
            id: "test".to_string(),
            goal: p.clone(),
            hypotheses: vec![not_not_p.clone()],
            steps: vec![
                CertificateStep {
                    id: 100,
                    formula: not_not_p.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 101,
                    formula: p.clone(),
                    justification: Justification::DoubleNegElim { premise: 100 },
                },
            ],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_universal_instantiation() {
        // Prove: Given ∀x. P(x), derive P(a)
        let x = "x".to_string();
        let a = Term::Const("a".to_string());
        let px = Formula::Predicate("P".to_string(), vec![Term::Var(x.clone())]);
        let pa = Formula::Predicate("P".to_string(), vec![a.clone()]);
        let forall_px = Formula::Forall(x.clone(), Box::new(px));

        let cert = Certificate {
            id: "test".to_string(),
            goal: pa.clone(),
            hypotheses: vec![forall_px.clone()],
            steps: vec![
                CertificateStep {
                    id: 100,
                    formula: forall_px.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 101,
                    formula: pa.clone(),
                    justification: Justification::UniversalInstantiation {
                        forall: 100,
                        term: a,
                    },
                },
            ],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_rewrite() {
        // Prove: Given a = b and P(a), derive P(b)
        let a = Term::Const("a".to_string());
        let b = Term::Const("b".to_string());
        let eq_ab = Formula::Eq(a.clone(), b.clone());
        let pa = Formula::Predicate("P".to_string(), vec![a]);
        let pb = Formula::Predicate("P".to_string(), vec![b]);

        let cert = Certificate {
            id: "test".to_string(),
            goal: pb.clone(),
            hypotheses: vec![eq_ab.clone(), pa.clone()],
            steps: vec![
                CertificateStep {
                    id: 100,
                    formula: eq_ab.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 101,
                    formula: pa.clone(),
                    justification: Justification::Hypothesis(1),
                },
                CertificateStep {
                    id: 102,
                    formula: pb.clone(),
                    justification: Justification::Rewrite {
                        equality: 100,
                        target: 101,
                    },
                },
            ],
            backend: Backend::Z3,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_axiom_weakening() {
        // P → (Q → P) is an axiom
        let p = Formula::Predicate("P".to_string(), vec![]);
        let q = Formula::Predicate("Q".to_string(), vec![]);
        let q_implies_p = Formula::Implies(Box::new(q), Box::new(p.clone()));
        let weakening = Formula::Implies(Box::new(p), Box::new(q_implies_p));

        let cert = Certificate {
            id: "test".to_string(),
            goal: weakening.clone(),
            hypotheses: vec![],
            steps: vec![CertificateStep {
                id: 100,
                formula: weakening.clone(),
                justification: Justification::Axiom(Axiom::Weakening),
            }],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_axiom_equality_sym() {
        // (a = b) → (b = a) is an axiom
        let a = Term::Const("a".to_string());
        let b = Term::Const("b".to_string());
        let eq_ab = Formula::Eq(a.clone(), b.clone());
        let eq_ba = Formula::Eq(b, a);
        let sym = Formula::Implies(Box::new(eq_ab), Box::new(eq_ba));

        let cert = Certificate {
            id: "test".to_string(),
            goal: sym.clone(),
            hypotheses: vec![],
            steps: vec![CertificateStep {
                id: 100,
                formula: sym.clone(),
                justification: Justification::Axiom(Axiom::EqualitySym),
            }],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_axiom_equality_trans() {
        // (a = b ∧ b = c) → (a = c) is an axiom
        let a = Term::Const("a".to_string());
        let b = Term::Const("b".to_string());
        let c = Term::Const("c".to_string());
        let eq_ab = Formula::Eq(a.clone(), b.clone());
        let eq_bc = Formula::Eq(b, c.clone());
        let eq_ac = Formula::Eq(a, c);
        let ante = Formula::And(Box::new(eq_ab), Box::new(eq_bc));
        let trans = Formula::Implies(Box::new(ante), Box::new(eq_ac));

        let cert = Certificate {
            id: "test".to_string(),
            goal: trans.clone(),
            hypotheses: vec![],
            steps: vec![CertificateStep {
                id: 100,
                formula: trans.clone(),
                justification: Justification::Axiom(Axiom::EqualityTrans),
            }],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_axiom_add_zero() {
        // 0 + a = a is an arithmetic axiom
        let a = Term::Var("a".to_string());
        let zero_plus_a = Term::App("+".to_string(), vec![Term::Int(0), a.clone()]);
        let eq = Formula::Eq(zero_plus_a, a);

        let cert = Certificate {
            id: "test".to_string(),
            goal: eq.clone(),
            hypotheses: vec![],
            steps: vec![CertificateStep {
                id: 100,
                formula: eq.clone(),
                justification: Justification::Axiom(Axiom::Arithmetic(ArithmeticAxiom::AddZero)),
            }],
            backend: Backend::Z3,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_axiom_add_comm() {
        // a + b = b + a is an arithmetic axiom
        let a = Term::Var("a".to_string());
        let b = Term::Var("b".to_string());
        let a_plus_b = Term::App("+".to_string(), vec![a.clone(), b.clone()]);
        let b_plus_a = Term::App("+".to_string(), vec![b, a]);
        let eq = Formula::Eq(a_plus_b, b_plus_a);

        let cert = Certificate {
            id: "test".to_string(),
            goal: eq.clone(),
            hypotheses: vec![],
            steps: vec![CertificateStep {
                id: 100,
                formula: eq.clone(),
                justification: Justification::Axiom(Axiom::Arithmetic(ArithmeticAxiom::AddComm)),
            }],
            backend: Backend::Z3,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_existential_intro_simple() {
        // From P(a), derive ∃x. P(x)
        let pa = Formula::Predicate("P".to_string(), vec![Term::Const("a".to_string())]);
        let px = Formula::Predicate("P".to_string(), vec![Term::Var("x".to_string())]);
        let exists_px = Formula::Exists("x".to_string(), Box::new(px));

        let cert = Certificate {
            id: "test".to_string(),
            goal: exists_px.clone(),
            hypotheses: vec![pa.clone()],
            steps: vec![
                CertificateStep {
                    id: 100,
                    formula: pa.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 101,
                    formula: exists_px.clone(),
                    justification: Justification::ExistentialIntro {
                        witness: 100,
                        variable: "x".to_string(),
                    },
                },
            ],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_existential_intro_multi_occurrence() {
        // From P(a) ∧ Q(a), derive ∃x. P(x) ∧ Q(x)
        let pa = Formula::Predicate("P".to_string(), vec![Term::Const("a".to_string())]);
        let qa = Formula::Predicate("Q".to_string(), vec![Term::Const("a".to_string())]);
        let witness = Formula::And(Box::new(pa), Box::new(qa));

        let px = Formula::Predicate("P".to_string(), vec![Term::Var("x".to_string())]);
        let qx = Formula::Predicate("Q".to_string(), vec![Term::Var("x".to_string())]);
        let exists_body = Formula::And(Box::new(px), Box::new(qx));
        let exists_formula = Formula::Exists("x".to_string(), Box::new(exists_body));

        let cert = Certificate {
            id: "test".to_string(),
            goal: exists_formula.clone(),
            hypotheses: vec![witness.clone()],
            steps: vec![
                CertificateStep {
                    id: 100,
                    formula: witness.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 101,
                    formula: exists_formula.clone(),
                    justification: Justification::ExistentialIntro {
                        witness: 100,
                        variable: "x".to_string(),
                    },
                },
            ],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_existential_intro_shadowed_var() {
        // From ∀x. P(x), derive ∃x. ∀x. P(x) (existential var is unused/shadowed)
        let px = Formula::Predicate("P".to_string(), vec![Term::Var("x".to_string())]);
        let forall_px = Formula::Forall("x".to_string(), Box::new(px));
        let exists_forall_px = Formula::Exists("x".to_string(), Box::new(forall_px.clone()));

        let cert = Certificate {
            id: "test".to_string(),
            goal: exists_forall_px.clone(),
            hypotheses: vec![forall_px.clone()],
            steps: vec![
                CertificateStep {
                    id: 100,
                    formula: forall_px.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 101,
                    formula: exists_forall_px.clone(),
                    justification: Justification::ExistentialIntro {
                        witness: 100,
                        variable: "x".to_string(),
                    },
                },
            ],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    #[test]
    fn test_existential_intro_invalid() {
        // Invalid: From P(a), cannot derive ∃x. Q(x)
        let pa = Formula::Predicate("P".to_string(), vec![Term::Const("a".to_string())]);
        let qx = Formula::Predicate("Q".to_string(), vec![Term::Var("x".to_string())]);
        let exists_qx = Formula::Exists("x".to_string(), Box::new(qx));

        let cert = Certificate {
            id: "test".to_string(),
            goal: exists_qx.clone(),
            hypotheses: vec![pa.clone()],
            steps: vec![
                CertificateStep {
                    id: 100,
                    formula: pa.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 101,
                    formula: exists_qx.clone(),
                    justification: Justification::ExistentialIntro {
                        witness: 100,
                        variable: "x".to_string(),
                    },
                },
            ],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);
        assert!(matches!(
            result,
            VerificationResult::Invalid(VerificationError::InvalidJustification { .. })
        ));
    }

    #[test]
    fn test_definition() {
        // Prove P using a definition
        let p = Formula::Predicate("P".to_string(), vec![]);

        let cert = Certificate {
            id: "test".to_string(),
            goal: p.clone(),
            hypotheses: vec![],
            steps: vec![CertificateStep {
                id: 100,
                formula: p.clone(),
                justification: Justification::Definition {
                    name: "MyDef".to_string(),
                },
            }],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        checker.add_definition("MyDef".to_string(), p.clone());
        let result = checker.verify(&cert);
        assert!(matches!(result, VerificationResult::Valid));
    }

    // ========================================================================
    // Serialization tests
    // ========================================================================

    #[test]
    fn test_certificate_json_roundtrip() {
        let p = Formula::Predicate("P".to_string(), vec![Term::Const("a".to_string())]);
        let q = Formula::Predicate("Q".to_string(), vec![Term::Var("x".to_string())]);
        let p_and_q = Formula::And(Box::new(p.clone()), Box::new(q.clone()));

        let cert = Certificate {
            id: "roundtrip-test".to_string(),
            goal: p_and_q.clone(),
            hypotheses: vec![p.clone(), q.clone()],
            steps: vec![
                CertificateStep {
                    id: 100,
                    formula: p.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 101,
                    formula: q.clone(),
                    justification: Justification::Hypothesis(1),
                },
                CertificateStep {
                    id: 102,
                    formula: p_and_q.clone(),
                    justification: Justification::AndIntro {
                        left: 100,
                        right: 101,
                    },
                },
            ],
            backend: Backend::Zenon,
        };

        // Serialize to JSON
        let json = cert.to_json().expect("serialization failed");

        // Deserialize back
        let restored = Certificate::from_json(&json).expect("deserialization failed");

        // Verify fields match
        assert_eq!(cert.id, restored.id);
        assert_eq!(cert.goal, restored.goal);
        assert_eq!(cert.hypotheses, restored.hypotheses);
        assert_eq!(cert.steps.len(), restored.steps.len());
        assert_eq!(cert.backend, restored.backend);

        // Verify the restored certificate still verifies
        let mut checker = CertificateChecker::new();
        let result = checker.verify(&restored);
        assert!(result.is_valid());
    }

    #[test]
    fn test_certificate_json_pretty() {
        let p = Formula::Bool(true);
        let cert = Certificate {
            id: "pretty-test".to_string(),
            goal: p.clone(),
            hypotheses: vec![p.clone()],
            steps: vec![CertificateStep {
                id: 0,
                formula: p,
                justification: Justification::Hypothesis(0),
            }],
            backend: Backend::Z3,
        };

        let pretty_json = cert.to_json_pretty().expect("pretty serialization failed");

        // Pretty JSON should contain newlines
        assert!(pretty_json.contains('\n'));

        // Should still deserialize correctly
        let restored = Certificate::from_json(&pretty_json).expect("deserialization failed");
        assert_eq!(cert.id, restored.id);
    }

    #[test]
    fn test_all_justification_variants_serialize() {
        // Test that all Justification variants can serialize/deserialize
        let justifications = vec![
            Justification::Axiom(Axiom::ExcludedMiddle(Formula::Bool(true))),
            Justification::Hypothesis(0),
            Justification::ModusPonens {
                premise: 1,
                implication: 2,
            },
            Justification::UniversalInstantiation {
                forall: 1,
                term: Term::Const("c".to_string()),
            },
            Justification::ExistentialIntro {
                witness: 1,
                variable: "x".to_string(),
            },
            Justification::Definition {
                name: "Def1".to_string(),
            },
            Justification::AndIntro { left: 1, right: 2 },
            Justification::AndElimLeft { conjunction: 1 },
            Justification::AndElimRight { conjunction: 1 },
            Justification::OrIntroLeft {
                premise: 1,
                right: Formula::Bool(false),
            },
            Justification::OrIntroRight {
                left: Formula::Bool(true),
                premise: 1,
            },
            Justification::DoubleNegElim { premise: 1 },
            Justification::Rewrite {
                equality: 1,
                target: 2,
            },
        ];

        for just in justifications {
            let json = serde_json::to_string(&just).expect("serialization failed");
            let restored: Justification =
                serde_json::from_str(&json).expect("deserialization failed");
            // Compare debug representations since Justification doesn't impl Eq
            assert_eq!(format!("{:?}", just), format!("{:?}", restored));
        }
    }

    #[test]
    fn test_all_axiom_variants_serialize() {
        let axioms = vec![
            Axiom::ExcludedMiddle(Formula::Bool(true)),
            Axiom::Identity(Formula::Bool(false)),
            Axiom::Weakening,
            Axiom::EqualityRefl,
            Axiom::EqualitySym,
            Axiom::EqualityTrans,
            Axiom::Arithmetic(ArithmeticAxiom::AddZero),
            Axiom::Arithmetic(ArithmeticAxiom::AddComm),
            Axiom::Arithmetic(ArithmeticAxiom::AddAssoc),
            Axiom::Arithmetic(ArithmeticAxiom::MulOne),
            Axiom::Arithmetic(ArithmeticAxiom::MulZero),
            Axiom::SetTheory(SetAxiom::EmptySet),
            Axiom::SetTheory(SetAxiom::Singleton),
            Axiom::SetTheory(SetAxiom::Union),
            Axiom::SetTheory(SetAxiom::Intersection),
        ];

        for axiom in axioms {
            let json = serde_json::to_string(&axiom).expect("serialization failed");
            let restored: Axiom = serde_json::from_str(&json).expect("deserialization failed");
            assert_eq!(format!("{:?}", axiom), format!("{:?}", restored));
        }
    }

    #[test]
    fn test_all_formula_variants_serialize() {
        let formulas = vec![
            Formula::Bool(true),
            Formula::Predicate("P".to_string(), vec![Term::Var("x".to_string())]),
            Formula::Not(Box::new(Formula::Bool(false))),
            Formula::And(
                Box::new(Formula::Bool(true)),
                Box::new(Formula::Bool(false)),
            ),
            Formula::Or(
                Box::new(Formula::Bool(true)),
                Box::new(Formula::Bool(false)),
            ),
            Formula::Implies(
                Box::new(Formula::Bool(true)),
                Box::new(Formula::Bool(false)),
            ),
            Formula::Equiv(Box::new(Formula::Bool(true)), Box::new(Formula::Bool(true))),
            Formula::Forall("x".to_string(), Box::new(Formula::Bool(true))),
            Formula::Exists("y".to_string(), Box::new(Formula::Bool(false))),
            Formula::Eq(Term::Var("a".to_string()), Term::Var("b".to_string())),
        ];

        for formula in formulas {
            let json = serde_json::to_string(&formula).expect("serialization failed");
            let restored: Formula = serde_json::from_str(&json).expect("deserialization failed");
            assert_eq!(formula, restored);
        }
    }

    #[test]
    fn test_all_term_variants_serialize() {
        let terms = vec![
            Term::Var("x".to_string()),
            Term::Const("c".to_string()),
            Term::Int(42),
            Term::Int(-100),
            Term::App("f".to_string(), vec![Term::Var("x".to_string())]),
            Term::App(
                "+".to_string(),
                vec![Term::Int(1), Term::Int(2), Term::Int(3)],
            ),
        ];

        for term in terms {
            let json = serde_json::to_string(&term).expect("serialization failed");
            let restored: Term = serde_json::from_str(&json).expect("deserialization failed");
            assert_eq!(term, restored);
        }
    }

    #[test]
    fn test_all_backend_variants_serialize() {
        let backends = vec![Backend::Zenon, Backend::Z3, Backend::CVC5, Backend::Lean4];

        for backend in backends {
            let json = serde_json::to_string(&backend).expect("serialization failed");
            let restored: Backend = serde_json::from_str(&json).expect("deserialization failed");
            assert_eq!(backend, restored);
        }
    }

    #[test]
    fn test_verification_result_serialize() {
        let valid = VerificationResult::Valid;
        let invalid = VerificationResult::Invalid(VerificationError::GoalMismatch);
        let invalid_step = VerificationResult::Invalid(VerificationError::UnknownStep(42));

        for result in [valid, invalid, invalid_step] {
            let json = serde_json::to_string(&result).expect("serialization failed");
            let restored: VerificationResult =
                serde_json::from_str(&json).expect("deserialization failed");
            assert_eq!(format!("{:?}", result), format!("{:?}", restored));
        }
    }

    #[test]
    fn test_complex_certificate_roundtrip() {
        // Build a more complex certificate with nested structures
        let x = Term::Var("x".to_string());
        let a = Term::Const("a".to_string());
        let px = Formula::Predicate("P".to_string(), vec![x.clone()]);
        let pa = Formula::Predicate("P".to_string(), vec![a.clone()]);
        let forall_px = Formula::Forall("x".to_string(), Box::new(px));
        let exists_pa = Formula::Exists("y".to_string(), Box::new(pa.clone()));

        let nested = Formula::Implies(
            Box::new(forall_px.clone()),
            Box::new(Formula::And(
                Box::new(pa.clone()),
                Box::new(exists_pa.clone()),
            )),
        );

        let cert = Certificate {
            id: "complex-test-αβγ".to_string(), // Unicode in ID
            goal: nested.clone(),
            hypotheses: vec![forall_px.clone()],
            steps: vec![
                CertificateStep {
                    id: 0,
                    formula: forall_px.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 1,
                    formula: pa.clone(),
                    justification: Justification::UniversalInstantiation {
                        forall: 0,
                        term: a.clone(),
                    },
                },
            ],
            backend: Backend::Zenon,
        };

        let json = cert.to_json_pretty().expect("serialization failed");
        let restored = Certificate::from_json(&json).expect("deserialization failed");

        assert_eq!(cert.id, restored.id);
        assert_eq!(cert.goal, restored.goal);
        assert_eq!(cert.hypotheses.len(), restored.hypotheses.len());
        assert_eq!(cert.steps.len(), restored.steps.len());
    }

    // ========================================================================
    // Alpha-equivalence tests
    // ========================================================================

    #[test]
    fn test_alpha_equiv_simple() {
        // ∀x. P(x) ≡ ∀y. P(y)
        let px = Formula::Predicate("P".to_string(), vec![Term::Var("x".to_string())]);
        let py = Formula::Predicate("P".to_string(), vec![Term::Var("y".to_string())]);
        let forall_x_px = Formula::Forall("x".to_string(), Box::new(px));
        let forall_y_py = Formula::Forall("y".to_string(), Box::new(py));

        assert!(alpha_equiv(&forall_x_px, &forall_y_py));
        assert!(alpha_equiv(&forall_y_py, &forall_x_px)); // symmetric
    }

    #[test]
    fn test_alpha_equiv_exists() {
        // ∃x. Q(x) ≡ ∃z. Q(z)
        let qx = Formula::Predicate("Q".to_string(), vec![Term::Var("x".to_string())]);
        let qz = Formula::Predicate("Q".to_string(), vec![Term::Var("z".to_string())]);
        let exists_x_qx = Formula::Exists("x".to_string(), Box::new(qx));
        let exists_z_qz = Formula::Exists("z".to_string(), Box::new(qz));

        assert!(alpha_equiv(&exists_x_qx, &exists_z_qz));
    }

    #[test]
    fn test_alpha_equiv_nested() {
        // ∀x. ∃y. R(x, y) ≡ ∀a. ∃b. R(a, b)
        let rxy = Formula::Predicate(
            "R".to_string(),
            vec![Term::Var("x".to_string()), Term::Var("y".to_string())],
        );
        let rab = Formula::Predicate(
            "R".to_string(),
            vec![Term::Var("a".to_string()), Term::Var("b".to_string())],
        );

        let f1 = Formula::Forall(
            "x".to_string(),
            Box::new(Formula::Exists("y".to_string(), Box::new(rxy))),
        );
        let f2 = Formula::Forall(
            "a".to_string(),
            Box::new(Formula::Exists("b".to_string(), Box::new(rab))),
        );

        assert!(alpha_equiv(&f1, &f2));
    }

    #[test]
    fn test_alpha_equiv_not_equiv_different_structure() {
        // ∀x. P(x) ≢ ∃x. P(x)
        let px = Formula::Predicate("P".to_string(), vec![Term::Var("x".to_string())]);
        let forall_x_px = Formula::Forall("x".to_string(), Box::new(px.clone()));
        let exists_x_px = Formula::Exists("x".to_string(), Box::new(px));

        assert!(!alpha_equiv(&forall_x_px, &exists_x_px));
    }

    #[test]
    fn test_alpha_equiv_not_equiv_free_vars() {
        // P(x) ≢ P(y) (free variables must match)
        let px = Formula::Predicate("P".to_string(), vec![Term::Var("x".to_string())]);
        let py = Formula::Predicate("P".to_string(), vec![Term::Var("y".to_string())]);

        assert!(!alpha_equiv(&px, &py));
    }

    #[test]
    fn test_alpha_equiv_with_free_and_bound() {
        // ∀x. R(x, z) ≡ ∀y. R(y, z) (z is free in both, x/y are bound)
        let rxz = Formula::Predicate(
            "R".to_string(),
            vec![Term::Var("x".to_string()), Term::Var("z".to_string())],
        );
        let ryz = Formula::Predicate(
            "R".to_string(),
            vec![Term::Var("y".to_string()), Term::Var("z".to_string())],
        );

        let f1 = Formula::Forall("x".to_string(), Box::new(rxz));
        let f2 = Formula::Forall("y".to_string(), Box::new(ryz));

        assert!(alpha_equiv(&f1, &f2));
    }

    #[test]
    fn test_alpha_equiv_shadowing() {
        // ∀x. ∀x. P(x) ≡ ∀y. ∀z. P(z) (inner binding shadows outer)
        let px = Formula::Predicate("P".to_string(), vec![Term::Var("x".to_string())]);
        let pz = Formula::Predicate("P".to_string(), vec![Term::Var("z".to_string())]);

        let f1 = Formula::Forall(
            "x".to_string(),
            Box::new(Formula::Forall("x".to_string(), Box::new(px))),
        );
        let f2 = Formula::Forall(
            "y".to_string(),
            Box::new(Formula::Forall("z".to_string(), Box::new(pz))),
        );

        assert!(alpha_equiv(&f1, &f2));
    }

    #[test]
    fn test_alpha_equiv_complex_formula() {
        // (∀x. P(x)) ∧ (∃y. Q(y)) ≡ (∀a. P(a)) ∧ (∃b. Q(b))
        let px = Formula::Predicate("P".to_string(), vec![Term::Var("x".to_string())]);
        let pa = Formula::Predicate("P".to_string(), vec![Term::Var("a".to_string())]);
        let qy = Formula::Predicate("Q".to_string(), vec![Term::Var("y".to_string())]);
        let qb = Formula::Predicate("Q".to_string(), vec![Term::Var("b".to_string())]);

        let f1 = Formula::And(
            Box::new(Formula::Forall("x".to_string(), Box::new(px))),
            Box::new(Formula::Exists("y".to_string(), Box::new(qy))),
        );
        let f2 = Formula::And(
            Box::new(Formula::Forall("a".to_string(), Box::new(pa))),
            Box::new(Formula::Exists("b".to_string(), Box::new(qb))),
        );

        assert!(alpha_equiv(&f1, &f2));
    }

    #[test]
    fn test_alpha_equiv_function_app() {
        // ∀x. f(x, x) = g(x) ≡ ∀y. f(y, y) = g(y)
        let fxx = Term::App(
            "f".to_string(),
            vec![Term::Var("x".to_string()), Term::Var("x".to_string())],
        );
        let fyy = Term::App(
            "f".to_string(),
            vec![Term::Var("y".to_string()), Term::Var("y".to_string())],
        );
        let gx = Term::App("g".to_string(), vec![Term::Var("x".to_string())]);
        let gy = Term::App("g".to_string(), vec![Term::Var("y".to_string())]);

        let f1 = Formula::Forall("x".to_string(), Box::new(Formula::Eq(fxx, gx)));
        let f2 = Formula::Forall("y".to_string(), Box::new(Formula::Eq(fyy, gy)));

        assert!(alpha_equiv(&f1, &f2));
    }

    #[test]
    fn test_goal_check_with_alpha_equiv() {
        // Certificate where goal uses different variable name than final step
        // Goal: ∀y. P(y)
        // Final step proves: ∀x. P(x)
        // These should be considered equivalent

        let px = Formula::Predicate("P".to_string(), vec![Term::Var("x".to_string())]);
        let py = Formula::Predicate("P".to_string(), vec![Term::Var("y".to_string())]);
        let forall_x_px = Formula::Forall("x".to_string(), Box::new(px));
        let forall_y_py = Formula::Forall("y".to_string(), Box::new(py));

        // Axiom: P → (Q → P) gives us a formula with any P, including ∀x.P(x)
        let cert = Certificate {
            id: "alpha-equiv-goal".to_string(),
            goal: forall_y_py.clone(),             // Goal uses y
            hypotheses: vec![forall_x_px.clone()], // Hypothesis uses x
            steps: vec![CertificateStep {
                id: 100,
                formula: forall_x_px.clone(), // Final step uses x
                justification: Justification::Hypothesis(0),
            }],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);

        // Should pass due to alpha-equivalence
        assert!(result.is_valid());
    }

    #[test]
    fn test_existential_intro_with_alpha_renamed_inner() {
        // From P(a) ∧ ∀y. Q(y), derive ∃x. P(x) ∧ ∀z. Q(z)
        // The inner quantifier uses different variable name (y vs z)

        let pa = Formula::Predicate("P".to_string(), vec![Term::Const("a".to_string())]);
        let qy = Formula::Predicate("Q".to_string(), vec![Term::Var("y".to_string())]);
        let forall_y_qy = Formula::Forall("y".to_string(), Box::new(qy));
        let witness = Formula::And(Box::new(pa), Box::new(forall_y_qy));

        let px = Formula::Predicate("P".to_string(), vec![Term::Var("x".to_string())]);
        let qz = Formula::Predicate("Q".to_string(), vec![Term::Var("z".to_string())]);
        let forall_z_qz = Formula::Forall("z".to_string(), Box::new(qz));
        let body = Formula::And(Box::new(px), Box::new(forall_z_qz));
        let exists_formula = Formula::Exists("x".to_string(), Box::new(body));

        let cert = Certificate {
            id: "test".to_string(),
            goal: exists_formula.clone(),
            hypotheses: vec![witness.clone()],
            steps: vec![
                CertificateStep {
                    id: 100,
                    formula: witness.clone(),
                    justification: Justification::Hypothesis(0),
                },
                CertificateStep {
                    id: 101,
                    formula: exists_formula.clone(),
                    justification: Justification::ExistentialIntro {
                        witness: 100,
                        variable: "x".to_string(),
                    },
                },
            ],
            backend: Backend::Zenon,
        };

        let mut checker = CertificateChecker::new();
        let result = checker.verify(&cert);

        // Should pass due to alpha-equivalence of inner quantifiers
        assert!(
            result.is_valid(),
            "Expected valid, got: {:?}",
            result.error()
        );
    }
}
