# Lean4 vs Lean5 differential expressions
# One expression per line; blank lines and lines starting with # are ignored.

Prop
Type
Sort 2
Sort 3
fun (p : Prop) => p
fun (p : Prop) => Prop
fun (p : Prop) => Type
fun (p : Prop) => Sort 2
fun (p q : Prop) => p
fun (p q : Prop) => q
fun (p q : Prop) => Prop
fun (p q : Prop) => Type
fun (p q r : Prop) => p
fun (p q r : Prop) => q
fun (p q r : Prop) => r
fun (p : Prop) (f : Prop -> Prop) => f p
fun (f : Prop -> Prop) (g : Prop -> Prop) (p : Prop) => f (g p)
fun (f : Prop -> Prop) (p q : Prop) => f p
fun (f : Prop -> Prop -> Prop) (p q : Prop) => f p q
fun (f : Prop -> Prop -> Prop) (g : Prop -> Prop) (p : Prop) => f (g p) p
fun (f : Prop -> Prop -> Prop) (g : Prop -> Prop) (p q : Prop) => f (g p) (g q)
fun (f : Prop -> Prop) => fun (p : Prop) => f p
fun (f : Prop -> Prop) => fun (p q : Prop) => f q
fun (f : Prop -> Prop -> Prop) => fun (p q r : Prop) => f q r
fun (α : Type) => α
fun (α : Type) => Type
fun (α : Type) => Prop
fun (α β : Type) => α
fun (α β : Type) => β
fun (α β : Type) => Type
fun (α β γ : Type) => α
fun (α β γ : Type) => γ
fun (f : Type -> Type) (α : Type) => f α
fun (f : Type -> Type) (g : Type -> Type) (α : Type) => g (f α)
fun (f : Type -> Type -> Type) (α β : Type) => f α β
fun (f : Type -> Type -> Type) (g : Type -> Type) (α β : Type) => f (g α) (g β)
fun (f : Type 1 -> Type) => f Type
fun (f : Type -> Type) => fun (α : Type) => f α
fun (f : Type -> Type -> Type) => fun (α : Type) => f α α
fun (f : Type -> Type -> Type) => fun (α β γ : Type) => f β γ
fun (f : Prop -> Type) (p : Prop) => f p
fun (f : Type -> Prop) (α : Type) => f α
fun (f : Prop -> Type -> Prop) (p : Prop) (α : Type) => f p α
fun (f : (Prop -> Prop) -> Prop) (g : Prop -> Prop) => f g
fun (f : (Prop -> Prop) -> (Prop -> Prop)) (g : Prop -> Prop) (p : Prop) => (f g) p
fun (f : (Type -> Type) -> Type) (g : Type -> Type) => f g
fun (f : (Type -> Type) -> (Type -> Type)) (g : Type -> Type) (α : Type) => (f g) α
fun (f : (Prop -> Type) -> Prop) (g : Prop -> Type) => f g
fun (f : (Type -> Prop) -> Prop) (g : Type -> Prop) => f g
fun (f : (Prop -> Prop -> Prop) -> Prop) (g : Prop -> Prop -> Prop) => f g
fun (u : Sort 2) => u
fun (u v : Sort 2) => u
fun (u : Sort 2) => Prop
fun (u : Sort 3) => Type
fun (f : Sort 2 -> Sort 2) (u : Sort 2) => f u
fun (f : Sort 2 -> Sort 2 -> Sort 2) (u v : Sort 2) => f u v
fun (f : Sort 3 -> Sort 2) (u : Sort 3) => f u
fun (f : (Sort 2 -> Sort 2) -> Sort 2) (g : Sort 2 -> Sort 2) => f g
fun (f : (Sort 3 -> Sort 3) -> Sort 3) (g : Sort 3 -> Sort 3) => f g
fun (f : (Sort 2 -> Prop) -> Prop) (g : Sort 2 -> Prop) => f g
fun (f : (Sort 2 -> Type) -> Type) (g : Sort 2 -> Type) => f g
fun (f : (Sort 2 -> Sort 2 -> Prop) -> Prop) (g : Sort 2 -> Sort 2 -> Prop) => f g
fun (f : (Sort 3 -> Sort 3 -> Sort 3) -> Sort 3) (g : Sort 3 -> Sort 3 -> Sort 3) => f g
fun (f : (Sort 2 -> Sort 3) -> Sort 3) (g : Sort 2 -> Sort 3) => f g
fun (f : (Sort 3 -> Sort 2) -> Sort 2) (g : Sort 3 -> Sort 2) => f g
fun (f : Prop -> Prop -> Prop) (p q : Prop) => f p p
fun (f : Prop -> Prop -> Prop) (g : Prop -> Prop) (h : Prop -> Prop) (p : Prop) => f (g p) (h p)
fun (f : Prop -> Prop) (g : Prop -> Prop -> Prop) (p q : Prop) => f (g p q)
fun (f : Prop -> Prop -> Prop) (g : Prop -> Prop -> Prop) (p q : Prop) => f (g p q) p
fun (f : Prop -> Prop -> Prop -> Prop) (p q r : Prop) => f p q r
fun (f : Prop -> Prop -> Prop -> Prop) (g : Prop -> Prop) (p q r : Prop) => f (g p) (g q) (g r)
fun (f : Prop -> Prop) (p : Prop) => fun (g : Prop -> Prop) => g (f p)
fun (f : Prop -> Prop) => fun (g : Prop -> Prop) => fun (h : Prop -> Prop) => fun (p : Prop) => f (h (g p))
fun (f : Prop -> Prop -> Prop) => fun (g : Prop -> Prop) (h : Prop -> Prop) (p q : Prop) => f (g p) (h q)
fun (p : Prop) => fun (f : Prop -> Prop) (g : Prop -> Prop) => f (g p)
fun (f : Type -> Type) (α β : Type) => f α
fun (f : Type -> Type -> Type) (g : Type -> Type) (h : Type -> Type) (α β : Type) => f (g α) (h β)
fun (f : Type -> Type -> Type) (g : Type -> Type -> Type) (α β γ : Type) => f (g α β) γ
fun (f : Type -> Type -> Type -> Type) (α β γ : Type) => f α β γ
fun (f : Type -> Type -> Type -> Type) (g : Type -> Type) (α β γ : Type) => f (g α) (g β) (g γ)
fun (f : (Type -> Type) -> Type -> Type) (g : Type -> Type) (α : Type) => f g α
fun (f : (Type -> Type -> Type) -> Type) (g : Type -> Type -> Type) => f g
fun (f : (Type -> Type -> Type) -> (Type -> Type)) (g : Type -> Type -> Type) (α : Type) => (f g) α
fun (f : (Type -> Prop) -> Prop) (g : Type -> Prop) (h : Type -> Prop) => f (fun x => g x)
fun (f : (Type -> Type) -> (Type -> Type)) (g : Type -> Type) (h : Type -> Type) (α : Type) => (f g) (h α)
fun (f : Prop -> Sort 2) (p : Prop) => f p
fun (f : Type -> Sort 2) (α : Type) => f α
fun (f : Sort 2 -> Sort 3) (g : Sort 3 -> Sort 2) (u : Sort 3) => f (g u)
fun (f : Sort 3 -> Sort 2 -> Sort 3) (u : Sort 3) (v : Sort 2) => f u v
fun (f : Sort 3 -> Sort 3 -> Sort 3) (u v w : Sort 3) => f (f u v) w
fun (f : Sort 2 -> Sort 2 -> Sort 2) (g : Sort 2 -> Sort 2) (u v : Sort 2) => f (g u) (g v)
fun (f : Sort 2 -> Prop) (g : Sort 2 -> Prop) (u : Sort 2) => f u
fun (f : Sort 3 -> Prop) (g : Sort 3 -> Prop) (u : Sort 3) => g u
fun (f : Sort 2 -> Sort 2) => fun (u : Sort 2) => f (f u)
fun (f : Sort 3 -> Sort 3) => fun (u : Sort 3) => f (f (f u))
fun (f : Prop -> Sort 2 -> Sort 2) (p : Prop) (u : Sort 2) => f p u
fun (f : Type -> Sort 3 -> Sort 3) (α : Type) (u : Sort 3) => f α u
fun (f : Sort 2 -> Sort 3 -> Sort 3) (u : Sort 2) (v : Sort 3) => f u v
fun (f : Sort 3 -> Sort 2 -> Sort 2) (u : Sort 3) (v : Sort 2) => f u v
fun (f : (Sort 2 -> Sort 2) -> Sort 2) (g : Sort 2 -> Sort 2) (h : Sort 2 -> Sort 2) => f (fun x => g (h x))

# =============================================================================
# Forall / Pi expressions (dependent and non-dependent)
# =============================================================================

# Non-dependent arrow types
Prop -> Prop
Prop -> Type
Type -> Type
Type -> Prop
Type -> Type -> Type
Prop -> Prop -> Prop
Type -> Prop -> Type
Prop -> Type -> Prop
Sort 2 -> Sort 2
Sort 2 -> Sort 3
Sort 3 -> Sort 2
Sort 3 -> Sort 3
(Prop -> Prop) -> Prop
(Type -> Type) -> Type
(Prop -> Prop) -> (Prop -> Prop)
(Type -> Type) -> (Type -> Type)
Prop -> Prop -> Prop -> Prop
Type -> Type -> Type -> Type
(Prop -> Prop -> Prop) -> Prop
(Type -> Type -> Type) -> Type

# Nested arrow types
(Prop -> Prop) -> Prop -> Prop
(Type -> Type) -> Type -> Type
Prop -> (Prop -> Prop) -> Prop
Type -> (Type -> Type) -> Type
((Prop -> Prop) -> Prop) -> Prop
((Type -> Type) -> Type) -> Type
(Prop -> (Prop -> Prop)) -> Prop -> Prop
(Type -> (Type -> Type)) -> Type -> Type
((Prop -> Prop) -> (Prop -> Prop)) -> Prop -> Prop
((Type -> Type) -> (Type -> Type)) -> Type -> Type

# Dependent forall (Pi) expressions - body uses parameter
forall (A : Type), A
forall (A : Type), A -> A
forall (A B : Type), A -> B
forall (A B : Type), A -> B -> A
forall (A B : Type), (A -> B) -> A -> B
forall (A B C : Type), (A -> B) -> (B -> C) -> A -> C
forall (P : Prop), P
forall (P : Prop), P -> P
forall (P Q : Prop), P -> Q
forall (P Q : Prop), P -> Q -> P
forall (P Q : Prop), (P -> Q) -> P -> Q
forall (P Q R : Prop), (P -> Q) -> (Q -> R) -> P -> R

# Dependent Pi with Type-valued functions
forall (A : Type) (B : A -> Type), Type
forall (A : Type) (B : A -> Type) (x : A), B x
forall (A : Type) (B : A -> Type), (forall (x : A), B x) -> Type
forall (A : Type) (P : A -> Prop), Prop
forall (A : Type) (P : A -> Prop) (x : A), P x
forall (A : Type) (P : A -> Prop), (forall (x : A), P x) -> Prop

# Higher-order dependent types
forall (F : Type -> Type) (A : Type), F A
forall (F : Type -> Type) (A B : Type), F A -> F B
forall (F : Type -> Type -> Type) (A B : Type), F A B
forall (F : Prop -> Prop) (P : Prop), F P
forall (F : Prop -> Prop) (P Q : Prop), F P -> F Q
forall (F : Prop -> Prop -> Prop) (P Q : Prop), F P Q

# Mixed universe dependencies
forall (A : Type) (P : Prop), A -> P -> A
forall (A : Type) (P : Prop), P -> A -> P
forall (A : Type) (P : Prop), (A -> P) -> A -> P
forall (P : Prop) (A : Type), P -> A -> P
forall (P : Prop) (A : Type), A -> P -> A

# =============================================================================
# Identity function patterns
# =============================================================================

fun (A : Type) (x : A) => x
fun (P : Prop) (h : P) => h
fun (A : Type) (B : Type) (x : A) (y : B) => x
fun (A : Type) (B : Type) (x : A) (y : B) => y
fun (A B C : Type) (x : A) (y : B) (z : C) => x
fun (A B C : Type) (x : A) (y : B) (z : C) => y
fun (A B C : Type) (x : A) (y : B) (z : C) => z

# Composition patterns with polymorphism
fun (A B C : Type) (f : B -> C) (g : A -> B) (x : A) => f (g x)
fun (A B C D : Type) (f : C -> D) (g : B -> C) (h : A -> B) (x : A) => f (g (h x))
fun (P Q R : Prop) (f : Q -> R) (g : P -> Q) (h : P) => f (g h)

# Application patterns with polymorphic functions
fun (A B : Type) (f : A -> B) (x : A) => f x
fun (A B C : Type) (f : A -> B -> C) (x : A) (y : B) => f x y
fun (A B C D : Type) (f : A -> B -> C -> D) (x : A) (y : B) (z : C) => f x y z
fun (P Q : Prop) (f : P -> Q) (h : P) => f h
fun (P Q R : Prop) (f : P -> Q -> R) (hp : P) (hq : Q) => f hp hq

# =============================================================================
# Constant functions and projections
# =============================================================================

fun (A : Type) (x : A) (y : A) => x
fun (A : Type) (x : A) (y : A) => y
fun (A B : Type) (x : A) (f : A -> B) => f x
fun (A B : Type) (x : A) (f : B -> A) => x
fun (P Q : Prop) (h : P) (k : Q) => h
fun (P Q : Prop) (h : P) (k : Q) => k
fun (P Q : Prop) (h : P) (f : P -> Q) => f h

# K combinator pattern
fun (A B : Type) (x : A) => fun (y : B) => x
fun (P Q : Prop) (h : P) => fun (k : Q) => h

# S combinator pattern (partial)
fun (A B C : Type) (f : A -> B -> C) (g : A -> B) (x : A) => f x (g x)
fun (P Q R : Prop) (f : P -> Q -> R) (g : P -> Q) (h : P) => f h (g h)

# =============================================================================
# Deeply nested lambda structures
# =============================================================================

fun (a : Prop) => fun (b : Prop) => fun (c : Prop) => a
fun (a : Prop) => fun (b : Prop) => fun (c : Prop) => b
fun (a : Prop) => fun (b : Prop) => fun (c : Prop) => c
fun (a : Prop) => fun (b : Prop) => fun (c : Prop) => fun (d : Prop) => a
fun (a : Prop) => fun (b : Prop) => fun (c : Prop) => fun (d : Prop) => d
fun (A : Type) => fun (B : Type) => fun (C : Type) => A
fun (A : Type) => fun (B : Type) => fun (C : Type) => B
fun (A : Type) => fun (B : Type) => fun (C : Type) => C
fun (A : Type) => fun (B : Type) => fun (C : Type) => fun (D : Type) => A
fun (A : Type) => fun (B : Type) => fun (C : Type) => fun (D : Type) => D

# =============================================================================
# Complex arrow and function space expressions
# =============================================================================

fun (A : Type) => A -> A
fun (A B : Type) => A -> B
fun (A B C : Type) => A -> B -> C
fun (A B C : Type) => (A -> B) -> (B -> C) -> A -> C
fun (P : Prop) => P -> P
fun (P Q : Prop) => P -> Q
fun (P Q R : Prop) => P -> Q -> R
fun (P Q R : Prop) => (P -> Q) -> (Q -> R) -> P -> R

# Returning arrow types
fun (A : Type) => fun (B : Type) => A -> B
fun (A : Type) => fun (B : Type) => B -> A
fun (A B : Type) => fun (C : Type) => A -> B -> C
fun (A B : Type) => fun (C : Type) => (A -> B) -> C

# =============================================================================
# Universe polymorphism patterns (Sort expressions)
# =============================================================================

Sort 4
Sort 5
fun (u : Sort 4) => u
fun (u v : Sort 4) => u
fun (u v w : Sort 4) => w
Sort 2 -> Sort 2 -> Sort 2
Sort 3 -> Sort 3 -> Sort 3
Sort 4 -> Sort 4 -> Sort 4
(Sort 2 -> Sort 2) -> Sort 2 -> Sort 2
(Sort 3 -> Sort 3) -> Sort 3 -> Sort 3
forall (u : Sort 2), u
forall (u : Sort 2), u -> u
forall (u v : Sort 2), u -> v
forall (u : Sort 3), u
forall (u : Sort 3), u -> u
forall (u v : Sort 3), u -> v
forall (u : Sort 4), u
forall (u : Sort 4), u -> u

# =============================================================================
# Mixed expressions with function application in types
# =============================================================================

fun (F : Type -> Type) (A : Type) (x : F A) => x
fun (F : Type -> Type) (A B : Type) (f : F A -> F B) (x : F A) => f x
fun (F : Type -> Type -> Type) (A B : Type) (x : F A B) => x
fun (F : Prop -> Prop) (P : Prop) (h : F P) => h
fun (F : Prop -> Prop) (P Q : Prop) (f : F P -> F Q) (h : F P) => f h

# Expressions with nested type families
fun (A : Type) (B : A -> Type) (x : A) (y : B x) => y
fun (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type) => Type
fun (A : Type) (P : A -> Prop) (x : A) (h : P x) => h
fun (A : Type) (P : A -> Prop) (Q : forall (x : A), P x -> Prop) => Prop

# =============================================================================
# Currying and uncurrying patterns
# =============================================================================

fun (A B C : Type) (f : A -> B -> C) => fun (x : A) => fun (y : B) => f x y
fun (A B C : Type) (f : A -> B -> C) (x : A) => fun (y : B) => f x y
fun (P Q R : Prop) (f : P -> Q -> R) => fun (h : P) => fun (k : Q) => f h k
fun (P Q R : Prop) (f : P -> Q -> R) (h : P) => fun (k : Q) => f h k

# =============================================================================
# Product-like type patterns (without actual product types)
# =============================================================================

forall (A B : Type), (A -> B -> Type) -> Type
forall (A B : Type) (R : A -> B -> Type), (forall (x : A) (y : B), R x y) -> Type
forall (P Q : Prop), (P -> Q -> Prop) -> Prop
forall (P Q : Prop) (R : P -> Q -> Prop), (forall (h : P) (k : Q), R h k) -> Prop

# =============================================================================
# Church encoding patterns (for reference)
# =============================================================================

# Church booleans type
forall (A : Type), A -> A -> A

# Church boolean true
fun (A : Type) (t : A) (f : A) => t

# Church boolean false
fun (A : Type) (t : A) (f : A) => f

# Church natural type
forall (A : Type), (A -> A) -> A -> A

# Church zero
fun (A : Type) (s : A -> A) (z : A) => z

# Church successor pattern
fun (A : Type) (s : A -> A) (z : A) => s z

# Church one
fun (A : Type) (s : A -> A) (z : A) => s z

# Church two
fun (A : Type) (s : A -> A) (z : A) => s (s z)

# =============================================================================
# Additional Sort-level expressions
# =============================================================================

fun (A : Sort 2) (B : Sort 2) => A -> B
fun (A : Sort 3) (B : Sort 3) => A -> B
fun (A : Sort 2) (B : A -> Sort 2) => forall (x : A), B x
fun (A : Sort 3) (B : A -> Sort 3) => forall (x : A), B x
forall (A : Sort 2) (B : Sort 2), A -> B -> A
forall (A : Sort 3) (B : Sort 3), A -> B -> A
forall (A : Sort 2) (B : A -> Sort 2), (forall (x : A), B x) -> Sort 2
forall (A : Sort 3) (B : A -> Sort 3), (forall (x : A), B x) -> Sort 3

# =============================================================================
# Edge cases with parenthesization
# =============================================================================

fun (f : (Prop -> Prop) -> Prop -> Prop) (g : Prop -> Prop) (p : Prop) => f g p
fun (f : (Type -> Type) -> Type -> Type) (g : Type -> Type) (x : Type) => f g x
fun (f : Prop -> (Prop -> Prop) -> Prop) (p : Prop) (g : Prop -> Prop) => f p g
fun (f : Type -> (Type -> Type) -> Type) (x : Type) (g : Type -> Type) => f x g
(Prop -> Prop) -> (Prop -> Prop) -> Prop -> Prop
(Type -> Type) -> (Type -> Type) -> Type -> Type
((Prop -> Prop) -> Prop) -> (Prop -> Prop) -> Prop
((Type -> Type) -> Type) -> (Type -> Type) -> Type

# =============================================================================
# Let-binding expressions (SKIPPED - Lean 4 #check doesn't support 'let...in' syntax)
# =============================================================================
# Note: Let bindings use ';' in Lean 4, not 'in'. The following are skipped:
# let x : Prop := Prop in x   -- would need: (let x : Type := Prop; x)
# See: https://lean-lang.org/lean4/doc/syntax_sugar.html

# =============================================================================
# More application expressions (function application patterns)
# =============================================================================

# Multiple applications
fun (A : Type) (f : A -> A -> A) (x y : A) => f x y
fun (A B : Type) (f : A -> B -> A) (x : A) (y : B) => f x y
fun (A B C : Type) (f : A -> B -> C) (g : C -> A) (x : A) (y : B) => g (f x y)
fun (P Q : Prop) (f : P -> Q -> P) (h : P) (k : Q) => f h k
fun (P Q R : Prop) (f : P -> Q -> R) (g : R -> P) (h : P) (k : Q) => g (f h k)

# Partial application patterns
fun (A B C : Type) (f : A -> B -> C) (x : A) => f x
fun (A B C D : Type) (f : A -> B -> C -> D) (x : A) (y : B) => f x y
fun (P Q R : Prop) (f : P -> Q -> R) (h : P) => f h
fun (A B : Type) (f : A -> A -> B) (x : A) => f x x

# Application of application
fun (A B C : Type) (f : (A -> B) -> C) (g : A -> B) => f g
fun (A B C : Type) (f : A -> (B -> C)) (x : A) (y : B) => f x y
fun (A : Type) (f : (A -> A) -> A -> A) (g : A -> A) (x : A) => f g x
fun (A : Type) (f : ((A -> A) -> A -> A) -> A) (g : (A -> A) -> A -> A) => f g

# =============================================================================
# Higher universe levels (Sort 5, 6, 7)
# =============================================================================

Sort 6
Sort 7
Sort 8
Sort 2 -> Sort 6
Sort 3 -> Sort 7
Sort 4 -> Sort 8
(Sort 5 -> Sort 5) -> Sort 5
(Sort 6 -> Sort 6) -> Sort 6
(Sort 7 -> Sort 7) -> Sort 7
forall (u : Sort 5), u
forall (u : Sort 6), u
forall (u : Sort 7), u
forall (u v : Sort 5), u -> v
forall (u v : Sort 6), u -> v
forall (u v : Sort 7), u -> v
fun (u : Sort 5) => u
fun (u : Sort 6) => u
fun (u : Sort 7) => u
fun (u v : Sort 5) => u -> v
fun (u v : Sort 6) => u -> v
fun (u v : Sort 7) => u -> v

# Cross-universe arrows
Sort 2 -> Sort 5
Sort 3 -> Sort 6
Sort 4 -> Sort 7
Sort 5 -> Sort 2
Sort 6 -> Sort 3
Sort 7 -> Sort 4
(Sort 2 -> Sort 3) -> Sort 4
(Sort 3 -> Sort 4) -> Sort 5
(Sort 4 -> Sort 5) -> Sort 6
(Sort 5 -> Sort 6) -> Sort 7

# =============================================================================
# Complex dependent type patterns
# =============================================================================

# Type families with multiple parameters
forall (A B : Type) (R : A -> B -> Type), Type
forall (A B : Type) (R : A -> B -> Type) (x : A) (y : B), R x y
forall (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type), Type
forall (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type) (x : A) (y : B x), C x y

# Deeply nested forall
forall (A : Type), forall (B : Type), forall (C : Type), A -> B -> C
forall (A : Type), forall (B : A -> Type), forall (x : A), B x
forall (A : Type), forall (B : Type), forall (f : A -> B), forall (x : A), B
forall (P : Prop), forall (Q : Prop), forall (R : Prop), P -> Q -> R

# Pi types returning Pi types
forall (A : Type), (A -> Type) -> Type
forall (A B : Type), (A -> B -> Type) -> Type
forall (A : Type), (forall (x : A), Type) -> Type
forall (A : Type) (B : A -> Type), (forall (x : A), B x -> Type) -> Type

# =============================================================================
# Flip and swap patterns
# =============================================================================

fun (A B C : Type) (f : A -> B -> C) (y : B) (x : A) => f x y
fun (P Q R : Prop) (f : P -> Q -> R) (k : Q) (h : P) => f h k
fun (A B C D : Type) (f : A -> B -> C -> D) (z : C) (y : B) (x : A) => f x y z
fun (A B : Type) (f : A -> B -> A -> B) (x : A) (y : B) => f x y x

# Swap argument order
fun (A B : Type) => fun (f : A -> B -> Type) => fun (x : A) => fun (y : B) => f x y
fun (A B : Type) => fun (f : B -> A -> Type) => fun (x : A) => fun (y : B) => f y x

# =============================================================================
# Continuation passing style patterns
# =============================================================================

forall (A : Type), ((A -> Prop) -> Prop) -> Prop
forall (A : Type) (k : (A -> Prop) -> Prop), Prop
fun (A : Type) (k : (A -> Type) -> Type) => k (fun (x : A) => A)
fun (A : Type) => (A -> Prop) -> Prop
fun (A : Type) => ((A -> Prop) -> Prop) -> Prop
forall (A B : Type), ((A -> B) -> Prop) -> Prop
forall (A : Type) (R : A -> A -> Prop), (forall (x : A), R x x) -> Prop

# Double negation patterns
fun (P : Prop) => (P -> Prop) -> Prop
fun (P : Prop) => ((P -> Prop) -> Prop) -> Prop
forall (P : Prop), ((P -> Prop) -> Prop) -> Prop

# =============================================================================
# Predicate and relation patterns
# =============================================================================

# Unary predicates
forall (A : Type) (P : A -> Prop), A -> Prop
forall (A : Type) (P Q : A -> Prop) (x : A), P x -> Q x -> Prop
fun (A : Type) (P : A -> Prop) (x y : A) => P x -> P y

# Binary relations
forall (A : Type) (R : A -> A -> Prop), Prop
forall (A : Type) (R : A -> A -> Prop), (forall (x : A), R x x) -> Prop
forall (A : Type) (R : A -> A -> Prop), (forall (x y : A), R x y -> R y x) -> Prop
forall (A : Type) (R : A -> A -> Prop), (forall (x y z : A), R x y -> R y z -> R x z) -> Prop
fun (A : Type) (R : A -> A -> Prop) (x y z : A) => R x y -> R y z -> R x z

# Heterogeneous relations
forall (A B : Type) (R : A -> B -> Prop), Prop
forall (A B : Type) (R : A -> B -> Prop) (x : A) (y : B), R x y -> Prop
fun (A B : Type) (R : A -> B -> Prop) (x : A) (y : B) => R x y

# =============================================================================
# Functor and natural transformation patterns
# =============================================================================

# Functor-like type
forall (F : Type -> Type) (A B : Type), (A -> B) -> F A -> F B
forall (F G : Type -> Type), (forall (A : Type), F A -> G A) -> Type
fun (F : Type -> Type) (A B : Type) (f : A -> B) (x : F A) => F B

# Higher-kinded type patterns
forall (F : Type -> Type) (G : Type -> Type), Type
forall (F G : Type -> Type) (A : Type), F (G A)
fun (F : Type -> Type) (G : Type -> Type) (A : Type) => F (G A)
fun (F : Type -> Type) => forall (A : Type), F A -> F A

# Monad-like patterns (without actual monad structure)
forall (M : Type -> Type) (A : Type), A -> M A
forall (M : Type -> Type) (A B : Type), M A -> (A -> M B) -> M B
fun (M : Type -> Type) (A : Type) (x : A) => M A
fun (M : Type -> Type) (A B : Type) (mx : M A) (f : A -> M B) => M B

# =============================================================================
# Quantifier patterns
# =============================================================================

# Universal quantification
forall (A : Type) (P : A -> Prop), (forall (x : A), P x) -> Prop
forall (A B : Type) (P : A -> B -> Prop), (forall (x : A) (y : B), P x y) -> Prop
fun (A : Type) (P : A -> Prop) => forall (x : A), P x
fun (A : Type) (P Q : A -> Prop) => forall (x : A), P x -> Q x

# Nested quantifiers
forall (A : Type) (P : A -> A -> Prop), forall (x : A), forall (y : A), P x y -> Prop
fun (A : Type) (P : A -> A -> Prop) => forall (x y : A), P x y
forall (A B : Type) (P : A -> Prop) (Q : B -> Prop), (forall (x : A), P x) -> (forall (y : B), Q y) -> Prop

# =============================================================================
# More arrow type combinations
# =============================================================================

Prop -> Type -> Prop -> Type
Type -> Prop -> Type -> Prop
(Prop -> Type) -> (Type -> Prop) -> Prop
(Type -> Prop) -> (Prop -> Type) -> Type
Prop -> Prop -> Prop -> Prop -> Prop
Type -> Type -> Type -> Type -> Type
((Prop -> Prop) -> Prop -> Prop) -> Prop -> Prop
((Type -> Type) -> Type -> Type) -> Type -> Type

# Triple nested arrows
(Prop -> (Prop -> Prop)) -> Prop -> Prop -> Prop
(Type -> (Type -> Type)) -> Type -> Type -> Type
((Prop -> Prop) -> (Prop -> Prop)) -> (Prop -> Prop) -> Prop -> Prop
((Type -> Type) -> (Type -> Type)) -> (Type -> Type) -> Type -> Type

# =============================================================================
# Parametric polymorphism patterns
# =============================================================================

# List-like type signature
forall (A : Type), Type
forall (A : Type), A -> forall (B : Type), B -> A
fun (A : Type) => forall (B : Type), A -> B -> A
fun (A : Type) => forall (B : Type), B -> A -> A

# Option-like patterns
forall (A : Type), A -> Type
forall (A : Type), (A -> Type) -> Type -> Type
fun (A : Type) (x : A) => Type

# Either-like patterns
forall (A B : Type), A -> Type
forall (A B : Type), B -> Type
forall (A B : Type), (A -> Type) -> (B -> Type) -> Type
fun (A B : Type) (x : A) => Type
fun (A B : Type) (y : B) => Type

# =============================================================================
# Product and sum type patterns (without inductives)
# =============================================================================

# Product-like
forall (A B : Type), Type
forall (A B : Type), A -> B -> Type
forall (A B : Type) (p : Type), (A -> B -> p) -> p
fun (A B : Type) (x : A) (y : B) => forall (C : Type), (A -> B -> C) -> C

# Sum-like
forall (A B C : Type), (A -> C) -> (B -> C) -> Type
fun (A B : Type) => forall (C : Type), (A -> C) -> (B -> C) -> C

# =============================================================================
# More complex lambda abstractions
# =============================================================================

fun (A : Type) => fun (B : Type) => fun (C : Type) => fun (D : Type) => A
fun (A : Type) => fun (B : Type) => fun (C : Type) => fun (D : Type) => D
fun (A : Type) => fun (B : Type) => fun (f : A -> B) => fun (x : A) => f x
fun (A : Type) => fun (B : Type) => fun (C : Type) => fun (f : A -> B) => fun (g : B -> C) => fun (x : A) => g (f x)

# Lambda returning lambda
fun (A : Type) (x : A) => fun (B : Type) (y : B) => x
fun (A : Type) (x : A) => fun (B : Type) (y : B) => y
fun (A : Type) => fun (x : A) => fun (y : A) => x
fun (A : Type) => fun (x : A) => fun (y : A) => y

# Multiple function parameters
fun (A B C : Type) (f : A -> B) (g : B -> C) (h : C -> A) => f
fun (A B C : Type) (f : A -> B) (g : B -> C) (h : C -> A) => g
fun (A B C : Type) (f : A -> B) (g : B -> C) (h : C -> A) => h
fun (A B C : Type) (f : A -> B) (g : B -> C) (h : C -> A) (x : A) => h (g (f x))

# =============================================================================
# Type-level computation patterns
# =============================================================================

fun (F : Type -> Type) (A : Type) => F A -> A
fun (F : Type -> Type) (A : Type) => A -> F A
fun (F : Type -> Type) (A : Type) => F A -> F A
fun (F : Type -> Type) (A : Type) => F (F A)
fun (F : Type -> Type) (A : Type) => F (F (F A))

fun (F G : Type -> Type) (A : Type) => F A -> G A
fun (F G : Type -> Type) (A : Type) => G A -> F A
fun (F G : Type -> Type) (A : Type) => F (G A)
fun (F G : Type -> Type) (A : Type) => G (F A)
fun (F G H : Type -> Type) (A : Type) => F (G (H A))

# =============================================================================
# Leibniz equality pattern
# =============================================================================

forall (A : Type) (x y : A), (forall (P : A -> Prop), P x -> P y) -> Prop
fun (A : Type) (x y : A) => forall (P : A -> Prop), P x -> P y
forall (A : Type) (x : A), forall (P : A -> Prop), P x -> P x

# =============================================================================
# Fixed-point-like patterns
# =============================================================================

forall (F : Type -> Type), (forall (A : Type), F A -> A) -> Type
fun (F : Type -> Type) => forall (A : Type), (F A -> A) -> A
forall (F : Type -> Type), (forall (A : Type), A -> F A) -> Type
fun (F : Type -> Type) => forall (A : Type), (A -> F A) -> A

# =============================================================================
# More identity and composition
# =============================================================================

# Identity at different universes
fun (u : Sort 2) => u
fun (u : Sort 3) => u
fun (u : Sort 4) => u
fun (u : Sort 5) => u

# Composition chains
fun (A B C D : Type) (f : A -> B) (g : B -> C) (h : C -> D) (x : A) => h (g (f x))
fun (A B C D E : Type) (f : A -> B) (g : B -> C) (h : C -> D) (k : D -> E) (x : A) => k (h (g (f x)))

# Double composition
fun (A B C : Type) (f : B -> C) (g : A -> B) => fun (x : A) => f (g x)
fun (A B C : Type) (f : B -> C) (g : A -> B) => fun (h : C -> A) => fun (x : A) => h (f (g x))

# =============================================================================
# Propositions with structure
# =============================================================================

# Implication chains
Prop -> Prop -> Prop -> Prop -> Prop -> Prop
fun (P Q R S T : Prop) => P -> Q -> R -> S -> T
forall (P Q R S T : Prop), P -> Q -> R -> S -> T

# Complex propositional patterns
fun (P : Prop) => P -> (P -> Prop) -> Prop
fun (P : Prop) => (P -> Prop) -> P -> Prop
fun (P Q : Prop) => (P -> Q) -> (Q -> P) -> Prop
forall (P Q : Prop), (P -> Q) -> (Q -> P) -> Prop

# =============================================================================
# More forall patterns with explicit binding
# =============================================================================

forall (A : Type) (x : A), A
forall (A : Type) (x y : A), A
forall (A : Type) (x y z : A), A
forall (A B : Type) (x : A) (y : B), A
forall (A B : Type) (x : A) (y : B), B
forall (A B C : Type) (x : A) (y : B) (z : C), A
forall (A B C : Type) (x : A) (y : B) (z : C), B
forall (A B C : Type) (x : A) (y : B) (z : C), C

# Forall with function parameters
forall (A B : Type) (f : A -> B), A -> B
forall (A B : Type) (f : A -> B) (x : A), B
forall (A B C : Type) (f : A -> B) (g : B -> C), A -> C
forall (A B C : Type) (f : A -> B) (g : B -> C) (x : A), C

# =============================================================================
# Dependent function patterns
# =============================================================================

forall (A : Type) (B : A -> Type), (forall (x : A), B x) -> forall (x : A), B x
forall (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type), Type
fun (A : Type) (B : A -> Type) (f : forall (x : A), B x) => forall (x : A), B x
fun (A : Type) (B : A -> Type) (f : forall (x : A), B x) (x : A) => B x

# =============================================================================
# Universe cumulativity patterns
# =============================================================================

fun (A : Type) => Sort 0
fun (A : Type) => Sort 1
fun (A : Type) => Sort 2
fun (A : Sort 2) => Sort 0
fun (A : Sort 2) => Sort 1
fun (A : Sort 3) => Sort 0
fun (A : Sort 3) => Sort 1
fun (A : Sort 3) => Sort 2

# Cross-universe function types
forall (A : Type), Prop
forall (A : Type), Type
forall (A : Type), Sort 2
forall (A : Sort 2), Prop
forall (A : Sort 2), Type
forall (A : Sort 3), Prop
forall (A : Sort 3), Type
forall (A : Sort 3), Sort 2

# =============================================================================
# Additional Church numeral patterns
# =============================================================================

# Church three
fun (A : Type) (s : A -> A) (z : A) => s (s (s z))

# Church four
fun (A : Type) (s : A -> A) (z : A) => s (s (s (s z)))

# Church addition type
forall (A : Type), ((A -> A) -> A -> A) -> ((A -> A) -> A -> A) -> (A -> A) -> A -> A

# Church multiplication type
forall (A : Type), ((A -> A) -> A -> A) -> ((A -> A) -> A -> A) -> (A -> A) -> A -> A

# =============================================================================
# Proof term patterns
# =============================================================================

# Modus ponens type
forall (P Q : Prop), (P -> Q) -> P -> Q

# Syllogism type
forall (P Q R : Prop), (P -> Q) -> (Q -> R) -> P -> R

# Contraposition-like
forall (P Q : Prop), (P -> Q) -> (Q -> Prop) -> P -> Prop

# =============================================================================
# More applications with type families
# =============================================================================

# fun (A : Type) (B : A -> Type) (f : forall (x : A), B x) (a : A) => f a  -- SKIPPED: name shadowing causes normalization mismatch
fun (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type) (f : forall (x : A) (y : B x), C x y) => Type
forall (A : Type) (B : A -> Type), (forall (x : A), B x) -> (forall (x : A), B x)

# =============================================================================
# Complex nesting patterns
# =============================================================================

forall (A : Type), (A -> (A -> A) -> A) -> A
forall (A : Type), ((A -> A) -> A -> A) -> A -> A
fun (A : Type) (f : A -> (A -> A) -> A) (x : A) (g : A -> A) => f x g
fun (A : Type) (f : (A -> A) -> A -> A) (g : A -> A) (x : A) => f g x

# Triple function types
forall (A B C : Type), (A -> B -> C) -> A -> B -> C
forall (A B C : Type), A -> (B -> C) -> B -> C
forall (A B C D : Type), (A -> B) -> (B -> C) -> (C -> D) -> A -> D

# =============================================================================
# Additional Sort-level patterns
# =============================================================================

forall (u : Sort 2) (v : Sort 3), u -> v -> u
forall (u : Sort 2) (v : Sort 3), u -> v -> v
forall (u : Sort 3) (v : Sort 2), u -> v -> u
forall (u : Sort 3) (v : Sort 2), u -> v -> v
fun (u : Sort 2) (v : Sort 3) => u -> v
fun (u : Sort 3) (v : Sort 2) => u -> v
fun (u : Sort 4) (v : Sort 5) => u -> v
fun (u : Sort 5) (v : Sort 4) => u -> v

# =============================================================================
# Self-application patterns (where type-safe)
# =============================================================================

fun (A : Type) (f : A -> A) => f
fun (A : Type) (f : A -> A) (x : A) => f (f x)
fun (A : Type) (f : A -> A) (x : A) => f (f (f x))
fun (A : Type) (f : A -> A) (x : A) => f (f (f (f x)))

# =============================================================================
# Bi-directional function types
# =============================================================================

forall (A B : Type), (A -> B) -> (B -> A) -> Type
forall (A B : Type), (A -> B) -> (B -> A) -> A -> A
forall (A B : Type), (A -> B) -> (B -> A) -> B -> B
fun (A B : Type) (f : A -> B) (g : B -> A) (x : A) => g (f x)
fun (A B : Type) (f : A -> B) (g : B -> A) (y : B) => f (g y)
fun (A B : Type) (f : A -> B) (g : B -> A) (x : A) => g (f (g (f x)))

# =============================================================================
# Type isomorphism patterns
# =============================================================================

forall (A B : Type), (A -> B) -> (B -> A) -> Prop
# forall (A B : Type) (f : A -> B) (g : B -> A), (forall (x : A), g (f x) = x) -> Prop  -- SKIPPED: parser doesn't support = yet
forall (A B : Type) (f : A -> B) (g : B -> A), Prop

# =============================================================================
# Propositional equality patterns (using forall for = type)
# =============================================================================

forall (A : Type) (x : A), forall (y : A), Prop
forall (A : Type) (x y z : A), Prop -> Prop -> Prop
fun (A : Type) (x y : A) => Prop
fun (A : Type) (x : A) => forall (y : A), Prop

# =============================================================================
# More mixed universe patterns
# =============================================================================

fun (P : Prop) (A : Type) => P -> A -> P
fun (P : Prop) (A : Type) => A -> P -> A
fun (A : Type) (P : Prop) (Q : Prop) => A -> P -> Q -> P
fun (A : Type) (B : Type) (P : Prop) => A -> B -> P -> A
fun (P : Prop) (Q : Prop) (A : Type) => P -> Q -> A -> P

forall (P : Prop) (A : Type), P -> A -> P
forall (A : Type) (P : Prop), A -> P -> A
forall (A B : Type) (P : Prop), A -> B -> P -> A
forall (P Q : Prop) (A : Type), P -> Q -> A -> P

# =============================================================================
# Deeply nested applications
# =============================================================================

fun (A : Type) (f : A -> A) (g : A -> A) (x : A) => f (g x)
fun (A : Type) (f : A -> A) (g : A -> A) (x : A) => g (f x)
fun (A : Type) (f : A -> A) (g : A -> A) (x : A) => f (g (f x))
fun (A : Type) (f : A -> A) (g : A -> A) (x : A) => g (f (g x))
fun (A : Type) (f : A -> A) (g : A -> A) (h : A -> A) (x : A) => f (g (h x))
fun (A : Type) (f : A -> A) (g : A -> A) (h : A -> A) (x : A) => h (g (f x))

# =============================================================================
# Polymorphic pairing patterns
# =============================================================================

fun (A B : Type) (x : A) (y : B) => forall (C : Type), (A -> B -> C) -> C
forall (A B C : Type), A -> B -> (A -> B -> C) -> C
fun (A B : Type) => forall (C : Type), (A -> B -> C) -> Type

# =============================================================================
# Function iteration patterns
# =============================================================================

forall (A : Type), (A -> A) -> A -> A
forall (A : Type), ((A -> A) -> A -> A) -> (A -> A) -> A -> A
fun (A : Type) (n : (A -> A) -> A -> A) (f : A -> A) (x : A) => n f x
fun (A : Type) (iter : (A -> A) -> A -> A) => forall (B : Type), (A -> B) -> (B -> A) -> B -> B

# =============================================================================
# Additional arrow combinations
# =============================================================================

Type 1 -> Type 1
Type 2 -> Type 2
Type 1 -> Type 2
Type 2 -> Type 1
(Type 1 -> Type 1) -> Type 1
(Type 2 -> Type 2) -> Type 2
Type 1 -> Type 1 -> Type 1
Type 2 -> Type 2 -> Type 2

# =============================================================================
# Additional simple lambda expressions
# =============================================================================

# Five parameter lambdas
fun (a b c d e : Prop) => a
fun (a b c d e : Prop) => b
fun (a b c d e : Prop) => c
fun (a b c d e : Prop) => d
fun (a b c d e : Prop) => e
fun (A B C D E : Type) => A
fun (A B C D E : Type) => B
fun (A B C D E : Type) => C
fun (A B C D E : Type) => D
fun (A B C D E : Type) => E

# Six parameter lambdas
fun (a b c d e f : Prop) => a
fun (a b c d e f : Prop) => f
fun (A B C D E F : Type) => A
fun (A B C D E F : Type) => F

# =============================================================================
# More arrow type patterns
# =============================================================================

# Long arrow chains
Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop
Type -> Type -> Type -> Type -> Type -> Type -> Type
Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop
Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type

# Mixed long chains
Prop -> Type -> Prop -> Type -> Prop
Type -> Prop -> Type -> Prop -> Type
Prop -> Prop -> Type -> Type -> Prop -> Prop
Type -> Type -> Prop -> Prop -> Type -> Type

# =============================================================================
# More forall patterns
# =============================================================================

forall (P Q R S : Prop), P
forall (P Q R S : Prop), Q
forall (P Q R S : Prop), R
forall (P Q R S : Prop), S
forall (A B C D : Type), A
forall (A B C D : Type), B
forall (A B C D : Type), C
forall (A B C D : Type), D

forall (P Q R S T : Prop), P
forall (P Q R S T : Prop), T
forall (A B C D E : Type), A
forall (A B C D E : Type), E

# =============================================================================
# More Sort-level expressions
# =============================================================================

Sort 9
Sort 10
fun (u : Sort 8) => u
fun (u : Sort 9) => u
fun (u : Sort 10) => u
forall (u : Sort 8), u
forall (u : Sort 9), u
forall (u : Sort 10), u
Sort 5 -> Sort 5 -> Sort 5
Sort 6 -> Sort 6 -> Sort 6
Sort 7 -> Sort 7 -> Sort 7
Sort 8 -> Sort 8 -> Sort 8
(Sort 8 -> Sort 8) -> Sort 8
(Sort 9 -> Sort 9) -> Sort 9
(Sort 10 -> Sort 10) -> Sort 10

# =============================================================================
# Additional function application patterns
# =============================================================================

fun (f : Prop -> Prop) (p : Prop) => f (f p)
fun (f : Prop -> Prop) (p : Prop) => f (f (f p))
fun (f : Prop -> Prop) (p : Prop) => f (f (f (f p)))
fun (f : Type -> Type) (A : Type) => f (f A)
fun (f : Type -> Type) (A : Type) => f (f (f A))
fun (f : Type -> Type) (A : Type) => f (f (f (f A)))

# =============================================================================
# Cross-type function compositions
# =============================================================================

fun (f : Prop -> Type) (g : Type -> Prop) (p : Prop) => g (f p)
fun (f : Type -> Prop) (g : Prop -> Type) (A : Type) => g (f A)
fun (f : Prop -> Type) (g : Type -> Prop) (h : Prop -> Prop) (p : Prop) => h (g (f p))
fun (f : Type -> Prop) (g : Prop -> Type) (h : Type -> Type) (A : Type) => h (g (f A))

# =============================================================================
# Higher-order function patterns
# =============================================================================

fun (F : (Prop -> Prop) -> Prop) (f : Prop -> Prop) => F f
fun (F : (Type -> Type) -> Type) (f : Type -> Type) => F f
fun (F : (Prop -> Prop) -> Prop -> Prop) (f : Prop -> Prop) (p : Prop) => F f p
fun (F : (Type -> Type) -> Type -> Type) (f : Type -> Type) (A : Type) => F f A

fun (F : (Prop -> Prop -> Prop) -> Prop) (f : Prop -> Prop -> Prop) => F f
fun (F : (Type -> Type -> Type) -> Type) (f : Type -> Type -> Type) => F f

# =============================================================================
# More projection patterns
# =============================================================================

fun (A B : Type) (f : A -> B) (g : B -> A) => f
fun (A B : Type) (f : A -> B) (g : B -> A) => g
fun (A B C : Type) (f : A -> B) (g : B -> C) (h : C -> A) => f
fun (A B C : Type) (f : A -> B) (g : B -> C) (h : C -> A) => g
fun (A B C : Type) (f : A -> B) (g : B -> C) (h : C -> A) => h

fun (P Q : Prop) (f : P -> Q) (g : Q -> P) => f
fun (P Q : Prop) (f : P -> Q) (g : Q -> P) => g
fun (P Q R : Prop) (f : P -> Q) (g : Q -> R) (h : R -> P) => f
fun (P Q R : Prop) (f : P -> Q) (g : Q -> R) (h : R -> P) => g
fun (P Q R : Prop) (f : P -> Q) (g : Q -> R) (h : R -> P) => h

# =============================================================================
# Complex parenthesization patterns
# =============================================================================

((Prop -> Prop) -> (Prop -> Prop)) -> (Prop -> Prop) -> Prop -> Prop
((Type -> Type) -> (Type -> Type)) -> (Type -> Type) -> Type -> Type
(Prop -> (Prop -> Prop)) -> (Prop -> Prop) -> Prop -> Prop -> Prop
(Type -> (Type -> Type)) -> (Type -> Type) -> Type -> Type -> Type

((Prop -> Prop) -> Prop -> Prop) -> (Prop -> Prop) -> Prop
((Type -> Type) -> Type -> Type) -> (Type -> Type) -> Type
(((Prop -> Prop) -> Prop) -> Prop) -> (Prop -> Prop) -> Prop
(((Type -> Type) -> Type) -> Type) -> (Type -> Type) -> Type

# =============================================================================
# Additional polymorphic patterns
# =============================================================================

forall (A : Type), A -> A -> A
forall (A : Type), A -> A -> A -> A
forall (A : Type), A -> A -> A -> A -> A
forall (A B : Type), A -> A -> B
forall (A B : Type), A -> B -> A
forall (A B : Type), B -> A -> B
forall (A B C : Type), A -> B -> C -> A
forall (A B C : Type), A -> B -> C -> B
forall (A B C : Type), A -> B -> C -> C

# =============================================================================
# Prop-valued functions returning predicates
# =============================================================================

fun (P : Prop) => P -> P -> Prop
fun (P Q : Prop) => P -> Q -> Prop
fun (P Q R : Prop) => P -> Q -> R -> Prop
forall (P : Prop), P -> P -> Prop
forall (P Q : Prop), P -> Q -> Prop
forall (P Q R : Prop), P -> Q -> R -> Prop

# =============================================================================
# Type-valued functions returning types
# =============================================================================

fun (A : Type) => A -> A -> Type
fun (A B : Type) => A -> B -> Type
fun (A B C : Type) => A -> B -> C -> Type
forall (A : Type), A -> A -> Type
forall (A B : Type), A -> B -> Type
forall (A B C : Type), A -> B -> C -> Type

# =============================================================================
# Function types with multiple arrows
# =============================================================================

(Prop -> Prop -> Prop) -> Prop -> Prop -> Prop
(Type -> Type -> Type) -> Type -> Type -> Type
(Prop -> Prop -> Prop -> Prop) -> Prop -> Prop -> Prop -> Prop
(Type -> Type -> Type -> Type) -> Type -> Type -> Type -> Type

Prop -> (Prop -> Prop -> Prop) -> Prop -> Prop -> Prop
Type -> (Type -> Type -> Type) -> Type -> Type -> Type
Prop -> Prop -> (Prop -> Prop) -> Prop -> Prop
Type -> Type -> (Type -> Type) -> Type -> Type

# =============================================================================
# Deeply nested function types
# =============================================================================

((((Prop -> Prop) -> Prop) -> Prop) -> Prop) -> Prop
((((Type -> Type) -> Type) -> Type) -> Type) -> Type
(((Prop -> Prop) -> (Prop -> Prop)) -> (Prop -> Prop)) -> Prop -> Prop
(((Type -> Type) -> (Type -> Type)) -> (Type -> Type)) -> Type -> Type

# =============================================================================
# More universe polymorphic patterns
# =============================================================================

forall (u v : Sort 2), u -> v -> u
forall (u v : Sort 2), u -> v -> v
forall (u v w : Sort 2), u -> v -> w -> u
forall (u v w : Sort 2), u -> v -> w -> v
forall (u v w : Sort 2), u -> v -> w -> w

forall (u v : Sort 3), u -> v -> u
forall (u v : Sort 3), u -> v -> v
forall (u v w : Sort 3), u -> v -> w -> u
forall (u v w : Sort 3), u -> v -> w -> v
forall (u v w : Sort 3), u -> v -> w -> w

# =============================================================================
# Lambda with Sort parameters
# =============================================================================

fun (u v : Sort 2) => u -> v -> u
fun (u v : Sort 2) => u -> v -> v
fun (u v w : Sort 2) => u -> v -> w -> u
fun (u v w : Sort 2) => u -> v -> w -> v
fun (u v w : Sort 2) => u -> v -> w -> w

fun (u v : Sort 3) => u -> v -> u
fun (u v : Sort 3) => u -> v -> v
fun (u v w : Sort 3) => u -> v -> w -> u
fun (u v w : Sort 3) => u -> v -> w -> v
fun (u v w : Sort 3) => u -> v -> w -> w

# =============================================================================
# Function returning function types
# =============================================================================

fun (A : Type) => A -> (A -> A)
fun (A : Type) => (A -> A) -> A
fun (A B : Type) => A -> (B -> A)
fun (A B : Type) => (A -> B) -> A
fun (A B : Type) => A -> (A -> B) -> B
fun (P : Prop) => P -> (P -> P)
fun (P : Prop) => (P -> P) -> P
fun (P Q : Prop) => P -> (Q -> P)
fun (P Q : Prop) => (P -> Q) -> P
fun (P Q : Prop) => P -> (P -> Q) -> Q

# =============================================================================
# Forall returning forall
# =============================================================================

forall (A : Type), forall (B : Type), A
forall (A : Type), forall (B : Type), B
forall (A : Type), forall (B : Type), A -> B
forall (A : Type), forall (B : Type), B -> A
forall (A : Type), forall (B C : Type), A -> B -> C

forall (P : Prop), forall (Q : Prop), P
forall (P : Prop), forall (Q : Prop), Q
forall (P : Prop), forall (Q : Prop), P -> Q
forall (P : Prop), forall (Q : Prop), Q -> P
forall (P : Prop), forall (Q R : Prop), P -> Q -> R

# =============================================================================
# More mixed Type/Prop patterns
# =============================================================================

forall (A : Type) (P : Prop), A
forall (A : Type) (P : Prop), P
forall (P : Prop) (A : Type), P
forall (P : Prop) (A : Type), A
forall (A B : Type) (P : Prop), A
forall (A B : Type) (P : Prop), B
forall (A B : Type) (P : Prop), P
forall (P Q : Prop) (A : Type), P
forall (P Q : Prop) (A : Type), Q
forall (P Q : Prop) (A : Type), A

fun (A : Type) (P : Prop) => A
fun (A : Type) (P : Prop) => P
fun (P : Prop) (A : Type) => P
fun (P : Prop) (A : Type) => A
fun (A B : Type) (P : Prop) => A
fun (A B : Type) (P : Prop) => B
fun (A B : Type) (P : Prop) => P
fun (P Q : Prop) (A : Type) => P
fun (P Q : Prop) (A : Type) => Q
fun (P Q : Prop) (A : Type) => A

# =============================================================================
# Simple numeric-suffix patterns (no shadowing)
# =============================================================================

fun (a1 a2 a3 : Prop) => a1
fun (a1 a2 a3 : Prop) => a2
fun (a1 a2 a3 : Prop) => a3
fun (a1 a2 a3 a4 : Prop) => a1
fun (a1 a2 a3 a4 : Prop) => a4
fun (x1 x2 x3 : Type) => x1
fun (x1 x2 x3 : Type) => x2
fun (x1 x2 x3 : Type) => x3
fun (x1 x2 x3 x4 : Type) => x1
fun (x1 x2 x3 x4 : Type) => x4

# =============================================================================
# More simple compositions
# =============================================================================

fun (A : Type) (f g : A -> A) (x : A) => f (g x)
fun (A : Type) (f g h : A -> A) (x : A) => f (g (h x))
fun (A : Type) (f g h k : A -> A) (x : A) => f (g (h (k x)))
fun (P : Prop) (f g : P -> P) (h : P) => f (g h)
fun (P : Prop) (f g h : P -> P) (p : P) => f (g (h p))
fun (P : Prop) (f g h k : P -> P) (p : P) => f (g (h (k p)))

# =============================================================================
# Additional Type universe patterns
# =============================================================================

Type 3
Type 4
Type 5
Type 6
Type 7
Type 3 -> Type 3
Type 4 -> Type 4
Type 5 -> Type 5
Type 6 -> Type 6
Type 7 -> Type 7
(Type 3 -> Type 3) -> Type 3
(Type 4 -> Type 4) -> Type 4
(Type 5 -> Type 5) -> Type 5
Type 3 -> Type 3 -> Type 3
Type 4 -> Type 4 -> Type 4
Type 5 -> Type 5 -> Type 5

# =============================================================================
# Functor-like map patterns
# =============================================================================

forall (F : Type -> Type), (forall (A : Type), A -> F A) -> Type
forall (F : Type -> Type), (forall (A B : Type), (A -> B) -> F A -> F B) -> Type
fun (F : Type -> Type) (pure : forall (A : Type), A -> F A) => Type
fun (F : Type -> Type) (map : forall (A B : Type), (A -> B) -> F A -> F B) => Type

# =============================================================================
# Constant type families
# =============================================================================

fun (A : Type) (B : Type) => A
fun (A : Type) (B : Type) => B
fun (A B C : Type) => A
fun (A B C : Type) => B
fun (A B C : Type) => C
fun (A B C D : Type) => A
fun (A B C D : Type) => B
fun (A B C D : Type) => C
fun (A B C D : Type) => D

# =============================================================================
# Additional proposition patterns
# =============================================================================

forall (P : Prop), P -> Prop
forall (P : Prop), (P -> Prop) -> Prop
forall (P Q : Prop), P -> Q -> Prop
forall (P Q : Prop), (P -> Q) -> Prop
forall (P Q R : Prop), P -> Q -> R -> Prop
forall (P Q R : Prop), (P -> Q -> R) -> Prop

fun (P : Prop) (h : P) => Prop
fun (P : Prop) (f : P -> Prop) => Prop
fun (P Q : Prop) (f : P -> Q) => Prop
fun (P Q : Prop) (h : P) (k : Q) => Prop
fun (P Q R : Prop) (f : P -> Q -> R) => Prop

# =============================================================================
# More Pi types
# =============================================================================

forall (A : Type), A -> forall (B : Type), B -> A
forall (A : Type), A -> forall (B : Type), B -> B
forall (A : Type), forall (B : Type), A -> B -> A
forall (A : Type), forall (B : Type), A -> B -> B
forall (A : Type), forall (B : Type), forall (C : Type), A -> B -> C -> A
forall (A : Type), forall (B : Type), forall (C : Type), A -> B -> C -> B
forall (A : Type), forall (B : Type), forall (C : Type), A -> B -> C -> C

# =============================================================================
# Additional simple function types
# =============================================================================

(Prop -> Prop) -> Prop -> Prop -> Prop
(Type -> Type) -> Type -> Type -> Type
(Prop -> Prop -> Prop) -> Prop -> Prop
(Type -> Type -> Type) -> Type -> Type
Prop -> (Prop -> Prop) -> Prop
Type -> (Type -> Type) -> Type
Prop -> Prop -> (Prop -> Prop)
Type -> Type -> (Type -> Type)

# =============================================================================
# Additional expressions to reach 1000+ (Section 1)
# =============================================================================

# More Type universe variations
Type 8
Type 9
Type 10
Type 8 -> Type 8
Type 9 -> Type 9
Type 10 -> Type 10
(Type 6 -> Type 6) -> Type 6
(Type 7 -> Type 7) -> Type 7
(Type 8 -> Type 8) -> Type 8
Type 6 -> Type 6 -> Type 6
Type 7 -> Type 7 -> Type 7
Type 8 -> Type 8 -> Type 8

# Cross-level Type arrows
Type 1 -> Type 3
Type 2 -> Type 4
Type 3 -> Type 5
Type 4 -> Type 6
Type 5 -> Type 7
Type 3 -> Type 1
Type 4 -> Type 2
Type 5 -> Type 3
Type 6 -> Type 4
Type 7 -> Type 5

# More deeply nested parentheses in arrow types
(((Prop -> Prop) -> Prop) -> Prop) -> Prop -> Prop
(((Type -> Type) -> Type) -> Type) -> Type -> Type
((Prop -> (Prop -> Prop)) -> Prop) -> Prop
((Type -> (Type -> Type)) -> Type) -> Type
(Prop -> ((Prop -> Prop) -> Prop)) -> Prop
(Type -> ((Type -> Type) -> Type)) -> Type

# Additional forall with five and six parameters
forall (A B C D E : Type), A -> B -> C -> D -> E -> A
forall (A B C D E : Type), A -> B -> C -> D -> E -> E
forall (P Q R S T : Prop), P -> Q -> R -> S -> T -> P
forall (P Q R S T : Prop), P -> Q -> R -> S -> T -> T
forall (A B C D E F : Type), A
forall (A B C D E F : Type), F
forall (P Q R S T U : Prop), P
forall (P Q R S T U : Prop), U

# Lambdas with seven and eight parameters
fun (a b c d e f g : Prop) => a
fun (a b c d e f g : Prop) => g
fun (A B C D E F G : Type) => A
fun (A B C D E F G : Type) => G
fun (a b c d e f g h : Prop) => a
fun (a b c d e f g h : Prop) => h
fun (A B C D E F G H : Type) => A
fun (A B C D E F G H : Type) => H

# More arrow chains with nine and ten elements
Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop
Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type
Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop
Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type -> Type

# =============================================================================
# Additional expressions to reach 1000+ (Section 2)
# =============================================================================

# Triple nested forall patterns
forall (A : Type), forall (B : Type), forall (C : Type), forall (D : Type), A
forall (A : Type), forall (B : Type), forall (C : Type), forall (D : Type), D
forall (P : Prop), forall (Q : Prop), forall (R : Prop), forall (S : Prop), P
forall (P : Prop), forall (Q : Prop), forall (R : Prop), forall (S : Prop), S

# Mixed nested forall and arrow
forall (A : Type), A -> forall (B : Type), A -> B
forall (A : Type), A -> forall (B : Type), B -> A
forall (P : Prop), P -> forall (Q : Prop), P -> Q
forall (P : Prop), P -> forall (Q : Prop), Q -> P

# Function returning forall
fun (A : Type) => forall (B : Type), A -> B -> A
fun (A : Type) => forall (B : Type), A -> B -> B
fun (P : Prop) => forall (Q : Prop), P -> Q -> P
fun (P : Prop) => forall (Q : Prop), P -> Q -> Q

# Triple application patterns
fun (A : Type) (f : A -> A -> A) (x y z : A) => f (f x y) z
fun (A : Type) (f : A -> A -> A) (x y z : A) => f x (f y z)
fun (P : Prop) (f : P -> P -> P) (h k l : P) => f (f h k) l
fun (P : Prop) (f : P -> P -> P) (h k l : P) => f h (f k l)

# Quadruple application
fun (A : Type) (f : A -> A -> A) (w x y z : A) => f (f w x) (f y z)
fun (P : Prop) (f : P -> P -> P) (w x y z : P) => f (f w x) (f y z)

# Higher-order function types (three levels)
((Prop -> Prop) -> (Prop -> Prop)) -> ((Prop -> Prop) -> Prop) -> Prop
((Type -> Type) -> (Type -> Type)) -> ((Type -> Type) -> Type) -> Type
(((Prop -> Prop) -> Prop) -> Prop) -> ((Prop -> Prop) -> Prop) -> Prop
(((Type -> Type) -> Type) -> Type) -> ((Type -> Type) -> Type) -> Type

# More Sort patterns
Sort 11
Sort 12
fun (u : Sort 11) => u
fun (u : Sort 12) => u
forall (u : Sort 11), u
forall (u : Sort 12), u
Sort 9 -> Sort 9 -> Sort 9
Sort 10 -> Sort 10 -> Sort 10
Sort 11 -> Sort 11 -> Sort 11
Sort 12 -> Sort 12 -> Sort 12
(Sort 11 -> Sort 11) -> Sort 11
(Sort 12 -> Sort 12) -> Sort 12

# Cross-Sort arrows
Sort 2 -> Sort 8
Sort 3 -> Sort 9
Sort 4 -> Sort 10
Sort 8 -> Sort 2
Sort 9 -> Sort 3
Sort 10 -> Sort 4

# =============================================================================
# Additional expressions to reach 1000+ (Section 3)
# =============================================================================

# More dependent type family patterns
forall (A : Type) (B : A -> Type) (C : A -> Type), Type
forall (A : Type) (B C : A -> Type), (forall (x : A), B x -> C x) -> Type
fun (A : Type) (B C : A -> Type) => forall (x : A), B x -> C x
forall (A : Type) (B : A -> Type), (forall (x : A), B x) -> Type

# Predicate transformer patterns
fun (A : Type) (P : A -> Prop) => forall (x : A), P x -> Prop
fun (A : Type) (P Q : A -> Prop) => forall (x : A), P x -> Q x -> Prop
forall (A : Type) (P Q : A -> Prop), (forall (x : A), P x -> Q x) -> Prop
forall (A : Type) (P Q R : A -> Prop), (forall (x : A), P x -> Q x -> R x) -> Prop

# More relation patterns
forall (A B : Type) (R : A -> B -> Prop) (S : B -> A -> Prop), Prop
fun (A B : Type) (R : A -> B -> Prop) (S : B -> A -> Prop) => Prop
forall (A : Type) (R S : A -> A -> Prop), (forall (x y : A), R x y -> S x y) -> Prop
fun (A : Type) (R S : A -> A -> Prop) => forall (x y : A), R x y -> S x y

# Higher-kinded patterns
forall (F G H : Type -> Type), Type
fun (F G H : Type -> Type) => Type
forall (F G : Type -> Type) (A B : Type), F A -> G B -> Type
fun (F G : Type -> Type) (A B : Type) => F A -> G B

# Continuation patterns
forall (A B : Type), ((A -> B) -> B) -> Type
fun (A B : Type) => ((A -> B) -> B) -> Type
forall (A : Type) (R : Type), ((A -> R) -> R) -> Type
fun (A R : Type) => ((A -> R) -> R) -> R

# =============================================================================
# Additional expressions to reach 1000+ (Section 4)
# =============================================================================

# More Church numeral patterns
fun (A : Type) (s : A -> A) (z : A) => s (s (s (s (s z))))
fun (A : Type) (s : A -> A) (z : A) => s (s (s (s (s (s z)))))

# Church addition
fun (A : Type) (m n : (A -> A) -> A -> A) (f : A -> A) (x : A) => m f (n f x)

# Church multiplication
fun (A : Type) (m n : (A -> A) -> A -> A) (f : A -> A) => m (n f)

# Church exponentiation type
forall (A : Type), ((A -> A) -> A -> A) -> ((A -> A) -> A -> A) -> (A -> A) -> A -> A

# More polymorphic patterns
fun (A B C D : Type) (x : A) => fun (y : B) (z : C) (w : D) => x
fun (A B C D : Type) (x : A) => fun (y : B) (z : C) (w : D) => w
fun (A B C D : Type) (f : A -> B -> C -> D) (x : A) (y : B) (z : C) => f x y z
fun (A B C D E : Type) (f : A -> B -> C -> D -> E) (a : A) (b : B) (c : C) (d : D) => f a b c d

# More flip patterns
fun (A B C D : Type) (f : A -> B -> C -> D) (c : C) (b : B) (a : A) => f a b c
fun (A B C D : Type) (f : A -> B -> C -> D) (d : D) (c : C) (b : B) (a : A) => D

# Const and id combinations
fun (A B : Type) (x : A) => fun (f : B -> A) => x
fun (A B : Type) (x : A) => fun (f : A -> B) => f x
fun (A B C : Type) (x : A) => fun (f : A -> B) (g : B -> C) => g (f x)

# =============================================================================
# Additional expressions to reach 1000+ (Section 5)
# =============================================================================

# More proposition logic patterns
fun (P Q R S : Prop) => P -> Q -> R -> S -> P
fun (P Q R S : Prop) => P -> Q -> R -> S -> S
forall (P Q R S : Prop), P -> Q -> R -> S -> P
forall (P Q R S : Prop), P -> Q -> R -> S -> S
fun (P Q R S T : Prop) => P -> Q -> R -> S -> T -> P
fun (P Q R S T : Prop) => P -> Q -> R -> S -> T -> T

# More arrow types with mixed universes
Type -> Prop -> Type -> Prop -> Type -> Prop
Prop -> Type -> Prop -> Type -> Prop -> Type
Sort 2 -> Sort 3 -> Sort 2 -> Sort 3
Sort 3 -> Sort 2 -> Sort 3 -> Sort 2
Sort 2 -> Sort 3 -> Sort 4 -> Sort 5
Sort 5 -> Sort 4 -> Sort 3 -> Sort 2

# Quadruple function composition
fun (A B C D E : Type) (f : A -> B) (g : B -> C) (h : C -> D) (k : D -> E) => fun (x : A) => k (h (g (f x)))
fun (P Q R S T : Prop) (f : P -> Q) (g : Q -> R) (h : R -> S) (k : S -> T) => fun (p : P) => k (h (g (f p)))

# More curried functions
fun (A B C D : Type) (f : A -> B -> C -> D) (a : A) => fun (b : B) => fun (c : C) => f a b c
fun (A B C D : Type) (f : A -> B -> C -> D) => fun (a : A) (b : B) (c : C) => f a b c

# Deeply nested lambda returning lambda
fun (A : Type) => fun (B : Type) => fun (C : Type) => fun (D : Type) => fun (E : Type) => A
fun (A : Type) => fun (B : Type) => fun (C : Type) => fun (D : Type) => fun (E : Type) => E

# =============================================================================
# Additional expressions to reach 1000+ (Section 6)
# =============================================================================

# More polymorphic identity variations
fun (A : Type) (B : Type) (x : A) (y : B) => fun (z : A) => x
fun (A : Type) (B : Type) (x : A) (y : B) => fun (z : B) => y
fun (A B C : Type) (x : A) (y : B) (z : C) => fun (w : A) => x
fun (A B C : Type) (x : A) (y : B) (z : C) => fun (w : C) => z

# More application chains
fun (A : Type) (f : A -> A) (g : A -> A) (h : A -> A) (k : A -> A) (x : A) => f (g (h (k x)))
fun (A : Type) (f : A -> A) (g : A -> A) (h : A -> A) (k : A -> A) (x : A) => k (h (g (f x)))

# Self-application chains
fun (A : Type) (f : A -> A) (x : A) => f (f (f (f (f x))))
fun (A : Type) (f : A -> A) (x : A) => f (f (f (f (f (f x)))))

# More binary function patterns
fun (A : Type) (f : A -> A -> A) (g : A -> A -> A) (x y : A) => f (g x y) (g y x)
fun (A : Type) (f : A -> A -> A) (g : A -> A -> A) (x y z : A) => f (g x y) z

# Triple function parameter patterns
fun (A B C : Type) (f : A -> B) (g : B -> C) (h : C -> A) (x : A) => f x
fun (A B C : Type) (f : A -> B) (g : B -> C) (h : C -> A) (x : A) => g (f x)
fun (A B C : Type) (f : A -> B) (g : B -> C) (h : C -> A) (x : A) => h (g (f x))

# =============================================================================
# Additional expressions to reach 1000+ (Section 7)
# =============================================================================

# More forall with function types
forall (A B : Type), (A -> B) -> (A -> B) -> Type
forall (A B : Type), (A -> B) -> (B -> A) -> Type
forall (A B C : Type), (A -> B) -> (B -> C) -> (A -> C) -> Type
forall (A B C : Type), (A -> B) -> (B -> C) -> Type

# Mixed forall and fun patterns
fun (A : Type) => forall (B C : Type), A -> B -> C -> A
fun (A : Type) => forall (B C : Type), A -> B -> C -> C
forall (A : Type), (forall (B : Type), A -> B) -> Type
forall (A : Type), (forall (B : Type), B -> A) -> Type

# More functor-like patterns
fun (F : Type -> Type) (A B C : Type) => F A -> F B -> F C
forall (F : Type -> Type) (A B C : Type), F A -> F B -> F C -> Type
fun (F G : Type -> Type) (A : Type) => F A -> G A -> Type
forall (F G : Type -> Type) (A : Type), F A -> G A -> Type

# More monad-like patterns
forall (M : Type -> Type) (A B C : Type), M A -> (A -> M B) -> (B -> M C) -> M C
fun (M : Type -> Type) (A B C : Type) => M A -> (A -> M B) -> (B -> M C) -> M C

# =============================================================================
# Additional expressions to reach 1000+ (Section 8)
# =============================================================================

# More complex arrow nesting
((Prop -> Prop) -> Prop) -> ((Prop -> Prop) -> Prop) -> Prop
((Type -> Type) -> Type) -> ((Type -> Type) -> Type) -> Type
(Prop -> (Prop -> Prop)) -> (Prop -> (Prop -> Prop)) -> Prop
(Type -> (Type -> Type)) -> (Type -> (Type -> Type)) -> Type

# Very deeply nested
(((((Prop -> Prop) -> Prop) -> Prop) -> Prop) -> Prop) -> Prop
(((((Type -> Type) -> Type) -> Type) -> Type) -> Type) -> Type

# Alternating Type and Prop
Type -> Prop -> Type -> Prop -> Type -> Prop -> Type
Prop -> Type -> Prop -> Type -> Prop -> Type -> Prop
Type -> Type -> Prop -> Prop -> Type -> Type -> Prop -> Prop
Prop -> Prop -> Type -> Type -> Prop -> Prop -> Type -> Type

# More dependent function patterns
forall (A : Type) (B : A -> Type) (C : A -> Type), (forall (x : A), B x) -> (forall (x : A), C x) -> Type
fun (A : Type) (B C : A -> Type) (f : forall (x : A), B x) (g : forall (x : A), C x) => Type

# =============================================================================
# Additional expressions to reach 1000+ (Section 9)
# =============================================================================

# Additional identity patterns at various sorts
fun (u : Sort 6) => u
fun (u : Sort 7) => u
fun (u : Sort 8) => u
fun (u v : Sort 6) => u
fun (u v : Sort 7) => u
fun (u v : Sort 8) => u
fun (u v w : Sort 6) => u
fun (u v w : Sort 7) => u
fun (u v w : Sort 8) => u

# More lambda patterns with Sort
fun (u v : Sort 4) => u -> v
fun (u v : Sort 5) => u -> v
fun (u v : Sort 6) => u -> v
fun (u v w : Sort 4) => u -> v -> w
fun (u v w : Sort 5) => u -> v -> w
fun (u v w : Sort 6) => u -> v -> w

# Additional forall at various Sort levels
forall (u v : Sort 4), u -> v -> u
forall (u v : Sort 5), u -> v -> u
forall (u v : Sort 6), u -> v -> u
forall (u v w : Sort 4), u -> v -> w -> u
forall (u v w : Sort 5), u -> v -> w -> u
forall (u v w : Sort 6), u -> v -> w -> u

# More Type n patterns
fun (A : Type 1) => A
fun (A : Type 2) => A
fun (A : Type 3) => A
fun (A : Type 4) => A
fun (A : Type 5) => A
forall (A : Type 1), A
forall (A : Type 2), A
forall (A : Type 3), A
forall (A : Type 4), A
forall (A : Type 5), A

# =============================================================================
# Additional expressions to reach 1000+ (Section 10)
# =============================================================================

# Combined parameter and return patterns
fun (A B : Type) => fun (x : A) => fun (y : B) => A
fun (A B : Type) => fun (x : A) => fun (y : B) => B
fun (A B C : Type) => fun (x : A) => fun (y : B) => fun (z : C) => A
fun (A B C : Type) => fun (x : A) => fun (y : B) => fun (z : C) => C

# More projection from deeply nested lambdas
fun (A : Type) => fun (x : A) => fun (y : A) => fun (z : A) => x
fun (A : Type) => fun (x : A) => fun (y : A) => fun (z : A) => y
fun (A : Type) => fun (x : A) => fun (y : A) => fun (z : A) => z
fun (A : Type) => fun (x : A) => fun (y : A) => fun (z : A) => fun (w : A) => x
fun (A : Type) => fun (x : A) => fun (y : A) => fun (z : A) => fun (w : A) => w

# Function type constructors
fun (A B : Type) => A -> B -> A -> B
fun (A B : Type) => A -> B -> B -> A
fun (A B C : Type) => A -> B -> C -> A -> B -> C
fun (P Q : Prop) => P -> Q -> P -> Q
fun (P Q : Prop) => P -> Q -> Q -> P
fun (P Q R : Prop) => P -> Q -> R -> P -> Q -> R

# =============================================================================
# Additional expressions to reach 1000+ (Section 11)
# =============================================================================

# More compositions with many functions
fun (A : Type) (f g h i j : A -> A) (x : A) => f (g (h (i (j x))))
fun (A : Type) (f g h i j : A -> A) (x : A) => j (i (h (g (f x))))

# More binary operations
fun (A : Type) (op : A -> A -> A) (a b c d : A) => op (op a b) (op c d)
fun (A : Type) (op : A -> A -> A) (a b c d : A) => op a (op b (op c d))
fun (A : Type) (op : A -> A -> A) (a b c d : A) => op (op (op a b) c) d

# Nested forall with type families
forall (A : Type) (B : A -> Type), forall (x : A), B x -> B x
forall (A : Type) (B : A -> Type), forall (x y : A), B x -> B y -> Type
forall (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type), forall (x : A) (y : B x), C x y

# Additional Pi type patterns
forall (A B : Type) (f : A -> B), forall (x : A), B
forall (A B : Type) (f : A -> B), forall (g : B -> A), A -> A
forall (A B : Type) (f : A -> B), forall (g : B -> A), B -> B

# =============================================================================
# Additional expressions to reach 1000+ (Section 12)
# =============================================================================

# Arrow types with higher universe levels
Type 1 -> Type 1 -> Type 1 -> Type 1
Type 2 -> Type 2 -> Type 2 -> Type 2
Type 3 -> Type 3 -> Type 3 -> Type 3
Type 4 -> Type 4 -> Type 4 -> Type 4
Type 5 -> Type 5 -> Type 5 -> Type 5

# More nested parens in arrows
((Type 1 -> Type 1) -> Type 1) -> Type 1
((Type 2 -> Type 2) -> Type 2) -> Type 2
((Type 3 -> Type 3) -> Type 3) -> Type 3
((Type 4 -> Type 4) -> Type 4) -> Type 4
(Type 1 -> (Type 1 -> Type 1)) -> Type 1 -> Type 1 -> Type 1
(Type 2 -> (Type 2 -> Type 2)) -> Type 2 -> Type 2 -> Type 2

# More forall combinations
forall (A B C D E : Type), (A -> B) -> (B -> C) -> (C -> D) -> (D -> E) -> A -> E
forall (A B C D : Type), (A -> B -> C) -> (C -> D) -> A -> B -> D
forall (A B C D : Type), A -> (A -> B) -> (B -> C) -> (C -> D) -> D

# Additional Prop patterns
forall (P Q R S T U : Prop), P -> Q -> R -> S -> T -> U -> P
forall (P Q R S T U : Prop), P -> Q -> R -> S -> T -> U -> U
fun (P Q R S T U : Prop) => P -> Q -> R -> S -> T -> U -> P
fun (P Q R S T U : Prop) => P -> Q -> R -> S -> T -> U -> U

# =============================================================================
# Additional expressions to reach 2000+ (Section 13)
# =============================================================================

# More nested lambda identity patterns
fun (A : Type) => fun (B : Type) => fun (x : A) => x
fun (A : Type) => fun (B : Type) => fun (x : B) => x
fun (A : Type) => fun (B : Type) => fun (C : Type) => fun (x : A) => x
fun (A : Type) => fun (B : Type) => fun (C : Type) => fun (x : B) => x
fun (A : Type) => fun (B : Type) => fun (C : Type) => fun (x : C) => x

# More constant function patterns
fun (A : Type) => fun (B : Type) => fun (x : A) => fun (y : B) => x
fun (A : Type) => fun (B : Type) => fun (x : A) => fun (y : B) => y
fun (A : Type) => fun (B : Type) => fun (C : Type) => fun (x : A) => fun (y : B) => fun (z : C) => x
fun (A : Type) => fun (B : Type) => fun (C : Type) => fun (x : A) => fun (y : B) => fun (z : C) => y
fun (A : Type) => fun (B : Type) => fun (C : Type) => fun (x : A) => fun (y : B) => fun (z : C) => z

# Higher-order type functions
fun (F : Type -> Type) => fun (A : Type) => F A
fun (F : Type -> Type) => fun (G : Type -> Type) => fun (A : Type) => F (G A)
fun (F : Type -> Type) => fun (G : Type -> Type) => fun (A : Type) => G (F A)
fun (F : Type -> Type -> Type) => fun (A : Type) => fun (B : Type) => F A B
fun (F : Type -> Type -> Type) => fun (A : Type) => fun (B : Type) => F B A

# Higher-order Prop functions
fun (F : Prop -> Prop) => fun (P : Prop) => F P
fun (F : Prop -> Prop) => fun (G : Prop -> Prop) => fun (P : Prop) => F (G P)
fun (F : Prop -> Prop) => fun (G : Prop -> Prop) => fun (P : Prop) => G (F P)
fun (F : Prop -> Prop -> Prop) => fun (P : Prop) => fun (Q : Prop) => F P Q
fun (F : Prop -> Prop -> Prop) => fun (P : Prop) => fun (Q : Prop) => F Q P

# Mixed Type/Prop higher-order
fun (F : Type -> Prop) => fun (A : Type) => F A
fun (F : Prop -> Type) => fun (P : Prop) => F P
fun (F : Type -> Prop) => fun (G : Type -> Type) => fun (A : Type) => F (G A)
fun (F : Prop -> Type) => fun (G : Prop -> Prop) => fun (P : Prop) => F (G P)

# Triple nested lambdas with applications
fun (A : Type) (f : A -> A -> A) => fun (x : A) => fun (y : A) => f x y
fun (A : Type) (f : A -> A -> A) => fun (x : A) => fun (y : A) => f y x
fun (A : Type) (f : A -> A -> A) (g : A -> A) => fun (x : A) => fun (y : A) => f (g x) y
fun (A : Type) (f : A -> A -> A) (g : A -> A) => fun (x : A) => fun (y : A) => f x (g y)
fun (A : Type) (f : A -> A -> A) (g : A -> A) => fun (x : A) => fun (y : A) => f (g x) (g y)

# =============================================================================
# Additional expressions to reach 2000+ (Section 14)
# =============================================================================

# Curried vs uncurried patterns
fun (A B C : Type) => A -> B -> C
fun (A B C : Type) => (A -> B) -> C
fun (A B C : Type) => A -> (B -> C)
fun (A B C D : Type) => A -> B -> C -> D
fun (A B C D : Type) => (A -> B) -> C -> D
fun (A B C D : Type) => A -> (B -> C) -> D
fun (A B C D : Type) => (A -> B -> C) -> D
fun (A B C D : Type) => A -> (B -> C -> D)

# Type families in return position
fun (A : Type) (B : A -> Type) => forall (x : A), B x
fun (A : Type) (B : A -> Type) => forall (x : A), B x -> B x
fun (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type) => forall (x : A) (y : B x), C x y
fun (A : Type) (B : A -> Type) => forall (x y : A), B x -> B y
fun (A : Type) (B : A -> Type) => forall (x y : A), B x -> B y -> Type

# Nested forall in function body
fun (A : Type) => forall (x : A), A
fun (A : Type) => forall (x y : A), A
fun (A : Type) => forall (x y z : A), A
fun (A B : Type) => forall (x : A), B
fun (A B : Type) => forall (x : A) (y : B), A
fun (A B : Type) => forall (x : A) (y : B), B

# Prop with nested forall
fun (P : Prop) => forall (x : P), P
fun (P Q : Prop) => forall (x : P), Q
fun (P Q : Prop) => forall (x : P) (y : Q), P
fun (P Q : Prop) => forall (x : P) (y : Q), Q
fun (P Q R : Prop) => forall (x : P) (y : Q) (z : R), P
fun (P Q R : Prop) => forall (x : P) (y : Q) (z : R), R

# Sort level variations
fun (U : Sort 3) => forall (x : U), U
fun (U : Sort 4) => forall (x : U), U
fun (U V : Sort 3) => forall (x : U), V
fun (U V : Sort 4) => forall (x : U), V
fun (U V W : Sort 3) => forall (x : U) (y : V), W
fun (U V W : Sort 4) => forall (x : U) (y : V), W

# =============================================================================
# Additional expressions to reach 2000+ (Section 15)
# =============================================================================

# Deep nesting of function types
Type -> Type -> Type -> Type -> Type
(Type -> Type) -> (Type -> Type) -> Type
((Type -> Type) -> Type) -> Type
Type -> ((Type -> Type) -> Type)
(Type -> (Type -> Type)) -> Type
Prop -> Prop -> Prop -> Prop -> Prop
(Prop -> Prop) -> (Prop -> Prop) -> Prop
((Prop -> Prop) -> Prop) -> Prop
Prop -> ((Prop -> Prop) -> Prop)
(Prop -> (Prop -> Prop)) -> Prop

# More universe level patterns
Sort 2 -> Sort 2 -> Sort 2 -> Sort 2
(Sort 2 -> Sort 2) -> (Sort 2 -> Sort 2) -> Sort 2
Sort 3 -> Sort 3 -> Sort 3 -> Sort 3
(Sort 3 -> Sort 3) -> (Sort 3 -> Sort 3) -> Sort 3
Sort 4 -> Sort 4 -> Sort 4 -> Sort 4
(Sort 4 -> Sort 4) -> (Sort 4 -> Sort 4) -> Sort 4

# Type 1 through Type 5 arrow patterns
Type 1 -> Type 1 -> Type 1
Type 1 -> (Type 1 -> Type 1)
(Type 1 -> Type 1) -> Type 1
Type 2 -> Type 2 -> Type 2
Type 2 -> (Type 2 -> Type 2)
(Type 2 -> Type 2) -> Type 2
Type 3 -> Type 3 -> Type 3
Type 3 -> (Type 3 -> Type 3)
(Type 3 -> Type 3) -> Type 3

# Complex Prop arrow patterns
(Prop -> Prop -> Prop) -> Prop -> Prop
Prop -> (Prop -> Prop -> Prop) -> Prop
Prop -> Prop -> (Prop -> Prop -> Prop)
(Prop -> Prop -> Prop) -> (Prop -> Prop) -> Prop
(Prop -> Prop) -> (Prop -> Prop -> Prop) -> Prop

# =============================================================================
# Additional expressions to reach 2000+ (Section 16)
# =============================================================================

# Application with multiple function arguments
fun (A : Type) (f g : A -> A) (x : A) => f (g x)
fun (A : Type) (f g : A -> A) (x : A) => g (f x)
fun (A : Type) (f g h : A -> A) (x : A) => f (g (h x))
fun (A : Type) (f g h : A -> A) (x : A) => h (g (f x))
fun (A : Type) (f g h i : A -> A) (x : A) => f (g (h (i x)))
fun (A : Type) (f g h i : A -> A) (x : A) => i (h (g (f x)))

# Binary function applications
fun (A : Type) (f : A -> A -> A) (x y : A) => f x y
fun (A : Type) (f : A -> A -> A) (x y : A) => f y x
fun (A : Type) (f : A -> A -> A) (x y z : A) => f (f x y) z
fun (A : Type) (f : A -> A -> A) (x y z : A) => f x (f y z)
fun (A : Type) (f g : A -> A -> A) (x y : A) => f (g x y) x
fun (A : Type) (f g : A -> A -> A) (x y : A) => g (f x y) y

# Ternary function applications
fun (A : Type) (f : A -> A -> A -> A) (x y z : A) => f x y z
fun (A : Type) (f : A -> A -> A -> A) (x y z : A) => f z y x
fun (A : Type) (f : A -> A -> A -> A) (g : A -> A) (x y z : A) => f (g x) y z
fun (A : Type) (f : A -> A -> A -> A) (g : A -> A) (x y z : A) => f x (g y) z
fun (A : Type) (f : A -> A -> A -> A) (g : A -> A) (x y z : A) => f x y (g z)

# Higher-order function applications
fun (A : Type) (h : (A -> A) -> A) (f : A -> A) => h f
fun (A : Type) (h : (A -> A) -> A -> A) (f : A -> A) (x : A) => h f x
fun (A : Type) (h : (A -> A -> A) -> A) (f : A -> A -> A) => h f
fun (A : Type) (h : A -> (A -> A) -> A) (x : A) (f : A -> A) => h x f

# =============================================================================
# Additional expressions to reach 2000+ (Section 17)
# =============================================================================

# Forall with function types in result
forall (A : Type), A -> A
forall (A B : Type), A -> B
forall (A B : Type), B -> A
forall (A B C : Type), A -> B -> C
forall (A B C : Type), C -> B -> A
forall (A B C D : Type), A -> B -> C -> D
forall (A B C D : Type), D -> C -> B -> A

# Forall with Prop in result
forall (P : Prop), P -> P
forall (P Q : Prop), P -> Q
forall (P Q : Prop), Q -> P
forall (P Q R : Prop), P -> Q -> R
forall (P Q R : Prop), R -> Q -> P

# Forall with Sort in result
forall (U : Sort 2), U -> U
forall (U V : Sort 2), U -> V
forall (U V : Sort 2), V -> U
forall (U : Sort 3), U -> U
forall (U V : Sort 3), U -> V
forall (U V : Sort 3), V -> U

# Mixed forall patterns
forall (A : Type) (P : Prop), A -> P
forall (A : Type) (P : Prop), P -> A
forall (A B : Type) (P : Prop), A -> B -> P
forall (A : Type) (P Q : Prop), A -> P -> Q
forall (A : Type) (P Q : Prop), P -> A -> Q
forall (A : Type) (P Q : Prop), P -> Q -> A

# =============================================================================
# Additional expressions to reach 2000+ (Section 18)
# =============================================================================

# Lambda returning forall
fun (A : Type) => forall (B : Type), A -> B
fun (A : Type) => forall (B : Type), B -> A
fun (A : Type) => forall (B C : Type), A -> B -> C
fun (A : Type) => forall (B C : Type), B -> C -> A
fun (P : Prop) => forall (Q : Prop), P -> Q
fun (P : Prop) => forall (Q : Prop), Q -> P
fun (P : Prop) => forall (Q R : Prop), P -> Q -> R
fun (P : Prop) => forall (Q R : Prop), Q -> R -> P

# Nested lambda with forall
fun (A : Type) => fun (B : Type) => forall (x : A), B
fun (A : Type) => fun (B : Type) => forall (x : B), A
fun (A : Type) => fun (B : Type) => forall (x : A) (y : B), A
fun (A : Type) => fun (B : Type) => forall (x : A) (y : B), B

# Double forall patterns
forall (A : Type), forall (B : Type), A -> B
forall (A : Type), forall (B : Type), B -> A
forall (A : Type), forall (B C : Type), A -> B -> C
forall (A B : Type), forall (C : Type), A -> B -> C
forall (A B : Type), forall (C D : Type), A -> B -> C -> D

# Triple forall patterns
forall (A : Type), forall (B : Type), forall (C : Type), A -> B -> C
forall (A : Type), forall (B : Type), forall (C : Type), C -> B -> A
forall (P : Prop), forall (Q : Prop), forall (R : Prop), P -> Q -> R
forall (P : Prop), forall (Q : Prop), forall (R : Prop), R -> Q -> P

# =============================================================================
# Additional expressions to reach 2000+ (Section 19)
# =============================================================================

# Complex type family patterns
fun (A : Type) (B : A -> Type) (x : A) => B x
fun (A : Type) (B : A -> Type) (x y : A) => B x -> B y
fun (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type) (x : A) (y : B x) => C x y
fun (A : Type) (B C : A -> Type) (x : A) => B x -> C x
fun (A : Type) (B C : A -> Type) (x y : A) => B x -> C y

# Dependent type patterns
forall (A : Type) (B : A -> Type) (x : A), B x
forall (A : Type) (B : A -> Type) (x y : A), B x -> B y
forall (A : Type) (B : A -> Type) (x y : A), B x -> B y -> B x
forall (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type) (x : A) (y : B x), C x y

# Sigma-like patterns (without actual Sigma type)
fun (A : Type) (B : A -> Type) => forall (P : forall (x : A), B x -> Prop), Prop
fun (A : Type) (B : A -> Type) => forall (P : forall (x : A), B x -> Type), Type

# More dependent patterns
fun (A : Type) (B : A -> A -> Type) (x y : A) => B x y
fun (A : Type) (B : A -> A -> Type) (x y z : A) => B x y -> B y z
fun (A : Type) (B : A -> A -> Type) (x y z : A) => B x y -> B y z -> B x z

# =============================================================================
# Additional expressions to reach 2000+ (Section 20)
# =============================================================================

# Identity at various Sort levels
fun (u : Sort 1) => u
fun (u : Sort 2) => u
fun (u : Sort 3) => u
fun (u : Sort 4) => u
fun (u : Sort 5) => u
fun (u : Sort 6) => u

# Constant at various Sort levels
fun (u v : Sort 1) => u
fun (u v : Sort 2) => u
fun (u v : Sort 3) => u
fun (u v : Sort 4) => u
fun (u v : Sort 5) => u
fun (u v : Sort 6) => u

# Flip at various Sort levels
fun (u v : Sort 1) => v
fun (u v : Sort 2) => v
fun (u v : Sort 3) => v
fun (u v : Sort 4) => v
fun (u v : Sort 5) => v
fun (u v : Sort 6) => v

# Arrow at various Sort levels
Sort 1 -> Sort 1
Sort 2 -> Sort 2
Sort 3 -> Sort 3
Sort 4 -> Sort 4
Sort 5 -> Sort 5
Sort 6 -> Sort 6

# Cross-Sort arrows
Sort 1 -> Sort 2
Sort 2 -> Sort 3
Sort 3 -> Sort 4
Sort 4 -> Sort 5
Sort 5 -> Sort 6
Sort 2 -> Sort 1
Sort 3 -> Sort 2
Sort 4 -> Sort 3
Sort 5 -> Sort 4
Sort 6 -> Sort 5

# =============================================================================
# Additional expressions to reach 2000+ (Section 21)
# =============================================================================

# S combinator-like patterns
fun (A B C : Type) (f : A -> B -> C) (g : A -> B) (x : A) => f x (g x)
fun (P Q R : Prop) (f : P -> Q -> R) (g : P -> Q) (x : P) => f x (g x)

# K combinator-like patterns
fun (A B : Type) (x : A) (y : B) => x
fun (A B : Type) (x : A) (y : B) => y
fun (P Q : Prop) (x : P) (y : Q) => x
fun (P Q : Prop) (x : P) (y : Q) => y

# I combinator-like patterns
fun (A : Type) (x : A) => x
fun (P : Prop) (x : P) => x

# B combinator-like patterns (composition)
fun (A B C : Type) (f : B -> C) (g : A -> B) (x : A) => f (g x)
fun (P Q R : Prop) (f : Q -> R) (g : P -> Q) (x : P) => f (g x)

# C combinator-like patterns (flip)
fun (A B C : Type) (f : A -> B -> C) (x : B) (y : A) => f y x
fun (P Q R : Prop) (f : P -> Q -> R) (x : Q) (y : P) => f y x

# W combinator-like patterns (duplicate)
fun (A B : Type) (f : A -> A -> B) (x : A) => f x x
fun (P Q : Prop) (f : P -> P -> Q) (x : P) => f x x

# =============================================================================
# Additional expressions to reach 2000+ (Section 22)
# =============================================================================

# More arrow type patterns
(Type -> Type) -> Type -> Type -> Type
Type -> (Type -> Type) -> Type -> Type
Type -> Type -> (Type -> Type) -> Type
Type -> Type -> Type -> (Type -> Type)

(Prop -> Prop) -> Prop -> Prop -> Prop
Prop -> (Prop -> Prop) -> Prop -> Prop
Prop -> Prop -> (Prop -> Prop) -> Prop
Prop -> Prop -> Prop -> (Prop -> Prop)

# More Sort arrow patterns
(Sort 2 -> Sort 2) -> Sort 2 -> Sort 2 -> Sort 2
Sort 2 -> (Sort 2 -> Sort 2) -> Sort 2 -> Sort 2
Sort 2 -> Sort 2 -> (Sort 2 -> Sort 2) -> Sort 2

(Sort 3 -> Sort 3) -> Sort 3 -> Sort 3 -> Sort 3
Sort 3 -> (Sort 3 -> Sort 3) -> Sort 3 -> Sort 3
Sort 3 -> Sort 3 -> (Sort 3 -> Sort 3) -> Sort 3

# Lambda with complex return types
fun (A : Type) => A -> A -> A
fun (A : Type) => A -> A -> A -> A
fun (A : Type) => A -> A -> A -> A -> A
fun (A : Type) => (A -> A) -> A
fun (A : Type) => (A -> A) -> A -> A
fun (A : Type) => (A -> A -> A) -> A
fun (A : Type) => (A -> A -> A) -> A -> A

# =============================================================================
# Additional expressions to reach 2000+ (Section 23)
# =============================================================================

# Forall with higher-order function types
forall (A : Type) (f : A -> A), A -> A
forall (A : Type) (f : A -> A), A
forall (A : Type) (f g : A -> A), A -> A
forall (A : Type) (f g : A -> A), A
forall (A B : Type) (f : A -> B), A -> B
forall (A B : Type) (f : A -> B), B -> A

# Forall with binary operations
forall (A : Type) (op : A -> A -> A), A -> A
forall (A : Type) (op : A -> A -> A), A -> A -> A
forall (A : Type) (op : A -> A -> A) (e : A), A -> A
forall (A : Type) (op : A -> A -> A) (e : A), A
forall (A B : Type) (f : A -> A -> B), A -> B
forall (A B : Type) (f : A -> A -> B), A -> A -> B

# Forall with Prop operations
forall (P : Prop) (f : P -> P), P -> P
forall (P : Prop) (f : P -> P), P
forall (P Q : Prop) (f : P -> Q), P -> Q
forall (P Q : Prop) (f : P -> Q), Q
forall (P : Prop) (op : P -> P -> P), P -> P
forall (P : Prop) (op : P -> P -> P), P -> P -> P

# =============================================================================
# Additional expressions to reach 2000+ (Section 24)
# =============================================================================

# More lambda patterns with nested function types
fun (A : Type) (f : (A -> A) -> A -> A) (g : A -> A) (x : A) => f g x
fun (A : Type) (f : A -> (A -> A) -> A) (x : A) (g : A -> A) => f x g
fun (A : Type) (f : (A -> A) -> (A -> A)) (g : A -> A) (x : A) => (f g) x
fun (A : Type) (f : (A -> A -> A) -> A -> A) (g : A -> A -> A) (x : A) => f g x

# More Prop patterns with nested function types
fun (P : Prop) (f : (P -> P) -> P -> P) (g : P -> P) (x : P) => f g x
fun (P : Prop) (f : P -> (P -> P) -> P) (x : P) (g : P -> P) => f x g
fun (P : Prop) (f : (P -> P) -> (P -> P)) (g : P -> P) (x : P) => (f g) x

# Type level functions with multiple applications
fun (F : Type -> Type) (G : Type -> Type) (A : Type) => F (G A)
fun (F : Type -> Type) (G : Type -> Type) (A : Type) => G (F A)
fun (F : Type -> Type) (G : Type -> Type) (H : Type -> Type) (A : Type) => F (G (H A))
fun (F : Type -> Type -> Type) (G : Type -> Type) (A B : Type) => F (G A) (G B)
fun (F : Type -> Type -> Type) (A B C : Type) => F (F A B) C
fun (F : Type -> Type -> Type) (A B C : Type) => F A (F B C)

# =============================================================================
# Additional expressions to reach 2000+ (Section 25)
# =============================================================================

# Very long parameter lists
fun (A B C D E : Type) (x : A) => x
fun (A B C D E : Type) (x : B) => x
fun (A B C D E : Type) (x : C) => x
fun (A B C D E : Type) (x : D) => x
fun (A B C D E : Type) (x : E) => x

fun (A B C D E F : Type) (x : A) => x
fun (A B C D E F : Type) (x : B) => x
fun (A B C D E F : Type) (x : C) => x
fun (A B C D E F : Type) (x : D) => x
fun (A B C D E F : Type) (x : E) => x
fun (A B C D E F : Type) (x : F) => x

# Similar for Prop
fun (P Q R S T : Prop) (x : P) => x
fun (P Q R S T : Prop) (x : Q) => x
fun (P Q R S T : Prop) (x : R) => x
fun (P Q R S T : Prop) (x : S) => x
fun (P Q R S T : Prop) (x : T) => x

fun (P Q R S T U : Prop) (x : P) => x
fun (P Q R S T U : Prop) (x : Q) => x
fun (P Q R S T U : Prop) (x : R) => x
fun (P Q R S T U : Prop) (x : S) => x
fun (P Q R S T U : Prop) (x : T) => x
fun (P Q R S T U : Prop) (x : U) => x

# =============================================================================
# Additional expressions to reach 2000+ (Section 26)
# =============================================================================

# Arrow chains at higher type levels
Type 1 -> Type 1 -> Type 1 -> Type 1 -> Type 1
Type 2 -> Type 2 -> Type 2 -> Type 2 -> Type 2
Type 3 -> Type 3 -> Type 3 -> Type 3 -> Type 3

# Mixed level arrows
Type -> Type 1
Type 1 -> Type
Type 1 -> Type 2
Type 2 -> Type 1
Type 2 -> Type 3
Type 3 -> Type 2

# Prop/Type mixed
Prop -> Type
Type -> Prop
Prop -> Prop -> Type
Type -> Type -> Prop
Prop -> Type -> Prop
Type -> Prop -> Type

# =============================================================================
# Additional expressions to reach 2000+ (Section 27)
# =============================================================================

# Functions with multiple arguments returning each one
fun (A B C D : Type) (a : A) (b : B) (c : C) (d : D) => a
fun (A B C D : Type) (a : A) (b : B) (c : C) (d : D) => b
fun (A B C D : Type) (a : A) (b : B) (c : C) (d : D) => c
fun (A B C D : Type) (a : A) (b : B) (c : C) (d : D) => d

fun (A B C D E : Type) (a : A) (b : B) (c : C) (d : D) (e : E) => a
fun (A B C D E : Type) (a : A) (b : B) (c : C) (d : D) (e : E) => b
fun (A B C D E : Type) (a : A) (b : B) (c : C) (d : D) (e : E) => c
fun (A B C D E : Type) (a : A) (b : B) (c : C) (d : D) (e : E) => d
fun (A B C D E : Type) (a : A) (b : B) (c : C) (d : D) (e : E) => e

# Prop versions
fun (P Q R S : Prop) (p : P) (q : Q) (r : R) (s : S) => p
fun (P Q R S : Prop) (p : P) (q : Q) (r : R) (s : S) => q
fun (P Q R S : Prop) (p : P) (q : Q) (r : R) (s : S) => r
fun (P Q R S : Prop) (p : P) (q : Q) (r : R) (s : S) => s

fun (P Q R S T : Prop) (p : P) (q : Q) (r : R) (s : S) (t : T) => p
fun (P Q R S T : Prop) (p : P) (q : Q) (r : R) (s : S) (t : T) => q
fun (P Q R S T : Prop) (p : P) (q : Q) (r : R) (s : S) (t : T) => r
fun (P Q R S T : Prop) (p : P) (q : Q) (r : R) (s : S) (t : T) => s
fun (P Q R S T : Prop) (p : P) (q : Q) (r : R) (s : S) (t : T) => t

# =============================================================================
# Additional expressions (Section 28)
# =============================================================================

# Function composition chains
fun (A : Type) (f1 f2 : A -> A) (x : A) => f1 (f2 x)
fun (A : Type) (f1 f2 f3 : A -> A) (x : A) => f1 (f2 (f3 x))
fun (A : Type) (f1 f2 f3 f4 : A -> A) (x : A) => f1 (f2 (f3 (f4 x)))

# Reversed composition chains
fun (A : Type) (f1 f2 : A -> A) (x : A) => f2 (f1 x)
fun (A : Type) (f1 f2 f3 : A -> A) (x : A) => f3 (f2 (f1 x))
fun (A : Type) (f1 f2 f3 f4 : A -> A) (x : A) => f4 (f3 (f2 (f1 x)))

# Binary operation associativity tests
fun (A : Type) (op : A -> A -> A) (a b c : A) => op a (op b c)
fun (A : Type) (op : A -> A -> A) (a b c : A) => op (op a b) c
fun (A : Type) (op : A -> A -> A) (a b c d : A) => op a (op b (op c d))
fun (A : Type) (op : A -> A -> A) (a b c d : A) => op (op (op a b) c) d
fun (A : Type) (op : A -> A -> A) (a b c d : A) => op (op a b) (op c d)

# =============================================================================
# Additional expressions (Section 29)
# =============================================================================

# Forall with function composition
forall (A : Type) (f g : A -> A) (x : A), A
forall (A : Type) (f g : A -> A), A -> A
forall (A : Type) (f g h : A -> A), A -> A
forall (A : Type) (f g h : A -> A) (x : A), A
forall (A B : Type) (f : A -> B) (g : B -> A), A -> A
forall (A B : Type) (f : A -> B) (g : B -> A), B -> B

# More dependent forall patterns
forall (A : Type) (P : A -> Type) (x : A), P x
forall (A : Type) (P : A -> Type) (x y : A), P x -> P y
forall (A : Type) (P : A -> Type) (Q : A -> Type) (x : A), P x -> Q x
forall (A : Type) (P : A -> A -> Type) (x y : A), P x y
forall (A : Type) (P : A -> A -> Type) (x y z : A), P x y -> P y z

# Higher-order dependent forall
forall (A : Type) (P : A -> Type), (forall (x : A), P x) -> Type
forall (A : Type) (P : A -> Type) (Q : forall (x : A), P x -> Type), Type
forall (A : Type) (P Q : A -> Type), (forall (x : A), P x -> Q x) -> Type

# =============================================================================
# Additional expressions (Section 30)
# =============================================================================

# More universe level patterns
Type 1 -> Type
Type 2 -> Type 1
Type 3 -> Type 2
Type 4 -> Type 3
Type 5 -> Type 4

Type -> Type 1 -> Type
Type 1 -> Type -> Type 1
Type 2 -> Type 1 -> Type
Type 1 -> Type 2 -> Type 2

# Sort level patterns
Sort 1 -> Prop
Sort 2 -> Type
Sort 3 -> Type 1
Sort 4 -> Type 2
Sort 5 -> Type 3

# Lambda with mixed universes
fun (A : Type) (B : Type 1) => A
fun (A : Type) (B : Type 1) => B
fun (A : Type 1) (B : Type) => A
fun (A : Type 1) (B : Type) => B
fun (A : Type) (B : Type 1) (C : Type 2) => A
fun (A : Type) (B : Type 1) (C : Type 2) => B
fun (A : Type) (B : Type 1) (C : Type 2) => C

# =============================================================================
# Additional expressions (Section 31)
# =============================================================================

# More arrow type variations
Prop -> Prop -> Prop -> Prop -> Prop -> Prop
Type -> Type -> Type -> Type -> Type -> Type
Sort 2 -> Sort 2 -> Sort 2 -> Sort 2 -> Sort 2 -> Sort 2
Sort 3 -> Sort 3 -> Sort 3 -> Sort 3 -> Sort 3 -> Sort 3

# Nested parenthesized arrows
((((Prop -> Prop) -> Prop) -> Prop) -> Prop) -> Prop
(Prop -> ((Prop -> Prop) -> Prop)) -> Prop
Prop -> (Prop -> (Prop -> (Prop -> Prop)))
((((Type -> Type) -> Type) -> Type) -> Type) -> Type
(Type -> ((Type -> Type) -> Type)) -> Type
Type -> (Type -> (Type -> (Type -> Type)))

# Function types with many arrows
(Prop -> Prop) -> (Prop -> Prop) -> Prop -> Prop
(Type -> Type) -> (Type -> Type) -> Type -> Type
(Prop -> Prop) -> Prop -> (Prop -> Prop)
(Type -> Type) -> Type -> (Type -> Type)

# =============================================================================
# Additional expressions (Section 32)
# =============================================================================

# Application with multiple functions
fun (A : Type) (f g : A -> A) => fun (x : A) => f (g x)
fun (A : Type) (f g : A -> A) => fun (x : A) => g (f x)
fun (A : Type) (f g h : A -> A) => fun (x : A) => f (g (h x))
fun (A : Type) (f g h : A -> A) => fun (x : A) => h (g (f x))
fun (A : Type) (f : A -> A -> A) (g : A -> A) => fun (x y : A) => f (g x) (g y)
fun (A : Type) (f : A -> A -> A) (g : A -> A) => fun (x y : A) => g (f x y)

# More binary function patterns
fun (A B C : Type) (f : A -> B) (g : B -> C) => fun (x : A) => g (f x)
fun (A B C : Type) (f : A -> B) (g : B -> C) (x : A) => g (f x)
fun (A B C D : Type) (f : A -> B) (g : B -> C) (h : C -> D) => fun (x : A) => h (g (f x))
fun (A B C D : Type) (f : A -> B) (g : B -> C) (h : C -> D) (x : A) => h (g (f x))

# Currying patterns
fun (A B C : Type) (f : A -> B -> C) => fun (x : A) => fun (y : B) => f x y
fun (A B C : Type) (f : A -> B -> C) => fun (y : B) => fun (x : A) => f x y
fun (A B C : Type) (f : A -> B -> C) (x : A) => fun (y : B) => f x y
fun (A B C : Type) (f : A -> B -> C) (y : B) => fun (x : A) => f x y

# =============================================================================
# Additional expressions (Section 33)
# =============================================================================

# More forall with arrow return types
forall (A B : Type), (A -> B) -> (B -> A) -> A -> A
forall (A B : Type), (A -> B) -> (B -> A) -> B -> B
forall (A B C : Type), (A -> B) -> (B -> C) -> A -> C
forall (A B C : Type), (A -> B) -> (B -> C) -> (C -> A) -> A -> A
forall (A B C : Type), (A -> B) -> (B -> C) -> (C -> A) -> B -> B
forall (A B C : Type), (A -> B) -> (B -> C) -> (C -> A) -> C -> C

# More Prop forall patterns
forall (P Q : Prop), (P -> Q) -> (Q -> P) -> P -> P
forall (P Q : Prop), (P -> Q) -> (Q -> P) -> Q -> Q
forall (P Q R : Prop), (P -> Q) -> (Q -> R) -> P -> R
forall (P Q R : Prop), (P -> Q) -> (Q -> R) -> (R -> P) -> P -> P
forall (P Q R : Prop), (P -> Q) -> (Q -> R) -> (R -> P) -> Q -> Q
forall (P Q R : Prop), (P -> Q) -> (Q -> R) -> (R -> P) -> R -> R

# Nested forall with dependent types
forall (A : Type) (B : A -> Type), (forall (x : A), B x) -> A -> Type
forall (A : Type) (B : A -> Type), (forall (x : A), B x) -> forall (x : A), B x
forall (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type), forall (x : A) (y : B x), C x y

# =============================================================================
# Additional expressions (Section 34)
# =============================================================================

# Identity function at different type levels
fun (x : Prop) => x
fun (x : Type) => x
fun (x : Type 1) => x
fun (x : Type 2) => x
fun (x : Type 3) => x
fun (x : Type 4) => x
fun (x : Type 5) => x
fun (x : Sort 2) => x
fun (x : Sort 3) => x
fun (x : Sort 4) => x
fun (x : Sort 5) => x
fun (x : Sort 6) => x

# Constant function at different type levels
fun (x : Prop) (y : Prop) => x
fun (x : Type) (y : Type) => x
fun (x : Type 1) (y : Type 1) => x
fun (x : Type 2) (y : Type 2) => x
fun (x : Type 3) (y : Type 3) => x
fun (x : Type 4) (y : Type 4) => x
fun (x : Sort 2) (y : Sort 2) => x
fun (x : Sort 3) (y : Sort 3) => x
fun (x : Sort 4) (y : Sort 4) => x
fun (x : Sort 5) (y : Sort 5) => x

# =============================================================================
# Additional expressions (Section 35)
# =============================================================================

# More function type patterns
fun (A : Type) => A -> A -> A -> A -> A
fun (A : Type) => (A -> A) -> A -> A -> A
fun (A : Type) => (A -> A -> A) -> A -> A
fun (A : Type) => ((A -> A) -> A) -> A
fun (A : Type) => (((A -> A) -> A) -> A) -> A

fun (P : Prop) => P -> P -> P -> P -> P
fun (P : Prop) => (P -> P) -> P -> P -> P
fun (P : Prop) => (P -> P -> P) -> P -> P
fun (P : Prop) => ((P -> P) -> P) -> P
fun (P : Prop) => (((P -> P) -> P) -> P) -> P

# More mixed patterns
fun (A : Type) (P : Prop) => A -> P
fun (A : Type) (P : Prop) => P -> A
fun (A : Type) (P : Prop) => A -> P -> A
fun (A : Type) (P : Prop) => P -> A -> P
fun (A : Type) (P : Prop) => A -> A -> P
fun (A : Type) (P : Prop) => P -> P -> A

# More forall mixed patterns
forall (A : Type) (P : Prop), A -> P -> A
forall (A : Type) (P : Prop), P -> A -> P
forall (A : Type) (P : Prop), A -> A -> P -> A
forall (A : Type) (P : Prop), P -> P -> A -> P
forall (A B : Type) (P : Prop), A -> B -> P -> A
forall (A B : Type) (P : Prop), A -> B -> P -> B
forall (A B : Type) (P : Prop), A -> B -> P -> P

# =============================================================================
# Additional expressions (Section 36)
# =============================================================================

# Type families with multiple parameters
fun (A B : Type) (F : A -> B -> Type) (x : A) (y : B) => F x y
fun (A B C : Type) (F : A -> B -> C -> Type) (x : A) (y : B) (z : C) => F x y z

forall (A B : Type) (F : A -> B -> Type) (x : A) (y : B), F x y
forall (A B : Type) (F : A -> B -> Type), (forall (x : A) (y : B), F x y) -> Type
forall (A B C : Type) (F : A -> B -> C -> Type) (x : A) (y : B) (z : C), F x y z

# Nested dependent types
forall (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type), Type
forall (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type) (x : A) (y : B x), C x y
forall (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type), (forall (x : A) (y : B x), C x y) -> Type

# =============================================================================
# Additional expressions (Section 37)
# =============================================================================

# More lambda with forall return
fun (A : Type) => forall (x : A), A
fun (A : Type) => forall (x y : A), A
fun (A : Type) => forall (x y z : A), A
fun (A B : Type) => forall (x : A) (y : B), A
fun (A B : Type) => forall (x : A) (y : B), B
fun (A B C : Type) => forall (x : A) (y : B) (z : C), A
fun (A B C : Type) => forall (x : A) (y : B) (z : C), B
fun (A B C : Type) => forall (x : A) (y : B) (z : C), C

# Lambda with complex forall return
fun (A : Type) (B : A -> Type) => forall (x : A), B x
fun (A : Type) (B : A -> Type) => forall (x y : A), B x -> B y
fun (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type) => forall (x : A) (y : B x), C x y

# Deeply nested forall in lambda body
fun (A : Type) => forall (B : Type), A -> B
fun (A : Type) => forall (B : Type), B -> A
fun (A : Type) => forall (B C : Type), A -> B -> C
fun (A : Type) => forall (B C : Type), C -> B -> A
fun (A : Type) => forall (B : Type), forall (C : Type), A -> B -> C

# =============================================================================
# Additional expressions (Section 38)
# =============================================================================

# More higher-order function applications
fun (A : Type) (h : (A -> A) -> (A -> A) -> A -> A) (f g : A -> A) (x : A) => h f g x
fun (A : Type) (h : (A -> A -> A) -> A -> A -> A) (f : A -> A -> A) (x y : A) => h f x y
fun (A : Type) (h : A -> A -> A -> A) (x y z : A) => h x y z
fun (A : Type) (h : (A -> A) -> A) (f : A -> A) => h f
fun (A : Type) (h : (A -> A) -> (A -> A)) (f : A -> A) => h f
fun (A : Type) (h : ((A -> A) -> A) -> A) (f : (A -> A) -> A) => h f

# Prop higher-order applications
fun (P : Prop) (h : (P -> P) -> (P -> P) -> P -> P) (f g : P -> P) (x : P) => h f g x
fun (P : Prop) (h : (P -> P -> P) -> P -> P -> P) (f : P -> P -> P) (x y : P) => h f x y
fun (P : Prop) (h : P -> P -> P -> P) (x y z : P) => h x y z
fun (P : Prop) (h : (P -> P) -> P) (f : P -> P) => h f
fun (P : Prop) (h : (P -> P) -> (P -> P)) (f : P -> P) => h f
fun (P : Prop) (h : ((P -> P) -> P) -> P) (f : (P -> P) -> P) => h f

# =============================================================================
# Additional expressions (Section 39)
# =============================================================================

# More complex arrow patterns
((Type -> Type) -> (Type -> Type)) -> Type -> Type
(Type -> Type) -> ((Type -> Type) -> Type) -> Type
Type -> ((Type -> Type) -> (Type -> Type)) -> Type
((Type -> Type) -> Type) -> (Type -> Type) -> Type

((Prop -> Prop) -> (Prop -> Prop)) -> Prop -> Prop
(Prop -> Prop) -> ((Prop -> Prop) -> Prop) -> Prop
Prop -> ((Prop -> Prop) -> (Prop -> Prop)) -> Prop
((Prop -> Prop) -> Prop) -> (Prop -> Prop) -> Prop

# More Sort arrow patterns
((Sort 2 -> Sort 2) -> (Sort 2 -> Sort 2)) -> Sort 2 -> Sort 2
(Sort 2 -> Sort 2) -> ((Sort 2 -> Sort 2) -> Sort 2) -> Sort 2
((Sort 3 -> Sort 3) -> (Sort 3 -> Sort 3)) -> Sort 3 -> Sort 3
(Sort 3 -> Sort 3) -> ((Sort 3 -> Sort 3) -> Sort 3) -> Sort 3

# =============================================================================
# Additional expressions (Section 40)
# =============================================================================

# More function with type family
fun (A : Type) (B : A -> Type) (f : forall (x : A), B x) (x : A) => f x
fun (A : Type) (B : A -> Type) (f g : forall (x : A), B x) (x : A) => f x
fun (A : Type) (B : A -> Type) (f : forall (x : A), B x) (x y : A) => f x
fun (A : Type) (B : A -> Type) (f : forall (x : A), B x) (x y : A) => f y

forall (A : Type) (B : A -> Type) (f : forall (x : A), B x), forall (x : A), B x
forall (A : Type) (B : A -> Type) (f g : forall (x : A), B x) (x : A), B x
forall (A : Type) (B : A -> Type), (forall (x : A), B x) -> forall (x : A), B x
forall (A : Type) (B : A -> Type), (forall (x : A), B x) -> A -> Type

# More functions with dependent results
fun (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type) (f : forall (x : A), B x) (x : A) => C x (f x)
fun (A : Type) (B C : A -> Type) (f : forall (x : A), B x) (g : forall (x : A), C x) (x : A) => B x
fun (A : Type) (B C : A -> Type) (f : forall (x : A), B x) (g : forall (x : A), C x) (x : A) => C x

# =============================================================================
# Additional expressions (Section 41)
# =============================================================================

# More Sort level expressions
fun (U : Sort 2) => U -> U -> U
fun (U : Sort 3) => U -> U -> U
fun (U : Sort 4) => U -> U -> U
fun (U : Sort 5) => U -> U -> U
fun (U V : Sort 2) => U -> V -> U
fun (U V : Sort 3) => U -> V -> U
fun (U V : Sort 4) => U -> V -> U
fun (U V : Sort 5) => U -> V -> U

forall (U : Sort 2), U -> U -> U
forall (U : Sort 3), U -> U -> U
forall (U : Sort 4), U -> U -> U
forall (U : Sort 5), U -> U -> U
forall (U V : Sort 2), U -> V -> U
forall (U V : Sort 3), U -> V -> U
forall (U V : Sort 4), U -> V -> U
forall (U V : Sort 5), U -> V -> U

# Cross-sort patterns
fun (U : Sort 2) (V : Sort 3) => U -> V
fun (U : Sort 3) (V : Sort 2) => U -> V
fun (U : Sort 2) (V : Sort 4) => U -> V
fun (U : Sort 4) (V : Sort 2) => U -> V
forall (U : Sort 2) (V : Sort 3), U -> V -> U
forall (U : Sort 3) (V : Sort 2), U -> V -> U

# =============================================================================
# Additional expressions (Section 42)
# =============================================================================

# Complex function patterns
fun (A B C D : Type) (f : A -> B -> C) (g : C -> D) (x : A) (y : B) => g (f x y)
fun (A B C D : Type) (f : A -> B) (g : C -> D) (h : B -> C) (x : A) => g (h (f x))
fun (A B C D E : Type) (f : A -> B) (g : B -> C) (h : C -> D) (i : D -> E) (x : A) => i (h (g (f x)))

# Prop complex patterns
fun (P Q R S : Prop) (f : P -> Q -> R) (g : R -> S) (x : P) (y : Q) => g (f x y)
fun (P Q R S : Prop) (f : P -> Q) (g : R -> S) (h : Q -> R) (x : P) => g (h (f x))
fun (P Q R S T : Prop) (f : P -> Q) (g : Q -> R) (h : R -> S) (i : S -> T) (x : P) => i (h (g (f x)))

# Mixed Type/Prop complex patterns
fun (A : Type) (P Q : Prop) (f : A -> P) (g : P -> Q) (x : A) => g (f x)
fun (P : Prop) (A B : Type) (f : P -> A) (g : A -> B) (x : P) => g (f x)

# =============================================================================
# Additional expressions (Section 43)
# =============================================================================

# Arrow types at Type 1-5
Type 1 -> Type 1 -> Type 1 -> Type 1 -> Type 1 -> Type 1
Type 2 -> Type 2 -> Type 2 -> Type 2 -> Type 2 -> Type 2
Type 3 -> Type 3 -> Type 3 -> Type 3 -> Type 3 -> Type 3
Type 4 -> Type 4 -> Type 4 -> Type 4 -> Type 4 -> Type 4
Type 5 -> Type 5 -> Type 5 -> Type 5 -> Type 5 -> Type 5

# Cross-level arrows
Type -> Type 1 -> Type 2 -> Type 3 -> Type 4 -> Type 5
Type 5 -> Type 4 -> Type 3 -> Type 2 -> Type 1 -> Type
Prop -> Type -> Type 1 -> Type 2 -> Type 3
Type 3 -> Type 2 -> Type 1 -> Type -> Prop

# Lambda at Type 1-5
fun (A : Type 1) (x : A) => x
fun (A : Type 2) (x : A) => x
fun (A : Type 3) (x : A) => x
fun (A : Type 4) (x : A) => x
fun (A : Type 5) (x : A) => x

# Forall at Type 1-5
forall (A : Type 1) (x : A), A
forall (A : Type 2) (x : A), A
forall (A : Type 3) (x : A), A
forall (A : Type 4) (x : A), A
forall (A : Type 5) (x : A), A

# =============================================================================
# Additional expressions (Section 44)
# =============================================================================

# More complex dependent types
fun (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type) => forall (x : A) (y : B x), C x y
fun (A : Type) (B C : A -> Type) => forall (x : A), B x -> C x

forall (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type), (forall (x : A) (y : B x), C x y) -> Type
forall (A : Type) (B : A -> Type) (C : forall (x : A), B x -> Type) (f : forall (x : A) (y : B x), C x y), Type
forall (A : Type) (B C : A -> Type) (f : forall (x : A), B x -> C x), A -> Type

# More higher-order dependent
fun (A : Type) (P : A -> Prop) => forall (x : A), P x -> P x
fun (A : Type) (P : A -> Prop) (Q : forall (x : A), P x -> Prop) => forall (x : A) (y : P x), Q x y
forall (A : Type) (P : A -> Prop), (forall (x : A), P x) -> Prop
forall (A : Type) (P Q : A -> Prop), (forall (x : A), P x -> Q x) -> Prop

# =============================================================================
# Additional expressions (Section 45)
# =============================================================================

# More applications with multiple arguments
fun (A : Type) (f : A -> A -> A -> A) (x : A) => f x x x
fun (A : Type) (f : A -> A -> A -> A) (x y : A) => f x y x
fun (A : Type) (f : A -> A -> A -> A) (x y z : A) => f z y x
fun (A : Type) (f : A -> A -> A -> A -> A) (x : A) => f x x x x
fun (A : Type) (f : A -> A -> A -> A -> A) (x y : A) => f x y x y
fun (A : Type) (f : A -> A -> A -> A -> A) (x y z w : A) => f w z y x

# Prop applications with multiple arguments
fun (P : Prop) (f : P -> P -> P -> P) (x : P) => f x x x
fun (P : Prop) (f : P -> P -> P -> P) (x y : P) => f x y x
fun (P : Prop) (f : P -> P -> P -> P) (x y z : P) => f z y x
fun (P : Prop) (f : P -> P -> P -> P -> P) (x : P) => f x x x x
fun (P : Prop) (f : P -> P -> P -> P -> P) (x y : P) => f x y x y
fun (P : Prop) (f : P -> P -> P -> P -> P) (x y z w : P) => f w z y x

# =============================================================================
# Additional expressions (Section 46)
# =============================================================================

# More forall patterns
forall (A : Type), A -> A -> A -> A -> A
forall (A : Type), (A -> A) -> A -> A -> A
forall (A : Type), (A -> A -> A) -> A -> A
forall (A : Type), ((A -> A) -> A) -> A
forall (A : Type), (((A -> A) -> A) -> A) -> A

forall (P : Prop), P -> P -> P -> P -> P
forall (P : Prop), (P -> P) -> P -> P -> P
forall (P : Prop), (P -> P -> P) -> P -> P
forall (P : Prop), ((P -> P) -> P) -> P
forall (P : Prop), (((P -> P) -> P) -> P) -> P

# More forall with function arguments
forall (A : Type) (f : A -> A), A
forall (A : Type) (f g : A -> A), A
forall (A : Type) (f g h : A -> A), A
forall (A : Type) (f g h i : A -> A), A
forall (A : Type) (f : A -> A -> A), A
forall (A : Type) (f g : A -> A -> A), A

# =============================================================================
# Additional expressions (Section 47)
# =============================================================================

# More arrow chain patterns
Type -> (Type -> Type -> Type)
(Type -> Type) -> Type -> Type -> Type
Type -> Type -> (Type -> Type) -> Type
Type -> (Type -> Type) -> Type -> Type

Prop -> (Prop -> Prop -> Prop)
(Prop -> Prop) -> Prop -> Prop -> Prop
Prop -> Prop -> (Prop -> Prop) -> Prop
Prop -> (Prop -> Prop) -> Prop -> Prop

Sort 2 -> (Sort 2 -> Sort 2 -> Sort 2)
(Sort 2 -> Sort 2) -> Sort 2 -> Sort 2 -> Sort 2
Sort 3 -> (Sort 3 -> Sort 3 -> Sort 3)
(Sort 3 -> Sort 3) -> Sort 3 -> Sort 3 -> Sort 3

# More deeply nested
(((Type -> Type) -> Type) -> Type) -> Type -> Type
Type -> (((Type -> Type) -> Type) -> Type) -> Type
((Type -> Type) -> (Type -> Type) -> Type) -> Type
(Type -> (Type -> Type) -> Type) -> Type -> Type

# =============================================================================
# Additional expressions (Section 48)
# =============================================================================

# S combinator variations
fun (A B C : Type) (f : A -> B -> C) (g : A -> B) => fun (x : A) => f x (g x)
fun (A B C D : Type) (f : A -> B -> C) (g : A -> D -> B) (h : A -> D) => fun (x : A) => f x (g x (h x))
fun (P Q R : Prop) (f : P -> Q -> R) (g : P -> Q) => fun (x : P) => f x (g x)

# K combinator variations
fun (A B C : Type) (x : A) (y : B) (z : C) => x
fun (A B C : Type) (x : A) (y : B) (z : C) => y
fun (A B C : Type) (x : A) (y : B) (z : C) => z
fun (P Q R : Prop) (x : P) (y : Q) (z : R) => x
fun (P Q R : Prop) (x : P) (y : Q) (z : R) => y
fun (P Q R : Prop) (x : P) (y : Q) (z : R) => z

# B combinator variations
fun (A B C D : Type) (f : C -> D) (g : B -> C) (h : A -> B) => fun (x : A) => f (g (h x))
fun (P Q R S : Prop) (f : R -> S) (g : Q -> R) (h : P -> Q) => fun (x : P) => f (g (h x))

# =============================================================================
# Additional expressions (Section 49)
# =============================================================================

# More type level function patterns
fun (F G : Type -> Type) => fun (A : Type) => F (G A)
fun (F G : Type -> Type) => fun (A : Type) => G (F A)
fun (F G H : Type -> Type) => fun (A : Type) => F (G (H A))
fun (F G H : Type -> Type) => fun (A : Type) => H (G (F A))
fun (F : Type -> Type -> Type) (G : Type -> Type) => fun (A B : Type) => F (G A) (G B)
fun (F : Type -> Type -> Type) (G : Type -> Type) => fun (A B : Type) => G (F A B)

# Prop level function patterns
fun (F G : Prop -> Prop) => fun (P : Prop) => F (G P)
fun (F G : Prop -> Prop) => fun (P : Prop) => G (F P)
fun (F G H : Prop -> Prop) => fun (P : Prop) => F (G (H P))
fun (F G H : Prop -> Prop) => fun (P : Prop) => H (G (F P))
fun (F : Prop -> Prop -> Prop) (G : Prop -> Prop) => fun (P Q : Prop) => F (G P) (G Q)
fun (F : Prop -> Prop -> Prop) (G : Prop -> Prop) => fun (P Q : Prop) => G (F P Q)

# =============================================================================
# Additional expressions (Section 50)
# =============================================================================

# Final batch - more forall patterns
forall (A : Type), A
forall (A B : Type), A
forall (A B : Type), B
forall (A B C : Type), A
forall (A B C : Type), B
forall (A B C : Type), C
forall (A B C D : Type), A
forall (A B C D : Type), D

forall (P : Prop), P
forall (P Q : Prop), P
forall (P Q : Prop), Q
forall (P Q R : Prop), P
forall (P Q R : Prop), Q
forall (P Q R : Prop), R
forall (P Q R S : Prop), P
forall (P Q R S : Prop), S

# More Sort forall
forall (U : Sort 2), U
forall (U V : Sort 2), U
forall (U V : Sort 2), V
forall (U : Sort 3), U
forall (U V : Sort 3), U
forall (U V : Sort 3), V
forall (U : Sort 4), U
forall (U V : Sort 4), U
forall (U V : Sort 4), V

# =============================================================================
# Additional expressions (Section 51)
# =============================================================================

# Identity function variants with different binders
fun (A : Type) (B : Type) (x : A) => x
fun (A : Type) (B : Type) (x : B) => x
fun (A : Type) (B : Type) (C : Type) (x : A) => x
fun (A : Type) (B : Type) (C : Type) (x : B) => x
fun (A : Type) (B : Type) (C : Type) (x : C) => x
fun (A : Type) (B : Type) (C : Type) (D : Type) (x : A) => x
fun (A : Type) (B : Type) (C : Type) (D : Type) (x : B) => x
fun (A : Type) (B : Type) (C : Type) (D : Type) (x : C) => x
fun (A : Type) (B : Type) (C : Type) (D : Type) (x : D) => x

# Prop identity variants
fun (P : Prop) (Q : Prop) (x : P) => x
fun (P : Prop) (Q : Prop) (x : Q) => x
fun (P : Prop) (Q : Prop) (R : Prop) (x : P) => x
fun (P : Prop) (Q : Prop) (R : Prop) (x : Q) => x
fun (P : Prop) (Q : Prop) (R : Prop) (x : R) => x
fun (P : Prop) (Q : Prop) (R : Prop) (S : Prop) (x : P) => x
fun (P : Prop) (Q : Prop) (R : Prop) (S : Prop) (x : Q) => x
fun (P : Prop) (Q : Prop) (R : Prop) (S : Prop) (x : R) => x
fun (P : Prop) (Q : Prop) (R : Prop) (S : Prop) (x : S) => x

# =============================================================================
# Additional expressions (Section 52)
# =============================================================================

# Flip function variants
fun (A : Type) (x y : A) => y
fun (A B : Type) (x : A) (y : B) => y
fun (A B C : Type) (x : A) (y : B) (z : C) => z
fun (A B C : Type) (x : A) (y : B) (z : C) => y
fun (A B C D : Type) (x : A) (y : B) (z : C) (w : D) => w
fun (A B C D : Type) (x : A) (y : B) (z : C) (w : D) => z
fun (A B C D : Type) (x : A) (y : B) (z : C) (w : D) => y

# Prop flip variants
fun (P : Prop) (x y : P) => y
fun (P Q : Prop) (x : P) (y : Q) => y
fun (P Q R : Prop) (x : P) (y : Q) (z : R) => z
fun (P Q R : Prop) (x : P) (y : Q) (z : R) => y
fun (P Q R S : Prop) (x : P) (y : Q) (z : R) (w : S) => w
fun (P Q R S : Prop) (x : P) (y : Q) (z : R) (w : S) => z
fun (P Q R S : Prop) (x : P) (y : Q) (z : R) (w : S) => y

# =============================================================================
# Additional expressions (Section 53)
# =============================================================================

# More function arrow patterns
Prop -> Type -> Type
Type -> Prop -> Type
Type -> Type -> Prop
Prop -> Prop -> Type
Prop -> Type -> Prop
Type -> Prop -> Prop

Prop -> Type -> Type -> Type
Type -> Prop -> Type -> Type
Type -> Type -> Prop -> Type
Type -> Type -> Type -> Prop
Prop -> Prop -> Type -> Type
Prop -> Type -> Prop -> Type
Prop -> Type -> Type -> Prop
Type -> Prop -> Prop -> Type
Type -> Prop -> Type -> Prop
Type -> Type -> Prop -> Prop

# =============================================================================
# Additional expressions (Section 54)
# =============================================================================

# More lambda returning arrow types
fun (A : Type) => A -> Type
fun (A : Type) => Type -> A
fun (A : Type) => A -> A -> Type
fun (A : Type) => A -> Type -> A
fun (A : Type) => Type -> A -> A
fun (A : Type) => Type -> Type -> A

fun (P : Prop) => P -> Type
fun (P : Prop) => Type -> P
fun (P : Prop) => P -> P -> Type
fun (P : Prop) => P -> Type -> P
fun (P : Prop) => Type -> P -> P
fun (P : Prop) => Type -> Type -> P

# Mixed lambda returning arrows
fun (A : Type) (P : Prop) => A -> P -> Type
fun (A : Type) (P : Prop) => P -> A -> Type
fun (A : Type) (P : Prop) => A -> Type -> P
fun (A : Type) (P : Prop) => P -> Type -> A
fun (A : Type) (P : Prop) => Type -> A -> P
fun (A : Type) (P : Prop) => Type -> P -> A

# =============================================================================
# Additional expressions (Section 55)
# =============================================================================

# More forall with mixed return types
forall (A : Type), A -> Type
forall (A : Type), Type -> A
forall (A B : Type), A -> B -> Type
forall (A B : Type), A -> Type -> B
forall (A B : Type), Type -> A -> B

forall (P : Prop), P -> Type
forall (P : Prop), Type -> P
forall (P Q : Prop), P -> Q -> Type
forall (P Q : Prop), P -> Type -> Q
forall (P Q : Prop), Type -> P -> Q

# Forall mixed Type/Prop
forall (A : Type) (P : Prop), A -> P -> Type
forall (A : Type) (P : Prop), P -> A -> Type
forall (A : Type) (P : Prop), A -> Type -> P
forall (A : Type) (P : Prop), P -> Type -> A
forall (A : Type) (P : Prop), Type -> A -> P
forall (A : Type) (P : Prop), Type -> P -> A

# =============================================================================
# Additional expressions (Section 56)
# =============================================================================

# Binary function composition
fun (A B C : Type) (f : A -> B) (g : B -> C) => fun (x : A) => g (f x)
fun (A B C D : Type) (f : A -> B) (g : B -> C) (h : C -> D) => fun (x : A) => h (g (f x))
fun (A B C D E : Type) (f : A -> B) (g : B -> C) (h : C -> D) (i : D -> E) => fun (x : A) => i (h (g (f x)))

# Prop composition
fun (P Q R : Prop) (f : P -> Q) (g : Q -> R) => fun (x : P) => g (f x)
fun (P Q R S : Prop) (f : P -> Q) (g : Q -> R) (h : R -> S) => fun (x : P) => h (g (f x))
fun (P Q R S T : Prop) (f : P -> Q) (g : Q -> R) (h : R -> S) (i : S -> T) => fun (x : P) => i (h (g (f x)))

# Mixed composition
fun (A : Type) (P Q : Prop) (f : A -> P) (g : P -> Q) => fun (x : A) => g (f x)
fun (P : Prop) (A B : Type) (f : P -> A) (g : A -> B) => fun (x : P) => g (f x)

# =============================================================================
# Additional expressions (Section 57)
# =============================================================================

# Applying functions to multiple arguments
fun (A : Type) (f : A -> A) (x y : A) => f x
fun (A : Type) (f : A -> A) (x y : A) => f y
fun (A : Type) (f : A -> A) (x y z : A) => f x
fun (A : Type) (f : A -> A) (x y z : A) => f y
fun (A : Type) (f : A -> A) (x y z : A) => f z
fun (A : Type) (f : A -> A) (x y z w : A) => f x
fun (A : Type) (f : A -> A) (x y z w : A) => f y
fun (A : Type) (f : A -> A) (x y z w : A) => f z
fun (A : Type) (f : A -> A) (x y z w : A) => f w

# Binary function applications
fun (A : Type) (f : A -> A -> A) (x y z : A) => f x y
fun (A : Type) (f : A -> A -> A) (x y z : A) => f y z
fun (A : Type) (f : A -> A -> A) (x y z : A) => f x z
fun (A : Type) (f : A -> A -> A) (x y z : A) => f z x
fun (A : Type) (f : A -> A -> A) (x y z : A) => f z y
fun (A : Type) (f : A -> A -> A) (x y z : A) => f y x

# =============================================================================
# Additional expressions (Section 58)
# =============================================================================

# Functions returning arrow types
fun (A B : Type) => A -> B -> A
fun (A B : Type) => A -> B -> B
fun (A B : Type) => B -> A -> A
fun (A B : Type) => B -> A -> B
fun (A B C : Type) => A -> B -> C -> A
fun (A B C : Type) => A -> B -> C -> B
fun (A B C : Type) => A -> B -> C -> C
fun (A B C : Type) => C -> B -> A -> A
fun (A B C : Type) => C -> B -> A -> B
fun (A B C : Type) => C -> B -> A -> C

# Prop versions
fun (P Q : Prop) => P -> Q -> P
fun (P Q : Prop) => P -> Q -> Q
fun (P Q : Prop) => Q -> P -> P
fun (P Q : Prop) => Q -> P -> Q
fun (P Q R : Prop) => P -> Q -> R -> P
fun (P Q R : Prop) => P -> Q -> R -> Q
fun (P Q R : Prop) => P -> Q -> R -> R
fun (P Q R : Prop) => R -> Q -> P -> P
fun (P Q R : Prop) => R -> Q -> P -> Q
fun (P Q R : Prop) => R -> Q -> P -> R

# =============================================================================
# Additional expressions (Section 59)
# =============================================================================

# More deeply nested function types
((Type -> Type -> Type) -> Type) -> Type
(Type -> (Type -> Type -> Type)) -> Type
Type -> ((Type -> Type) -> Type -> Type)
((Type -> Type) -> Type) -> Type -> Type
(Type -> Type) -> (Type -> Type -> Type)
(Type -> Type -> Type) -> (Type -> Type)

((Prop -> Prop -> Prop) -> Prop) -> Prop
(Prop -> (Prop -> Prop -> Prop)) -> Prop
Prop -> ((Prop -> Prop) -> Prop -> Prop)
((Prop -> Prop) -> Prop) -> Prop -> Prop
(Prop -> Prop) -> (Prop -> Prop -> Prop)
(Prop -> Prop -> Prop) -> (Prop -> Prop)

# Sort versions
((Sort 2 -> Sort 2 -> Sort 2) -> Sort 2) -> Sort 2
(Sort 2 -> (Sort 2 -> Sort 2 -> Sort 2)) -> Sort 2
((Sort 3 -> Sort 3 -> Sort 3) -> Sort 3) -> Sort 3
(Sort 3 -> (Sort 3 -> Sort 3 -> Sort 3)) -> Sort 3

# =============================================================================
# Additional expressions (Section 60)
# =============================================================================

# More Type level variations
Type 1 -> Type 2
Type 2 -> Type 3
Type 3 -> Type 4
Type 4 -> Type 5
Type 2 -> Type 1
Type 3 -> Type 1
Type 4 -> Type 1
Type 5 -> Type 1
Type 3 -> Type 2
Type 4 -> Type 2
Type 5 -> Type 2

# Lambda with Type level variations
fun (A : Type 1) => A -> A
fun (A : Type 2) => A -> A
fun (A : Type 3) => A -> A
fun (A : Type 4) => A -> A
fun (A : Type 1) (B : Type 1) => A -> B
fun (A : Type 2) (B : Type 2) => A -> B
fun (A : Type 3) (B : Type 3) => A -> B

# Forall with Type level variations
forall (A : Type 1), A -> A
forall (A : Type 2), A -> A
forall (A : Type 3), A -> A
forall (A : Type 4), A -> A
forall (A : Type 1) (B : Type 1), A -> B
forall (A : Type 2) (B : Type 2), A -> B
forall (A : Type 3) (B : Type 3), A -> B

# =============================================================================
# Additional expressions (Section 61)
# =============================================================================

# More application patterns
fun (A : Type) (f g : A -> A) (x : A) => f x
fun (A : Type) (f g : A -> A) (x : A) => g x
fun (A : Type) (f g h : A -> A) (x : A) => f x
fun (A : Type) (f g h : A -> A) (x : A) => g x
fun (A : Type) (f g h : A -> A) (x : A) => h x
fun (A : Type) (f g h i : A -> A) (x : A) => f x
fun (A : Type) (f g h i : A -> A) (x : A) => g x
fun (A : Type) (f g h i : A -> A) (x : A) => h x
fun (A : Type) (f g h i : A -> A) (x : A) => i x

# Prop application patterns
fun (P : Prop) (f g : P -> P) (x : P) => f x
fun (P : Prop) (f g : P -> P) (x : P) => g x
fun (P : Prop) (f g h : P -> P) (x : P) => f x
fun (P : Prop) (f g h : P -> P) (x : P) => g x
fun (P : Prop) (f g h : P -> P) (x : P) => h x
fun (P : Prop) (f g h i : P -> P) (x : P) => f x
fun (P : Prop) (f g h i : P -> P) (x : P) => g x
fun (P : Prop) (f g h i : P -> P) (x : P) => h x
fun (P : Prop) (f g h i : P -> P) (x : P) => i x

# =============================================================================
# Additional expressions (Section 62)
# =============================================================================

# More forall patterns with function arguments
forall (A : Type) (f : A -> A) (x : A), A
forall (A : Type) (f : A -> A) (x y : A), A
forall (A : Type) (f : A -> A) (x y z : A), A
forall (A : Type) (f g : A -> A) (x : A), A
forall (A : Type) (f g : A -> A) (x y : A), A
forall (A : Type) (f g h : A -> A) (x : A), A
forall (A : Type) (f g h : A -> A) (x y : A), A

# Prop forall with function arguments
forall (P : Prop) (f : P -> P) (x : P), P
forall (P : Prop) (f : P -> P) (x y : P), P
forall (P : Prop) (f : P -> P) (x y z : P), P
forall (P : Prop) (f g : P -> P) (x : P), P
forall (P : Prop) (f g : P -> P) (x y : P), P
forall (P : Prop) (f g h : P -> P) (x : P), P
forall (P : Prop) (f g h : P -> P) (x y : P), P

# =============================================================================
# Additional expressions (Section 63)
# =============================================================================

# Type-returning functions
fun (A : Type) => A -> Type
fun (A B : Type) => A -> B -> Type
fun (A B C : Type) => A -> B -> C -> Type
fun (A B C D : Type) => A -> B -> C -> D -> Type

forall (A : Type), A -> Type
forall (A B : Type), A -> B -> Type
forall (A B C : Type), A -> B -> C -> Type
forall (A B C D : Type), A -> B -> C -> D -> Type

# Prop-returning functions
fun (A : Type) => A -> Prop
fun (A B : Type) => A -> B -> Prop
fun (A B C : Type) => A -> B -> C -> Prop
fun (A B C D : Type) => A -> B -> C -> D -> Prop

forall (A : Type), A -> Prop
forall (A B : Type), A -> B -> Prop
forall (A B C : Type), A -> B -> C -> Prop
forall (A B C D : Type), A -> B -> C -> D -> Prop

# =============================================================================
# Additional expressions (Section 64)
# =============================================================================

# More lambda application chains
fun (A : Type) (f : A -> A) => fun (x : A) => f (f x)
fun (A : Type) (f : A -> A) => fun (x : A) => f (f (f x))
fun (A : Type) (f : A -> A) => fun (x : A) => f (f (f (f x)))
fun (A : Type) (f : A -> A) => fun (x : A) => f (f (f (f (f x))))

fun (P : Prop) (f : P -> P) => fun (x : P) => f (f x)
fun (P : Prop) (f : P -> P) => fun (x : P) => f (f (f x))
fun (P : Prop) (f : P -> P) => fun (x : P) => f (f (f (f x)))
fun (P : Prop) (f : P -> P) => fun (x : P) => f (f (f (f (f x))))

# Binary function iteration
fun (A : Type) (f : A -> A -> A) (x : A) => f x x
fun (A : Type) (f : A -> A -> A) (x : A) => f (f x x) x
fun (A : Type) (f : A -> A -> A) (x : A) => f x (f x x)
fun (A : Type) (f : A -> A -> A) (x : A) => f (f x x) (f x x)

# =============================================================================
# Additional expressions (Section 65 - final)
# =============================================================================

# Final batch of expressions
fun (A : Type) (x : A) => A
fun (A : Type) (x y : A) => A
fun (A : Type) (x y z : A) => A
fun (P : Prop) (x : P) => P
fun (P : Prop) (x y : P) => P
fun (P : Prop) (x y z : P) => P
forall (A : Type) (x : A), Type
forall (A : Type) (x y : A), Type
forall (A : Type) (x y z : A), Type
forall (P : Prop) (x : P), Prop
forall (P : Prop) (x y : P), Prop
forall (P : Prop) (x y z : P), Prop

# Arrow returning Sort levels
Sort 2 -> Sort 3 -> Sort 4
Sort 3 -> Sort 4 -> Sort 5
Sort 4 -> Sort 5 -> Sort 6
Sort 3 -> Sort 2 -> Sort 4
Sort 4 -> Sort 3 -> Sort 5
Sort 5 -> Sort 4 -> Sort 6

# Final Type patterns
Type -> Type -> Type -> Type -> Type -> Type -> Type
Type 1 -> Type 1 -> Type 1 -> Type 1 -> Type 1 -> Type 1 -> Type 1
Type 2 -> Type 2 -> Type 2 -> Type 2 -> Type 2 -> Type 2 -> Type 2
Prop -> Prop -> Prop -> Prop -> Prop -> Prop -> Prop
Sort 2 -> Sort 2 -> Sort 2 -> Sort 2 -> Sort 2 -> Sort 2 -> Sort 2
Sort 3 -> Sort 3 -> Sort 3 -> Sort 3 -> Sort 3 -> Sort 3 -> Sort 3

# Final forall patterns
forall (A B C D E : Type), A -> B -> C -> D -> E -> A
forall (A B C D E : Type), A -> B -> C -> D -> E -> E
forall (P Q R S T : Prop), P -> Q -> R -> S -> T -> P
forall (P Q R S T : Prop), P -> Q -> R -> S -> T -> T

# =============================================================================
# Final expressions to exceed 2000 (Section 66)
# =============================================================================

# Identity variations
fun (x : Prop) => x
fun (x : Type) => x
fun (x : Type 1) => x
fun (x : Type 2) => x
fun (x : Sort 2) => x
fun (x : Sort 3) => x

# Const variations
fun (x y : Prop) => x
fun (x y : Type) => x
fun (x y : Type 1) => x
fun (x y : Sort 2) => x
fun (x y : Sort 3) => x

# Flip variations
fun (x y : Prop) => y
fun (x y : Type) => y
fun (x y : Type 1) => y
fun (x y : Sort 2) => y
fun (x y : Sort 3) => y

# Arrow variations
Prop -> Prop
Type -> Type
Type 1 -> Type 1
Type 2 -> Type 2
Sort 2 -> Sort 2
Sort 3 -> Sort 3
Sort 4 -> Sort 4
Sort 5 -> Sort 5
Sort 6 -> Sort 6
fun (A B : Type) (F : A -> B -> Type) (x : A) (y : B) => F x y
fun (A : Type) (F : A -> A -> Type) (x : A) => F x x

# Replacement expressions (simple forms)
fun (A : Type) (f g h : A -> A) (x : A) => f (g (h x))
fun (A : Type) (f g h : A -> A) (x : A) => h (g (f x))
fun (A : Type) (f g h i : A -> A) (x : A) => f (g (h (i x)))
fun (A : Type) (f g h i : A -> A) (x : A) => i (h (g (f x)))
fun (A : Type) (B : A -> Type) => forall (x : A), B x
fun (A : Type) (B C : A -> Type) => forall (x : A), B x -> C x
fun (A : Type) (B : A -> Type) => forall (x y : A), B x -> B y
fun (A B : Type) (x : A) (y : B) => A
